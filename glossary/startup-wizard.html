<!doctype html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Startup Wizard — Prompt Builder</title>
<style>
/* ===== Design tokens ===== */
:root{
  --bg:#fafafa; --fg:#0f1720; --muted:#506070; --chip:#f3f6fa; --border:#e3e9f2; --accent:#1e293b;
  --focus:#0ea5e9; --shadow:0 12px 40px rgba(0,0,0,.08); --radius:16px; --cta:#1e293b;
  --r1:#ff007a; --r2:#ff8d00; --r3:#ffd600; --r4:#00dc82; --r5:#00d2ff; --r6:#7850ff;
  --text:var(--fg); --card:#fff; --panel:#fff; --border-strong:var(--border);
  --red:#ef4444; --green:#10b981; --yellow:#f59e0b; --purple:#8b5cf6;
}
html[data-theme="dark"]{
  --bg:#0c1220; --fg:#e6ebf2; --muted:#9aa8b7; --chip:#111827; --border:#2f3f56;
  --shadow:0 8px 28px rgba(0,0,0,.55); --accent:#cbd5e1; --card:#0e1726; --panel:#0b1322;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
  color:var(--fg); background:var(--bg); line-height:1.5; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
}
h1,h2,h3,.subhead,.areaLabel{ text-transform:lowercase; letter-spacing:.25px; font-weight:600; }

/* Header */
header{
  display:flex; align-items:center; gap:12px; padding:12px 16px; position:sticky; top:0; z-index:10;
  background:rgba(255,255,255,.78); -webkit-backdrop-filter:blur(10px); backdrop-filter:blur(10px);
  border-bottom:1px solid var(--border);
}
html[data-theme="dark"] header{ background:rgba(12,18,32,.76); }
header .spacer{flex:1}
a{color:var(--accent); text-decoration:none}
a:hover{text-decoration:underline}

/* Buttons (no underline ever) */
a.btn,a.btn:hover,.btn,.btn:hover,.btn:focus,.btn:active{ text-decoration:none!important }
.btn{
  cursor:pointer; display:inline-flex; align-items:center; justify-content:center; gap:.5ch;
  background:var(--card); color:var(--fg); border:1px solid var(--border);
  padding:9px 14px; border-radius:999px; font-weight:600; text-transform:lowercase;
  transition: transform .06s ease, box-shadow .12s ease, background-color .12s ease, color .12s ease, border-color .12s ease;
}
.btn:hover{ transform:translateY(-2px) scale(1.02); box-shadow:0 12px 28px -14px rgba(0,0,0,.35),0 4px 10px -6px rgba(0,0,0,.25) }
.btn.primary{ background:var(--cta); color:#fff; border:1px solid transparent; box-shadow:none }
.btn.sm{ padding:6px 12px; font-size:14px; min-height:32px }
.pill{ display:inline-flex; gap:.5ch; align-items:center; padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:var(--chip); font-size:12px }
.muted{ color:var(--muted) }

/* Rainbow border utility (subtle) */
.rainbow{
  border:1px solid transparent;
  background:
    linear-gradient(var(--card), var(--card)) padding-box,
    conic-gradient(from 210deg,
      color-mix(in srgb, var(--r1), transparent 75%),
      color-mix(in srgb, var(--r2), transparent 78%),
      color-mix(in srgb, var(--r3), transparent 82%),
      color-mix(in srgb, var(--r4), transparent 80%),
      color-mix(in srgb, var(--r5), transparent 78%),
      color-mix(in srgb, var(--r6), transparent 75%),
      color-mix(in srgb, var(--r1), transparent 75%)
    ) border-box;
}
.rainbow:hover{ background:
  linear-gradient(color-mix(in srgb, var(--card), white 2%), color-mix(in srgb, var(--card), white 2%)) padding-box,
  conic-gradient(from 210deg, var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1)) border-box;
}

/* Inputs */
/* === Stepper fields: spacing & label/description distinction === */
#wizViewSteps .field {
  margin: 0 0 8px; /* baseline */
}

/* When there are 2+ fields on the step, increase vertical spacing */
#wizStepBody.many-fields .field + .field,
#commonCtxBody .field + .field {
  margin-top: 16px;
}

/* Labels: stronger and a touch larger */
#wizViewSteps .field > label {
  display: block;
  font-weight: 600;
  font-size: 14.5px;
  letter-spacing: .1px;
  color: var(--fg);
  margin: 0 0 6px;
}

/* Descriptive text: smaller, muted, and clearly separate */
#wizViewSteps .field .desc {
  font-size: 12.75px;
  line-height: 1.5;
  color: var(--muted);
  margin-top: 6px;
}
html[data-theme="dark"] #wizViewSteps .field .desc {
  color: color-mix(in srgb, var(--muted), white 10%);
}



input[type="text"], textarea, select{
  width:100%; height:48px; padding:0 12px; border-radius:var(--radius); border:1px solid var(--border);
  background:var(--card); color:var(--fg); outline:none; box-shadow:var(--shadow);
}
textarea{ min-height:100px; height:auto; padding:10px 12px; resize:vertical }

/* Ambient rainbow glimmer (very subtle) */
body::before{
  content:""; position:fixed; inset:auto auto 40% 0; width:min(70vw,920px); height:min(70vh,680px);
  pointer-events:none; z-index:-1; filter:blur(48px) saturate(115%); opacity:.08;
  background: radial-gradient(120% 120% at 0% 0%, rgba(255,255,255,.85) 0 36%, transparent 52%),
              conic-gradient(from 210deg at 0% 0%, rgba(255,0,122,.22), rgba(255,141,0,.18), rgba(255,214,0,.18), rgba(0,220,130,.20), rgba(0,210,255,.18), rgba(120,80,255,.22), rgba(255,0,122,.22));
}

/* Page shell */
.wiz-root{ max-width:1120px; margin:18px auto; padding:0 16px; }

/* Centered search region */
.wiz-header-search{ display:flex; justify-content:center; margin:8px 0 18px }
.searchCenter{ width:min(880px, 100%); display:flex; flex-direction:column; align-items:center; gap:10px }
.wiz-searchShell{
  width:100%; display:flex; align-items:center; gap:8px; padding:6px;
  background:var(--card); border-radius:999px; position:relative; /* anchors typeahead */
}
.wiz-searchShell input{ flex:1; height:38px; border:none; box-shadow:none; background:transparent; padding:0 8px }
.wiz-clear{ border:none; background:transparent; color:var(--muted); cursor:pointer }
.quickRow{ display:flex; gap:10px; align-items:center; justify-content:center; width:100% }

/* Typeahead (absolute so it never shifts layout) */
#taSug{
  position:absolute; left:8px; right:8px; top:calc(100% + 8px); z-index:20;
}
#taSug[hidden]{ display:none }
#taSug .box{
  border:1px solid var(--border); background:var(--card); border-radius:12px; box-shadow:var(--shadow);
  max-height:320px; overflow-y:auto;
}
#taSug .row{ padding:10px 12px; display:flex; gap:8px; align-items:flex-start; cursor:pointer }
#taSug .row:hover, #taSug .row[aria-selected="true"]{ background:color-mix(in srgb, var(--chip), white 30%) }
#taSug .lbl{ font-weight:600 }

/* Startup */
.wiz-startup{ display:grid; grid-template-columns:1fr; gap:12px }
.wiz-row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
.wiz-cards{ display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:10px }
@media (max-width:900px){ .wiz-cards{ grid-template-columns:1fr } }
.card{ border:1px solid var(--border); background:var(--card); border-radius:16px; padding:12px; box-shadow:var(--shadow) }
.card h4{ margin:0 0 4px; font-size:16px }
.card p{ margin:0 0 10px; color:var(--muted); font-size:13px; line-height:1.35 }
.card .foot{ display:flex; align-items:center; justify-content:space-between; gap:8px }

/* Step 0 */
.wiz-step0 .title{ font-size:20px; margin:0 0 6px }
.wiz-step0 .def{ color:var(--muted); margin:0 0 10px }
.wiz-step0 ul.meta{ display:flex; flex-wrap:wrap; gap:12px; margin:8px 0; padding:0; list-style:none }
.wiz-step0 .uses{ margin-top:10px }
.wiz-step0 .uses li{ margin:6px 0; color:var(--fg) }

/* === Step 0 layout refresh (left-aligned, centered column, larger type) === */
.wiz-step0{
  max-width: 820px;        /* narrower column to pull content toward center */
  margin: 8vh auto 6vh;    /* centers the section while keeping left alignment */
  padding: 20px 22px;
}

@media (max-width: 900px){
  .wiz-step0{ margin: 4vh auto; padding: 16px; }
}

.wiz-step0 .title{
  font-size: clamp(28px, 3.2vw, 40px);
  margin: 0 0 12px;
}

.wiz-step0 .def{
  font-size: clamp(15px, 1.35vw, 18px);
  line-height: 1.6;
  margin: 0 0 16px;
  max-width: 70ch;
}

.wiz-step0 ul.meta{
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin: 10px 0 4px;
  padding: 0;
  list-style: none;
  font-size: 14px;
}
.wiz-step0 ul.meta li{
  background: var(--chip);
  border: 1px solid var(--border);
  border-radius: 999px;
  padding: 6px 10px;
}

.wiz-step0 .uses{ margin-top: 18px; }
.wiz-step0 .uses .subhead{ font-size: 14px; letter-spacing: .2px; }
.wiz-step0 .uses li{ font-size: 14.5px; line-height: 1.45; }

/* Actions row: show "back to search" first visually, keep DOM order accessible */
.wiz-step0 .step0-actions{
  display: flex;
  gap: 10px;
  margin-top: 18px;
  /* flips visual order only */
}
.wiz-step0 .step0-actions .btn{
  padding: 10px 16px;
  font-size: 15px;
}


/* Steps layout */
.wiz-stepsWrap{ display:grid; grid-template-columns:260px 1fr; gap:14px; align-items:start }
@media (max-width:860px){ .wiz-stepsWrap{ grid-template-columns:1fr } }
.wiz-rail{ position:sticky; top:76px; border:1px solid var(--border); background:var(--card); border-radius:16px; padding:12px; box-shadow:var(--shadow) }
.wiz-rail ul{ list-style:none; margin:0; padding:0; }
.wiz-rail li{ display:flex; gap:8px; align-items:center; padding:8px; border-radius:10px; cursor:pointer }
.wiz-rail li[aria-current="true"]{ background:var(--chip); border:1px dashed var(--border) }
.wiz-prog{ height:6px; background:var(--chip); border-radius:999px; overflow:hidden; margin:8px 0 12px }
.wiz-prog > i{ display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--r5),var(--r6)) }
.wiz-pane{ border:1px solid var(--border); background:var(--card); border-radius:16px; padding:12px; box-shadow:var(--shadow) }
.wiz-foot{ position:sticky; bottom:12px; display:flex; gap:8px; justify-content:flex-end; padding-top:10px; background:transparent }

/* utilities */
.hide{ display:none!important }
.right{ margin-left:auto }
.mono{ font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace }
.block-title{ display:flex; align-items:center; gap:10px; }


/* === Brand patch: Rainbow Enhancements (index → wizard) =================== */
@keyframes spinRainbow { to { --angle: 360deg; } }

/* Search pill: stronger rainbow border, soft halo, “hanging” underline */
.wiz-searchShell{
  position: relative;            /* anchor pseudo-elements */
  border: 2px solid transparent; /* gradient border layer */
  background-image:
    linear-gradient(var(--card), var(--card)),
    conic-gradient(from 200deg,
      var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  background-clip: padding-box, border-box;
  background-origin: padding-box, border-box;
  box-shadow: var(--shadow);
  transition: transform .08s ease, box-shadow .18s ease, filter .18s ease;
}
.wiz-searchShell::before{
  content:"";
  position:absolute; inset:-10px; border-radius:999px; z-index:-1;
  filter: blur(20px) saturate(118%);
  background: conic-gradient(from 200deg,
    var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  opacity:.14;
  transition: opacity .18s ease, filter .18s ease;
}
/* “Hanging rainbow” underline */
.wiz-searchShell::after{
  content:"";
  position:absolute; left:10%; right:10%; bottom:-6px; height:4px; border-radius:999px;
  background: linear-gradient(90deg,
    var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  opacity:0; transform: translateY(0);
  transition: opacity .20s ease, transform .20s ease;
  pointer-events:none;
}
/* Micro-motion + brighter halo + drop the underline on hover/focus */
.wiz-searchShell:hover,
.wiz-searchShell:focus-within{
  transform: translateY(-1px);
  box-shadow: 0 16px 32px rgba(0,0,0,.12), 0 4px 10px rgba(0,0,0,.10);
}
.wiz-searchShell:hover::before,
.wiz-searchShell:focus-within::before{
  opacity:.20; filter: blur(22px) saturate(125%);
}
.wiz-searchShell:hover::after,
.wiz-searchShell:focus-within::after{
  opacity:.95; transform: translateY(2px);
}

/* Primary buttons: animated rainbow “ring” on hover/focus */
.btn.primary.rainbow-hover{ position:relative; overflow:hidden; }
.btn.primary.rainbow-hover::after{
  content:""; position:absolute; inset:-2px; border-radius:inherit; padding:2px;
  --angle: 0deg;
  background: conic-gradient(from var(--angle),
    var(--r1), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  -webkit-mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  -webkit-mask-composite: xor; mask-composite: exclude; /* punch out center */
  opacity:0; transition: opacity .2s ease; pointer-events:none;
}
.btn.primary.rainbow-hover::before{
  content:""; position:absolute; inset:0; border-radius:inherit;
  background: radial-gradient(120% 120% at 50% -20%, rgba(255,255,255,.16), transparent 60%);
  opacity:0; transition: opacity .2s ease; pointer-events:none;
}
.btn.primary.rainbow-hover:hover::after,
.btn.primary.rainbow-hover:focus-visible::after{
  opacity:1; animation: spinRainbow 2.25s linear infinite;
}
.btn.primary.rainbow-hover:hover::before,
.btn.primary.rainbow-hover:focus-visible::before{ opacity:1; }

/* Reduced-motion respect */
@media (prefers-reduced-motion: reduce){
  .wiz-searchShell{ transition:none }
  .wiz-searchShell::before, .wiz-searchShell::after{ transition:none }
  .btn.primary.rainbow-hover::after{ animation:none; }
}

/* Optional utilities */
.rainbowLine{
  height:3px; width:100%;
  background: linear-gradient(90deg, var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  filter: saturate(115%); opacity:.85; border-radius:999px;
}
.rainbow-border{
  border:1px solid transparent;
  background:
    linear-gradient(var(--card), var(--card)) padding-box,
    conic-gradient(from 210deg, var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1)) border-box;
}

/* --- Top Card typography (title / subtitle / definition) --- */
.card .card-title{ font-weight:600; margin-bottom:2px; }
.card .card-sub{ color:var(--muted); font-size:12.5px; margin-bottom:6px; font-weight:500; }
.card .card-def{ font-size:12.5px; line-height:1.45; }
.card .card-def .full[hidden]{ display:none!important; }
.card .card-def .short[hidden]{ display:none!important; }
.card .card-def .btn{ padding:2px 8px; font-size:12px; }


/* Soften the search-bar rainbow hover */
.wiz-searchShell::before{
  /* base halo */
  opacity:.10;              /* was .14 */
  filter: blur(16px) saturate(110%);  /* was blur(20px) saturate(118%) */
}
.wiz-searchShell:hover::before,
.wiz-searchShell:focus-within::before{
  /* hover halo */
  opacity:.05;              /* was .20 */
  filter: blur(18px) saturate(112%);  /* was blur(22px) saturate(125%) */
}
.wiz-searchShell:hover,
.wiz-searchShell:focus-within{
  /* lift + shadow */
  transform: translateY(-0.5px);      /* was -1px */
  box-shadow: 0 10px 24px rgba(0,0,0,.10), 0 3px 8px rgba(0,0,0,.08); /* softer */
}
.wiz-searchShell:hover::after,
.wiz-searchShell:focus-within::after{
  /* “hanging rainbow” underline */
  opacity:.0;              /* was .95 */
  transform: translateY(1px);         /* was 2px */
}

/* Pin "use this template" buttons bottom-right on every card */
.wiz-cards .card{
  display:flex;
  flex-direction:column;
  height:100%;
}

.wiz-cards .card .foot{
  /* override inline margin-top from renderer so the footer can stick to bottom */
  margin-top:auto !important;
  display:flex;
  align-items:center;
  justify-content:flex-end; /* right align the CTA cluster */
  gap:8px;
}

/* (optional) if any cards have an empty leading spacer element, hide it */
.wiz-cards .card .foot > span:empty{ display:none; }

/* ---- Step status colors (rail) ---- */
.wiz-rail .wiz-prog{ display:none } /* we’re moving progress to the top bar */
.wiz-rail li{ border:1px solid transparent; }
.wiz-rail li.done{
  background: color-mix(in srgb, var(--green), var(--chip) 68%);
  border-color: color-mix(in srgb, var(--green), transparent 70%);
}
.wiz-rail li.warn{
  background: color-mix(in srgb, var(--yellow), var(--chip) 72%);
  border-color: color-mix(in srgb, var(--yellow), transparent 70%);
}

/* ---- Top progress bar (under search) ---- */
/* container now stacks children with meta ON TOP of the bar */
.wiz-topprog{
  display:flex; 
  flex-direction:column-reverse;  /* moves meta above the bar without touching HTML */
  gap:8px;                         /* space between meta and bar */
  margin:16px auto 14px;           /* extra top margin for separation from search */
  width:100%; max-width:1120px; padding:0 16px;
}

.wiz-topprog .wiz-topprog-bar{
  height:8px; border-radius:999px; background:var(--chip); overflow:hidden;
  border:1px solid var(--border);
}
.wiz-topprog .wiz-topprog-bar > i{
  display:block; height:100%; width:0%;
  background: linear-gradient(90deg, var(--r5), var(--r6));
  transition: width .25s ease;
}
.wiz-topprog .wiz-topprog-meta{
  display:flex; gap:8px; align-items:center; justify-content:space-between;
  margin:0;                        /* let the container’s gap handle spacing */
  font-size:12.5px; color:var(--muted);
}
.wiz-topprog .wiz-topprog-meta > span[aria-hidden="true"]{ opacity:.5; }
.wiz-output{
  border:1px solid var(--border); background:var(--card); border-radius:12px;
  padding:10px; font: 12.5px/1.45 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
  white-space:pre-wrap;
}

/* Output step: head row + actions placeholder (Slice 0) */
.out-head-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  margin:10px 0 6px;
}
.out-head-row .subhead{ margin:0; } /* keep subhead snug when paired with actions */

.out-actions.placeholder{
  min-width:160px;
  height:28px;
  border:1px dashed var(--border);
  border-radius:999px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:12px;
  color:var(--muted);
  padding:0 10px;
  user-select:none;
}

/* Output step: actions group (Slice 1) */
.out-actions{
  display:flex;
  align-items:center;
  gap:8px;
}
.out-actions .btn.sm{ padding:6px 10px; }

/* “Ask ChatGPT” visual treatment: black background, white text */
.btn.ask{
  background:#000;
  color:#fff;
  border-color:#000;
}
.btn.ask:hover,
.btn.ask:focus-visible{
  filter:brightness(0.9);
  outline:none;
}

/* === Action Modal (shared) — Slice 1 === */
dialog#actionModal{
  width:min(900px, 92vw);
  max-width:900px;
  border:1px solid var(--border, #ddd);
  border-radius:12px;
  padding:0;
  box-shadow:0 10px 30px rgba(0,0,0,.18);
}
#actionModal::backdrop{ background:rgba(0,0,0,.35); }

#actionModal .dlg-head{
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 16px; border-bottom:1px solid var(--border, #eee);
}
#actionModal .dlg-head .title{ font-weight:600; font-size:16px; }
#actionModal .icon-btn{
  background:transparent; border:0; font-size:20px; line-height:1; cursor:pointer;
}

#actionModal .dlg-body{ padding:12px 16px; }

/* Slice 2: subtle helper note inside the action modal */
#actionModal .note{
  margin:8px 0 0 0;
  font-size:12px;
  color:var(--muted, #666);
}

/* === Slice 3: Post-Launch Helper dialog === */
dialog#postLaunchDlg{
  width:min(820px, 92vw);
  max-width:820px;
  border:1px solid var(--border, #ddd);
  border-radius:12px;
  padding:0;
  box-shadow:0 10px 30px rgba(0,0,0,.18);
}
#postLaunchDlg::backdrop{ background:rgba(0,0,0,.35); }

#postLaunchDlg .dlg-head{
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 16px; border-bottom:1px solid var(--border, #eee);
}
#postLaunchDlg .dlg-head .title{ font-weight:600; font-size:16px; }
#postLaunchDlg .icon-btn{
  background:transparent; border:0; font-size:20px; line-height:1; cursor:pointer;
}

#postLaunchDlg .dlg-body{ padding:12px 16px; }
#postLaunchDlg .note{
  margin:0 0 8px 0; font-size:12px; color:var(--muted, #666);
}
#postLaunchText{
  width:100%; min-height:220px; resize:vertical;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size:13px; line-height:1.4;
  border:1px solid var(--border, #ddd); border-radius:8px; padding:10px; box-sizing:border-box;
  white-space:pre-wrap; background: #fafafa;
}

#postLaunchDlg .dlg-foot{
  display:flex; align-items:center; gap:10px;
  padding:12px 16px; border-top:1px solid var(--border, #eee);
}
#postLaunchStatus[hidden]{ display:none; }
#postLaunchStatus{ font-size:12px; color:var(--muted, #666); }

@media (max-width:640px){
  #postLaunchText{ min-height:180px; }
}


#actionPreview{
  width:100%; min-height:220px; resize:vertical;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size:13px; line-height:1.4;
  border:1px solid var(--border, #ddd); border-radius:8px; padding:10px; box-sizing:border-box;
  white-space:pre-wrap;
}

#actionModal .dlg-foot{
  display:flex; align-items:center; gap:10px;
  padding:12px 16px; border-top:1px solid var(--border, #eee);
}
#copyStatus[hidden]{ display:none; }
#copyStatus{ font-size:12px; color:var(--muted, #666); }
#actionModal .grow{ flex:1; }


@media (max-width:640px){
  .out-head-row{ flex-direction:column; align-items:flex-start; gap:8px; }
  .out-actions.placeholder{ align-self:stretch; height:32px; }
}


/* Typeahead: render above all app layers when portaled */
#taSug.ta-portal{
  position: fixed;         /* viewport-based, not limited by parents */
  left: 0; top: 0;         /* real position set via JS */
  width: auto;             /* real width set via JS */
  z-index: 9999;           /* top of the app */
}

/* ===== INDEX ↔ WIZARD SEARCH PARITY — place at end of <style> ===== */

/* Container width + pop-in like index */
#wizViewStartup .searchWrap{
  width:min(780px,100%);
  margin:6px auto 0;
  position:relative;
  transform-origin:center;
  animation: popIn .56s cubic-bezier(.2,.9,.2,1.2) both;
  z-index:10; /* keep suggestions above following content */
}
@keyframes popIn{ 0%{transform:scale(.88);opacity:0}60%{transform:scale(1.03);opacity:1}100%{transform:scale(1)} }

/* The pill itself: gradient border + soft halo + “hanging” underline */
#wizViewStartup .wiz-searchShell{
  width:100%; display:flex; align-items:center; gap:8px; padding:8px;
  border:2px solid transparent; border-radius:999px; position:relative;
  background:var(--card);
  background-image:
    linear-gradient(var(--card), var(--card)),
    conic-gradient(from 200deg,
      var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  background-clip: padding-box, border-box;
  background-origin: padding-box, border-box;
  box-shadow: var(--shadow);
  transition: transform .08s ease, box-shadow .18s ease, filter .18s ease;
}
#wizViewStartup .wiz-searchShell::before{
  content:""; position:absolute; inset:-10px; border-radius:999px; z-index:-1;
  filter: blur(22px) saturate(120%);
  background: conic-gradient(from 200deg,
    var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  opacity:.16; transition: opacity .18s ease, filter .18s ease;
}
#wizViewStartup .wiz-searchShell::after{
  content:""; position:absolute; left:10%; right:10%; bottom:-6px; height:4px; border-radius:999px;
  background: linear-gradient(90deg,
    var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  opacity:0; transform: translateY(0); transition: opacity .20s ease, transform .20s ease; pointer-events:none;
}
#wizViewStartup .wiz-searchShell:hover,
#wizViewStartup .wiz-searchShell:focus-within{
  transform: translateY(-1px);
  box-shadow: 0 16px 32px rgba(0,0,0,.12), 0 4px 10px rgba(0,0,0,.10);
}
#wizViewStartup .wiz-searchShell:hover::before,
#wizViewStartup .wiz-searchShell:focus-within::before{
  opacity:.20; filter: blur(22px) saturate(125%);
}
#wizViewStartup .wiz-searchShell:hover::after,
#wizViewStartup .wiz-searchShell:focus-within::after{
  opacity:.95; transform: translateY(2px);
}

/* Input sizing/typography parity with index */
#wizViewStartup #wizQ{
  display:block; width:100%; max-width:100%; box-sizing:border-box;
  min-height:48px; padding:12px 16px;
  border:none; outline:none; border-radius:16px; background:transparent; color:var(--fg);
  font:16px/1.2 inherit;
}

/* “search” button parity (overrides .btn sm look inside the shell) */
#wizViewStartup #wizGo{
  border:none; border-radius:999px; padding:10px 14px; cursor:pointer;
  font-weight:600; text-transform:lowercase;
  background: var(--fg); color:#fff;
}
#wizViewStartup #wizClear{ border:none; background:transparent; color:var(--muted); cursor:pointer; }

/* Typeahead shell parity (index uses #ta; wizard uses #taSug .box) */
#wizViewStartup #taSug{
  position:absolute; left:10px; right:10px; top:calc(100% + 8px);
  z-index:300;
}
#wizViewStartup #taSug .box{
  border:1px solid var(--border); background:var(--card); border-radius:12px;
  box-shadow: var(--shadow); max-height:260px; overflow:auto;
}

/* Quick actions row parity */
#wizViewStartup .searchCtas, 
#wizViewStartup .quickRow{
  display:grid;
  grid-template-columns:repeat(3, minmax(0,1fr));
  gap:8px; margin-top:10px;
}
@media (max-width:480px){
  #wizViewStartup .searchCtas .btn, #wizViewStartup .quickRow .btn{ padding:8px 12px }
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce){
  #wizViewStartup .wiz-searchShell,
  #wizViewStartup .wiz-searchShell::before,
  #wizViewStartup .wiz-searchShell::after{ transition:none }
}

/* Header should be flush on the Wizard page */
header.no-edge{
  background: transparent;
  -webkit-backdrop-filter: none;
  backdrop-filter: none;
  border-bottom: none;
  box-shadow: none;
}

/* ===== Wizard search: subtle mode (no underline, softer glow) ===== */

/* Reduce border rainbow to a gentle hint */
#wizSearchShell{
  border-width: 1px;                 /* thinner than 2px */
  background:
    linear-gradient(var(--card), var(--card)) padding-box,
    conic-gradient(from 200deg,
      color-mix(in srgb, var(--r1), transparent 88%),
      color-mix(in srgb, var(--r2), transparent 90%),
      color-mix(in srgb, var(--r3), transparent 92%),
      color-mix(in srgb, var(--r4), transparent 90%),
      color-mix(in srgb, var(--r5), transparent 90%),
      color-mix(in srgb, var(--r6), transparent 88%),
      color-mix(in srgb, var(--r1), transparent 88%)
    ) border-box !important;         /* ensure we win against the utility */
  background-clip: padding-box, border-box;
  background-origin: padding-box, border-box;
}

/* Kill the “hanging rainbow” underline entirely */
#wizSearchShell::after{ display: none !important; }

/* Make the halo almost imperceptible */
#wizSearchShell::before{
  opacity: .04 !important;           /* was ~.10–.16 */
  filter: blur(12px) saturate(104%) !important;
}
#wizSearchShell:hover::before,
#wizSearchShell:focus-within::before{
  opacity: .06 !important;           /* gentle bump instead of a glow bomb */
  filter: blur(14px) saturate(106%) !important;
}

/* Softer hover: no lift, lighter shadow */
#wizSearchShell:hover,
#wizSearchShell:focus-within{
  transform: none !important;
  box-shadow: 0 8px 20px rgba(0,0,0,.08), 0 2px 6px rgba(0,0,0,.06) !important;
}

/* If the .rainbow utility is present on the shell, neutralize its stronger hover */
#wizSearchShell.rainbow:hover{
  background:
    linear-gradient(color-mix(in srgb, var(--card), white 2%), color-mix(in srgb, var(--card), white 2%)) padding-box,
    conic-gradient(from 200deg,
      color-mix(in srgb, var(--r1), transparent 88%),
      color-mix(in srgb, var(--r2), transparent 90%),
      color-mix(in srgb, var(--r3), transparent 92%),
      color-mix(in srgb, var(--r4), transparent 90%),
      color-mix(in srgb, var(--r5), transparent 90%),
      color-mix(in srgb, var(--r6), transparent 88%),
      color-mix(in srgb, var(--r1), transparent 88%)
    ) border-box !important;
}

/* Quick actions: no stretch; size to content like the home page */
#wizViewStartup .quickRow,
#wizViewStartup .searchCtas{
  display: flex !important;
  justify-content: center;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

/* Tighten the button padding slightly on the wizard page */
#wizViewStartup .quickRow .btn,
#wizViewStartup .searchCtas .btn{
  padding: 6px 10px;                 /* was 6px 12–14px */
  min-width: auto;                    /* don’t force equal widths */
}


</style>
</head>
<body>

<header class="no-edge">

<a class="btn sm" href="../index.html">← back to home</a>
<div class="spacer"></div>


<button class="btn sm hide" id="btnExitSearch">search</button>

<!-- AI: -->
  <button id="aiSettingsBtn" class="btn sm" type="button" title="AI Assist Settings">ai settings</button>

  </header>

  <main class="wiz-root">


    <!-- Startup view -->
    <section id="wizViewStartup" class="wiz-startup">
        <!-- Header strip: search pill -->
<div class="wiz-header-search" id="wizHdr">
  <div class="searchCenter">
    <div class="wiz-searchShell search rainbow" id="wizSearchShell">
      <input id="wizQ" type="text" placeholder="search use-cases, labels, tags…" autocomplete="off" />
      <button id="wizClear" class="wiz-clear" title="clear">×</button>
     <button id="wizGo" class="btn sm">search</button>
      <div id="taSug" hidden>
      <div class="box" role="listbox" aria-label="suggestions"></div>
      </div>
    </div>
        <p class="hint">type what you want to make in everyday words — we’ll shape it into a clear ai prompt.</p>

        <div class="quickRow searchCtas">
         <a id="btnAdv" class="btn sm rainbow" href="./templates-glossary.html">advanced search</a>
      <a id="btnHelp"  class="btn sm rainbow"  href="./startup-wizard.html?slug=pattern-picker">help me</a>
      <button id="btnLucky" class="btn sm rainbow">i’m feeling lucky</button>
    </div>
  </div>
</div>
     <!-- existing Startup content begins -->
<div class="wiz-row">
  <label for="wizAllSelect" class="muted">all matches</label>
  <span id="wizMatchMeta" class="muted" style="margin-left:8px">0 matches of 0 total</span>
</div>
<select id="wizAllSelect" style="min-width:280px">
  <option value="" disabled selected>— choose a template —</option>
</select>
<div id="wizTop" class="block">
  <div class="block-title">
    <h3>top matches</h3>
    <div class="right" style="display:flex; align-items:center; gap:10px">
      <button id="btnNext3" class="btn sm">next 3</button>
      <span id="wizTopMeta" class="muted">showing 0 of 0 (out of 0)</span>
    </div>
  </div>
  <div id="wizTopCards" class="wiz-cards" style="margin-top:8px"></div>
</div>
    </section>

    <!-- Step 0 view -->
    <section id="wizViewStep0" class="wiz-step0 hide">
      <h2 class="title" id="wizStep0Title">template</h2>
      <p class="def" id="wizStep0Def"></p>
      <ul class="meta" id="wizStep0Stats"></ul>
      <div class="uses">
        <div class="subhead">use-cases</div>
        <ul id="wizStep0Uses"></ul>
      </div>
<div class="step0-actions">
  <button id="wizStep0Start" class="btn primary">← start guided setup</button>
  <button id="wizExitSearch" class="btn">back to search</button>
</div>
    </section>

    <!-- Steps view -->
    <section id="wizViewSteps" class="hide">
        <div id="wizTopProgress" class="wiz-topprog hide">
  <div class="wiz-topprog-bar" aria-hidden="true"><i id="tpBar"></i></div>
  <div class="wiz-topprog-meta">
    <span id="tpStep">step 1 of 1</span>
    <span aria-hidden="true">•</span>
    <span id="tpPct">0%</span>
    <span aria-hidden="true">•</span>
    <span id="tpEnc">let’s get rolling</span>
    <span aria-hidden="true">•</span>
    <span id="tpTime">~0 min left</span>
  </div>
</div>
      <div class="wiz-stepsWrap">
        <aside class="wiz-rail">
          <div class="wiz-prog" aria-hidden="true"><i id="wizProgBar"></i></div>
          <ul id="wizStepList"></ul>
        </aside>
        <div class="wiz-pane">
          <div id="wizStepBody"></div>
          <div class="wiz-foot">
            <button id="wizShowAll" class="btn">show all</button>
            <div class="spacer"></div>
            <button id="wizStepBack" class="btn">← back</button>
            <button id="wizStepNext" class="btn primary rainbow-hover">next →</button>
          </div>
        </div>
      </div>
    </section>
  </main>
  
  <!-- === Slice 1: Action Modal (shared for Copy / Ask) === -->
<dialog id="actionModal" aria-labelledby="actionTitle">
  <div class="dlg-head">
    <div id="actionTitle" class="title">Copy prompt</div>
    <button id="actionClose" class="icon-btn" aria-label="Close">×</button>
  </div>
  <div class="dlg-body">
    <textarea id="actionPreview" aria-label="Editable prompt preview"></textarea>
    <p id="actionNote" class="note" hidden>
      If your prompt doesn’t appear in ChatGPT, very long URLs or cached drafts can get in the way. You’ll be able to open a clean chat or copy/paste manually.
    </p>
  </div>
  <div class="dlg-foot">
    <span id="copyStatus" role="status" aria-live="polite" aria-atomic="true" hidden>Copied to clipboard.</span>
    <div class="grow"></div>
    <button id="actionCopy" class="btn sm">Copy</button>
    <button id="actionCancel" class="btn sm">Close</button>
  </div>
</dialog>

<!-- === Slice 3: Post-Launch Helper (shown after returning from ChatGPT) === -->
<dialog id="postLaunchDlg" aria-labelledby="postLaunchTitle">
  <div class="dlg-head">
    <div id="postLaunchTitle" class="title">Did the prompt appear in ChatGPT?</div>
    <button id="postLaunchClose" class="icon-btn" aria-label="Close">×</button>
  </div>

  <div class="dlg-body">
    <p id="postLaunchMsg" class="note">
      If it didn’t, very long URLs or a cached draft can get in the way.
      You can open a clean chat or copy the prompt and paste it manually.
    </p>

    <textarea id="postLaunchText" aria-label="Your prompt (read-only)" readonly></textarea>
  </div>

  <div class="dlg-foot">
    <span id="postLaunchStatus" role="status" aria-live="polite" aria-atomic="true" hidden></span>
    <div class="grow"></div>
    <button id="postLaunchOpenBase" class="btn sm">Open clean chat</button>
    <button id="postLaunchCopy" class="btn sm">Copy again</button>
    <button id="postLaunchDismiss" class="btn sm">Dismiss</button>
  </div>
</dialog>


  <script>
  // Tiny UI state (theme, mode preference)
  function readUI(){ try{ return JSON.parse(localStorage.getItem('pb.v1.ui')||'{}'); }catch(_){ return {}; } }
  function writeUI(x){ localStorage.setItem('pb.v1.ui', JSON.stringify(Object.assign(readUI(), x))); }

  // ===== Data access: dedupe across FRAMEWORKS/TEMPLATES/TASK_TEMPLATES =====
  function allTemplates(){
    const A = [];
    const seen = new Set();
    const sources = [window.FRAMEWORKS, window.TEMPLATES, window.TASK_TEMPLATES, window.TASKS, window.templates, window.tasks]
      .filter(Boolean);
    for (const src of sources){
      for (const t of src){
        const kind = (t.kind||t.type||'framework').toLowerCase();
        const id   = (t.id||t.slug||t.key||t.label||'').toString().toLowerCase().trim();
        const slug = (t.slug||id).toLowerCase();
        const key  = kind+':'+(slug||id);
        if (!id) continue;
        if (seen.has(key)) continue;
        seen.add(key);
        A.push(Object.assign({ kind, slug }, t));
      }
    }
    return A;
  }

  // ===== Ranking: prioritize full-phrase, whole-word, starts-with =====
// ===== Index & Ranking (use-case first, tags second; task-nudged) =====
const REC_KEY = 'pb_recent_queries';

function getRecents(){
  try{
    const arr = JSON.parse(localStorage.getItem(REC_KEY) || '[]');
    return Array.isArray(arr) ? arr : [];
  }catch(_){ return []; }
}
function saveRecent(q){
  const s = (q||'').trim(); if (!s) return;
  const cur = getRecents();
  const idx = cur.findIndex(x => x.toLowerCase() === s.toLowerCase());
  if (idx >= 0) cur.splice(idx,1);
  cur.unshift(s);
  localStorage.setItem(REC_KEY, JSON.stringify(cur.slice(0,12)));
}

function isTaskKind(kind){ return (kind||'').toLowerCase()==='task'; }
function isHelperTemplate(t){
  const lab = (t.label||'').toLowerCase();
  const tags = ((t.tags||[]).join(' ')||'').toLowerCase();
  return /helper|picker|guide|wizard/.test(lab+' '+tags);
}

// Build a compact index of searchables from templates & tasks.
let SEARCH_INDEX = [];
function buildIndex(){
  const T = allTemplates(); // already merges framework+tasks
  const idx = [];
  for (const t of T){
    const kind = (t.kind||'framework').toLowerCase();
    const id   = (t.id||t.slug||t.key||t.label||'').toString();
    const slug = (t.slug||'').toString();
    const isTask = isTaskKind(kind) || /^task[_:\-]/i.test(id) || /^task[_:\-]/i.test(slug);
    const uses = Array.isArray(t.use_cases) ? t.use_cases : [];
    const tags = Array.isArray(t.tags) ? t.tags : [];
    const cats = Array.isArray(t.categories) ? t.categories : (t.category? [t.category] : []);

    // extract "use:" tags as dedicated use-tags (lightweight)
    const useTags = tags
      .map(x=> String(x||'').trim().toLowerCase())
      .filter(x=> x.startsWith('use:'))
      .map(x=> x.replace(/^use:\s*/,'').trim())
      .filter(Boolean);

    // index each use-case as a suggestion candidate
    for (const u of uses){
      const text = String(u||'').trim();
      if (!text) continue;
      idx.push({ bucket:'uc', text, t, kind, isTask });
    }
    // index "use:" tags as lighter suggestions
    for (const tag of useTags){
      idx.push({ bucket:'tag', text: tag, t, kind, isTask });
    }
  }
  SEARCH_INDEX = idx;
}

function tokenize(s){ return (s||'').toLowerCase().split(/[^a-z0-9]+/).filter(Boolean); }

// Scoring tuned for use-cases (UCs first), then use: tags; gentle task nudge.
function scoreOne(q, entry){
  const Q = (q||'').trim().toLowerCase();
  const T = entry.text.toLowerCase();
  if (!Q || !T) return 0;

  let s = 0;
  // Phrase & substring bonuses
  if (T.includes(Q)) s += 220;                 // exact phrase
  if (Q.includes(T) && T.length>2) s += 120;   // entry is substring of the full query
  // Token scoring
  const qTok = tokenize(Q);
  for (const w of qTok){
    if (T === w) s += 80;                       // exact token equals use
    if (new RegExp(`\\b${w}\\b`).test(T)) s += 40; // word-boundary hit
    if (T.indexOf(w) >= 0) s += 24;             // substring
    if (T.startsWith(w)) s += 10;               // starts-with nudge
  }
  // Kind nudges
  if (entry.isTask) s += 30;                    // tasks up-weighted
  if (qTok.some(w => (entry.kind||'').includes(w))) s += 12; // kind-token overlap
  // Brevity & position nudges (mild; only if matched)
  if (s>0){
    s += Math.max(0, 20 - Math.min(20, T.length/6)); // shorter use-cases get tiny lift
  }
  return s;
}

// Build idle suggestions: recents first, then helpers (use-cases)
function helperUsecaseSuggestions(limit=8){
  const out = [];
  for (const e of SEARCH_INDEX){
    if (e.bucket!=='uc') continue;
    if (!isHelperTemplate(e.t)) continue;
    out.push({ kind:e.kind, isTask:e.isTask, bucket:'uc', text:e.text, t:e.t, idle:true });
    if (out.length>=limit) break;
  }
  return out;
}
function buildIdleSuggestions(limit=8){
  const rec = getRecents().slice(0,limit).map(q => ({ bucket:'recent', text:q }));
  if (rec.length>=limit) return rec;
  const need = limit - rec.length;
  return rec.concat(helperUsecaseSuggestions(need));
}

function rankSuggestions(q, limit=8){
  const list = SEARCH_INDEX.map(e => ({
    e, score: scoreOne(q, e),
  })).filter(x => x.score>0);

  // If too few or weak, inject helpers near the top to keep UX friendly
  let suggestions = list.sort((a,b)=> b.score - a.score);
  if (suggestions.length < 3){
    const inject = helperUsecaseSuggestions(Math.max(3, limit));
    const maxScore = suggestions[0]?.score || 200;
    suggestions = inject.map((h,i)=>({ e:h, score:maxScore + 5 - i })).concat(suggestions);
  }

  // Sort: bucket (uc > tag), score desc, isTask desc, use-length asc, alpha
  suggestions.sort((A,B)=>{
    const a=A.e, b=B.e;
    const bucketOrder = (a.bucket==='uc'?0:1) - (b.bucket==='uc'?0:1);
    if (bucketOrder!==0) return bucketOrder;
    if (B.score!==A.score) return B.score - A.score;
    if ((b.isTask?1:0)!==(a.isTask?1:0)) return (b.isTask?1:0)-(a.isTask?1:0);
    const la=a.text.length, lb=b.text.length; if (la!==lb) return la-lb;
    return a.text.localeCompare(b.text);
  });

  // map to plain suggestion entries and cap
  return suggestions.slice(0, limit).map(x => x.e);
}

  // ===== Renderers =====
  const el = id => document.getElementById(id);
  const qs = sel => document.querySelector(sel);

  function estimateTimeByFields(n){
    const approx = Math.max(1, Math.min(60, Math.ceil((n||0)*0.75))); // ~minutes   [oai_citation:14‡prompt_builder_test.html](file-service://file-9EZtQuEpjH3EQyYCFvQSHV)
    return `~${approx} min`;
  }

  function rowsFromTemplates(T){
    return T.map(t=>{
      const useText = Array.isArray(t.use_cases) && t.use_cases.length ? t.use_cases.join(' • ') : (t.label||t.slug||t.id||'');
      return {
        id:t.id, slug:t.slug, key:t.key, label:(t.label||t.slug||t.id||'template'),
        definition:(t.definition||t.help||''), useText, kind:(t.kind||'framework'), ref:t
      };
    });
  }

  function renderAllSelect(rows){
    const sel = el('wizAllSelect');
    const cur = sel.value;
    const opts = [`<option value="" disabled ${!cur?'selected':''}>— choose a template —</option>`]
      .concat(rows.map(r=> `<option value="${r.slug||r.id}" data-id="${r.id||''}" data-slug="${r.slug||''}">${r.label}</option>`));
    sel.innerHTML = opts.join('');
  }

function cardHTML(r){
  // Title = first use-case on the template (fallback: suggestion text or label)
  const firstUse = (r.ref && Array.isArray(r.ref.use_cases) && r.ref.use_cases[0])
    || r.useText || r.label;

  // Subtitle = the template label
  const sub = r.label;

  // Definition with truncation + “more”
  const defFull = String(r.definition||'').trim();
  const LIMIT = 180; // tweak as desired
  const needsMore = defFull.length > LIMIT;
  const defShort = needsMore ? (defFull.slice(0, LIMIT - 1) + '…') : defFull;

  // Unique id per card’s definition container (based on slug/id)
  const defId = 'def_' + (r.slug || r.id || Math.random().toString(36).slice(2));

  return `
    <article class="card" data-id="${r.id||''}" data-slug="${r.slug||''}">
      <div class="card-title">${firstUse}</div>
      <div class="card-sub">${sub}</div>

      <div class="card-def" id="${defId}">
        <span class="short">${defShort}</span>
        ${needsMore
          ? `<button class="btn sm js-more" type="button" data-target="${defId}">more</button>
             <span class="full" hidden>${defFull.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</span>`
          : ''}
      </div>

      <div class="foot" style="margin-top:8px">
        <span></span>
        <button class="btn sm primary rainbow-hover js-use" type="button">use this template</button>
      </div>
    </article>`;
}

let topIndex = 0; // rotating window start

function renderTop(rows){
  const top = el('wizTopCards');
  if (!rows.length){
    top.innerHTML = `<div class="muted">no matches yet — try a different search</div>`;
    el('wizTopMeta').textContent = `showing 0 of 0 (out of ${allRows.length||0})`;
    return;
  }
  // compute current window [topIndex, topIndex+3)
  const start = topIndex % rows.length;
  const slice = [rows[start], rows[(start+1)%rows.length], rows[(start+2)%rows.length]].filter(Boolean);
  top.innerHTML = slice.map(cardHTML).join('');
  el('wizTopMeta').textContent = `showing ${Math.min(3, rows.length)} of ${rows.length} (out of ${allRows.length||0})`;
}



  // ===== Startup compute =====
  let allRows = [];       // every template row
  let matchRows = [];     // current filtered rows
function recompute(query=''){
  // delegate to the unified scanner; do not save history on incidental recomputes
  if (typeof window.__startScan === 'function'){
    window.__startScan(String(query||''), { saveHistory:false });
  }
}

  // ===== Typeahead =====
// ===== Typeahead (use-cases + recents) =====
(function wireTypeahead(){
  const qEl  = el('wizQ');
  const sug  = el('taSug');
  const box  = qs('#taSug .box');
  
    const shell = qEl.closest('.wiz-searchShell'); // the pill that anchors the dropdown
  let portalized = false;

  function ensurePortal(){
    if (!portalized){
      sug.classList.add('ta-portal');
      document.body.appendChild(sug); // move out of lower stacking contexts
      portalized = true;
    }
  }
  function positionSug(){
    const r = shell.getBoundingClientRect();
    // mirror the original left/right 8px padding of the search shell
    const left  = Math.round(r.left + 8);
    const top   = Math.round(r.bottom + 8);          // was calc(100% + 8px)
    const width = Math.max(240, Math.round(r.width - 16));
    Object.assign(sug.style, { left: left+'px', top: top+'px', width: width+'px' });
  }


  let idx = -1, open = false, curList = []; // curList items: {bucket:'uc'|'tag'|'recent', text, t?, kind?, isTask?}

  function renderRows(list){
    box.innerHTML = list.map((r,i)=>`
      <div class="row" role="option" data-i="${i}">
        <div style="display:flex; flex-direction:column; gap:2px; width:100%">
          <div class="lbl">${r.text}</div>
          <div class="muted" style="font-size:12px; display:flex; gap:8px; align-items:center;">
            ${r.t ? `<span>${r.t.label||r.t.slug||'template'}</span>` : `<span>recent</span>`}
            ${r.bucket!=='recent' ? `<span class="pill" style="padding:2px 8px">${r.bucket}${r.isTask?' · task':''}</span>` : ''}
          </div>
        </div>
      </div>
    `).join('');
  }
 function openSug(list){
    curList = list.slice(0,8);
    if (curList.length === 0){ hideSug(); return; }
    renderRows(curList);
    ensurePortal();
    positionSug();
    sug.hidden = false; open = true; idx = 0; highlight(idx);
  }
  function hideSug(){
    sug.hidden = true; open = false; idx = -1; curList = [];
  }
  function hideSug(){ sug.hidden = true; open = false; idx = -1; curList = []; }
  function highlight(i){
    [...box.querySelectorAll('.row')].forEach((r,k)=> r.setAttribute('aria-selected', k===i?'true':'false'));
  }

  function startScan(query, opts={}){
    // Update top-3 + all-matches based on ranked suggestions; do not navigate.
    const q = String(query||'').trim();
    if (opts.saveHistory) saveRecent(q);

    // Rank suggestions, then collapse to unique templates by order
    const ranked = q ? rankSuggestions(q, 64) : [];
    const seen = new Set();
    const dedupRows = [];
    for (const s of ranked){
      const t = s.t; if (!t) continue;
      const slug = (t.slug||t.id||t.label||'').toLowerCase();
      if (seen.has(slug)) continue;
      seen.add(slug);
      dedupRows.push({ // row used by Top/All renders
        id:t.id, slug:t.slug, key:t.key, label:(t.label||t.slug||t.id||'template'),
        definition:(t.definition||t.help||''), useText: s.text, kind:(t.kind||'framework'), ref:t
      });
    }

    matchRows = dedupRows.length ? dedupRows : rowsFromTemplates(allTemplates()).sort((a,b)=> a.label.localeCompare(b.label));
    el('wizMatchMeta').textContent = `${matchRows.length} matches of ${rowsFromTemplates(allTemplates()).length} total`;

    topIndex = 0;
    renderAllSelect(matchRows);
    renderTop(matchRows);
  }

  function choose(i){
    const r = curList[i]; if (!r) return;
    qEl.value = r.text;
    hideSug();
    if (r.bucket==='recent'){
      // Re-rank for this query, then show top-3; save to history again
      startScan(r.text, { saveHistory:true });
    }else{
      startScan(r.text, { saveHistory:true });
    }
  }

  qEl.addEventListener('focus', ()=>{
    const val = qEl.value.trim();
    if (!val) openSug(buildIdleSuggestions(8));
  });
  qEl.addEventListener('blur', ()=>{
    // Delay to allow click selection
    setTimeout(()=> hideSug(), 120);
  });

  qEl.addEventListener('input', ()=>{
    const val = qEl.value;
    if (!val.trim()){
      openSug(buildIdleSuggestions(8));
      // optional: keep Top-3 as last “run”; don’t overwrite
      return;
    }
    // Live suggestions; also update Top-3 live without writing history
    openSug(rankSuggestions(val, 8));
    // Live top refresh (no history write)
    startScan(val, { saveHistory:false });
  });

  qEl.addEventListener('keydown', (e)=>{
    if (!open){
      if (e.key==='Enter'){
        e.preventDefault();
        startScan(qEl.value, { saveHistory:true }); // run typed query
      }
      return;
    }
    if (e.key==='ArrowDown'){ idx = Math.min(curList.length-1, idx+1); highlight(idx); e.preventDefault(); }
    else if (e.key==='ArrowUp'){ idx = Math.max(0, idx-1); highlight(idx); e.preventDefault(); }
    else if (e.key==='Enter'){ e.preventDefault(); choose(idx>=0?idx:0); }
    else if (e.key==='Escape'){ hideSug(); }
  });

  box.addEventListener('mousedown', (e)=>{
    // mousedown so blur doesn’t cancel
    const row = e.target.closest('.row'); if (!row) return;
    choose(+row.dataset.i);
  });
  
    // keep the portal aligned as the page moves/resizes
  window.addEventListener('resize', ()=>{ if (!sug.hidden) positionSug(); });
  // capture scrolls from any ancestor (left rail, main pane, window)
  window.addEventListener('scroll', ()=>{ if (!sug.hidden) positionSug(); }, true);


  // expose for other buttons
  window.__startScan = startScan;
})();

  // ===== Header search router: if not on Startup, bounce back then replay =====
  (function headerSearchRouter(){
    const qEl  = el('wizQ'), goEl = el('wizGo');
    let reenter = false; // guard so native handler runs once   [oai_citation:15‡prompt_builder_test.html](file-service://file-9EZtQuEpjH3EQyYCFvQSHV)
    function currentView(){ return !el('wizViewStartup').classList.contains('hide') ? 'startup' :
                                   !el('wizViewStep0').classList.contains('hide') ? 'step0' : 'steps'; }
    function gotoStartup(){ if (currentView()!=='startup'){ showView('startup'); } }

    goEl.addEventListener('click', (e)=>{
      if (reenter || currentView()==='startup') return;
      e.preventDefault(); e.stopPropagation();
      gotoStartup();
      setTimeout(()=>{ reenter=true; try{ goEl.click(); } finally{ reenter=false; } }, 0);  /*  [oai_citation:16‡prompt_builder_test.html](file-service://file-9EZtQuEpjH3EQyYCFvQSHV) */
    }, true);

    qEl.addEventListener('keydown', (e)=>{
      if (e.key!=='Enter' || currentView()==='startup') return;
      e.preventDefault(); e.stopPropagation();
      const ev = new KeyboardEvent('keydown', { key:'Enter', bubbles:true, cancelable:true });
      gotoStartup();
      setTimeout(()=>{ reenter=true; try{ qEl.dispatchEvent(ev);} finally{ reenter=false; } }, 0);  /*  [oai_citation:17‡prompt_builder_test.html](file-service://file-9EZtQuEpjH3EQyYCFvQSHV) */
    }, true);
  })();

// ===== Startup actions =====
el('wizGo').addEventListener('click', ()=>{
  const val = el('wizQ').value;
  if (document.getElementById('taSug') && !document.getElementById('taSug').hidden){
    // dropdown is open → choose top suggestion
    if (typeof window.__startScan === 'function'){
      window.__startScan(val, { saveHistory:true });
    }
  }else{
    // no dropdown → run typed query
    if (typeof window.__startScan === 'function'){
      window.__startScan(val, { saveHistory:true });
    }
  }
});


  el('wizClear').addEventListener('click', ()=>{ el('wizQ').value=''; recompute(''); });

  document.addEventListener('change', (ev)=>{
    const elx = ev.target;
    if (elx && elx.id==='wizAllSelect'){
      const opt = elx.selectedOptions && elx.selectedOptions[0]; if (!opt) return;
      const slug = opt.getAttribute('data-slug')||''; const id = opt.getAttribute('data-id')||'';
      const t = (allTemplates().find(x => (x.slug||'')===slug || (x.id||'')===id) || {}).ref || allTemplates().find(x => (x.slug||'')===slug || (x.id||'')===id) || null;
      if (!t) return;
      openStep0(t);  // delegated select → step0   [oai_citation:18‡prompt_builder_test.html](file-service://file-9EZtQuEpjH3EQyYCFvQSHV)
    }
  }, true);




  // Quick actions
  el('btnLucky').addEventListener('click', ()=>{
    const T = [...allTemplates()];
    for (let i=T.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [T[i],T[j]]=[T[j],T[i]]; }
    const rows = rowsFromTemplates(T).slice(0,3);
    el('wizTopCards').innerHTML = rows.map(cardHTML).join('');
  });
  el('btnHelp').addEventListener('click', ()=>{
    const rows = matchRows.filter(r => /picker|helper|guide|wizard/i.test(r.label + ' ' + r.useText)).slice(0,3);
    el('wizTopCards').innerHTML = (rows.length? rows: matchRows.slice(0,3)).map(cardHTML).join('');
  });

  // Click “Use this template” on any card → Step 0 (delegated)
  document.addEventListener('click', (ev)=>{
    const btn = ev.target.closest('.js-use'); if (!btn) return;
    const card = btn.closest('.card'); if (!card) return;
    const slug = card.getAttribute('data-slug')||''; const id = card.getAttribute('data-id')||'';
    const t = allTemplates().find(x => (x.slug||'')===slug || (x.id||'')===id) || null;
    if (t) openStep0(t);   // delegated button → step0   [oai_citation:19‡prompt_builder_test.html](file-service://file-9EZtQuEpjH3EQyYCFvQSHV)
  }, true);

  // ===== View switching (page version of your controller) =====
function showView(name){
  const s0 = el('wizViewStartup'), s1 = el('wizViewStep0'), s2 = el('wizViewSteps');
  s0.classList.toggle('hide', name!=='startup');
  s1.classList.toggle('hide', name!=='step0');
  s2.classList.toggle('hide', name!=='steps');

  // header affordances: show "exit to search" when not on main page
  const isStartup = name === 'startup';
  const exitSearch = el('btnExitSearch');
  if (exitSearch) exitSearch.classList.toggle('hide', isStartup);

  // NEW: Only show quick action buttons on Startup
  ['btnHelp','btnLucky'].forEach(id=>{
    const btn = el(id);
    if (btn) btn.classList.toggle('hide', !isStartup);
  });

  // Optional: collapse the row entirely so there’s no extra gap
  const quickRow = document.querySelector('.quickRow');
  if (quickRow) quickRow.classList.toggle('hide', !isStartup);
}

  
  
  // Next 3 — cycle the rotating window
el('btnNext3').addEventListener('click', ()=>{
  if (!matchRows.length) return;
  topIndex = (topIndex + 3) % Math.max(1, matchRows.length);
  renderTop(matchRows);
});

  // ===== Step 0 =====
  let CURRENT = null;
  function renderStep0Meta(t){
    el('wizStep0Title').textContent = String(t.label||t.slug||t.id||'template');
    const def = String(t.definition||t.help||'').trim();
el('wizStep0Def').textContent = def;

// fields count as before
const fields = Array.isArray(t.fields) ? t.fields.length : 0;

// LIMIT: show only the first 10 use-cases
const uses = Array.isArray(t.use_cases) ? t.use_cases.slice(0, 10) : [];

// REMOVE total use-cases count line from stats
el('wizStep0Stats').innerHTML =
  `<li><strong>${fields}</strong> fields</li>
   <li><strong>${estimateTimeByFields(fields)}</strong> to complete</li>`;

// Render only the (up to) 10 use-cases
el('wizStep0Uses').innerHTML = uses.length
  ? uses.map(u=>`<li>${u}</li>`).join('')
  : `<li class="muted">no use-cases listed</li>`;

  }

  function openStep0(t){
    CURRENT = t;
    renderStep0Meta(t);
    showView('step0');
     if (typeof window.__setURLForTemplate==='function') // ⟵ add this
    window.__setURLForTemplate(t);
    el('wizTopProgress').classList.add('hide'); // add this
  }


// Expand long definitions: reveal full text, hide short + button
document.addEventListener('click', (ev)=>{
  const more = ev.target.closest('.js-more'); if (!more) return;
  const id = more.getAttribute('data-target'); const def = document.getElementById(id);
  if (!def) return;
  const short = def.querySelector('.short');
  const full  = def.querySelector('.full');
  if (full){ if (short) short.hidden = true; full.hidden = false; }
  more.remove();
}, true);

// ---- Field state tracking (touched & values) ----
const TOUCH = new Set();           // field ids user interacted with
const VALUES = new Map();          // field id -> current value text

function computeFieldId(f){
  const base = (f.id||f.key||f.slug||f.label||('x_'+Math.random().toString(36).slice(2))).toString();
  return 'fld_'+base.toLowerCase().replace(/[^a-z0-9]+/g,'_');
}
function isTextAreaOrRepeater(f){
  const t = String(f.type||'').toLowerCase();
  return /textarea|repeater/.test(t);
}
function fieldFilled(fid){
  const el = document.getElementById(fid);
  if (!el){
    const v = (VALUES.get(fid)||'').trim();
    return v.length > 0;
  }
  if (el.tagName === 'SELECT' && el.multiple){
    return [...el.selectedOptions].length > 0 || ((VALUES.get(fid)||'').trim().length>0);
  }
  const v = (el.value||'').trim();
  return v.length > 0;
}

// Read a field by id; prefer the VALUES map (survives step unmounts)
function wiz_getVal(id){
  const v = (VALUES.get(id) ?? '').toString().trim();
  if (v) return v;
  const el = document.getElementById(id);
  return ((el && el.value) ? String(el.value).trim() : '');
}
function encouragement(p){
  if (p>=100) return 'ready to ship';
  if (p>=90)  return 'final polish';
  if (p>=75)  return 'home stretch';
  if (p>=50)  return 'over halfway';
  if (p>=25)  return 'nice pace';
  if (p>0)    return 'good start';
  return 'let’s get rolling';
}

// collect remaining work for time estimate (template-only steps)
function remainingFieldCount(){
  if (!Array.isArray(STEPS)||!STEPS.length) return 0;
  let total = 0;
  for (const g of STEPS){
    if (g.special) continue; // skip overview/extra/output from ETA
    for (const fid of (g.fids||[])) total += fieldFilled(fid)?0:1;
  }
  return total;
}



function stepStatusFor(i){
  const S = STEPS[i]; if (!S) return '';
  if (S.special) return ''; // overview/extra/output are informational
  const fids = S.fids||[];
  if (!fids.length) return 'done';
  const allFilled = fids.every(fieldFilled);
  if (allFilled) return 'done';
  const anyTouched = fids.some(fid => TOUCH.has(fid) || (VALUES.get(fid)||'').trim().length>0);
  return anyTouched ? 'warn' : '';
}

function updateStepStates(prevIndex){
  const items = document.querySelectorAll('#wizStepList li');
  items.forEach((li, i)=>{
    li.classList.remove('done','warn');
    const s = stepStatusFor(i);
    if (s) li.classList.add(s);
    li.setAttribute('aria-current', i===STEP_INDEX ? 'true' : 'false');
  });
  if (typeof prevIndex==='number'){
    const li = items[prevIndex];
    if (li){
      li.classList.remove('done','warn');
      const s = stepStatusFor(prevIndex);
      if (s) li.classList.add(s);
    }
  }
}

function updateTopProgress(){
  const bar = el('tpBar'), stepTxt = el('tpStep'), pctTxt = el('tpPct'), encTxt = el('tpEnc'), timeTxt = el('tpTime');
  const totalSteps = STEPS.length||1;
  const cur = STEP_INDEX+1;
  stepTxt.textContent = `step ${cur} of ${totalSteps}`;

  const req = (STEPS.filter(s=>!s.special).flatMap(s=> s.fids||[])).length || 1;
  const filled = STEPS.filter(s=>!s.special).flatMap(s=> s.fids||[]).reduce((n,fid)=> n + (fieldFilled(fid)?1:0), 0);
  const pct = Math.round((filled/req)*100);
  bar.style.width = pct+'%';
  pctTxt.textContent = `${pct}%`;
  encTxt.textContent = encouragement(pct);

  const rem = remainingFieldCount();
  timeTxt.textContent = `${estimateTimeByFields(rem)} left`;
}

/* ==== Slice 2: Extras parity — helpers =================================== */

/* Get the joined boosters string for the current framework (or '') */
function wiz_defaultBooster(fw){
  const boosters = Array.isArray(fw?.boosters) ? fw.boosters : [];
  return boosters.join(' ').trim();
}

/* Update a small char counter next to a textarea */
function wiz_updateCounter(textareaEl, counterEl){
  if (!textareaEl || !counterEl) return;
  const n = (textareaEl.value || '').length;
  counterEl.textContent = `${n} chars`;
}

function setSelectValue(selectEl, saved){
  if (!selectEl) return;
  const isMulti = !!selectEl.multiple;
  if (!isMulti){ selectEl.value = saved || ''; return; }
  const want = new Set(String(saved||'').split(/\s*,\s*|\n+/).filter(Boolean));
  [...selectEl.options].forEach(opt => opt.selected = want.has(opt.value));
}


// Set input/textarea/select values from VALUES so edits persist across step switches
function wiz_hydrateFields(container){
  if (!container) return;
  container.querySelectorAll('input[type="text"], textarea, select').forEach(ctrl=>{
    const id = ctrl.id; if (!id) return;
    const saved = VALUES.get(id);
    if (typeof saved !== 'string') return;
    if (ctrl.tagName === 'SELECT'){ setSelectValue(ctrl, saved); }
    else { ctrl.value = saved; }
  });
}


/* Wire Extras UI: placeholder, optional prefill, counters, and Restore */
function wiz_bindExtrasUI(fw){
  const extra   = document.getElementById('extra');
  const extraCt = document.getElementById('extraCnt');
  const more    = document.getElementById('extraMore');
  const moreCt  = document.getElementById('extraMoreCnt');
  const restore = document.getElementById('extraRestore');

  if (!extra || !more) return;

  const boosters = wiz_defaultBooster(fw);

  // 1) Hydrate from saved VALUES first (so user text persists across step changes)
  const savedExtra = wiz_getVal('extra');
  const savedMore  = wiz_getVal('extraMore');
  if (savedExtra){ extra.value = savedExtra; }
  if (savedMore){  more.value  = savedMore;  }

  // 2) If still empty and boosters exist, seed boosters as initial value (default shows in Output)
  if (!extra.value && boosters){
    extra.value = boosters;
    VALUES.set('extra', boosters);
  }

  // 3) Always show boosters as placeholder (visual hint)
  extra.placeholder = boosters || 'Write instructions to replace the template’s boosters (optional)';

  // 4) Counters (initial paint)
  wiz_updateCounter(extra, extraCt);
  wiz_updateCounter(more,  moreCt);

  // 5) Input listeners keep VALUES map & preview in sync
  const onInput = (ev)=>{
    const t = ev.target;
    if (!t || !t.id) return;
    VALUES.set(t.id, t.value || '');
    if (t.id === 'extra') wiz_updateCounter(extra, extraCt);
    if (t.id === 'extraMore') wiz_updateCounter(more,  moreCt);
    renderPreviewMaybe();
  };
  extra.addEventListener('input', onInput);
  more.addEventListener('input', onInput);

  // 6) Restore button → boosters as current value (+ preview)
  if (restore){
    restore.disabled = !boosters;
    restore.addEventListener('click', ()=>{
      if (!boosters) return;
      extra.value = boosters;
      VALUES.set('extra', boosters);
      wiz_updateCounter(extra, extraCt);
      renderPreviewMaybe();
      extra.focus();
    });
  }

  // 7) Ensure preview matches hydrated/seeded values even if user never types here
  renderPreviewMaybe();
}


/* ==== Wizard → Prompt composer (Slice 1 shim) ============================= */
/* Collect Common Context (Step 1) safely from DOM */
function wiz_collectCommonContext(){
  const use   = wiz_getVal('ctx_use');
  const aud   = wiz_getVal('ctx_aud');
  const style = wiz_getVal('ctx_style');
  const tone  = wiz_getVal('ctx_tone');

  const bits = [];
  if (use)   bits.push(`Use-case: ${use}`);
  if (aud)   bits.push(`Audience: ${aud}`);
  if (style) bits.push(`Style: ${style}`);
  if (tone)  bits.push(`Tone: ${tone}`);
  const ctx = bits.join(' | ');

  const persona = aud ? `Persona/Audience: ${aud}${style?` | Style: ${style}`:''}${tone?` | Tone: ${tone}`:''}` : '';

  return { ctx, persona, raw:{ use, aud, style, tone } };
}

/* Split textareas/repeaters into list items (— or newline separated) */
function wiz_toItems(s){
  const txt = String(s||'').trim();
  if (!txt) return [];
  // Support '---' dividers, bullet-like lines, and plain newlines
  return txt
    .split(/\n-{3,}\n|^- |\n- |\n• |\n· |\r?\n/gm)
    .flatMap(x => String(x).split(/\r?\n/g))
    .map(x => x.trim())
    .filter(Boolean);
}

/* Collect template field values keyed by the template’s own keys */
function wiz_collectTemplateFields(fw){
  const bag = {};
  const lists = {};
  const fields = Array.isArray(fw?.fields) ? fw.fields : [];

  for (const f of fields){
    const key = (f.key || f.id || f.slug || f.label || '').toString().trim();
    if (!key) continue;
    const fid = computeFieldId(f);
    const el  = document.getElementById(fid);
    const t   = String(f.type||'').toLowerCase();

    let raw = '';
    if (el && el.tagName === 'SELECT' && el.multiple){
      const vals = [...el.selectedOptions].map(o=>o.value.trim()).filter(Boolean);
      raw = vals.join(', ');
      if (vals.length) lists[key] = vals;
    } else {
      raw = (el ? el.value : (VALUES.get(fid)||'')).trim();
    }
    if (!raw) continue;

    const isListish = /textarea|repeater/.test(t);
    if (isListish){
      const arr = wiz_toItems(raw);
      if (arr.length){ lists[key] = arr; }
    }else{
      bag[key] = raw;
    }
  }

  // keep the convenient aliases
  for (const [k,arr] of Object.entries(lists)){
    bag[k] = Array.isArray(arr) ? arr.join('\n') : String(arr);
    bag[`${k}_list`]  = arr;
    bag[`${k}_items`] = arr;
    bag[`${k}_arr`]   = arr;
    if (Array.isArray(arr) && k.endsWith('s') && arr.length===1){
      const singular = k.replace(/s$/, '');
      if (singular && !(singular in bag)) bag[singular] = arr[0];
    }
  }

  return bag;
}


/* Extras — user text wins; otherwise boosters from the framework */
function wiz_extras(fw){
  // Has the user ever edited #extra this session?
  var userTouchedExtra = VALUES.has('extra');

  // Current values (survive when Extras step is unmounted)
  var rawExtra  = wiz_getVal('extra');      // user's text if any
  var extraMore = wiz_getVal('extraMore');  // appended after the labeled block

  // Default boosters (string; may be empty)
  var boosters = wiz_defaultBooster(fw);

  // Semantics:
  // - If user NEVER touched #extra: show boosters by default (even if the box is empty).
  // - If user HAS touched #extra:
  //     - use their text;
  //     - if they cleared it, omit the boosters (no "Additional instructions" unless extraMore exists).
  var chosen = userTouchedExtra
    ? (rawExtra ? rawExtra.trim() : '')                  // touched → user text wins; empty means "none"
    : ((rawExtra ? rawExtra.trim() : '') || boosters);   // untouched → boosters by default

  var hasChosen = !!chosen;
  var hasMore   = !!extraMore;

  var extraCombined = '';
  if (hasChosen && hasMore){
    extraCombined = 'Additional instructions: ' + chosen + '\n\n' + extraMore;
  } else if (hasChosen){
    extraCombined = 'Additional instructions: ' + chosen;
  } else if (hasMore){
    // Keep the label even if only extraMore exists
    extraCombined = 'Additional instructions: ' + extraMore;
  }

  return {
    boosterFallback: boosters,
    extraChosen:     chosen,
    extraMore:       extraMore,
    extraCombined:   extraCombined
  };
}

/* Compose final text in PB order: Header → Persona → Body → Extra */
function wiz_composePrompt(){
  const fw = CURRENT || {};                            // active template
  const label = String(fw.label || fw.slug || fw.id || 'template').trim();
  const def   = String(fw.definition || fw.help || '').trim();

  // 1) Common Context
  const CC  = wiz_collectCommonContext();

  // 2) Template data bag (fields + CC for templates that use it)
  const bag = Object.assign({ ctx: CC.ctx }, wiz_collectTemplateFields(fw));

  // 3) Template body — prefer framework.template(bag); fallback to simple echo
  let body = '';
  try{
    if (typeof fw.template === 'function'){
      body = String(fw.template(bag) || '').trim();
    }
  }catch(_){}
  if (!body){
    // Safe fallback: print filled fields in a friendly way
    const lines = [];
    for (const [k,v] of Object.entries(bag)){
      if (!v) continue;
      if (Array.isArray(v)) continue; // aliases handled above; we printed joined string on k
      lines.push(`${k}: ${v}`);
    }
    body = lines.join('\n');
  }

  // 4) Extras logic
  const EX = wiz_extras(fw);

  // 5) Header — self-describing
  const header = def ? `Using ${label}: ${def}` : `Using ${label}`;

  // 6) Persona fallback (only if body doesn’t already include persona markers)
  const personaNeeded = !!CC.persona && !/persona|audience/i.test(body);
  const personaBlock  = personaNeeded ? CC.persona : '';

  // 7) Assemble in fixed order; collapse excess blank lines
  const parts = [header, personaBlock, body, EX.extraCombined].filter(Boolean);
  const txt = parts.join('\n\n')
    .replace(/\n{3,}/g, '\n\n') // tidy
    .trim();

  return txt || '(no content yet)';
}

// Preview writer (Slice 1): always compose from wizard state
function renderPreviewMaybe(){
  const out = document.getElementById('out'); if (!out) return;

  // Compose our final text using CURRENT + field values + common context + extras
  const txt = wiz_composePrompt();

  // If the page later ships PB's official makePromptForTab and you want to prefer it,
  // you can gate it here, but for Slice 1 we rely on the shim for determinism.
  out.textContent = txt;
}

  // ===== Steps (standalone renderer — uses template.fields directly) =====
// ===== Steps (guided wizard with shared first/penultimate/final) =====
function fieldInput(f){
  const fid   = computeFieldId(f);
  const label = f.label || f.name || f.key || 'field';
  const desc  = f.desc || f.description || '';
  const ph    = f.ph || f.placeholder || '';
  const t     = String(f.type || '').toLowerCase();

  // normalize options: strings or {value,label}
  const rawOpts = Array.isArray(f.options) ? f.options
                 : Array.isArray(f.choices) ? f.choices
                 : [];
  const opts = rawOpts.map(o => {
    if (o && typeof o === 'object') return { value: String(o.value ?? o.label ?? ''), label: String(o.label ?? o.value ?? '') };
    return { value: String(o ?? ''), label: String(o ?? '') };
  }).filter(o => o.value);

  // select / multiselect
  if (t === 'select' || t === 'dropdown' || t === 'multiselect'){
    const multiple = (t === 'multiselect') || !!f.multiple;
    const optHtml = [
      (!multiple ? `<option value="" disabled selected>${ph || '— choose —'}</option>` : ''),
      ...opts.map(o => `<option value="${o.value}">${o.label}</option>`)
    ].join('');
    return `
      <div class="field" data-field-id="${fid}">
        <label for="${fid}">${label}</label>
        <select id="${fid}" name="${fid}" ${multiple?'multiple size="'+Math.min(6, Math.max(3, opts.length))+'"':''}>
          ${optHtml}
        </select>
        ${desc?`<div class="desc muted" style="margin-top:6px">${desc}</div>`:''}
      </div>`;
  }

  // textarea/repeater stay as-is
  if (isTextAreaOrRepeater(f) || (ph && ph.length>60) || (desc && desc.length>80)){
    return `
      <div class="field" data-field-id="${fid}">
        <label for="${fid}">${label}</label>
        <textarea id="${fid}" name="${fid}" placeholder="${ph}"></textarea>
        ${desc?`<div class="desc muted" style="margin-top:6px">${desc}</div>`:''}
      </div>`;
  }

  // default short input
  return `
    <div class="field" data-field-id="${fid}">
      <label for="${fid}">${label}</label>
      <input type="text" id="${fid}" name="${fid}" placeholder="${ph}">
      ${desc?`<div class="desc muted" style="margin-top:6px">${desc}</div>`:''}
    </div>`;
}

let SHOW_ALL = false, STEP_INDEX = 0, STEPS = [], REQUIRED_FIDS = [];

// Build steps:
// 1) Overview (shared): label + full definition + Common Context block (#commonCtxBody)
// 2..N-2) Template-specific: textarea/repeater = own step; others batched up to 3; title = first field label
// N-1) Extra (shared): #extra and #extraMore together
// N) Output (shared): #out preview
function buildSteps(t){
  const fields = Array.isArray(t.fields)? t.fields : [];

  // 1) Overview
  const steps = [{ title:'overview', special:'overview', fields:[], fids:[] }];

  // 2) Template-specific grouping
  let bucket = [];
  let bucketTitle = null;
  function flushBucket(){
    if (!bucket.length) return;
    const fids = bucket.map(f => computeFieldId(f));
    steps.push({ title: bucketTitle || (bucket[0]?.label||'fields'), fields:[...bucket], fids });
    bucket = []; bucketTitle = null;
  }
  for (const f of fields){
    if (isTextAreaOrRepeater(f)){
      flushBucket();
      const fid = computeFieldId(f);
      steps.push({ title: (f.label||'section'), fields:[f], fids:[fid] });
    }else{
      if (!bucket.length) bucketTitle = f.label||'fields';
      bucket.push(f);
      if (bucket.length>=3) flushBucket();
    }
  }
  flushBucket();

  // 3) Extras (shared)
  steps.push({ title:'extra instructions', special:'extra', fields:[], fids:['extra','extraMore'] });

  // 4) Output (shared)
  steps.push({ title:'output', special:'output', fields:[], fids:[] });

  STEPS = steps;
  STEP_INDEX = 0;
  REQUIRED_FIDS = steps.filter(s=>!s.special).flatMap(s=> s.fids||[]);
  
    // --- Seed boosters into state so Output shows default instructions by default
  if (!VALUES.has('extra') || (VALUES.get('extra')||'').trim()===''){
    const b = wiz_defaultBooster(t);
    if (b){ VALUES.set('extra', b); }
  }

  
  renderSteps(t);
  updateStepStates();
  updateTopProgress();
}

function renderSteps(t){
  // Rail
  const list = el('wizStepList');
  list.innerHTML = STEPS.map((s,i)=> `
    <li data-i="${i}" ${i===STEP_INDEX?'aria-current="true"':''}>
      <span class="pill">${i+1}</span>
      <span>${s.special ? s.title : (s.title||('step '+(i+1)))}</span>
    </li>`).join('');
  list.querySelectorAll('li').forEach(li=>{
    li.addEventListener('click', ()=>{
      const prev = STEP_INDEX;
      STEP_INDEX = +li.getAttribute('data-i');
      updateStepStates(prev);
      renderSteps(t);
      updateTopProgress();
    });
  });

  // Body
  const S = STEPS[STEP_INDEX]||{fields:[]};
  const body = el('wizStepBody');

  if (S.special === 'overview'){
    const lab = String((t && (t.label||t.slug||t.id)) || 'template');
    const def = String((t && (t.definition||t.help)) || '').trim();
    body.innerHTML = `
      <h3 class="subhead" style="margin-bottom:6px">${lab}</h3>
      <div class="muted" style="margin:0 0 10px">${def||'<em>no definition provided</em>'}</div>
      <div class="subhead" style="margin:8px 0 6px">common context <span class="muted">(optional; same across templates)</span></div>
      <div id="commonCtxBody">
        <div class="field"><label for="ctx_use">Use-case</label><input id="ctx_use" type="text" placeholder="what are you trying to do?"></div>
        <div class="field"><label for="ctx_aud">Audience</label><input id="ctx_aud" type="text" placeholder="who is this for?"></div>
        <div class="field"><label for="ctx_style">Style</label><input id="ctx_style" type="text" placeholder="e.g., concise, academic, playful"></div>
        <div class="field"><label for="ctx_tone">Tone</label><input id="ctx_tone" type="text" placeholder="e.g., supportive, neutral, assertive"></div>
      </div>
    `;
      // 🔧 Repaint saved values for use/audience/style/tone
  wiz_hydrateFields(body);
  
} 



else if (S.special === 'extra'){
  // HTML only; placeholder/prefill will be set by wiz_bindExtrasUI(t)
  body.innerHTML = `
    <h3 class="subhead">extra instructions</h3>

    <div class="field" data-field-id="extra" style="margin-bottom:10px">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <label for="extra">Default included instructions</label>
        <div class="muted" id="extraCnt" style="font-size:12px"></div>
      </div>
      <textarea id="extra" placeholder="Write instructions to replace the template’s boosters (optional)"></textarea>
      <div class="desc muted" style="margin-top:6px; display:flex; gap:8px; align-items:center;">
        <button type="button" id="extraRestore" class="btn sm">Restore recommended text</button>
        <span class="muted" style="font-size:12px">Your text replaces the recommended boosters.</span>
      </div>
    </div>

    <div class="field" data-field-id="extraMore" style="margin-top:8px">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <label for="extraMore">Anything else to include (optional)</label>
        <div class="muted" id="extraMoreCnt" style="font-size:12px"></div>
      </div>
      <textarea id="extraMore" placeholder="Append any final details or constraints"></textarea>
    </div>
  `;
  // Wire counters, placeholder/prefill, and Restore behavior
   wiz_hydrateFields(body);
  wiz_bindExtrasUI(t);
} else if (S.special === 'output'){
  body.innerHTML = `
    <div class="out-head-row">
      <h3 class="subhead">output</h3>
      <div id="outActions" class="out-actions">
        <button id="copyBtn2" class="btn sm">Copy</button>
        <button id="openBtn2" class="btn sm ask" title="Ask ChatGPT">Ask ChatGPT</button>
      </div>
    </div>
    <pre id="out" class="wiz-output" aria-live="polite">(your generated prompt will appear here)</pre>
  `;
  // Wire Slice 1 actions for this step render
  wireOutputActions();
  renderPreviewMaybe();
} else {


    // Template fields step
    body.innerHTML = `<h3 class="subhead">${S.title||('step '+(STEP_INDEX+1))}</h3>` + S.fields.map(fieldInput).join('');
     wiz_hydrateFields(body);
  }
  
// In "show all" mode, render the entire flow in one page
if (SHOW_ALL){
  const lab = String((t && (t.label||t.slug||t.id)) || 'template');
  const def = String((t && (t.definition||t.help)) || '').trim();

  // 1) Overview
  let html = `
    <h3 class="subhead" style="margin-bottom:6px">${lab}</h3>
    <div class="muted" style="margin:0 0 10px">${def||'<em>no definition provided</em>'}</div>

    <div class="subhead" style="margin:8px 0 6px">
      common context <span class="muted">(optional; same across templates)</span>
    </div>
    <div id="commonCtxBody">
      <div class="field"><label for="ctx_use">Use-case</label><input id="ctx_use" type="text" placeholder="what are you trying to do?"></div>
      <div class="field"><label for="ctx_aud">Audience</label><input id="ctx_aud" type="text" placeholder="who is this for?"></div>
      <div class="field"><label for="ctx_style">Style</label><input id="ctx_style" type="text" placeholder="e.g., concise, academic, playful"></div>
      <div class="field"><label for="ctx_tone">Tone</label><input id="ctx_tone" type="text" placeholder="e.g., supportive, neutral, assertive"></div>
    </div>
  `;

  // 2) All template-specific fields (each step’s fields, in order)
  for (const s of STEPS){
    if (s.special || !Array.isArray(s.fields)) continue;
    html += `<h3 class="subhead">${s.title||'fields'}</h3>` + s.fields.map(fieldInput).join('');
  }

  // 3) Extras (same UI as the single-step version)
  html += `
    <h3 class="subhead">extra instructions</h3>

    <div class="field" data-field-id="extra" style="margin-bottom:10px">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <label for="extra">Default included instructions</label>
        <div class="muted" id="extraCnt" style="font-size:12px"></div>
      </div>
      <textarea id="extra" placeholder="Write instructions to replace the template’s boosters (optional)"></textarea>
      <div class="desc muted" style="margin-top:6px; display:flex; gap:8px; align-items:center;">
        <button type="button" id="extraRestore" class="btn sm">Restore recommended text</button>
        <span class="muted" style="font-size:12px">Your text replaces the recommended boosters.</span>
      </div>
    </div>

    <div class="field" data-field-id="extraMore" style="margin-top:8px">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <label for="extraMore">Anything else to include (optional)</label>
        <div class="muted" id="extraMoreCnt" style="font-size:12px"></div>
      </div>
      <textarea id="extraMore" placeholder="Append any final details or constraints"></textarea>
    </div>
  `;

  // 4) Output preview (same preview hook)
  html += `
    <h3 class="subhead" style="margin-top:12px">output</h3>
    <pre id="out" class="wiz-output" aria-live="polite">(your generated prompt will appear here)</pre>
  `;

  body.innerHTML = html;

  // Hydrate saved values + wire extras helpers + render preview
  wiz_hydrateFields(body);
  wiz_bindExtrasUI(t);
  renderPreviewMaybe();
}

  // Nav buttons (hide vs. disable)
  const isFirst = STEP_INDEX<=0, isLast = STEP_INDEX>=STEPS.length-1;
  el('wizStepBack').style.display = isFirst ? 'none' : '';
  el('wizStepNext').style.display = isLast  ? 'none' : '';
  el('wizStepBack').disabled = isFirst;
  el('wizStepNext').disabled = isLast;
  // Toggle label and hide nav when in "show all"
el('wizShowAll').textContent = SHOW_ALL ? 'step-by-step' : 'show all';
if (SHOW_ALL){ el('wizStepBack').style.display='none'; el('wizStepNext').style.display='none'; }


  // Delegate inputs → track TOUCH/VALUES, update states + progress + preview
  const bodyEl = el('wizStepBody');
  bodyEl.oninput = bodyEl.onchange = (ev)=>{
    const t = ev.target;
    if (!t || !t.id) return;
    VALUES.set(t.id, t.value||'');
    const wrapper = t.closest('[data-field-id]');
    if (wrapper){ TOUCH.add(wrapper.getAttribute('data-field-id')); }
    updateStepStates();
    updateTopProgress();
    renderPreviewMaybe();
  };
  bodyEl.onfocusin = (ev)=>{
    const w = ev.target.closest('[data-field-id]');
    if (w) TOUCH.add(w.getAttribute('data-field-id'));
  };

  updateStepStates();
}

// Step nav + show/hide top progress
el('wizStep0Start').addEventListener('click', ()=>{
  if (!CURRENT) return;
  buildSteps(CURRENT);
  showView('steps');
  el('wizTopProgress').classList.remove('hide');
  updateTopProgress();
});
el('wizExitSearch').addEventListener('click', ()=> { showView('startup'); el('wizTopProgress').classList.add('hide'); });
el('wizShowAll').addEventListener('click', ()=>{ SHOW_ALL=!SHOW_ALL; renderSteps(CURRENT); updateTopProgress(); });
el('wizStepBack').addEventListener('click', ()=>{
  if (STEP_INDEX>0){ const prev=STEP_INDEX; STEP_INDEX--; updateStepStates(prev); renderSteps(CURRENT); updateTopProgress(); }
});
el('wizStepNext').addEventListener('click', ()=>{
  if (STEP_INDEX<STEPS.length-1){ const prev=STEP_INDEX; STEP_INDEX++; updateStepStates(prev); renderSteps(CURRENT); updateTopProgress(); }
});
  
  el('btnExitSearch').addEventListener('click', ()=> showView('startup'));
  
  
  
/* ===== URL deep-linking (slug/id → Step 0) ============================== */
(function wireDeepLinking(){
  function readTargetFromURL(){
    const url = new URL(window.location.href);
    const p   = url.searchParams;
    let v = (p.get('slug') || p.get('id') || p.get('t') || '').trim();
    if (!v && url.hash) v = url.hash.replace(/^#/, '').trim();
    return v.toLowerCase();
  }

  function findTemplate(slugOrId){
    if (!slugOrId) return null;
    const s = slugOrId.toLowerCase();
    const T = allTemplates();
    return T.find(x =>
      String(x.slug||'').toLowerCase() === s ||
      String(x.id  ||'').toLowerCase() === s ||
      String(x.key ||'').toLowerCase() === s ||
      String(x.label||'').toLowerCase() === s
    ) || null;
  }

  function setURLForTemplate(t){
    try{
      const url = new URL(window.location.href);
      const canonical = (t.slug || t.id || '').toString().toLowerCase();
      // normalize to ?slug=… and drop ?id=…
      if (canonical){
        url.searchParams.set('slug', canonical);
        url.searchParams.delete('id');
      }else{
        url.searchParams.delete('slug');
        url.searchParams.delete('id');
      }
      history.replaceState({}, '', url);
    }catch(_){}
  }
  window.__setURLForTemplate = setURLForTemplate; // used when user clicks cards too

  function tryOpenFromURL(){
    const target = readTargetFromURL();
    if (!target) return;

    // immediate attempt
    const hit = findTemplate(target);
    if (hit){ openStep0(hit); setURLForTemplate(hit); return; }

    // datasets may still be loading → retry a few times
    let tries = 0;
    const iv = setInterval(()=>{
      const h = findTemplate(target);
      if (h){ clearInterval(iv); openStep0(h); setURLForTemplate(h); }
      else if (++tries >= 30){ clearInterval(iv); } // ~4.5s total
    }, 150);
  }

  // run after DOM is ready; safe with late-loading datasets thanks to retry loop
  window.addEventListener('DOMContentLoaded', tryOpenFromURL);
})();



// ===== Boot =====
buildIndex();
recompute('');                   // prime UI
setTimeout(()=>{ buildIndex(); recompute(el('wizQ').value); }, 300); // pick up late dataset


/* ===================== Slice 1: Copy modal logic ===================== */

/** Seeds and opens the shared Action Modal in "Copy" mode. */
function openCopyModalFromOut(){
  const dlg     = document.getElementById('actionModal');
  const title   = document.getElementById('actionTitle');
  const ta      = document.getElementById('actionPreview');
  const primary = document.getElementById('actionCopy');
  const status  = document.getElementById('copyStatus');
  const note    = document.getElementById('actionNote');

  const outEl = document.getElementById('out');
  const text  = outEl ? outEl.textContent : '';

  title.textContent = 'Copy prompt';
  ta.value = text;
  status.hidden = true;

  // Primary button acts as "Copy" in this mode
  primary.textContent = 'Copy';
  primary.onclick = copyFromModal;

  // Hide the advisory note in Copy mode
  if (note) note.hidden = true;

  // Open and focus textarea
  if (typeof dlg.showModal === 'function') dlg.showModal();
  else dlg.setAttribute('open','');

  setTimeout(() => { ta.focus(); ta.select(); }, 0);
}


/** Copies current modal textarea to clipboard, keeps dialog open, shows status. */
async function copyFromModal(){
  const ta = document.getElementById('actionPreview');
  const status = document.getElementById('copyStatus');
  try {
    await navigator.clipboard.writeText(ta.value);
    status.textContent = 'Copied to clipboard.';
  } catch(e){
    status.textContent = 'Copy failed. Select all and press ⌘/Ctrl+C.';
  }
  status.hidden = false;
}

/** Closes the action modal */
function closeActionModal(){
  const dlg = document.getElementById('actionModal');
  if (!dlg) return;
  dlg.close ? dlg.close() : dlg.removeAttribute('open');
}

/**
 * Wires buttons for the Output step (called after the Output HTML is injected).
 * Safe to call repeatedly; it rebinds current step's elements.
 */
function wireOutputActions(){
  const copyBtn = document.getElementById('copyBtn2');
  const askBtn  = document.getElementById('openBtn2'); // present, no behavior yet (Slice 2)

  const dlg = document.getElementById('actionModal');
  const actionCopy = document.getElementById('actionCopy');
  const actionCancel = document.getElementById('actionCancel');
  const actionCloseX = document.getElementById('actionClose');

  if (copyBtn){
    copyBtn.onclick = openCopyModalFromOut;
  }
if (askBtn){
  askBtn.onclick = openAskModalFromOut;
}


  if (actionCopy){
    actionCopy.onclick = copyFromModal;
  }
  if (actionCancel){
    actionCancel.onclick = closeActionModal;
  }
  if (actionCloseX){
    actionCloseX.onclick = closeActionModal;
  }

  // Optional: close on backdrop click
  if (dlg && !dlg._backdropBound){
    dlg.addEventListener('click', (e) => {
      const rect = dlg.getBoundingClientRect();
      const inDialog = (
        e.clientX >= rect.left && e.clientX <= rect.right &&
        e.clientY >= rect.top  && e.clientY <= rect.bottom
      );
      if (!inDialog) closeActionModal();
    });
    dlg._backdropBound = true;
  }
}

/* ===================== Slice 2: Ask ChatGPT (happy path) ===================== */

/** Returns ChatGPT URL and base given a prompt string. */
function buildChatURL(promptText){
  const base = 'https://chat.openai.com/'; // base ChatGPT entry
  const url  = base + '?prompt=' + encodeURIComponent(promptText || '');
  return { url, base };
}

/** Seeds and opens the shared Action Modal in "Ask ChatGPT" mode. */
function openAskModalFromOut(){
  const dlg      = document.getElementById('actionModal');
  const title    = document.getElementById('actionTitle');
  const ta       = document.getElementById('actionPreview');
  const primary  = document.getElementById('actionCopy');     // reuse as primary
  const note     = document.getElementById('actionNote');

  const outEl = document.getElementById('out');
  const text  = outEl ? outEl.textContent : '';

  title.textContent = 'Ask ChatGPT';
  ta.value = text;

  // Primary button behaves as "Open in ChatGPT" in this mode
  primary.textContent = 'Open in ChatGPT';
  primary.onclick = openChatFromModal;

  // Show the advisory note (helpful hint; Slice 3 will drive fallbacks)
  if (note) note.hidden = false;

  // Open dialog
  if (typeof dlg.showModal === 'function') dlg.showModal();
  else dlg.setAttribute('open','');

  // Focus the textarea for quick edits
  setTimeout(() => { ta.focus(); ta.select(); }, 0);
}

/** Opens ChatGPT with the textarea contents in the URL (happy path), then closes modal. */
function openChatFromModal(){
  const dlg   = document.getElementById('actionModal');
  const ta    = document.getElementById('actionPreview');
  const text  = ta ? ta.value : '';
  const { url, base } = buildChatURL(text);

  // 1) Long URL guard → copy + open clean chat + post-launch helper
  if (url.length > MAX_URL_CHARS) {
    openBaseAndNotify(base, text, 'long-url');
    if (dlg && dlg.close) dlg.close(); else dlg.removeAttribute('open');
    return;
  }

  // 2) Try happy path
  const win = window.open(url, '_blank', 'noopener,noreferrer');

  // 3) Popup blocked or navigation refused → copy + open clean chat + post-launch helper
  if (!win) {
    openBaseAndNotify(base, text, 'popup-blocked');
    if (dlg && dlg.close) dlg.close(); else dlg.removeAttribute('open');
    return;
  }

  // 4) Happy path: close modal; if the user returns later and wants help,
  // they can still click Copy/Ask again. (No post-launch prompt in happy path.)
  if (dlg && dlg.close) dlg.close(); else dlg.removeAttribute('open');
}


/* ===================== Slice 3: Fallbacks & Post-Launch Helper ===================== */

const MAX_URL_CHARS = 7800; // conservative safety threshold for ?prompt= URLs
const POST_LAUNCH_KEY = 'postLaunchAsk';

/** Store post-launch payload so we can prompt the user when they return. */
function markPostLaunch(payload){
  try {
    sessionStorage.setItem(POST_LAUNCH_KEY, JSON.stringify({
      text: payload.text || '',
      base: payload.base || 'https://chat.openai.com/',
      reason: payload.reason || 'unknown',
      t: Date.now()
    }));
  } catch(e) {/* ignore */}
}

/** Try to open a clean chat, copy text, and record post-launch state. */
async function openBaseAndNotify(base, text, reason){
  try { await navigator.clipboard.writeText(text); } catch(e) {/* ignore */}
  window.open(base, '_blank', 'noopener,noreferrer');
  markPostLaunch({ text, base, reason });
}

/** If a post-launch payload exists (and we're back on this tab), show the helper once. */
function consumePostLaunchIfAny(){
  let raw = null;
  try { raw = sessionStorage.getItem(POST_LAUNCH_KEY); } catch(e) {}
  if (!raw) return;

  let data = null;
  try { data = JSON.parse(raw); } catch(e) {}
  if (!data) { try { sessionStorage.removeItem(POST_LAUNCH_KEY); } catch(_) {} ; return; }

  // Clear immediately so we only show once
  try { sessionStorage.removeItem(POST_LAUNCH_KEY); } catch(_) {}

  openPostLaunchDlg(data);
}

/** Open the helper dialog with buttons: Open clean chat, Copy again, Dismiss. */
function openPostLaunchDlg(data){
  const dlg   = document.getElementById('postLaunchDlg');
  const ta    = document.getElementById('postLaunchText');
  const openB = document.getElementById('postLaunchOpenBase');
  const copyB = document.getElementById('postLaunchCopy');
  const dismB = document.getElementById('postLaunchDismiss');
  const xBtn  = document.getElementById('postLaunchClose');
  const stat  = document.getElementById('postLaunchStatus');

  const text = (data && data.text) || '';
  const base = (data && data.base) || 'https://chat.openai.com/';

  ta.value = text;
  stat.hidden = true;

  openB.onclick = () => { window.open(base, '_blank', 'noopener,noreferrer'); };
  copyB.onclick = async () => {
    try { await navigator.clipboard.writeText(text); stat.textContent = 'Copied to clipboard.'; }
    catch(e){ stat.textContent = 'Copy failed. Select all and press ⌘/Ctrl+C.'; }
    stat.hidden = false;
  };
  const closeDlg = () => { dlg.close ? dlg.close() : dlg.removeAttribute('open'); };
  dismB.onclick = closeDlg;
  xBtn.onclick  = closeDlg;

  if (typeof dlg.showModal === 'function') dlg.showModal();
  else dlg.setAttribute('open','');

  // Focus textarea for quick manual copy
  setTimeout(() => { ta.focus(); ta.select(); }, 0);
}

/** Bind once: when the tab regains focus/visibility, check for post-launch payload. */
(function bindPostLaunchReturnHooks(){
  if (window.__postLaunchBound) return;
  window.__postLaunchBound = true;
  window.addEventListener('focus', consumePostLaunchIfAny, { passive: true });
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') consumePostLaunchIfAny();
  }, { passive: true });
})();



  </script>
  
  <script>
(function ensureIndexSkin(){
  const root = document.getElementById('wizViewStartup');
  if (!root) return;
  const apply = () => {
    document.getElementById('wizHdr')?.classList.add('searchWrap');
    root.querySelector('.wiz-searchShell')?.classList.add('search');
    root.querySelector('.quickRow')?.classList.add('searchCtas');
    const box = document.querySelector('#taSug .box');
    if (box) box.parentElement.classList.add('ta');
  };
  apply();
  // If your framework re-renders, keep it skinned.
  new MutationObserver(apply).observe(root, { childList:true, subtree:true });
})();
</script>



  <!-- ===== Only external deps (datasets) ===== -->
     <script src="./aisettings.js"></script>
  <script src="./templates.data.js"></script>
  <script src="./templates.tasks.data.js"></script>
</body>
</html>
