<!doctype html>
<html lang="en-US" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  
 <!-- Canonical + robots -->
<title>Startup Wizard for clearer AI prompts | Prompt Builder</title>
<meta name="description" content="Search use-cases, pick a template, and follow guided steps to shape clear, reusable AI prompts—fewer retries, better results.">
<link rel="canonical" href="https://jonathankhobson.github.io/AI/glossary/startup-wizard.html">
<meta name="robots" content="index,follow,max-image-preview:large,max-snippet:-1,max-video-preview:-1">

<!-- UI integration -->
<meta name="color-scheme" content="light dark">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#111111">

<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:site_name" content="Prompt Builder">
<meta property="og:locale" content="en_US">
<meta property="og:url" content="https://jonathankhobson.github.io/AI/glossary/startup-wizard.html">
<meta property="og:title" content="Startup Wizard for clearer AI prompts">
<meta property="og:description" content="Pick a template and follow guided steps to craft precise, reusable AI prompts.">
<meta property="og:image" content="https://jonathankhobson.github.io/AI/assets/og/prompt-builder-og.png">
<meta property="og:image:alt" content="Startup Wizard interface with search, template cards, and guided steps">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta property="og:image:type" content="image/png">

<!-- Twitter -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Startup Wizard for clearer AI prompts">
<meta name="twitter:description" content="Search use-cases, choose a template, and follow guided steps to shape better prompts.">
<meta name="twitter:image" content="https://jonathankhobson.github.io/AI/assets/og/prompt-builder-og.png">

<!-- Icons (ok to leave as placeholders until uploaded) -->
<link rel="icon" href="https://jonathankhobson.github.io/AI/favicon.ico" sizes="any">
<link rel="icon" type="image/png" sizes="32x32" href="https://jonathankhobson.github.io/AI/icons/favicon-32.png">
<link rel="icon" type="image/png" sizes="192x192" href="https://jonathankhobson.github.io/AI/icons/icon-192.png">
<link rel="apple-touch-icon" href="https://jonathankhobson.github.io/AI/icons/apple-touch-icon.png">

<!-- (Optional) font preload; safe to keep even if the file isn’t there yet -->
<link rel="preload" as="font" href="https://jonathankhobson.github.io/AI/assets/fonts/inter-var.woff2" type="font/woff2" crossorigin> 
  
  
  <style>
  .skip-link{position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden}
  .skip-link:focus{position:static;width:auto;height:auto;padding:.5rem 1rem;background:#111;color:#fff;z-index:9999}
  .visually-hidden{position:absolute!important;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0 0 0 0);white-space:nowrap;border:0}
</style>


<style>
/* ===== Design tokens ===== */
:root{
  --bg:#fafafa; --fg:#0f1720; --muted:#506070; --chip:#f3f6fa; --border:#e3e9f2; --accent:#1e293b;
  --focus:#0ea5e9; --shadow:0 12px 40px rgba(0,0,0,.08); --radius:16px; --cta:#1e293b;
  --r1:#ff007a; --r2:#ff8d00; --r3:#ffd600; --r4:#00dc82; --r5:#00d2ff; --r6:#7850ff;
  --text:var(--fg); --card:#fff; --panel:#fff; --border-strong:var(--border);
  --red:#ef4444; --green:#10b981; --yellow:#f59e0b; --purple:#8b5cf6;
}
html[data-theme="dark"]{
  --bg:#0c1220; --fg:#e6ebf2; --muted:#9aa8b7; --chip:#111827; --border:#2f3f56;
  --shadow:0 8px 28px rgba(0,0,0,.55); --accent:#cbd5e1; --card:#0e1726; --panel:#0b1322;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
  color:var(--fg); background:var(--bg); line-height:1.5; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
}
h1,h2,h3,.subhead,.areaLabel{ text-transform:lowercase; letter-spacing:.25px; font-weight:600; }

/* Header */
header{
  display:flex; align-items:center; gap:12px; padding:12px 16px; position:sticky; top:0; z-index:10;
  background:rgba(255,255,255,.78); -webkit-backdrop-filter:blur(10px); backdrop-filter:blur(10px);
  border-bottom:1px solid var(--border);
}
html[data-theme="dark"] header{ background:rgba(12,18,32,.76); }
header .spacer{flex:1}
a{color:var(--accent); text-decoration:none}
a:hover{text-decoration:underline}

/* Buttons (no underline ever) */
a.btn,a.btn:hover,.btn,.btn:hover,.btn:focus,.btn:active{ text-decoration:none!important }
.btn{
  cursor:pointer; display:inline-flex; align-items:center; justify-content:center; gap:.5ch;
  background:var(--card); color:var(--fg); border:1px solid var(--border);
  padding:9px 14px; border-radius:999px; font-weight:600; text-transform:lowercase;
  transition: transform .06s ease, box-shadow .12s ease, background-color .12s ease, color .12s ease, border-color .12s ease;
}
.btn:hover{ transform:translateY(-2px) scale(1.02); box-shadow:0 12px 28px -14px rgba(0,0,0,.35),0 4px 10px -6px rgba(0,0,0,.25) }
.btn.primary{ background:var(--cta); color:#fff; border:1px solid transparent; box-shadow:none }
.btn.sm{ padding:6px 12px; font-size:14px; min-height:32px }
.pill{ display:inline-flex; gap:.5ch; align-items:center; padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:var(--chip); font-size:12px }
.muted{ color:var(--muted) }

/* Rainbow border utility (subtle) */
.rainbow{
  border:1px solid transparent;
  background:
    linear-gradient(var(--card), var(--card)) padding-box,
    conic-gradient(from 210deg,
      color-mix(in srgb, var(--r1), transparent 75%),
      color-mix(in srgb, var(--r2), transparent 78%),
      color-mix(in srgb, var(--r3), transparent 82%),
      color-mix(in srgb, var(--r4), transparent 80%),
      color-mix(in srgb, var(--r5), transparent 78%),
      color-mix(in srgb, var(--r6), transparent 75%),
      color-mix(in srgb, var(--r1), transparent 75%)
    ) border-box;
}
.rainbow:hover{ background:
  linear-gradient(color-mix(in srgb, var(--card), white 2%), color-mix(in srgb, var(--card), white 2%)) padding-box,
  conic-gradient(from 210deg, var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1)) border-box;
}

/* Inputs */
/* === Stepper fields: spacing & label/description distinction === */
#wizViewSteps .field {
  margin: 0 0 8px; /* baseline */
}

/* When there are 2+ fields on the step, increase vertical spacing */
#wizStepBody.many-fields .field + .field,
#commonCtxBody .field + .field {
  margin-top: 16px;
}

/* Labels: stronger and a touch larger */
#wizViewSteps .field > label {
  display: block;
  font-weight: 600;
  font-size: 14.5px;
  letter-spacing: .1px;
  color: var(--fg);
  margin: 0 0 6px;
}

/* Descriptive text: smaller, muted, and clearly separate */
#wizViewSteps .field .desc {
  font-size: 12.75px;
  line-height: 1.5;
  color: var(--muted);
  margin-top: 6px;
}

/* ==== Slice 2: Assist-lite checkbox (left-aligned, inline with desc) ====== */
#wizViewSteps .field .desc{
  display:flex; align-items:center; gap:8px; flex-wrap:wrap;
}
#wizViewSteps .field .assist-lite{
  display:inline-flex; align-items:center; gap:6px;
  font-size:12.5px; color: var(--muted);
}
#wizViewSteps .field .assist-lite input[type="checkbox"]{
  width:14px; height:14px; accent-color: currentColor;
  transform: translateY(-1px);
}

html[data-theme="dark"] #wizViewSteps .field .desc {
  color: color-mix(in srgb, var(--muted), white 10%);
}



input[type="text"], textarea, select{
  width:100%; height:48px; padding:0 12px; border-radius:var(--radius); border:1px solid var(--border);
  background:var(--card); color:var(--fg); outline:none; box-shadow:var(--shadow);
}
textarea{ min-height:100px; height:auto; padding:10px 12px; resize:vertical }

/* Ambient rainbow glimmer (very subtle) */
body::before{
  content:""; position:fixed; inset:auto auto 40% 0; width:min(70vw,920px); height:min(70vh,680px);
  pointer-events:none; z-index:-1; filter:blur(48px) saturate(115%); opacity:.08;
  background: radial-gradient(120% 120% at 0% 0%, rgba(255,255,255,.85) 0 36%, transparent 52%),
              conic-gradient(from 210deg at 0% 0%, rgba(255,0,122,.22), rgba(255,141,0,.18), rgba(255,214,0,.18), rgba(0,220,130,.20), rgba(0,210,255,.18), rgba(120,80,255,.22), rgba(255,0,122,.22));
}

/* Page shell */
.wiz-root{ max-width:1120px; margin:18px auto; padding:0 16px; }

/* Centered search region */
.wiz-header-search{ display:flex; justify-content:center; margin:8px 0 18px }
.searchCenter{ width:min(880px, 100%); display:flex; flex-direction:column; align-items:center; gap:10px }
.wiz-searchShell{
  width:100%; display:flex; align-items:center; gap:8px; padding:6px;
  background:var(--card); border-radius:999px; position:relative; /* anchors typeahead */
}
.wiz-searchShell input{ flex:1; height:38px; border:none; box-shadow:none; background:transparent; padding:0 8px }
.wiz-clear{ border:none; background:transparent; color:var(--muted); cursor:pointer }
.quickRow{ display:flex; gap:10px; align-items:center; justify-content:center; width:100% }

/* Typeahead (absolute so it never shifts layout) */
#taSug{
  position:absolute; left:8px; right:8px; top:calc(100% + 8px); z-index:20;
}
#taSug[hidden]{ display:none }
#taSug .box{
  border:1px solid var(--border); background:var(--card); border-radius:12px; box-shadow:var(--shadow);
  max-height:320px; overflow-y:auto;
}
#taSug .row{ padding:10px 12px; display:flex; gap:8px; align-items:flex-start; cursor:pointer }
#taSug .row:hover, #taSug .row[aria-selected="true"]{ background:color-mix(in srgb, var(--chip), white 30%) }
#taSug .lbl{ font-weight:600 }

/* Startup */
.wiz-startup{ display:grid; grid-template-columns:1fr; gap:12px }
.wiz-row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
.wiz-cards{ display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:10px }
@media (max-width:900px){ .wiz-cards{ grid-template-columns:1fr } }
.card{ border:1px solid var(--border); background:var(--card); border-radius:16px; padding:12px; box-shadow:var(--shadow) }
.card h4{ margin:0 0 4px; font-size:16px }
.card p{ margin:0 0 10px; color:var(--muted); font-size:13px; line-height:1.35 }
.card .foot{ display:flex; align-items:center; justify-content:space-between; gap:8px }

/* Step 0 */
.wiz-step0 .title{ font-size:20px; margin:0 0 6px }
.wiz-step0 .def{ color:var(--muted); margin:0 0 10px }
.wiz-step0 ul.meta{ display:flex; flex-wrap:wrap; gap:12px; margin:8px 0; padding:0; list-style:none }
.wiz-step0 .uses{ margin-top:10px }
.wiz-step0 .uses li{ margin:6px 0; color:var(--fg) }

/* === Step 0 layout refresh (left-aligned, centered column, larger type) === */
.wiz-step0{
  max-width: 820px;        /* narrower column to pull content toward center */
  margin: 8vh auto 6vh;    /* centers the section while keeping left alignment */
  padding: 20px 22px;
}

@media (max-width: 900px){
  .wiz-step0{ margin: 4vh auto; padding: 16px; }
}

.wiz-step0 .title{
  font-size: clamp(28px, 3.2vw, 40px);
  margin: 0 0 12px;
}

.wiz-step0 .def{
  font-size: clamp(15px, 1.35vw, 18px);
  line-height: 1.6;
  margin: 0 0 16px;
  max-width: 70ch;
}

.wiz-step0 ul.meta{
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin: 10px 0 4px;
  padding: 0;
  list-style: none;
  font-size: 14px;
}
.wiz-step0 ul.meta li{
  background: var(--chip);
  border: 1px solid var(--border);
  border-radius: 999px;
  padding: 6px 10px;
}

.wiz-step0 .uses{ margin-top: 18px; }
.wiz-step0 .uses .subhead{ font-size: 14px; letter-spacing: .2px; }
.wiz-step0 .uses li{ font-size: 14.5px; line-height: 1.45; }

/* Actions row: show "back to search" first visually, keep DOM order accessible */
.wiz-step0 .step0-actions{
  display: flex;
  gap: 10px;
  margin-top: 18px;
  /* flips visual order only */
}
.wiz-step0 .step0-actions .btn{
  padding: 10px 16px;
  font-size: 15px;
}


/* Steps layout */
.wiz-stepsWrap{ display:grid; grid-template-columns:260px 1fr; gap:14px; align-items:start }
@media (max-width:860px){ .wiz-stepsWrap{ grid-template-columns:1fr } }
.wiz-rail{ position:sticky; top:76px; border:1px solid var(--border); background:var(--card); border-radius:16px; padding:12px; box-shadow:var(--shadow) }
.wiz-rail ul{ list-style:none; margin:0; padding:0; }
.wiz-rail li{ display:flex; gap:8px; align-items:center; padding:8px; border-radius:10px; cursor:pointer }
.wiz-rail li[aria-current="true"]{ background:var(--chip); border:1px dashed var(--border) }
.wiz-prog{ height:6px; background:var(--chip); border-radius:999px; overflow:hidden; margin:8px 0 12px }
.wiz-prog > i{ display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--r5),var(--r6)) }
.wiz-pane{ border:1px solid var(--border); background:var(--card); border-radius:16px; padding:12px; box-shadow:var(--shadow) }
.wiz-foot{ position:sticky; bottom:12px; display:flex; gap:8px; justify-content:flex-end; padding-top:10px; background:transparent }

/* utilities */
.hide{ display:none!important }
.right{ margin-left:auto }
.mono{ font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace }
.block-title{ display:flex; align-items:center; gap:10px; }


/* === Brand patch: Rainbow Enhancements (index → wizard) =================== */
@keyframes spinRainbow { to { --angle: 360deg; } }

/* Search pill: stronger rainbow border, soft halo, “hanging” underline */
.wiz-searchShell{
  position: relative;            /* anchor pseudo-elements */
  border: 2px solid transparent; /* gradient border layer */
  background-image:
    linear-gradient(var(--card), var(--card)),
    conic-gradient(from 200deg,
      var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  background-clip: padding-box, border-box;
  background-origin: padding-box, border-box;
  box-shadow: var(--shadow);
  transition: transform .08s ease, box-shadow .18s ease, filter .18s ease;
}
.wiz-searchShell::before{
  content:"";
  position:absolute; inset:-10px; border-radius:999px; z-index:-1;
  filter: blur(20px) saturate(118%);
  background: conic-gradient(from 200deg,
    var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  opacity:.14;
  transition: opacity .18s ease, filter .18s ease;
}
/* “Hanging rainbow” underline */
.wiz-searchShell::after{
  content:"";
  position:absolute; left:10%; right:10%; bottom:-6px; height:4px; border-radius:999px;
  background: linear-gradient(90deg,
    var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  opacity:0; transform: translateY(0);
  transition: opacity .20s ease, transform .20s ease;
  pointer-events:none;
}
/* Micro-motion + brighter halo + drop the underline on hover/focus */
.wiz-searchShell:hover,
.wiz-searchShell:focus-within{
  transform: translateY(-1px);
  box-shadow: 0 16px 32px rgba(0,0,0,.12), 0 4px 10px rgba(0,0,0,.10);
}
.wiz-searchShell:hover::before,
.wiz-searchShell:focus-within::before{
  opacity:.20; filter: blur(22px) saturate(125%);
}
.wiz-searchShell:hover::after,
.wiz-searchShell:focus-within::after{
  opacity:.95; transform: translateY(2px);
}

/* Primary buttons: animated rainbow “ring” on hover/focus */
.btn.primary.rainbow-hover{ position:relative; overflow:hidden; }
.btn.primary.rainbow-hover::after{
  content:""; position:absolute; inset:-2px; border-radius:inherit; padding:2px;
  --angle: 0deg;
  background: conic-gradient(from var(--angle),
    var(--r1), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  -webkit-mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  -webkit-mask-composite: xor; mask-composite: exclude; /* punch out center */
  opacity:0; transition: opacity .2s ease; pointer-events:none;
}
.btn.primary.rainbow-hover::before{
  content:""; position:absolute; inset:0; border-radius:inherit;
  background: radial-gradient(120% 120% at 50% -20%, rgba(255,255,255,.16), transparent 60%);
  opacity:0; transition: opacity .2s ease; pointer-events:none;
}
.btn.primary.rainbow-hover:hover::after,
.btn.primary.rainbow-hover:focus-visible::after{
  opacity:1; animation: spinRainbow 2.25s linear infinite;
}
.btn.primary.rainbow-hover:hover::before,
.btn.primary.rainbow-hover:focus-visible::before{ opacity:1; }

/* Reduced-motion respect */
@media (prefers-reduced-motion: reduce){
  .wiz-searchShell{ transition:none }
  .wiz-searchShell::before, .wiz-searchShell::after{ transition:none }
  .btn.primary.rainbow-hover::after{ animation:none; }
}

/* Optional utilities */
.rainbowLine{
  height:3px; width:100%;
  background: linear-gradient(90deg, var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  filter: saturate(115%); opacity:.85; border-radius:999px;
}
.rainbow-border{
  border:1px solid transparent;
  background:
    linear-gradient(var(--card), var(--card)) padding-box,
    conic-gradient(from 210deg, var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1)) border-box;
}

/* --- Top Card typography (title / subtitle / definition) --- */
.card .card-title{ font-weight:600; margin-bottom:2px; }
.card .card-sub{ color:var(--muted); font-size:12.5px; margin-bottom:6px; font-weight:500; }
.card .card-def{ font-size:12.5px; line-height:1.45; }
.card .card-def .full[hidden]{ display:none!important; }
.card .card-def .short[hidden]{ display:none!important; }
.card .card-def .btn{ padding:2px 8px; font-size:12px; }


/* Soften the search-bar rainbow hover */
.wiz-searchShell::before{
  /* base halo */
  opacity:.10;              /* was .14 */
  filter: blur(16px) saturate(110%);  /* was blur(20px) saturate(118%) */
}
.wiz-searchShell:hover::before,
.wiz-searchShell:focus-within::before{
  /* hover halo */
  opacity:.05;              /* was .20 */
  filter: blur(18px) saturate(112%);  /* was blur(22px) saturate(125%) */
}
.wiz-searchShell:hover,
.wiz-searchShell:focus-within{
  /* lift + shadow */
  transform: translateY(-0.5px);      /* was -1px */
  box-shadow: 0 10px 24px rgba(0,0,0,.10), 0 3px 8px rgba(0,0,0,.08); /* softer */
}
.wiz-searchShell:hover::after,
.wiz-searchShell:focus-within::after{
  /* “hanging rainbow” underline */
  opacity:.0;              /* was .95 */
  transform: translateY(1px);         /* was 2px */
}

/* Pin "use this template" buttons bottom-right on every card */
.wiz-cards .card{
  display:flex;
  flex-direction:column;
  height:100%;
}

.wiz-cards .card .foot{
  /* override inline margin-top from renderer so the footer can stick to bottom */
  margin-top:auto !important;
  display:flex;
  align-items:center;
  justify-content:flex-end; /* right align the CTA cluster */
  gap:8px;
}

/* (optional) if any cards have an empty leading spacer element, hide it */
.wiz-cards .card .foot > span:empty{ display:none; }

/* ---- Step status colors (rail) ---- */
.wiz-rail .wiz-prog{ display:none } /* we’re moving progress to the top bar */
.wiz-rail li{ border:1px solid transparent; }
.wiz-rail li.done{
  background: color-mix(in srgb, var(--green), var(--chip) 68%);
  border-color: color-mix(in srgb, var(--green), transparent 70%);
}
.wiz-rail li.warn{
  background: color-mix(in srgb, var(--yellow), var(--chip) 72%);
  border-color: color-mix(in srgb, var(--yellow), transparent 70%);
}

/* ---- Top progress bar (under search) ---- */
/* container now stacks children with meta ON TOP of the bar */
.wiz-topprog{
  display:flex; 
  flex-direction:column-reverse;  /* moves meta above the bar without touching HTML */
  gap:8px;                         /* space between meta and bar */
  margin:16px auto 14px;           /* extra top margin for separation from search */
  width:100%; max-width:1120px; padding:0 16px;
}

.wiz-topprog .wiz-topprog-bar{
  height:8px; border-radius:999px; background:var(--chip); overflow:hidden;
  border:1px solid var(--border);
}
.wiz-topprog .wiz-topprog-bar > i{
  display:block; height:100%; width:0%;
  background: linear-gradient(90deg, var(--r5), var(--r6));
  transition: width .25s ease;
}
.wiz-topprog .wiz-topprog-meta{
  display:flex; gap:8px; align-items:center; justify-content:space-between;
  margin:0;                        /* let the container’s gap handle spacing */
  font-size:12.5px; color:var(--muted);
}
.wiz-topprog .wiz-topprog-meta > span[aria-hidden="true"]{ opacity:.5; }
.wiz-output{
  border:1px solid var(--border); background:var(--card); border-radius:12px;
  padding:10px; font: 12.5px/1.45 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
  white-space:pre-wrap;
}

/* Output step: head row + actions placeholder (Slice 0) */
.out-head-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  margin:10px 0 6px;
}
.out-head-row .subhead{ margin:0; } /* keep subhead snug when paired with actions */

.out-actions.placeholder{
  min-width:160px;
  height:28px;
  border:1px dashed var(--border);
  border-radius:999px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:12px;
  color:var(--muted);
  padding:0 10px;
  user-select:none;
}

/* Output step: actions group (Slice 1) */
.out-actions{
  display:flex;
  align-items:center;
  gap:8px;
}
.out-actions .btn.sm{ padding:6px 10px; }

/* “Ask ChatGPT” visual treatment: black background, white text */
.btn.ask{
  background:#000;
  color:#fff;
  border-color:#000;
}
.btn.ask:hover,
.btn.ask:focus-visible{
  filter:brightness(0.9);
  outline:none;
}

/* === Action Modal (shared) — Slice 1 === */
dialog#actionModal{
  width:min(900px, 92vw);
  max-width:900px;
  border:1px solid var(--border, #ddd);
  border-radius:12px;
  padding:0;
  box-shadow:0 10px 30px rgba(0,0,0,.18);
}
#actionModal::backdrop{ background:rgba(0,0,0,.35); }

#actionModal .dlg-head{
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 16px; border-bottom:1px solid var(--border, #eee);
}
#actionModal .dlg-head .title{ font-weight:600; font-size:16px; }
#actionModal .icon-btn{
  background:transparent; border:0; font-size:20px; line-height:1; cursor:pointer;
}

#actionModal .dlg-body{ padding:12px 16px; }

/* Slice 2: subtle helper note inside the action modal */
#actionModal .note{
  margin:8px 0 0 0;
  font-size:12px;
  color:var(--muted, #666);
}

/* === Slice 3: Post-Launch Helper dialog === */
dialog#postLaunchDlg{
  width:min(820px, 92vw);
  max-width:820px;
  border:1px solid var(--border, #ddd);
  border-radius:12px;
  padding:0;
  box-shadow:0 10px 30px rgba(0,0,0,.18);
}
#postLaunchDlg::backdrop{ background:rgba(0,0,0,.35); }

#postLaunchDlg .dlg-head{
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 16px; border-bottom:1px solid var(--border, #eee);
}
#postLaunchDlg .dlg-head .title{ font-weight:600; font-size:16px; }
#postLaunchDlg .icon-btn{
  background:transparent; border:0; font-size:20px; line-height:1; cursor:pointer;
}

#postLaunchDlg .dlg-body{ padding:12px 16px; }
#postLaunchDlg .note{
  margin:0 0 8px 0; font-size:12px; color:var(--muted, #666);
}
#postLaunchText{
  width:100%; min-height:220px; resize:vertical;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size:13px; line-height:1.4;
  border:1px solid var(--border, #ddd); border-radius:8px; padding:10px; box-sizing:border-box;
  white-space:pre-wrap; background: #fafafa;
}

#postLaunchDlg .dlg-foot{
  display:flex; align-items:center; gap:10px;
  padding:12px 16px; border-top:1px solid var(--border, #eee);
}
#postLaunchStatus[hidden]{ display:none; }
#postLaunchStatus{ font-size:12px; color:var(--muted, #666); }

@media (max-width:640px){
  #postLaunchText{ min-height:180px; }
}


#actionPreview{
  width:100%; min-height:220px; resize:vertical;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size:13px; line-height:1.4;
  border:1px solid var(--border, #ddd); border-radius:8px; padding:10px; box-sizing:border-box;
  white-space:pre-wrap;
}

#actionModal .dlg-foot{
  display:flex; align-items:center; gap:10px;
  padding:12px 16px; border-top:1px solid var(--border, #eee);
}
#copyStatus[hidden]{ display:none; }
#copyStatus{ font-size:12px; color:var(--muted, #666); }
#actionModal .grow{ flex:1; }


@media (max-width:640px){
  .out-head-row{ flex-direction:column; align-items:flex-start; gap:8px; }
  .out-actions.placeholder{ align-self:stretch; height:32px; }
}


/* Typeahead: render above all app layers when portaled */
#taSug.ta-portal{
  position: fixed;         /* viewport-based, not limited by parents */
  left: 0; top: 0;         /* real position set via JS */
  width: auto;             /* real width set via JS */
  z-index: 9999;           /* top of the app */
}

/* ===== INDEX ↔ WIZARD SEARCH PARITY — place at end of <style> ===== */

/* Container width + pop-in like index */
#wizViewStartup .searchWrap{
  width:min(780px,100%);
  margin:6px auto 0;
  position:relative;
  transform-origin:center;
  animation: popIn .56s cubic-bezier(.2,.9,.2,1.2) both;
  z-index:10; /* keep suggestions above following content */
}
@keyframes popIn{ 0%{transform:scale(.88);opacity:0}60%{transform:scale(1.03);opacity:1}100%{transform:scale(1)} }

/* The pill itself: gradient border + soft halo + “hanging” underline */
#wizViewStartup .wiz-searchShell{
  width:100%; display:flex; align-items:center; gap:8px; padding:8px;
  border:2px solid transparent; border-radius:999px; position:relative;
  background:var(--card);
  background-image:
    linear-gradient(var(--card), var(--card)),
    conic-gradient(from 200deg,
      var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  background-clip: padding-box, border-box;
  background-origin: padding-box, border-box;
  box-shadow: var(--shadow);
  transition: transform .08s ease, box-shadow .18s ease, filter .18s ease;
}
#wizViewStartup .wiz-searchShell::before{
  content:""; position:absolute; inset:-10px; border-radius:999px; z-index:-1;
  filter: blur(22px) saturate(120%);
  background: conic-gradient(from 200deg,
    var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  opacity:.16; transition: opacity .18s ease, filter .18s ease;
}
#wizViewStartup .wiz-searchShell::after{
  content:""; position:absolute; left:10%; right:10%; bottom:-6px; height:4px; border-radius:999px;
  background: linear-gradient(90deg,
    var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  opacity:0; transform: translateY(0); transition: opacity .20s ease, transform .20s ease; pointer-events:none;
}
#wizViewStartup .wiz-searchShell:hover,
#wizViewStartup .wiz-searchShell:focus-within{
  transform: translateY(-1px);
  box-shadow: 0 16px 32px rgba(0,0,0,.12), 0 4px 10px rgba(0,0,0,.10);
}
#wizViewStartup .wiz-searchShell:hover::before,
#wizViewStartup .wiz-searchShell:focus-within::before{
  opacity:.20; filter: blur(22px) saturate(125%);
}
#wizViewStartup .wiz-searchShell:hover::after,
#wizViewStartup .wiz-searchShell:focus-within::after{
  opacity:.95; transform: translateY(2px);
}

/* Input sizing/typography parity with index */
#wizViewStartup #wizQ{
  display:block; width:100%; max-width:100%; box-sizing:border-box;
  min-height:48px; padding:12px 16px;
  border:none; outline:none; border-radius:16px; background:transparent; color:var(--fg);
  font:16px/1.2 inherit;
}

/* “search” button parity (overrides .btn sm look inside the shell) */
#wizViewStartup #wizGo{
  border:none; border-radius:999px; padding:10px 14px; cursor:pointer;
  font-weight:600; text-transform:lowercase;
  background: var(--fg); color:#fff;
}
#wizViewStartup #wizClear{ border:none; background:transparent; color:var(--muted); cursor:pointer; }

/* Typeahead shell parity (index uses #ta; wizard uses #taSug .box) */
#wizViewStartup #taSug{
  position:absolute; left:10px; right:10px; top:calc(100% + 8px);
  z-index:300;
}
#wizViewStartup #taSug .box{
  border:1px solid var(--border); background:var(--card); border-radius:12px;
  box-shadow: var(--shadow); max-height:260px; overflow:auto;
}

/* Quick actions row parity */
#wizViewStartup .searchCtas, 
#wizViewStartup .quickRow{
  display:grid;
  grid-template-columns:repeat(3, minmax(0,1fr));
  gap:8px; margin-top:10px;
}
@media (max-width:480px){
  #wizViewStartup .searchCtas .btn, #wizViewStartup .quickRow .btn{ padding:8px 12px }
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce){
  #wizViewStartup .wiz-searchShell,
  #wizViewStartup .wiz-searchShell::before,
  #wizViewStartup .wiz-searchShell::after{ transition:none }
}

/* Header should be flush on the Wizard page */
header.no-edge{
  background: transparent;
  -webkit-backdrop-filter: none;
  backdrop-filter: none;
  border-bottom: none;
  box-shadow: none;
}

/* ===== Wizard search: subtle mode (no underline, softer glow) ===== */

/* Reduce border rainbow to a gentle hint */
#wizSearchShell{
  border-width: 1px;                 /* thinner than 2px */
  background:
    linear-gradient(var(--card), var(--card)) padding-box,
    conic-gradient(from 200deg,
      color-mix(in srgb, var(--r1), transparent 88%),
      color-mix(in srgb, var(--r2), transparent 90%),
      color-mix(in srgb, var(--r3), transparent 92%),
      color-mix(in srgb, var(--r4), transparent 90%),
      color-mix(in srgb, var(--r5), transparent 90%),
      color-mix(in srgb, var(--r6), transparent 88%),
      color-mix(in srgb, var(--r1), transparent 88%)
    ) border-box !important;         /* ensure we win against the utility */
  background-clip: padding-box, border-box;
  background-origin: padding-box, border-box;
}

/* Kill the “hanging rainbow” underline entirely */
#wizSearchShell::after{ display: none !important; }

/* Make the halo almost imperceptible */
#wizSearchShell::before{
  opacity: .04 !important;           /* was ~.10–.16 */
  filter: blur(12px) saturate(104%) !important;
}
#wizSearchShell:hover::before,
#wizSearchShell:focus-within::before{
  opacity: .06 !important;           /* gentle bump instead of a glow bomb */
  filter: blur(14px) saturate(106%) !important;
}

/* Softer hover: no lift, lighter shadow */
#wizSearchShell:hover,
#wizSearchShell:focus-within{
  transform: none !important;
  box-shadow: 0 8px 20px rgba(0,0,0,.08), 0 2px 6px rgba(0,0,0,.06) !important;
}

/* If the .rainbow utility is present on the shell, neutralize its stronger hover */
#wizSearchShell.rainbow:hover{
  background:
    linear-gradient(color-mix(in srgb, var(--card), white 2%), color-mix(in srgb, var(--card), white 2%)) padding-box,
    conic-gradient(from 200deg,
      color-mix(in srgb, var(--r1), transparent 88%),
      color-mix(in srgb, var(--r2), transparent 90%),
      color-mix(in srgb, var(--r3), transparent 92%),
      color-mix(in srgb, var(--r4), transparent 90%),
      color-mix(in srgb, var(--r5), transparent 90%),
      color-mix(in srgb, var(--r6), transparent 88%),
      color-mix(in srgb, var(--r1), transparent 88%)
    ) border-box !important;
}

/* Quick actions: no stretch; size to content like the home page */
#wizViewStartup .quickRow,
#wizViewStartup .searchCtas{
  display: flex !important;
  justify-content: center;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

/* Tighten the button padding slightly on the wizard page */
#wizViewStartup .quickRow .btn,
#wizViewStartup .searchCtas .btn{
  padding: 6px 10px;                 /* was 6px 12–14px */
  min-width: auto;                    /* don’t force equal widths */
}

/* Step 0 — Similar matches: divider + spacing (scoped) */
#step0Similar {
  position: relative;
  margin-top: 24px;     /* space from main content */
  padding-top: 14px;    /* space after divider */
  --hairline: rgba(0,0,0,0.12);  /* fallback if you don't have a var */
}

/* subtle hairline divider above the similar section */
#step0Similar::before {
  content: "";
  display: block;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--hairline) 15%, var(--hairline) 85%, transparent);
  margin-bottom: 14px;
}

/* card grid breathing room (doesn't change your layout columns) */
#step0Similar .wiz-cards {
  gap: 12px;  /* adds spacing between cards */
}

/* inside each card: ensure content doesn’t crash into actions */
#step0Similar .card > * + * { 
  margin-top: 6px;      /* gentle vertical rhythm between siblings */
}

/* common class names seen in your cards; safe, scoped nudges */
#step0Similar .card .def,
#step0Similar .card .desc { 
  margin-bottom: 6px;
}

/* space the “More” toggle from what follows */
#step0Similar .card .more,
#step0Similar .card .toggle-more {
  display: inline-block;
  margin-top: 6px;
}

/* ensure the primary CTA never kisses the text or the More toggle */
#step0Similar .card .def + .btn,
#step0Similar .card .more + .btn,
#step0Similar .card .toggle-more + .btn,
#step0Similar .card .desc + .btn {
  margin-top: 10px;
}

/* if you have an actions row/container, add a bit more air */
#step0Similar .card .card-actions { 
  margin-top: 10px;
}

/* if multiple buttons sit on the same row, give them elbow room */
#step0Similar .card .btn + .btn {
  margin-left: 8px;
}

/* === AI Settings dialog polish (scoped, non-destructive) ================== */
/* Scope to *any* AI Settings modal flavors we might render */
dialog.ai-settings,
dialog[id*="aiSettings"],
dialog[id*="ai-modal"],
dialog[class*="ai-settings"] {
  border-radius: 14px;
  box-shadow: var(--shadow, 0 12px 40px rgba(0,0,0,.12));
  border: 1px solid var(--border, #e3e9f2);
  background: var(--panel, #fff);
}

/* Header: make room and pin the X in the upper-right */
dialog.ai-settings .modal-header,
dialog[id*="aiSettings"] .modal-header,
dialog[id*="ai-modal"] .modal-header,
dialog[class*="ai-settings"] .modal-header,
dialog.ai-settings .dlg-head,
dialog[id*="aiSettings"] .dlg-head,
dialog[id*="ai-modal"] .dlg-head,
dialog[class*="ai-settings"] .dlg-head {
  position: relative;
  padding: 14px 20px;
  border-bottom: 1px solid var(--border, #e3e9f2);
}

/* Close/X button: absolute in the top-right, smaller + crisp hit-area */
dialog.ai-settings .modal-header .icon.close,
dialog[id*="aiSettings"] .modal-header .icon.close,
dialog[id*="ai-modal"] .modal-header .icon.close,
dialog[class*="ai-settings"] .modal-header .icon.close,
dialog.ai-settings .dlg-head .icon-btn,
dialog[id*="aiSettings"] .dlg-head .icon-btn,
dialog[id*="ai-modal"] .dlg-head .icon-btn,
dialog[class*="ai-settings"] .dlg-head .icon-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  line-height: 1;
  width: 32px;
  height: 32px;
  border-radius: 8px;
  background: transparent;
  border: 1px solid transparent;
  font-size: 18px;
}
dialog[class*="ai-settings"] .modal-header .icon.close:hover,
dialog[class*="ai-settings"] .dlg-head .icon-btn:hover {
  background: var(--chip, #f3f6fa);
  border-color: var(--border, #e3e9f2);
}

/* Body: keep things airy and modern */
dialog.ai-settings .modal-section,
dialog[id*="aiSettings"] .modal-section,
dialog[id*="ai-modal"] .modal-section,
dialog[class*="ai-settings"] .modal-section,
dialog[class*="ai-settings"] .dlg-body {
  padding: 16px 20px;
}

/* “Universal prompt” line: add separation from footer buttons.
   If AISettings.js gives this row an id/class, we catch it.
   Otherwise this still helps by targeting common label/input rows. */
dialog[class*="ai-settings"] .universal-row,
dialog[class*="ai-settings"] .universal,
dialog[class*="ai-settings"] .row-universal,
dialog[class*="ai-settings"] [id*="universal"],
dialog[class*="ai-settings"] [name*="universal"] {
  margin-bottom: 10px;
}

/* Footer: increase top spacing + button gap */
dialog.ai-settings .modal-footer,
dialog[id*="aiSettings"] .modal-footer,
dialog[id*="ai-modal"] .modal-footer,
dialog[class*="ai-settings"] .modal-footer,
dialog[class*="ai-settings"] .dlg-foot {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 10px 12px;         /* more space between buttons */
  padding: 14px 20px;     /* more padding around area */
  margin-top: 8px;        /* more space from content above */
  border-top: 1px solid var(--border, #e3e9f2);
}

/* Forgot keys: make it a red (danger) button without guessing exact id */
dialog[class*="ai-settings"] button[id*="forget"],
dialog[class*="ai-settings"] button[name*="forget"],
dialog[class*="ai-settings"] button[data-action*="forget"],
dialog[class*="ai-settings"] button[data-variant="danger"] {
  background: #b91c1c;      /* red-700 */
  border-color: #b91c1c;
  color: #fff;
}
dialog[class*="ai-settings"] button[id*="forget"]:hover,
dialog[class*="ai-settings"] button[name*="forget"]:hover,
dialog[class*="ai-settings"] button[data-action*="forget"]:hover,
dialog[class*="ai-settings"] button[data-variant="danger"]:hover {
  background: #991b1b;      /* red-800 */
  border-color: #991b1b;
}

/* Keep secondary/ghost buttons lean */
dialog[class*="ai-settings"] .btn:not(.primary):not([id*="forget"]):not([name*="forget"]):not([data-action*="forget"]) {
  background: #fff;
  color: var(--fg, #0f1720);
  border-color: var(--border, #e3e9f2);
}
dialog[class*="ai-settings"] .btn:not(.primary):hover {
  background: var(--chip, #f3f6fa);
}

/* Steps header (persistent template context above the progress bar) */
.wiz-steps-header{
  width:100%;
  max-width:1120px;
  padding:0 16px;
  margin:10px auto 8px;
}
.wiz-steps-header .title{
  font-size: clamp(24px, 2.6vw, 32px);
  margin: 0 0 6px;
}
.wiz-steps-header .def{
  margin: 0;
  max-width: 75ch;
  font-size: 13.5px;
  line-height: 1.55;
  color: var(--muted);
}

/* === Slice 1: Wizard single type-ahead (local menu) ===================== */
.wiz-pane .ta-shell { position: relative; }               /* anchor for the menu */

/* === Slice 2: Repeater chips (wizard) =================================== */
.wiz-pane .chips { display:flex; flex-wrap:wrap; gap:6px; margin: 0 0 6px 0; }
.wiz-pane .chip {
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 8px; border:1px solid var(--border); border-radius:14px;
  background: var(--chip); line-height:1; font-size:12px;
}
.wiz-pane .chip .x { cursor:pointer; border:0; background:none; font-size:14px; line-height:1; }
.wiz-pane .chip-input { width:100%; }

.wiz-pane .ta-menu[hidden]{ display:none }
.wiz-pane .ta-menu{
  position:absolute; left:0; right:0; top:calc(100% + 6px); z-index:20;
  border:1px solid var(--border); background:var(--card);
  border-radius:12px; box-shadow:var(--shadow);
  max-height:260px; overflow:auto;
}
.wiz-pane .ta-item{ padding:8px 10px; cursor:pointer; }
.wiz-pane .ta-item[aria-selected="true"],
.wiz-pane .ta-item:hover{
  background:color-mix(in srgb, var(--chip), white 30%);
}
.wiz-pane .ta-hint{
  margin-top:6px; font-size:12px; color:var(--muted);
}


</style>



<!-- Beta/BMC UI -->
<link rel="stylesheet" href="./assets/beta-bmc.css?v=2025-09-29">
<script defer
        src="./assets/beta-bmc.js?v=2025-09-29"
        data-beta="pill"
        data-bmc="discrete"
        data-bmc-dismissible="true"></script>
  
 <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "Organization",
      "@id": "https://jonathankhobson.github.io/AI/#org",
      "name": "Prompt Builder",
      "url": "https://jonathankhobson.github.io/AI/index.html",
      "logo": {
        "@type": "ImageObject",
        "url": "https://jonathankhobson.github.io/AI/assets/brand/logo-512.png",
        "width": 512,
        "height": 512
      },
      "sameAs": [
        "https://www.linkedin.com/in/jonathankylehobson/"
      ]
    },
    {
      "@type": "WebSite",
      "@id": "https://jonathankhobson.github.io/AI/#website",
      "url": "https://jonathankhobson.github.io/AI/index.html",
      "name": "Prompt Builder",
      "inLanguage": "en-US",
      "publisher": { "@id": "https://jonathankhobson.github.io/AI/#org" },
      "potentialAction": {
        "@type": "SearchAction",
        "target": "https://jonathankhobson.github.io/AI/index.html?q={search_term_string}",
        "query-input": "required name=search_term_string"
      }
    },
    {
      "@type": "WebPage",
      "@id": "https://jonathankhobson.github.io/AI/glossary/startup-wizard.html#webpage",
      "url": "https://jonathankhobson.github.io/AI/glossary/startup-wizard.html",
      "name": "Startup Wizard for clearer AI prompts | Prompt Builder",
      "isPartOf": { "@id": "https://jonathankhobson.github.io/AI/#website" },
      "inLanguage": "en-US",
      "description": "Search use-cases, pick a template, and follow guided steps to shape clear, reusable AI prompts.",
      "datePublished": "2025-09-29",
      "dateModified": "2025-09-30",
      "primaryImageOfPage": {
        "@type": "ImageObject",
        "url": "https://jonathankhobson.github.io/AI/assets/og/prompt-builder-og.png",
        "width": 1200,
        "height": 630
      },
      "breadcrumb": {
        "@type": "BreadcrumbList",
        "itemListElement": [
          { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://jonathankhobson.github.io/AI/index.html" },
          { "@type": "ListItem", "position": 2, "name": "Glossary", "item": "https://jonathankhobson.github.io/AI/glossary/index.html" },
          { "@type": "ListItem", "position": 3, "name": "Startup Wizard", "item": "https://jonathankhobson.github.io/AI/glossary/startup-wizard.html" }
        ]
      }
    }
  ]
}
</script>
 
</head>
<body data-beta="pill" data-bmc="discrete" data-bmc-dismissible="true">
 <a class="skip-link" href="#main">Skip to content</a>

<header class="no-edge">

<a class="btn sm" href="../index.html">← back to home</a>
<div class="spacer"></div>


<button class="btn sm hide" id="btnExitSearch">search</button>

<!-- AI: -->
<a id="hdrPB" class="btn sm" href="prompt-builder.html">Advanced Prompt Builder</a>
  <button id="aiSettingsBtn" class="btn sm" type="button" title="AI Assist Settings">ai settings</button>

  </header>

  <main id="main" class="wiz-root">
  <h1 class="visually-hidden">Startup Wizard</h1>


    <!-- Startup view -->
    <section id="wizViewStartup" class="wiz-startup">
        <!-- Header strip: search pill -->
<div class="wiz-header-search" id="wizHdr">
  <div class="searchCenter">
    <div class="wiz-searchShell search rainbow" id="wizSearchShell">
      <input id="wizQ" type="text" placeholder="search use-cases, labels, tags…" autocomplete="off" />
      <button id="wizClear" class="wiz-clear" title="clear">×</button>
     <button id="wizGo" class="btn sm">search</button>
      <div id="taSug" hidden>
      <div class="box" role="listbox" aria-label="suggestions"></div>
      </div>
    </div>
        <p class="hint">type what you want to make in everyday words — we’ll shape it into a clear ai prompt.</p>

        <div class="quickRow searchCtas">
         <a id="btnAdv" class="btn sm rainbow" href="./templates-glossary.html">advanced search</a>
      <a id="btnHelp"  class="btn sm rainbow"  href="./startup-wizard.html?slug=pattern-picker">help me</a>
      <button id="btnLucky" class="btn sm rainbow">i’m feeling lucky</button>
    </div>
  </div>
</div>
     <!-- existing Startup content begins -->
<div class="wiz-row">
  <label for="wizAllSelect" class="muted">all matches</label>
  <span id="wizMatchMeta" class="muted" style="margin-left:8px">0 matches of 0 total</span>
</div>
<select id="wizAllSelect" style="min-width:280px">
  <option value="" disabled selected>— choose a template —</option>
</select>
<div id="wizTop" class="block">
  <div class="block-title">
    <h3>top matches</h3>
    <div class="right" style="display:flex; align-items:center; gap:10px">
      <button id="btnNext3" class="btn sm">next 3</button>
      <span id="wizTopMeta" class="muted">showing 0 of 0 (out of 0)</span>
    </div>
  </div>
  <div id="wizTopCards" class="wiz-cards" style="margin-top:8px"></div>
</div>
    </section>

<!-- Step 0 view -->
<section id="wizViewStep0" class="wiz-step0 hide">
  <h2 class="title" id="wizStep0Title">template</h2>
  <p class="def" id="wizStep0Def"></p>
  <ul class="meta" id="wizStep0Stats"></ul>
  <div class="uses">
    <div class="subhead">use-cases</div>
    <ul id="wizStep0Uses"></ul>
  </div>

  <div class="step0-actions">
    <button id="wizStep0Start" class="btn primary">← start guided setup</button>
    <button id="wizExitSearch" class="btn">back to search</button>
  </div>

  <!-- Similar matches (Step 0 footer) -->
<div id="step0Similar" class="block">
  <!-- Row 1: heading only -->
  <div class="block-title" style="display:flex; align-items:center; justify-content:space-between;">
    <h3 class="subhead" style="margin:0">similar matches</h3>
  </div>

  <!-- Row 2: controls (Prev on left, meta + Next on right) -->
  <div class="block-controls" style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-top:6px;">
    <div class="left">
      <button id="btnSimPrev3" class="btn sm" title="show previous 3" aria-label="show previous 3">previous 3</button>
    </div>
    <div class="right" style="display:flex; align-items:center; gap:10px">
      <span id="simMeta" class="muted">showing 0 of 0</span>
      <button id="btnSimNext3" class="btn sm" title="show next 3" aria-label="show next 3">next 3</button>
    </div>
  </div>

  <!-- Row 3: cards -->
  <div id="simCards" class="wiz-cards" style="margin-top:8px"></div>
</div>
</section>


    <!-- Steps view -->
    <section id="wizViewSteps" class="hide">
      <!-- Steps Header: persistent template context -->
  <div id="wizStepsHeader" class="wiz-steps-header">
    <h2 id="wizStepsTitle" class="title">template</h2>
    <p id="wizStepsDef" class="def"></p>
  </div>
        <div id="wizTopProgress" class="wiz-topprog hide">
  <div class="wiz-topprog-bar" aria-hidden="true"><i id="tpBar"></i></div>
  <div class="wiz-topprog-meta">
    <span id="tpStep">step 1 of 1</span>
    <span aria-hidden="true">•</span>
    <span id="tpPct">0%</span>
    <span aria-hidden="true">•</span>
    <span id="tpEnc">let’s get rolling</span>
    <span aria-hidden="true">•</span>
    <span id="tpTime">~0 min left</span>
  </div>
</div>
      <div class="wiz-stepsWrap">
        <aside class="wiz-rail">
          <div class="wiz-prog" aria-hidden="true"><i id="wizProgBar"></i></div>
          <ul id="wizStepList"></ul>
        </aside>
        <div class="wiz-pane">
          <div id="wizStepBody"></div>
          <div class="wiz-foot">
            <button id="wizShowAll" class="btn">show all</button>
            <div class="spacer"></div>
            <button id="wizStepBack" class="btn">← back</button>
            <button id="wizStepNext" class="btn primary rainbow-hover">next →</button>
          </div>
        </div>
      </div>
    </section>
    
    <nav id="templateIndex" aria-labelledby="template-index" class="visually-hidden">
  <h2 id="template-index">Template index</h2>
  <ul id="templateIndexList"></ul>
</nav>
<noscript>
  <p>See all templates in the <a href="./templates-glossary.html">templates glossary</a>.</p>
</noscript>
  </main>
  
  <!-- === Slice 1: Action Modal (shared for Copy / Ask) === -->
<dialog id="actionModal" aria-labelledby="actionTitle">
  <div class="dlg-head">
    <div id="actionTitle" class="title">Copy prompt</div>
    <button id="actionClose" class="icon-btn" aria-label="Close">×</button>
  </div>
  <div class="dlg-body">
    <textarea id="actionPreview" aria-label="Editable prompt preview"></textarea>
    <p id="actionNote" class="note" hidden>
      If your prompt doesn’t appear in ChatGPT, very long URLs or cached drafts can get in the way. You’ll be able to open a clean chat or copy/paste manually.
    </p>
  </div>
  <div class="dlg-foot">
    <span id="copyStatus" role="status" aria-live="polite" aria-atomic="true" hidden>Copied to clipboard.</span>
    <div class="grow"></div>
    <button id="actionCopy" class="btn sm">Copy</button>
    <button id="actionCancel" class="btn sm">Close</button>
  </div>
</dialog>

<!-- === Slice 3: Post-Launch Helper (shown after returning from ChatGPT) === -->
<dialog id="postLaunchDlg" aria-labelledby="postLaunchTitle">
  <div class="dlg-head">
    <div id="postLaunchTitle" class="title">Did the prompt appear in ChatGPT?</div>
    <button id="postLaunchClose" class="icon-btn" aria-label="Close">×</button>
  </div>

  <div class="dlg-body">
    <p id="postLaunchMsg" class="note">
      If it didn’t, very long URLs or a cached draft can get in the way.
      You can open a clean chat or copy the prompt and paste it manually.
    </p>

    <textarea id="postLaunchText" aria-label="Your prompt (read-only)" readonly></textarea>
  </div>

  <div class="dlg-foot">
    <span id="postLaunchStatus" role="status" aria-live="polite" aria-atomic="true" hidden></span>
    <div class="grow"></div>
    <button id="postLaunchOpenBase" class="btn sm">Open clean chat</button>
    <button id="postLaunchCopy" class="btn sm">Copy again</button>
    <button id="postLaunchDismiss" class="btn sm">Dismiss</button>
  </div>
</dialog>


  <script>
  // Tiny UI state (theme, mode preference)
  function readUI(){ try{ return JSON.parse(localStorage.getItem('pb.v1.ui')||'{}'); }catch(_){ return {}; } }
  function writeUI(x){ localStorage.setItem('pb.v1.ui', JSON.stringify(Object.assign(readUI(), x))); }

  // ===== Data access: dedupe across FRAMEWORKS/TEMPLATES/TASK_TEMPLATES =====
  function allTemplates(){
    const A = [];
    const seen = new Set();
    const sources = [window.FRAMEWORKS, window.TEMPLATES, window.TASK_TEMPLATES, window.TASKS, window.templates, window.tasks]
      .filter(Boolean);
    for (const src of sources){
      for (const t of src){
        const kind = (t.kind||t.type||'framework').toLowerCase();
        const id   = (t.id||t.slug||t.key||t.label||'').toString().toLowerCase().trim();
        const slug = (t.slug||id).toLowerCase();
        const key  = kind+':'+(slug||id);
        if (!id) continue;
        if (seen.has(key)) continue;
        seen.add(key);
        A.push(Object.assign({ kind, slug }, t));
      }
    }
    return A;
  }

  // ===== Ranking: prioritize full-phrase, whole-word, starts-with =====
// ===== Index & Ranking (use-case first, tags second; task-nudged) =====
const REC_KEY = 'pb_recent_queries';

function getRecents(){
  try{
    const arr = JSON.parse(localStorage.getItem(REC_KEY) || '[]');
    return Array.isArray(arr) ? arr : [];
  }catch(_){ return []; }
}
function saveRecent(q){
  const s = (q||'').trim(); if (!s) return;
  const cur = getRecents();
  const idx = cur.findIndex(x => x.toLowerCase() === s.toLowerCase());
  if (idx >= 0) cur.splice(idx,1);
  cur.unshift(s);
  localStorage.setItem(REC_KEY, JSON.stringify(cur.slice(0,12)));
}

function isTaskKind(kind){ return (kind||'').toLowerCase()==='task'; }
function isHelperTemplate(t){
  const lab = (t.label||'').toLowerCase();
  const tags = ((t.tags||[]).join(' ')||'').toLowerCase();
  return /helper|picker|guide|wizard/.test(lab+' '+tags);
}

// Build a compact index of searchables from templates & tasks.
let SEARCH_INDEX = [];
function buildIndex(){
  const T = allTemplates(); // already merges framework+tasks
  const idx = [];
  for (const t of T){
    const kind = (t.kind||'framework').toLowerCase();
    const id   = (t.id||t.slug||t.key||t.label||'').toString();
    const slug = (t.slug||'').toString();
    const isTask = isTaskKind(kind) || /^task[_:\-]/i.test(id) || /^task[_:\-]/i.test(slug);
    const uses = Array.isArray(t.use_cases) ? t.use_cases : [];
    const tags = Array.isArray(t.tags) ? t.tags : [];
    const cats = Array.isArray(t.categories) ? t.categories : (t.category? [t.category] : []);

    // extract "use:" tags as dedicated use-tags (lightweight)
    const useTags = tags
      .map(x=> String(x||'').trim().toLowerCase())
      .filter(x=> x.startsWith('use:'))
      .map(x=> x.replace(/^use:\s*/,'').trim())
      .filter(Boolean);

    // index each use-case as a suggestion candidate
    for (const u of uses){
      const text = String(u||'').trim();
      if (!text) continue;
      idx.push({ bucket:'uc', text, t, kind, isTask });
    }
    // index "use:" tags as lighter suggestions
    for (const tag of useTags){
      idx.push({ bucket:'tag', text: tag, t, kind, isTask });
    }
  }
  SEARCH_INDEX = idx;
}

function tokenize(s){ return (s||'').toLowerCase().split(/[^a-z0-9]+/).filter(Boolean); }

// Scoring tuned for use-cases (UCs first), then use: tags; gentle task nudge.
function scoreOne(q, entry){
  const Q = (q||'').trim().toLowerCase();
  const T = entry.text.toLowerCase();
  if (!Q || !T) return 0;

  let s = 0;
  // Phrase & substring bonuses
  if (T.includes(Q)) s += 220;                 // exact phrase
  if (Q.includes(T) && T.length>2) s += 120;   // entry is substring of the full query
  // Token scoring
  const qTok = tokenize(Q);
  for (const w of qTok){
    if (T === w) s += 80;                       // exact token equals use
    if (new RegExp(`\\b${w}\\b`).test(T)) s += 40; // word-boundary hit
    if (T.indexOf(w) >= 0) s += 24;             // substring
    if (T.startsWith(w)) s += 10;               // starts-with nudge
  }
  // Kind nudges
  if (entry.isTask) s += 30;                    // tasks up-weighted
  if (qTok.some(w => (entry.kind||'').includes(w))) s += 12; // kind-token overlap
  // Brevity & position nudges (mild; only if matched)
  if (s>0){
    s += Math.max(0, 20 - Math.min(20, T.length/6)); // shorter use-cases get tiny lift
  }
  return s;
}

// Build idle suggestions: recents first, then helpers (use-cases)
function helperUsecaseSuggestions(limit=8){
  const out = [];
  for (const e of SEARCH_INDEX){
    if (e.bucket!=='uc') continue;
    if (!isHelperTemplate(e.t)) continue;
    out.push({ kind:e.kind, isTask:e.isTask, bucket:'uc', text:e.text, t:e.t, idle:true });
    if (out.length>=limit) break;
  }
  return out;
}
function buildIdleSuggestions(limit=8){
  const rec = getRecents().slice(0,limit).map(q => ({ bucket:'recent', text:q }));
  if (rec.length>=limit) return rec;
  const need = limit - rec.length;
  return rec.concat(helperUsecaseSuggestions(need));
}

function rankSuggestions(q, limit=8){
  const list = SEARCH_INDEX.map(e => ({
    e, score: scoreOne(q, e),
  })).filter(x => x.score>0);

  // If too few or weak, inject helpers near the top to keep UX friendly
  let suggestions = list.sort((a,b)=> b.score - a.score);
  if (suggestions.length < 3){
    const inject = helperUsecaseSuggestions(Math.max(3, limit));
    const maxScore = suggestions[0]?.score || 200;
    suggestions = inject.map((h,i)=>({ e:h, score:maxScore + 5 - i })).concat(suggestions);
  }

  // Sort: bucket (uc > tag), score desc, isTask desc, use-length asc, alpha
  suggestions.sort((A,B)=>{
    const a=A.e, b=B.e;
    const bucketOrder = (a.bucket==='uc'?0:1) - (b.bucket==='uc'?0:1);
    if (bucketOrder!==0) return bucketOrder;
    if (B.score!==A.score) return B.score - A.score;
    if ((b.isTask?1:0)!==(a.isTask?1:0)) return (b.isTask?1:0)-(a.isTask?1:0);
    const la=a.text.length, lb=b.text.length; if (la!==lb) return la-lb;
    return a.text.localeCompare(b.text);
  });

  // map to plain suggestion entries and cap
  return suggestions.slice(0, limit).map(x => x.e);
}

  // ===== Renderers =====
  const el = id => document.getElementById(id);
  const qs = sel => document.querySelector(sel);
  
  // Persist & render the current template in Steps header
function setCurrentTemplate(t){
  window.CURRENT_TEMPLATE = t || null;
  updateStepsHeaderFrom(window.CURRENT_TEMPLATE);
}

function updateStepsHeaderFrom(t){
  const titleEl = el('wizStepsTitle');
  const defEl   = el('wizStepsDef');
  if (!titleEl || !defEl) return;

  // Prefer explicit template object; otherwise fall back to Step 0 text if present
  const label = (t && (t.label || t.slug || t.id)) || (el('wizStep0Title')?.textContent) || 'template';
  const desc  = (t && (t.definition || t.help)) || (el('wizStep0Def')?.textContent) || '';

  titleEl.textContent = label;
  defEl.textContent   = desc;
}

  function estimateTimeByFields(n){
    const approx = Math.max(1, Math.min(60, Math.ceil((n||0)*0.75))); // ~minutes   [oai_citation:14‡prompt_builder_test.html](file-service://file-9EZtQuEpjH3EQyYCFvQSHV)
    return `~${approx} min`;
  }

  function rowsFromTemplates(T){
    return T.map(t=>{
      const useText = Array.isArray(t.use_cases) && t.use_cases.length ? t.use_cases.join(' • ') : (t.label||t.slug||t.id||'');
      return {
        id:t.id, slug:t.slug, key:t.key, label:(t.label||t.slug||t.id||'template'),
        definition:(t.definition||t.help||''), useText, kind:(t.kind||'framework'), ref:t
      };
    });
  }

  function renderAllSelect(rows){
    const sel = el('wizAllSelect');
    const cur = sel.value;
    const opts = [`<option value="" disabled ${!cur?'selected':''}>— choose a template —</option>`]
      .concat(rows.map(r=> `<option value="${r.slug||r.id}" data-id="${r.id||''}" data-slug="${r.slug||''}">${r.label}</option>`));
    sel.innerHTML = opts.join('');
  }

function cardHTML(r){
  // Title = first use-case on the template (fallback: suggestion text or label)
  const firstUse = (r.ref && Array.isArray(r.ref.use_cases) && r.ref.use_cases[0])
    || r.useText || r.label;

  // Subtitle = the template label
  const sub = r.label;

  // Definition with truncation + “more”
  const defFull = String(r.definition||'').trim();
  const LIMIT = 180; // tweak as desired
  const needsMore = defFull.length > LIMIT;
  const defShort = needsMore ? (defFull.slice(0, LIMIT - 1) + '…') : defFull;

  // Unique id per card’s definition container (based on slug/id)
  const defId = 'def_' + (r.slug || r.id || Math.random().toString(36).slice(2));

  return `
    <article class="card" data-id="${r.id||''}" data-slug="${r.slug||''}">
      <div class="card-title">${firstUse}</div>
      <div class="card-sub">${sub}</div>

      <div class="card-def" id="${defId}">
        <span class="short">${defShort}</span>
        ${needsMore
          ? `<button class="btn sm js-more" type="button" data-target="${defId}">more</button>
             <span class="full" hidden>${defFull.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</span>`
          : ''}
      </div>

      <div class="foot" style="margin-top:8px">
        <span></span>
        <button class="btn sm primary rainbow-hover js-use" type="button">use this template</button>
      </div>
    </article>`;
}

let topIndex = 0; // rotating window start

function renderTop(rows){
  const top = el('wizTopCards');
  if (!rows.length){
    top.innerHTML = `<div class="muted">no matches yet — try a different search</div>`;
    el('wizTopMeta').textContent = `showing 0 of 0 (out of ${allRows.length||0})`;
    return;
  }
  // compute current window [topIndex, topIndex+3)
  const start = topIndex % rows.length;
  const slice = [rows[start], rows[(start+1)%rows.length], rows[(start+2)%rows.length]].filter(Boolean);
  top.innerHTML = slice.map(cardHTML).join('');
  el('wizTopMeta').textContent = `showing ${Math.min(3, rows.length)} of ${rows.length} (out of ${allRows.length||0})`;
}



  // ===== Startup compute =====
  let allRows = [];       // every template row
  let matchRows = [];     // current filtered rows
function recompute(query=''){
  // delegate to the unified scanner; do not save history on incidental recomputes
  if (typeof window.__startScan === 'function'){
    window.__startScan(String(query||''), { saveHistory:false });
  }
}

  // ===== Typeahead =====
// ===== Typeahead (use-cases + recents) =====
(function wireTypeahead(){
  const qEl  = el('wizQ');
  const sug  = el('taSug');
  const box  = qs('#taSug .box');
  
    const shell = qEl.closest('.wiz-searchShell'); // the pill that anchors the dropdown
  let portalized = false;

  function ensurePortal(){
    if (!portalized){
      sug.classList.add('ta-portal');
      document.body.appendChild(sug); // move out of lower stacking contexts
      portalized = true;
    }
  }
  function positionSug(){
    const r = shell.getBoundingClientRect();
    // mirror the original left/right 8px padding of the search shell
    const left  = Math.round(r.left + 8);
    const top   = Math.round(r.bottom + 8);          // was calc(100% + 8px)
    const width = Math.max(240, Math.round(r.width - 16));
    Object.assign(sug.style, { left: left+'px', top: top+'px', width: width+'px' });
  }


  let idx = -1, open = false, curList = []; // curList items: {bucket:'uc'|'tag'|'recent', text, t?, kind?, isTask?}

  function renderRows(list){
    box.innerHTML = list.map((r,i)=>`
      <div class="row" role="option" data-i="${i}">
        <div style="display:flex; flex-direction:column; gap:2px; width:100%">
          <div class="lbl">${r.text}</div>
          <div class="muted" style="font-size:12px; display:flex; gap:8px; align-items:center;">
            ${r.t ? `<span>${r.t.label||r.t.slug||'template'}</span>` : `<span>recent</span>`}
            ${r.bucket!=='recent' ? `<span class="pill" style="padding:2px 8px">${r.bucket}${r.isTask?' · task':''}</span>` : ''}
          </div>
        </div>
      </div>
    `).join('');
  }
 function openSug(list){
    curList = list.slice(0,8);
    if (curList.length === 0){ hideSug(); return; }
    renderRows(curList);
    ensurePortal();
    positionSug();
    sug.hidden = false; open = true; idx = 0; highlight(idx);
  }
  function hideSug(){
    sug.hidden = true; open = false; idx = -1; curList = [];
  }
  function hideSug(){ sug.hidden = true; open = false; idx = -1; curList = []; }
  function highlight(i){
    [...box.querySelectorAll('.row')].forEach((r,k)=> r.setAttribute('aria-selected', k===i?'true':'false'));
  }

  function startScan(query, opts={}){
    // Update top-3 + all-matches based on ranked suggestions; do not navigate.
    const q = String(query||'').trim();
    if (opts.saveHistory) saveRecent(q);
    
      // 🔧 NEW: keep a fresh total for “(out of N)”
  allRows = rowsFromTemplates(allTemplates());

    // Rank suggestions, then collapse to unique templates by order
    const ranked = q ? rankSuggestions(q, 64) : [];
    const seen = new Set();
    const dedupRows = [];
    for (const s of ranked){
      const t = s.t; if (!t) continue;
      const slug = (t.slug||t.id||t.label||'').toLowerCase();
      if (seen.has(slug)) continue;
      seen.add(slug);
      dedupRows.push({ // row used by Top/All renders
        id:t.id, slug:t.slug, key:t.key, label:(t.label||t.slug||t.id||'template'),
        definition:(t.definition||t.help||''), useText: s.text, kind:(t.kind||'framework'), ref:t
      });
    }

    matchRows = dedupRows.length ? dedupRows : rowsFromTemplates(allTemplates()).sort((a,b)=> a.label.localeCompare(b.label));
    el('wizMatchMeta').textContent = `${matchRows.length} matches of ${rowsFromTemplates(allTemplates()).length} total`;

    topIndex = 0;
    renderAllSelect(matchRows);
    renderTop(matchRows);
  }

  function choose(i){
    const r = curList[i]; if (!r) return;
    qEl.value = r.text;
    hideSug();
    if (r.bucket==='recent'){
      // Re-rank for this query, then show top-3; save to history again
      startScan(r.text, { saveHistory:true });
    }else{
      startScan(r.text, { saveHistory:true });
    }
  }

  qEl.addEventListener('focus', ()=>{
    const val = qEl.value.trim();
    if (!val) openSug(buildIdleSuggestions(8));
  });
  qEl.addEventListener('blur', ()=>{
    // Delay to allow click selection
    setTimeout(()=> hideSug(), 120);
  });

  qEl.addEventListener('input', ()=>{
    const val = qEl.value;
    if (!val.trim()){
      openSug(buildIdleSuggestions(8));
      // optional: keep Top-3 as last “run”; don’t overwrite
      return;
    }
    // Live suggestions; also update Top-3 live without writing history
    openSug(rankSuggestions(val, 8));
    // Live top refresh (no history write)
    startScan(val, { saveHistory:false });
  });

  qEl.addEventListener('keydown', (e)=>{
    if (!open){
      if (e.key==='Enter'){
        e.preventDefault();
        startScan(qEl.value, { saveHistory:true }); // run typed query
      }
      return;
    }
    if (e.key==='ArrowDown'){ idx = Math.min(curList.length-1, idx+1); highlight(idx); e.preventDefault(); }
    else if (e.key==='ArrowUp'){ idx = Math.max(0, idx-1); highlight(idx); e.preventDefault(); }
    else if (e.key==='Enter'){ e.preventDefault(); choose(idx>=0?idx:0); }
    else if (e.key==='Escape'){ hideSug(); }
  });

  box.addEventListener('mousedown', (e)=>{
    // mousedown so blur doesn’t cancel
    const row = e.target.closest('.row'); if (!row) return;
    choose(+row.dataset.i);
  });
  
    // keep the portal aligned as the page moves/resizes
  window.addEventListener('resize', ()=>{ if (!sug.hidden) positionSug(); });
  // capture scrolls from any ancestor (left rail, main pane, window)
  window.addEventListener('scroll', ()=>{ if (!sug.hidden) positionSug(); }, true);


  // expose for other buttons
  window.__startScan = startScan;
})();

  // ===== Header search router: if not on Startup, bounce back then replay =====
  (function headerSearchRouter(){
    const qEl  = el('wizQ'), goEl = el('wizGo');
    let reenter = false; // guard so native handler runs once   [oai_citation:15‡prompt_builder_test.html](file-service://file-9EZtQuEpjH3EQyYCFvQSHV)
    function currentView(){ return !el('wizViewStartup').classList.contains('hide') ? 'startup' :
                                   !el('wizViewStep0').classList.contains('hide') ? 'step0' : 'steps'; }
    function gotoStartup(){ if (currentView()!=='startup'){ showView('startup'); } }

    goEl.addEventListener('click', (e)=>{
      if (reenter || currentView()==='startup') return;
      e.preventDefault(); e.stopPropagation();
      gotoStartup();
      setTimeout(()=>{ reenter=true; try{ goEl.click(); } finally{ reenter=false; } }, 0);  /*  [oai_citation:16‡prompt_builder_test.html](file-service://file-9EZtQuEpjH3EQyYCFvQSHV) */
    }, true);

    qEl.addEventListener('keydown', (e)=>{
      if (e.key!=='Enter' || currentView()==='startup') return;
      e.preventDefault(); e.stopPropagation();
      const ev = new KeyboardEvent('keydown', { key:'Enter', bubbles:true, cancelable:true });
      gotoStartup();
      setTimeout(()=>{ reenter=true; try{ qEl.dispatchEvent(ev);} finally{ reenter=false; } }, 0);  /*  [oai_citation:17‡prompt_builder_test.html](file-service://file-9EZtQuEpjH3EQyYCFvQSHV) */
    }, true);
  })();

// ===== Startup actions =====
el('wizGo').addEventListener('click', ()=>{
  const val = el('wizQ').value;
  if (document.getElementById('taSug') && !document.getElementById('taSug').hidden){
    // dropdown is open → choose top suggestion
    if (typeof window.__startScan === 'function'){
      window.__startScan(val, { saveHistory:true });
    }
  }else{
    // no dropdown → run typed query
    if (typeof window.__startScan === 'function'){
      window.__startScan(val, { saveHistory:true });
    }
  }
});


  el('wizClear').addEventListener('click', ()=>{ el('wizQ').value=''; recompute(''); });

  document.addEventListener('change', (ev)=>{
    const elx = ev.target;
    if (elx && elx.id==='wizAllSelect'){
      const opt = elx.selectedOptions && elx.selectedOptions[0]; if (!opt) return;
      const slug = opt.getAttribute('data-slug')||''; const id = opt.getAttribute('data-id')||'';
      const t = (allTemplates().find(x => (x.slug||'')===slug || (x.id||'')===id) || {}).ref || allTemplates().find(x => (x.slug||'')===slug || (x.id||'')===id) || null;
      if (!t) return;
      openStep0(t);  // delegated select → step0   [oai_citation:18‡prompt_builder_test.html](file-service://file-9EZtQuEpjH3EQyYCFvQSHV)
    }
  }, true);




  // Quick actions
  el('btnLucky').addEventListener('click', ()=>{
    const T = [...allTemplates()];
    for (let i=T.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [T[i],T[j]]=[T[j],T[i]]; }
    const rows = rowsFromTemplates(T).slice(0,3);
    el('wizTopCards').innerHTML = rows.map(cardHTML).join('');
  });
  el('btnHelp').addEventListener('click', ()=>{
    const rows = matchRows.filter(r => /picker|helper|guide|wizard/i.test(r.label + ' ' + r.useText)).slice(0,3);
    el('wizTopCards').innerHTML = (rows.length? rows: matchRows.slice(0,3)).map(cardHTML).join('');
  });

  // Click “Use this template” on any card → Step 0 (delegated)
  document.addEventListener('click', (ev)=>{
    const btn = ev.target.closest('.js-use'); if (!btn) return;
    const card = btn.closest('.card'); if (!card) return;
    const slug = card.getAttribute('data-slug')||''; const id = card.getAttribute('data-id')||'';
    const t = allTemplates().find(x => (x.slug||'')===slug || (x.id||'')===id) || null;
   if (t){ setCurrentTemplate(t); openStep0(t); }  // record → step0
  }, true);

  // ===== View switching (page version of your controller) =====
function showView(name){
  const s0 = el('wizViewStartup'), s1 = el('wizViewStep0'), s2 = el('wizViewSteps');
  s0.classList.toggle('hide', name!=='startup');
  s1.classList.toggle('hide', name!=='step0');
  s2.classList.toggle('hide', name!=='steps');

  // keep the steps header up to date when Steps becomes visible
  if (name === 'steps') {
    updateStepsHeaderFrom(window.CURRENT_TEMPLATE);
  }

  // header affordances: show "exit to search" when not on main page
  const isStartup = name === 'startup';
  const exitSearch = el('btnExitSearch');
  if (exitSearch) exitSearch.classList.toggle('hide', isStartup);

  // NEW: Only show quick action buttons on Startup
  ['btnHelp','btnLucky'].forEach(id=>{
    const btn = el(id);
    if (btn) btn.classList.toggle('hide', !isStartup);
  });

  // Optional: collapse the row entirely so there’s no extra gap
  const quickRow = document.querySelector('.quickRow');
  if (quickRow) quickRow.classList.toggle('hide', !isStartup);
}

  
  
  // Next 3 — cycle the rotating window
el('btnNext3').addEventListener('click', ()=>{
  if (!matchRows.length) return;
  topIndex = (topIndex + 3) % Math.max(1, matchRows.length);
  renderTop(matchRows);
});

/* ===== Step 0: Similar templates v4 (intentional, inclusive, alignment-aware, future-proof) ===== */

let SIM_ROWS = [];
let simIndex = 0;

/* --- Slice 1: Similar Matches pager (prev/next 3) ----------------------- */
/* This relies on SIM_ROWS (array of row-like objects) and simIndex (offset). 
   It is deliberately defensive: if upstream gives template-shaped objects,
   we normalize them before calling cardHTML(). */

(function wireSimilarPager(){
  const $simCards = document.getElementById('simCards');
  const $simMeta  = document.getElementById('simMeta');
  const $prevBtn  = document.getElementById('btnSimPrev3');
  const $nextBtn  = document.getElementById('btnSimNext3');

  if (!$simCards || !$simMeta || !$prevBtn || !$nextBtn) return; // not on Step 0 yet

  // Normalize anything in SIM_ROWS to the shape cardHTML() expects.
  function toRow(x){
    // If it already looks like our row shape, return as-is.
    if (x && (x.label || x.useText) && (x.slug || x.id)) return x;

    // If upstream provided { t, sc, why } or a raw template object, adapt it.
    const t = x?.t || x;
    const label = t?.label || t?.slug || t?.id || 'template';
    const useText = Array.isArray(t?.use_cases) && t.use_cases.length ? t.use_cases.join(' • ') : label;
    const definition = t?.definition || t?.help || '';
    const kind = t?.kind || 'framework';
    return {
      id: t?.id, slug: t?.slug, key: t?.key,
      label, definition, useText, kind, ref: t
    };
  }

  function renderWindow(){
    const N = Array.isArray(SIM_ROWS) ? SIM_ROWS.length : 0;

    // Edge case: no data
    if (N === 0){
      $simCards.innerHTML = `<div class="muted">no similar matches</div>`;
      $simMeta.textContent = `showing 0 of 0`;
      $prevBtn.classList.add('hide');
      $nextBtn.classList.add('hide');
      return;
    }

    // Show all if fewer than 4 (hide pagers)
    if (N < 4){
      const allRows = SIM_ROWS.map(toRow);
      $simCards.innerHTML = allRows.map(cardHTML).join('');
      $simMeta.textContent = `showing ${N} of ${N}`;
      $prevBtn.classList.add('hide');
      $nextBtn.classList.add('hide');
      return;
    }

    // N >= 4 → paged window of 3, index wraps on NEXT; prev is gated by history
    const start = simIndex % N;                 // ensure in-range
    const take  = 3;
    const slice = [];
    for (let i = 0; i < take; i++){
      slice.push(SIM_ROWS[(start + i) % N]);
    }

    const rows = slice.map(toRow);
    $simCards.innerHTML = rows.map(cardHTML).join('');
    $simMeta.textContent = `showing ${Math.min(take, N)} of ${N}`;

    // Pager visibility rules:
    // - Next is visible for N>=4 (always)
    // - Prev is visible only after user has advanced at least once (simIndex > 0)
    $nextBtn.classList.remove('hide');
    if (simIndex > 0){
      $prevBtn.classList.remove('hide');
    }else{
      $prevBtn.classList.add('hide');
    }
  }

  // PUBLIC refresh used by Step 0 open/render code after SIM_ROWS updates
  window.__renderSimilarWindow = renderWindow;

  // Click handlers
  $nextBtn.addEventListener('click', ()=>{
    if (!Array.isArray(SIM_ROWS) || SIM_ROWS.length < 4) return;
    simIndex = (simIndex + 3) % SIM_ROWS.length;  // wrap on next
    renderWindow();
  });

  $prevBtn.addEventListener('click', ()=>{
    if (!Array.isArray(SIM_ROWS) || SIM_ROWS.length < 4) return;
    // Only allow prev after at least one next (acceptance criterion)
    if (simIndex <= 0) return;
    simIndex = Math.max(0, simIndex - 3);        // clamp at 0 (no wrap on prev)
    renderWindow();
  });

})();

/* ---------- Config (tweak without touching logic) ------------------------- */
/* ===== Slice 2: Advanced Builder CTA (Step 0 only) ======================== */
/* Injects a low-emphasis "advanced builder" button into the Step 0 actions row,
   aligned right, navigates to prompt-builder.html?slug=<currentTemplateSlug>.
   Idempotent and safe to call every time Step 0 opens. */

(function setupAdvBuilderStylesOnce(){
  // Add a tiny style shim (once) for ghost button + row alignment
  if (document.getElementById('advBuilderStyles')) return;
  const css = `
    .btn.ghost { background: transparent; border: 1px solid #ccc; color: #222; }
    .btn.ghost:hover { border-color: #999; }
    .step0-actions { display:flex; align-items:center; gap:8px; }
    .step0-actions .push-right { margin-left:auto; }
  `.trim();
  const tag = document.createElement('style');
  tag.id = 'advBuilderStyles';
  tag.textContent = css;
  document.head.appendChild(tag);
})();

function slugifyLoose(s){
  return String(s||'').toLowerCase()
    .replace(/&/g,' and ')
    .replace(/[^a-z0-9]+/g,'-')
    .replace(/^-+|-+$/g,'')
    .replace(/-+/g,'-');
}

/** Resolve the best slug for CURRENT */
function resolveTemplateSlug(t){
  if (!t) return '';
  return (t.slug && String(t.slug)) ||
         (t.id && String(t.id)) ||
         slugifyLoose(t.label || '');
}

/** Find the Step 0 actions row that already contains #wizStep0Start */
function findStep0ActionsRow(){
  const startBtn = document.getElementById('wizStep0Start');
  if (!startBtn) return null;

  // Preferred: a container with class .step0-actions (your stated structure)
  let row = startBtn.closest('.step0-actions');
  if (row) return row;

  // Fallbacks: common wrappers you use, else parentNode
  row = startBtn.closest('.actions')
     || startBtn.closest('.btn-row')
     || startBtn.parentElement;
  if (!row) return null;

  // Tag it so our CSS can apply cleanly
  row.classList.add('step0-actions');
  return row;
}

/** Create or update the Advanced Builder button and place it on the right */
function ensureAdvBuilderCTA(currentTemplate){
  const row = findStep0ActionsRow();
  if (!row) return;

  // Ensure a right-push spacer exists so the CTA sits on the far right
  let spacer = row.querySelector('.push-right');
  if (!spacer){
    spacer = document.createElement('div');
    spacer.className = 'push-right';
    row.appendChild(spacer);
  }

  // Create the button if missing
  let btn = document.getElementById('wizAdvBuilder');
  if (!btn){
    btn = document.createElement('button');
    btn.id = 'wizAdvBuilder';
    btn.type = 'button';
    btn.className = 'btn sm ghost';
    btn.textContent = 'advanced builder';
    btn.title = 'Open the advanced editor with this template preloaded';
    btn.setAttribute('aria-label', 'Open the advanced editor with this template preloaded');
    row.appendChild(btn);
  }

  // Update navigation target for the current template and (re)bind click
  const slug = resolveTemplateSlug(currentTemplate);
  const url  = slug ? `prompt-builder.html?slug=${encodeURIComponent(slug)}` : 'prompt-builder.html';
  btn.onclick = () => { window.location.href = url; };

  // Visual safety: keep Start guided setup looking primary via classes it already has
  // (We do not alter #wizStep0Start; we only add a ghost-styled secondary CTA.)
}


// --- PBAIHandoff reader shim (wizard-side) ---
// This lets the wizard read the handoff even if the helper was only defined on index.html.
(function ensurePBAIHandoffShim(){
  if (window.PBAIHandoff && typeof window.PBAIHandoff.load === 'function') return;
  const KEY = 'pb_ai_handoff_v1';
  window.PBAIHandoff = {
    load: () => {
      try { return JSON.parse(localStorage.getItem(KEY) || 'null'); }
      catch { return null; }
    },
    clear: () => { try { localStorage.removeItem(KEY); } catch{} },
    getCandidates: () => {
      const h = (function(){ try{ return JSON.parse(localStorage.getItem(KEY)||'null'); }catch{ return null; }})();
      return (h && Array.isArray(h.items)) ? h.items : [];
    },
    getPicked: () => {
      const h = (function(){ try{ return JSON.parse(localStorage.getItem(KEY)||'null'); }catch{ return null; }})();
      return (h && h.pickedSlug) ? h.pickedSlug : null;
    }
  };
})();


/* ===== Slice 3: AI Picks strip (conditionally above Similar Matches) ====== */
/* Reads AI suggestions from:
   1) window.PBAIHandoff (localStorage-backed), or
   2) sessionStorage['pb.ai.suggestions'] (legacy),
   validates freshness, and renders an AI-picked strip above #step0Similar
   ONLY on Step 0 and ONLY when suggestions are relevant to the current template.
*/

(function setupAIPicksStylesOnce(){
  if (document.getElementById('aiPicksStyles')) return;
  const css = `
    #step0AIPicks { position:relative; margin-top:20px; }
    #step0AIPicks .block-title { display:flex; align-items:center; justify-content:space-between; }
    #step0AIPicks .block-controls { display:flex; align-items:center; justify-content:space-between; gap:10px; margin-top:6px; }
    #step0AIPicks .wiz-cards { margin-top:8px; gap:12px; }
    #btnAIClear { background:transparent; border:1px solid transparent; border-radius:8px; width:28px; height:28px; line-height:1; font-size:18px; cursor:pointer; }
    #btnAIClear:hover { background:var(--chip, #f3f6fa); border-color:var(--border, #e3e9f2); }
    .hide { display:none !important; }
  `.trim();
  const tag = document.createElement('style');
  tag.id = 'aiPicksStyles';
  tag.textContent = css;
  document.head.appendChild(tag);
})();

const AIP_CFG = { ttlMin: 30 }; // default freshness window for sessionStorage payloads

function __ai_norm(s){
  return String(s||'')
    .trim().toLowerCase()
    .replace(/[\s_]+/g,'-')
    .replace(/[^a-z0-9-]/g,'');
}
function __ai_nowSlug(){
  try{ return new URLSearchParams(location.search).get('slug') || ''; }
  catch(_){ return ''; }
}
function __ai_isFresh(ts, maxMin){
  if (!ts) return true;
  const age = Date.now() - Number(ts||0);
  return age < (Number(maxMin||AIP_CFG.ttlMin) * 60 * 1000);
}

/* Read candidates from PBAIHandoff (preferred) */
function __ai_fromHandoff(){
  const api = window.PBAIHandoff || {};
  const obj = api.load ? api.load() : null;
  const items = (obj && Array.isArray(obj.items)) ? obj.items : [];
  const picked = (api.getPicked ? api.getPicked() : (obj && obj.pickedSlug)) || null;
  const slugNow = __ai_norm(__ai_nowSlug());
  // relevant if current slug or picked matches any candidate
  let relevant = false;
  if (items.length){
    const set = new Set(items.map(it => __ai_norm(it.slug||'')));
    if (set.has(slugNow) || (picked && set.has(__ai_norm(picked)))) relevant = true;
  }
  // optional staleness (e.g., 120 minutes)
  const staleIgnore = obj && obj.ts && ((Date.now() - Number(obj.ts)) > (120*60*1000));
  return {
    ok: !!(items.length && relevant && !staleIgnore),
    items,
    clear: ()=>{ api.clear && api.clear(); },
    meta: { query: obj&&obj.query, provider: obj&&obj.provider, model: obj&&obj.model, ts: obj&&obj.ts }
  };
}

/* Read candidates from sessionStorage fallback */
function __ai_fromSession(){
  try{
    const raw = sessionStorage.getItem('pb.ai.suggestions');
    if (!raw) return { ok:false, items:[], clear:()=>{} };
    const obj = JSON.parse(raw);
    const items = Array.isArray(obj.suggestions) ? obj.suggestions : [];
    const fresh = __ai_isFresh(obj.ts, obj.ttlMin || AIP_CFG.ttlMin);
    return {
      ok: !!(items.length && fresh),
      items: items.map(it => ({
        slug: it.slug, label: it.label, use: it.use || it.label, def: it.def || '', confidence: it.score || it.confidence
      })),
      clear: ()=>{ try{ sessionStorage.removeItem('pb.ai.suggestions'); }catch(_){ } },
      meta: { query: obj.query, ts: obj.ts }
    };
  }catch(_){
    return { ok:false, items:[], clear:()=>{} };
  }
}

/* Map input items to real templates and to our card row shape */
function __ai_buildRows(items){
  const T = allTemplates(); // provided by your code
  const bySlug = new Map(T.map(t => [__ai_norm(t.slug || t.id || t.label), t]));
  const rows = [];
  for (const it of items){
    const slugKey = __ai_norm(it.slug||'');
    const t = bySlug.get(slugKey);
    if (!t) continue; // ignore unknown
    const useText = it.use || (Array.isArray(t.use_cases)&&t.use_cases[0]) || (t.label||t.slug||t.id||'');
    rows.push({
      id: t.id, slug: t.slug, key: t.key,
      label: it.label || t.label || t.slug || t.id || 'template',
      definition: it.def || t.definition || t.help || '',
      useText,
      kind: (t.kind || 'framework'),
      ref: t
    });
  }
  return rows;
}

/* Ensure the block exists (or remove it) and return the DOM refs */
function __ai_ensureBlock(exists){
  const host = document.getElementById('step0Similar');
  let blk = document.getElementById('step0AIPicks');

  if (!exists){
    if (blk){ blk.remove(); }
    return null;
  }

  // Create and insert above #step0Similar on first use
  if (!blk){
    blk = document.createElement('div');
    blk.id = 'step0AIPicks';
    blk.className = 'block';
    blk.innerHTML = `
      <div class="block-title">
        <h3 class="subhead" style="margin:0">AI-picked for you</h3>
        <button id="btnAIClear" class="icon-btn" title="Hide AI suggestions" aria-label="Hide AI suggestions">×</button>
      </div>
      <div class="block-controls">
        <div class="left">
          <button id="btnAIPrev3" class="btn sm" title="show previous 3" aria-label="show previous 3">previous 3</button>
        </div>
        <div class="right" style="display:flex; align-items:center; gap:10px">
          <span id="aiMeta" class="muted">showing 0 of 0</span>
          <button id="btnAINext3" class="btn sm" title="show next 3" aria-label="show next 3">next 3</button>
        </div>
      </div>
      <div id="aiCards" class="wiz-cards"></div>
    `;
    if (host && host.parentElement){
      host.parentElement.insertBefore(blk, host);
    }
  }
  return {
    root: blk,
    cards: blk.querySelector('#aiCards'),
    meta: blk.querySelector('#aiMeta'),
    prev: blk.querySelector('#btnAIPrev3'),
    next: blk.querySelector('#btnAINext3'),
    clear: blk.querySelector('#btnAIClear')
  };
}

let __ai_rows = [];   // mapped card rows
let __ai_index = 0;   // window start for AI picks
let __ai_clearFn = null;

/* Render the AI picks window of up to 3, with optional prev/next */
function __ai_renderWindow(dom){
  const N = (__ai_rows && __ai_rows.length) ? __ai_rows.length : 0;

  if (!N){
    if (dom && dom.root) dom.root.remove();
    return;
  }

  // Show all if fewer than 6 (hide pagers)
  if (N < 6){
    dom.cards.innerHTML = __ai_rows.map(cardHTML).join('');
    dom.meta.textContent = `showing ${N} of ${N}`;
    dom.prev.classList.add('hide');
    dom.next.classList.add('hide');
    return;
  }

  // N >= 6 → windowed view of 5
  const start = __ai_index % N;
  const take = 5;
  const slice = [];
  for (let i=0;i<take;i++) slice.push(__ai_rows[(start+i) % N]);

  dom.cards.innerHTML = slice.map(cardHTML).join('');
  dom.meta.textContent = `showing ${Math.min(take, N)} of ${N}`;

  // Prev appears only after at least one next (match Similar Matches parity)
  dom.next.classList.remove('hide');
  if (__ai_index > 0) dom.prev.classList.remove('hide'); else dom.prev.classList.add('hide');
}

/* Public entry: called when Step 0 opens (with current template) */
function renderAIPicksForStep0(currentTemplate){
  // 1) prefer PBAIHandoff
  let src = __ai_fromHandoff();
  // 2) fallback to sessionStorage if handoff not relevant
  if (!src.ok){
    const ss = __ai_fromSession();
    if (ss.ok){ src = ss; }
  }

  // If neither source is valid, remove any existing block and bail
  const validItems = (src.ok && Array.isArray(src.items) && src.items.length) ? src.items : null;
  const domMaybe = __ai_ensureBlock(!!validItems);
  if (!validItems){ return; }

  // Map to rows that exist in our library
  __ai_rows = __ai_buildRows(validItems);
  if (!__ai_rows.length){
    // no known slugs → remove block and bail
    if (domMaybe && domMaybe.root) domMaybe.root.remove();
    return;
  }

  __ai_index = 0;
  __ai_clearFn = src.clear || null;

  const dom = __ai_ensureBlock(true);
  if (!dom) return;

  // Bind controls once (idempotent)
  if (!dom.root.__wired){
  dom.next.addEventListener('click', ()=>{
  if (__ai_rows.length < 6) return;
  __ai_index = (__ai_index + 5) % __ai_rows.length;
  __ai_renderWindow(dom);
});
dom.prev.addEventListener('click', ()=>{
  if (__ai_rows.length < 6) return;
  if (__ai_index <= 0) return; // no wrap on prev
  __ai_index = Math.max(0, __ai_index - 5);
  __ai_renderWindow(dom);
});
    dom.clear.addEventListener('click', ()=>{
      try{ __ai_clearFn && __ai_clearFn(); }catch(_){}
      dom.root.remove();
    });
    dom.root.__wired = true;
  }

  // Paint
  __ai_renderWindow(dom);
}

const SIM_CONFIG = {
  MIN_POOL: 3,                 // minimum pool size before falling back
  REQUIRE_TOP_FAMILY: true,    // require same top family unless topic “escape” hits hardThreshold
  ALLOW_TOPIC_ESCAPE: true,    // allow strong topic match to cross domains
  SCORE_THRESHOLDS: {          // escape gates
    hard: 2600,                // allow cross-domain if candidate score >= hard
    soft: 1500                 // nudge for in-domain-but-weak matches
  },
  SHOW_SIM_EXPLAIN: false,     // flip to true to attach reason strings for your UI
  MAX_CARDS: 3                 // how many to render at once
};

/* ---------- Utils --------------------------------------------------------- */
const normStr = (s)=> String(s||'').toLowerCase().trim();
const arrStr  = (x)=> Array.isArray(x) ? x.flatMap(v => v==null?[]:[String(v)]) : (typeof x==='string'? [x] : []);
const uniq    = (arr)=> Array.from(new Set(arr.filter(Boolean)));
const tok     = (s)=> String(s||'').toLowerCase().normalize('NFKD')
                  .replace(/[\u0300-\u036f]/g,'') // strip diacritics
                  .split(/[^a-z0-9]+/).filter(Boolean);
const kebab   = (s)=> String(s||'').toLowerCase()
                  .replace(/[_\s]+/g,'-').replace(/[^a-z0-9\.\-]/g,'')
                  .replace(/^-+|-+$/g,'').replace(/-+/g,'-');
function slugify(s){
  return String(s||'').toLowerCase()
    .replace(/&/g,' and ')
    .replace(/[^a-z0-9]+/g,'-')
    .replace(/^-+|-+$/g,'')
    .replace(/-+/g,'-');
}
function overlapCount(A,B){ if(!A.length||!B.length) return 0; const s=new Set(B); let n=0; for(const a of A){ if(s.has(a)) n++; } return n; }
function tokenOverlap(A,B){ if(!A.length||!B.length) return 0; const s=new Set(B); let n=0; for(const a of A){ if(s.has(a)) n++; } return n; }
function topFamilies(fams){ return uniq(fams.map(f=>f.split('.')[0])); }

/* ---------- Category canon (manual families + dynamic discovery) ---------- */
/* We merge a curated inclusive canon with auto-discovered categories appearing
   in both your template libraries (TEMPLATES & TASK_TEMPLATES). */
(function buildCategoryCanon(root){
  const MANUAL_CANON = {
    // Health
    'health': ['health','medical','medicine','med','healthcare','health-care','health care','clinical','clinic','wellness','well-being','wellbeing'],
    'health.public': ['public-health','public health','population-health','population health','epidemiology','epi'],
    'health.mental': ['mental-health','mental health','behavioral-health','behavioural-health','psych','psychology','psychiatry','therapy','counseling','counselling'],

    // Career
    'career': ['career','job','jobs','employment','hiring','recruiting','recruitment','job-search','job search'],
    'career.resume': ['resume','cv','curriculum-vitae','cover-letter','cover letter','portfolio'],
    'career.interview': ['interview','interviews','interviewing'],
    'career.networking': ['networking','outreach','cold outreach','cold-outreach','follow-up','follow up','warm intro','warm-intro'],

    // Planning & Strategy
    'planning': ['planning','roadmap','prioritization','prioritisation','backlog','capacity','forecast','timeline','scheduling','time-planning','time planning'],
    'strategy': ['strategy','strategic','vision','goals','north-star','okrs','v2mom','theory-of-change','backcasting'],

    // Design / Research / Accessibility
    'design': ['design','product-design','ui','ux-ui'],
    'design.ux': ['ux','user-experience','ux-design','experience-design'],
    'design.accessibility': ['accessibility','a11y','inclusive-design','inclusive design','universal-design','universal design'],
    'research': ['research','evaluation','analysis','benchmarking','testing','study'],
    'research.ux': ['ux-research','user-research','research-ux','usability','usability-test','usability testing'],

    // Communication & Writing
    'communication': ['communication','comms','presentations','slides','docs','documentation','announcement','press','press-release','press release','brief','one-pager','one pager'],
    'communication.email': ['email','emails','mail'],
    'writing': ['writing','copywriting','content','blog','article','narrative','story','storytelling'],
    'writing.press': ['press','press-release','press release','news','newsroom'],

    // Ops, Governance, Safety, Ethics
    'operations': ['operations','ops','process','workflow','sops','runbook','governance','policy','policies','compliance','playbook','oncall','incident','postmortem','premortem','pre-mortem'],
    'safety': ['safety','risk','risk-management','incident-response','integrity'],
    'ethics': ['ethics','equity','dei','inclusion','responsible','fairness','bias','privacy','data-ethics','ai-ethics'],

    // Community / Civic
    'community': ['community','civic','public-participation','public participation','stakeholders','engagement','governance-community'],

    // Product & AI
    'product': ['product','product-management','product mgmt','prd','requirements','release','mvp','mlp','epic','epics','user-story','user stories','story','stories'],
    'ai': ['ai','ml','machine-learning','large-language-models','llm','genai','gen-ai'],
    'ai.prompting': ['prompt','prompts','prompting','prompt-engineering','prompt design','prompt-design','prompt-architect'],

    // Meta / Personal admin / Notes
    'notes': ['notes','journal','journaling','meeting-notes','minutes','log','tracker'],
    'personal-admin': ['personal-admin','personal admin','admin','life-admin','life admin'],

    // Education / Productivity
    'education': ['education','teach','learning','learn','workshop','lesson','curriculum','course'],
    'productivity': ['productivity','time-management','habits','routines'],

    // Inclusion-oriented topics (help cross-link future content)
    'accessibility': ['access','accessibility','a11y','assistive-tech','assistive tech'],
    'language': ['language','localization','l10n','internationalization','i18n','translation','multilingual','bilingual']
  };

  // Generic families get a mild penalty for off-domain suggestions
  var GENERIC_TOP_FAMS = new Set(['planning','notes','communication','operations','strategy','productivity','design','community','language']);
  // Expose so scoring can see it
  window.GENERIC_TOP_FAMS = GENERIC_TOP_FAMS;

  // Build alias map from manual canon
  const map = new Map();
  function addAliases(canon, list){
    const C = kebab(canon);
    const all = [canon, ...list];
    for (const raw of all){
      const v = kebab(raw);
      if (!v) continue;
      map.set(v, C);
      map.set(v.replace(/-/g,' '), C); // tolerate spaces
      if (v.endsWith('s')) map.set(v.slice(0,-1), C);
      if (!v.endsWith('s')) map.set(v+'s', C);
    }
    map.set(C, C);
  }
  for (const k of Object.keys(MANUAL_CANON)) addAliases(k, MANUAL_CANON[k]);

  // Dynamic discovery from libraries (future-proof)
  const sources = [
    ...(Array.isArray(root.TEMPLATES) ? root.TEMPLATES : []),
    ...(Array.isArray(root.FRAMEWORKS) ? root.FRAMEWORKS : []),
    ...(Array.isArray(root.TASK_TEMPLATES) ? root.TASK_TEMPLATES : []),
    ...(Array.isArray(root.TASKS) ? root.TASKS : [])
  ];
  const discovered = new Set();
  for (const t of sources){
    for (const c of (t?.categories || [])) discovered.add(kebab(c));
  }
  // Light heuristics to fold common free categories into inclusive families
  const heuristics = [
    { test:/^ux$/, canon:'design.ux' },
    { test:/^user-?research$/, canon:'research.ux' },
    { test:/^usability(-test|testing)?$/, canon:'research.ux' },
    { test:/^public-?health$/, canon:'health.public' },
    { test:/^mental-?health$/, canon:'health.mental' },
    { test:/^email(s)?$/, canon:'communication.email' },
    { test:/^(resume|cv|cover-?letter)$/, canon:'career.resume' },
    { test:/^jobs?$/, canon:'career' },
    { test:/^personal-?admin$/, canon:'personal-admin' },
    { test:/^a11y|^access(ibility)?$/, canon:'design.accessibility' },
    { test:/^(i18n|l10n|localization|internationalization)$/, canon:'language' }
  ];
  for (const c of discovered){
    if (map.has(c)) continue;
    let mapped = null;
    for (const rule of heuristics){ if (rule.test.test(c)){ mapped = rule.canon; break; } }
    map.set(c, mapped ? mapped : c); // identity if unknown
  }

  // Export
  window.CAT_ALIASES = map;
})(typeof window !== 'undefined' ? window : globalThis);

/* Heuristic canonicalization that remains domain-agnostic. */
function canonicalCategory(cat){
  const s = slugify(cat);
  if (window.CAT_ALIASES && window.CAT_ALIASES.has(s)) return window.CAT_ALIASES.get(s);
  if (s.includes('research')) return 'research';
  if (s.includes('education') || s.includes('teach') || s.includes('learn')) return 'education';
  if (s.includes('plan') || s.includes('roadmap')) return 'planning';
  return s;
}

/* Expand a canonical key into family chain: "alpha.beta" → ["alpha.beta","alpha"] */
function expandFamily(key){
  const parts = key.split('.');
  const keys = [key];
  if (parts.length > 1) keys.push(parts[0]); // parent
  return uniq(keys);
}
function familiesFromCategories(cats){
  const fams = [];
  for (const c of arrStr(cats)){
    const canon = canonicalCategory(c);
    fams.push(...expandFamily(canon));
  }
  return uniq(fams);
}

/* ---------- Tag parsing (typed prefixes, inclusive) ----------------------- */
/* Normalizes:
   - stage → phase
   - supports audience, persona, language, region, ethics, safety, access, inclusion
   - accepts "key: value" and single bare tags
*/
function parseTag(tag){
  const s = normStr(tag);
  const m = s.match(/^([a-z\.\-_]+)\s*:\s*(.+)$/); // "use:planning"
  if (!m) return {type:'other', value:s};
  let type = m[1];
  let value = m[2].trim();
  if (type === 'stage') type = 'phase';
  if (type === 'aud') type = 'audience';
  if (type === 'lvl') type = 'level';
  if (type === 'lang') type = 'language';
  if (type === 'loc') type = 'region';
  if (type === 'a11y' || type === 'access') type = 'accessibility';
  return {type, value};
}

/* ---------- Facet extraction (inclusive, future-proof) -------------------- */
function extractFacets(t){
  const families = familiesFromCategories(t?.categories || []);

  const tags = arrStr(t?.tags || []).map(parseTag);
  const topics   = uniq(tags.filter(x=>x.type==='topic').map(x=>x.value));
  const useTags  = uniq(tags.filter(x=>x.type==='use').map(x=>x.value));
  const phases   = uniq(tags.filter(x=>x.type==='phase').map(x=>x.value));
  const levels   = uniq(tags.filter(x=>x.type==='level').map(x=>x.value));
  const types    = uniq(tags.filter(x=>x.type==='type').map(x=>x.value));
  const audience = uniq(tags.filter(x=>x.type==='audience' || x.type==='persona').map(x=>x.value));
  const persona  = uniq(tags.filter(x=>x.type==='persona').map(x=>x.value));
  const ethics   = uniq(tags.filter(x=>x.type==='ethics' || x.type==='equity' || x.type==='dei' || x.type==='bias').map(x=>x.value));
  const safety   = uniq(tags.filter(x=>x.type==='safety' || x.type==='risk').map(x=>x.value));
  const access   = uniq(tags.filter(x=>x.type==='accessibility').map(x=>x.value));
  const language = uniq(tags.filter(x=>x.type==='language').map(x=>x.value));
  const region   = uniq(tags.filter(x=>x.type==='region' || x.type==='locale').map(x=>x.value));

  const otherTags = uniq(tags.filter(x=>!['use','topic','phase','level','type','audience','persona','ethics','safety','accessibility','language','region'].includes(x.type)).map(x=>x.value));

  const usesInput = arrStr(t?.use_cases || []);
  const uses = usesInput.length ? usesInput.map(normStr) : [];

  const label = normStr(t?.label || t?.slug || t?.id);
  const def   = normStr(t?.definition || t?.help || '');
  const kind  = normStr(t?.kind || '');

  // tokens intentionally weighted toward “what it does” content
  const textTokens = uniq(tok([label, def, ...uses, ...topics, ...useTags].join(' ')));

  // Build an intent signature to help with alignment
  const sig = {
    hasHealth: families.some(f => f.startsWith('health')),
    hasDesign: families.some(f => f.startsWith('design')),
    hasResearch: families.some(f => f.startsWith('research')),
    hasCareer: families.some(f => f.startsWith('career')),
    hasCommunity: families.some(f => f.startsWith('community')),
    hasAI: families.some(f => f.startsWith('ai')),
  };

  return {
    families, topics, useTags, phases, levels, types,
    audience, persona, ethics, safety, access, language, region,
    otherTags, uses, kind, textTokens, sig
  };
}

/* ---------- Index templates once for speed & determinism ------------------ */
const __FACET_CACHE = new WeakMap();
function getFacets(t){
  let f = __FACET_CACHE.get(t);
  if (!f){ f = extractFacets(t); __FACET_CACHE.set(t, f); }
  return f;
}

/* ---------- Scoring (alignment-aware, inclusive) -------------------------- */
function similarScore(base, cand){
  // Skip self
  const bslug = normStr(base.slug || base.id || base.label);
  const cslug = normStr(cand.slug || cand.id || cand.label);
  if (bslug && cslug && bslug === cslug) return {score:-1, why:'self'};

  const BF = getFacets(base);
  const CF = getFacets(cand);

  const reasons = [];
  let s = 0;

  // Category family overlap
  const bDeep = BF.families.filter(f=>f.includes('.'));
  const cDeep = CF.families.filter(f=>f.includes('.'));
  const deepMatch = overlapCount(bDeep, cDeep);

  const bTop = topFamilies(BF.families);
  const cTop = topFamilies(CF.families);
  const topMatch = overlapCount(bTop, cTop);

  if (deepMatch) { s += deepMatch * 5200; reasons.push(`deep-family x${deepMatch}`); }
  if (topMatch)  { s += (topMatch - deepMatch) * 2800; if (topMatch - deepMatch>0) reasons.push(`top-family x${topMatch - deepMatch}`); }

  // Typed tags
  const topicO = overlapCount(BF.topics,  CF.topics);
  const useO   = overlapCount(BF.useTags, CF.useTags);
  const otherO = overlapCount(BF.otherTags, CF.otherTags);

  if (topicO){ s += topicO * 1000; reasons.push(`topics +${topicO*1000}`); }
  if (useO){   s += useO   * 550;  reasons.push(`use +${useO*550}`); }
  if (otherO){ s += otherO * 140;  reasons.push(`other +${otherO*140}`); }

  // Phase, level, type, kind alignment
  const phaseO = overlapCount(BF.phases, CF.phases);
  if (phaseO){ s += phaseO * 30; reasons.push(`phase +${phaseO*30}`); }
  if (BF.kind && CF.kind && BF.kind === CF.kind){ s += 60; reasons.push('kind +60'); }

  const levelO = overlapCount(BF.levels, CF.levels);
  if (levelO){ s += levelO * 45; reasons.push(`level +${levelO*45}`); }

  const audO = overlapCount(BF.audience, CF.audience) + overlapCount(BF.persona, CF.persona);
  if (audO){ s += audO * 160; reasons.push(`audience/persona +${audO*160}`); }

  const accessO = overlapCount(BF.access, CF.access);
  if (accessO){ s += accessO * 120; reasons.push(`access +${accessO*120}`); }

  const ethicsO = overlapCount(BF.ethics, CF.ethics) + overlapCount(BF.safety, CF.safety);
  if (ethicsO){ s += ethicsO * 120; reasons.push(`ethics/safety +${ethicsO*120}`); }

  const langO = overlapCount(BF.language, CF.language) + overlapCount(BF.region, CF.region);
  if (langO){ s += langO * 80; reasons.push(`language/region +${langO*80}`); }

  // Text fallback — tiny but inclusive
  const baseTokens = uniq(tok([...BF.topics, ...BF.useTags, ...BF.otherTags, ...BF.uses].join(' ')));
  const tokenO = tokenOverlap(baseTokens, CF.textTokens);
  if (tokenO){ s += tokenO * 3; reasons.push(`tokens +${tokenO*3}`); }

  // Distance penalties (push off-domain down)
  const sharesTop = topMatch > 0;
  if (!sharesTop) {
    s -= 3500; reasons.push('off-domain -3500');
  }

  // Mild penalty for generic families when base isn’t generic
  const baseTop = bTop[0] || '';
  const candTopSet = new Set(cTop);
  const candIsGeneric = cTop.some(f=>window.GENERIC_TOP_FAMS.has(f));
  const baseIsGeneric = window.GENERIC_TOP_FAMS.has(baseTop);
  if (!baseIsGeneric && candIsGeneric && !candTopSet.has(baseTop)){
    s -= 600; reasons.push('generic-mismatch -600');
  }

  // Inclusive domain alignment nudges:
  // If base is health-any, boost other health.*; penalize unrelated unless strong topical bridge.
  if (BF.sig.hasHealth && !CF.sig.hasHealth){
    s -= 800; reasons.push('health-domain guard -800');
  }
  if (BF.sig.hasDesign && CF.sig.hasResearch) { s += 120; reasons.push('design↔research +120'); }
  if (BF.sig.hasAI && CF.sig.hasEthics) { s += 120; reasons.push('ai↔ethics +120'); }

  return {score: s, why: reasons.join(' | ')};
}

/* Dominant anchor for gating (kept simple, deterministic) */
function dominantFamily(fams){
  const deep = fams.find(f=>f.includes('.'));
  if (deep) return deep.split('.')[0];
  const top = fams.find(f=>!f.includes('.'));
  return top || '';
}

/* ---------- Pool selection with strict gating + topic escape -------------- */
const MIN3 = SIM_CONFIG.MIN_POOL;

function buildSimilarRows(base){
  const T = allTemplates();
  const BF = getFacets(base);

  const scored = [];
  for (const t of T){
    const {score, why} = similarScore(base, t);
    if (score <= 0) continue;
    scored.push({ t, sc: score, why });
  }

  // Global ranking
  scored.sort((a,b)=>{
    if (b.sc !== a.sc) return b.sc - a.sc;
    const an = normStr(a.t.label||a.t.slug||a.t.id);
    const bn = normStr(b.t.label||b.t.slug||b.t.id);
    return an.localeCompare(bn);
  });

  // Pools
  const bDeep = new Set(BF.families.filter(f=>f.includes('.')));
  const bTop  = new Set(topFamilies(BF.families));
  const bTopic= new Set(BF.topics);

  const deepPool = scored.filter(({t})=>{
    const cf = getFacets(t);
    return cf.families.some(f=>bDeep.has(f));
  });

  const topPool = scored.filter(({t})=>{
    const cf = getFacets(t);
    return topFamilies(cf.families).some(f=>bTop.has(f));
  });

  const topicPool = scored.filter(({t,sc})=>{
    const cf = getFacets(t);
    const topicHit = cf.topics.some(v=>bTopic.has(v));
    // Only allow “topic escape” if strong enough score
    if (!SIM_CONFIG.ALLOW_TOPIC_ESCAPE) return false;
    if (!topicHit) return false;
    return sc >= SIM_CONFIG.SCORE_THRESHOLDS.hard;
  });

  // Primary gating
  let pool = null;
  if (deepPool.length >= MIN3) pool = deepPool;
  else if (topPool.length >= MIN3) pool = topPool;
  else if (topicPool.length >= MIN3) pool = topicPool;
  else {
    // Last resort: keep in-domain candidates unless we have very strong out-of-domain bridges
    if (SIM_CONFIG.REQUIRE_TOP_FAMILY){
      const inDomain = scored.filter(({t,sc})=>{
        const cf = getFacets(t);
        const shareTop = topFamilies(cf.families).some(f=>bTop.has(f));
        if (shareTop) return true;
        // allow really strong bridges
        return sc >= SIM_CONFIG.SCORE_THRESHOLDS.hard && cf.topics.some(v=>bTopic.has(v));
      });
      pool = inDomain.length ? inDomain : scored;
    } else {
      pool = scored;
    }
  }

  // Map to card rows (with optional explain)
  return pool.map(({t, sc, why})=>{
    const useText = Array.isArray(t.use_cases) && t.use_cases.length ? arrStr(t.use_cases).join(' • ')
                  : (t.label||t.slug||t.id||'');
    const row = {
      id: t.id, slug: t.slug, key: t.key,
      label: (t.label||t.slug||t.id||'template'),
      definition: (t.definition||t.help||''),
      useText,
      kind: (t.kind||'framework'),
      ref: t
    };
    if (SIM_CONFIG.SHOW_SIM_EXPLAIN) row._simWhy = why;
    row._simScore = sc;
    return row;
  });
}






  // ===== Step 0 =====
  let CURRENT = null;
  function renderStep0Meta(t){
    el('wizStep0Title').textContent = String(t.label||t.slug||t.id||'template');
    const def = String(t.definition||t.help||'').trim();
el('wizStep0Def').textContent = def;

// fields count as before
const fields = Array.isArray(t.fields) ? t.fields.length : 0;

// LIMIT: show only the first 10 use-cases
const uses = Array.isArray(t.use_cases) ? t.use_cases.slice(0, 10) : [];

// REMOVE total use-cases count line from stats
el('wizStep0Stats').innerHTML =
  `<li><strong>${fields}</strong> fields</li>
   <li><strong>${estimateTimeByFields(fields)}</strong> to complete</li>`;

// Render only the (up to) 10 use-cases
el('wizStep0Uses').innerHTML = uses.length
  ? uses.map(u=>`<li>${u}</li>`).join('')
  : `<li class="muted">no use-cases listed</li>`;

  }

function openStep0(t){
  CURRENT = t;
  renderStep0Meta(t);
  showView('step0');
  
    // NEW — Slice 3: conditionally render AI Picks strip above Similar Matches
  renderAIPicksForStep0(t);
  
    // NEW — Slice 2: ensure Advanced Builder CTA is present and points to this template
  ensureAdvBuilderCTA(t);

  if (typeof window.__setURLForTemplate==='function')
    window.__setURLForTemplate(t);
  el('wizTopProgress').classList.add('hide');

  // Build SIM_ROWS for Step 0 Similar Matches and render via unified pager
  SIM_ROWS = buildSimilarRows(t);
  simIndex = 0;
  if (typeof window.__renderSimilarWindow === 'function') {
    window.__renderSimilarWindow();
  }
}

// Augment openStep0 so Similar Matches always render through the new pager.
(function patchOpenStep0(){
  if (typeof window.openStep0 !== 'function') return;
  const __orig = window.openStep0;
  window.openStep0 = function patchedOpenStep0(tpl){
    // Call the original open
    const r = __orig.apply(this, arguments);

    // If upstream recomputed SIM_ROWS, great; otherwise compute here as a fallback.
    try{
      if (!Array.isArray(SIM_ROWS) || SIM_ROWS.length === 0){
        if (typeof buildSimilarRows === 'function'){
          SIM_ROWS = buildSimilarRows(tpl) || [];
        }
      }
      // Reset window and render
      simIndex = 0;
      if (typeof window.__renderSimilarWindow === 'function'){
        window.__renderSimilarWindow();
      }
    }catch(_err){
      // fail safe: leave whatever upstream rendered
    }
    return r;
  };
})();



// Expand long definitions: reveal full text, hide short + button
document.addEventListener('click', (ev)=>{
  const more = ev.target.closest('.js-more'); if (!more) return;
  const id = more.getAttribute('data-target'); const def = document.getElementById(id);
  if (!def) return;
  const short = def.querySelector('.short');
  const full  = def.querySelector('.full');
  if (full){ if (short) short.hidden = true; full.hidden = false; }
  more.remove();
}, true);

// ---- Field state tracking (touched & values) ----
const TOUCH = new Set();           // field ids user interacted with
const VALUES = new Map();          // field id -> current value text

/* Slice 1.5: Common Context persistence (across templates & sessions) */
const CC_LS_KEY = 'pb.wizard.commonCtx.v1';
const CC_IDS = ['ctx_use','ctx_aud','ctx_style','ctx_tone'];

function ccLoad(){
  try { return JSON.parse(localStorage.getItem(CC_LS_KEY) || '{}'); }
  catch(_){ return {}; }
}
function ccSave(obj){
  try { localStorage.setItem(CC_LS_KEY, JSON.stringify(obj || {})); }
  catch(_){ /* ignore */ }
}
/** Seed VALUES from localStorage so hydration fills the inputs before first render */
function ccSeedVALUESFromStorage(){
  const data = ccLoad();
  CC_IDS.forEach(id => {
    const v = (data[id] ?? '');
    // Always set; allows “clear” to persist as empty string
    VALUES.set(id, String(v));
  });
}
/** Persist the 4 Common Context fields from current wizard values */
function ccPersistFromVALUES(){
  const obj = {};
  CC_IDS.forEach(id => {
    const v = wiz_getVal(id);           // uses VALUES → survives unmounted steps
    obj[id] = String(v || '');          // store empty string if cleared
  });
  ccSave(obj);
}
/* Seed immediately so first paint hydrates from storage */
ccSeedVALUESFromStorage();

function computeFieldId(f){
  const base = (f.id||f.key||f.slug||f.label||('x_'+Math.random().toString(36).slice(2))).toString();
  return 'fld_'+base.toLowerCase().replace(/[^a-z0-9]+/g,'_');
}
function isTextAreaOrRepeater(f){
  const t = String(f.type||'').toLowerCase();
  return /textarea|repeater/.test(t);
}
function fieldFilled(fid){
  const el = document.getElementById(fid);
  if (!el){
    const v = (VALUES.get(fid)||'').trim();
    return v.length > 0;
  }
  if (el.tagName === 'SELECT' && el.multiple){
    return [...el.selectedOptions].length > 0 || ((VALUES.get(fid)||'').trim().length>0);
  }
  const v = (el.value||'').trim();
  return v.length > 0;
}

// Read a field by id; prefer the VALUES map (survives step unmounts)
function wiz_getVal(id){
  const v = (VALUES.get(id) ?? '').toString().trim();
  if (v) return v;
  const el = document.getElementById(id);
  return ((el && el.value) ? String(el.value).trim() : '');
}
function encouragement(p){
  if (p>=100) return 'ready to ship';
  if (p>=90)  return 'final polish';
  if (p>=75)  return 'home stretch';
  if (p>=50)  return 'over halfway';
  if (p>=25)  return 'nice pace';
  if (p>0)    return 'good start';
  return 'let’s get rolling';
}

// collect remaining work for time estimate (template-only steps)
function remainingFieldCount(){
  if (!Array.isArray(STEPS)||!STEPS.length) return 0;
  let total = 0;
  for (const g of STEPS){
    if (g.special) continue; // skip overview/extra/output from ETA
    for (const fid of (g.fids||[])) total += fieldFilled(fid)?0:1;
  }
  return total;
}



function stepStatusFor(i){
  const S = STEPS[i]; if (!S) return '';
  if (S.special) return ''; // overview/extra/output are informational
  const fids = S.fids||[];
  if (!fids.length) return 'done';
  const allFilled = fids.every(fieldFilled);
  if (allFilled) return 'done';
  const anyTouched = fids.some(fid => TOUCH.has(fid) || (VALUES.get(fid)||'').trim().length>0);
  return anyTouched ? 'warn' : '';
}

function updateStepStates(prevIndex){
  const items = document.querySelectorAll('#wizStepList li');
  items.forEach((li, i)=>{
    li.classList.remove('done','warn');
    const s = stepStatusFor(i);
    if (s) li.classList.add(s);
    li.setAttribute('aria-current', i===STEP_INDEX ? 'true' : 'false');
  });
  if (typeof prevIndex==='number'){
    const li = items[prevIndex];
    if (li){
      li.classList.remove('done','warn');
      const s = stepStatusFor(prevIndex);
      if (s) li.classList.add(s);
    }
  }
}

function updateTopProgress(){
  const bar = el('tpBar'), stepTxt = el('tpStep'), pctTxt = el('tpPct'), encTxt = el('tpEnc'), timeTxt = el('tpTime');
  const totalSteps = STEPS.length||1;
  const cur = STEP_INDEX+1;
  stepTxt.textContent = `step ${cur} of ${totalSteps}`;

  const req = (STEPS.filter(s=>!s.special).flatMap(s=> s.fids||[])).length || 1;
  const filled = STEPS.filter(s=>!s.special).flatMap(s=> s.fids||[]).reduce((n,fid)=> n + (fieldFilled(fid)?1:0), 0);
  const pct = Math.round((filled/req)*100);
  bar.style.width = pct+'%';
  pctTxt.textContent = `${pct}%`;
  encTxt.textContent = encouragement(pct);

  const rem = remainingFieldCount();
  timeTxt.textContent = `${estimateTimeByFields(rem)} left`;
}

/* ==== Slice 2: Extras parity — helpers =================================== */

/* Get the joined boosters string for the current framework (or '') */
function wiz_defaultBooster(fw){
  const boosters = Array.isArray(fw?.boosters) ? fw.boosters : [];
  return boosters.join(' ').trim();
}

/* Update a small char counter next to a textarea */
function wiz_updateCounter(textareaEl, counterEl){
  if (!textareaEl || !counterEl) return;
  const n = (textareaEl.value || '').length;
  counterEl.textContent = `${n} chars`;
}

function setSelectValue(selectEl, saved){
  if (!selectEl) return;
  const isMulti = !!selectEl.multiple;
  if (!isMulti){ selectEl.value = saved || ''; return; }
  const want = new Set(String(saved||'').split(/\s*,\s*|\n+/).filter(Boolean));
  [...selectEl.options].forEach(opt => opt.selected = want.has(opt.value));
}


// Set input/textarea/select values from VALUES so edits persist across step switches
function wiz_hydrateFields(container){
  if (!container) return;
  container.querySelectorAll('input[type="text"], textarea, select').forEach(ctrl=>{
    const id = ctrl.id; if (!id) return;
    const saved = VALUES.get(id);
    if (typeof saved !== 'string') return;
    if (ctrl.tagName === 'SELECT'){ setSelectValue(ctrl, saved); }
    else { ctrl.value = saved; }
  });
}


/* Wire Extras UI: placeholder, optional prefill, counters, and Restore */
function wiz_bindExtrasUI(fw){
  const extra   = document.getElementById('extra');
  const extraCt = document.getElementById('extraCnt');
  const more    = document.getElementById('extraMore');
  const moreCt  = document.getElementById('extraMoreCnt');
  const restore = document.getElementById('extraRestore');

  if (!extra || !more) return;

  const boosters = wiz_defaultBooster(fw);

  // 1) Hydrate from saved VALUES first (so user text persists across step changes)
  const savedExtra = wiz_getVal('extra');
  const savedMore  = wiz_getVal('extraMore');
  if (savedExtra){ extra.value = savedExtra; }
  if (savedMore){  more.value  = savedMore;  }

  // 2) If still empty and boosters exist, seed boosters as initial value (default shows in Output)
  if (!extra.value && boosters){
    extra.value = boosters;
    VALUES.set('extra', boosters);
  }

  // 3) Always show boosters as placeholder (visual hint)
  extra.placeholder = boosters || 'Write instructions to replace the template’s boosters (optional)';

  // 4) Counters (initial paint)
  wiz_updateCounter(extra, extraCt);
  wiz_updateCounter(more,  moreCt);

  // 5) Input listeners keep VALUES map & preview in sync
  const onInput = (ev)=>{
    const t = ev.target;
    if (!t || !t.id) return;
    VALUES.set(t.id, t.value || '');
    if (t.id === 'extra') wiz_updateCounter(extra, extraCt);
    if (t.id === 'extraMore') wiz_updateCounter(more,  moreCt);
    renderPreviewMaybe();
  };
  extra.addEventListener('input', onInput);
  more.addEventListener('input', onInput);

  // 6) Restore button → boosters as current value (+ preview)
  if (restore){
    restore.disabled = !boosters;
    restore.addEventListener('click', ()=>{
      if (!boosters) return;
      extra.value = boosters;
      VALUES.set('extra', boosters);
      wiz_updateCounter(extra, extraCt);
      renderPreviewMaybe();
      extra.focus();
    });
  }

  // 7) Ensure preview matches hydrated/seeded values even if user never types here
  renderPreviewMaybe();
}


/* ==== Wizard → Prompt composer (Slice 1 shim) ============================= */
/* Collect Common Context (Step 1) safely from DOM */
function wiz_collectCommonContext(){
  const use   = wiz_getVal('ctx_use');
  const aud   = wiz_getVal('ctx_aud');
  const style = wiz_getVal('ctx_style');
  const tone  = wiz_getVal('ctx_tone');

  const bits = [];
  if (use)   bits.push(`Use-case: ${use}`);
  if (aud)   bits.push(`Audience: ${aud}`);
  if (style) bits.push(`Style: ${style}`);
  if (tone)  bits.push(`Tone: ${tone}`);
  const ctx = bits.join(' | ');

  const persona = aud ? `Persona/Audience: ${aud}${style?` | Style: ${style}`:''}${tone?` | Tone: ${tone}`:''}` : '';

  return { ctx, persona, raw:{ use, aud, style, tone } };
}

/* Split textareas/repeaters into list items (— or newline separated) */
function wiz_toItems(s){
  const txt = String(s||'').trim();
  if (!txt) return [];
  // Support '---' dividers, bullet-like lines, and plain newlines
  return txt
    .split(/\n-{3,}\n|^- |\n- |\n• |\n· |\r?\n/gm)
    .flatMap(x => String(x).split(/\r?\n/g))
    .map(x => x.trim())
    .filter(Boolean);
}

/* Collect template field values keyed by the template’s own keys */
function wiz_collectTemplateFields(fw){
  const bag = {};
  const lists = {};
  const fields = Array.isArray(fw?.fields) ? fw.fields : [];

  for (const f of fields){
    const key = (f.key || f.id || f.slug || f.label || '').toString().trim();
    if (!key) continue;
    const fid = computeFieldId(f);
    const el  = document.getElementById(fid);
    const t   = String(f.type||'').toLowerCase();

    let raw = '';
    if (el && el.tagName === 'SELECT' && el.multiple){
      const vals = [...el.selectedOptions].map(o=>o.value.trim()).filter(Boolean);
      raw = vals.join(', ');
      if (vals.length) lists[key] = vals;
    } else {
      raw = (el ? el.value : (VALUES.get(fid)||'')).trim();
    }
    if (!raw) continue;

    const isListish = /textarea|repeater/.test(t);
    if (isListish){
      const arr = wiz_toItems(raw);
      if (arr.length){ lists[key] = arr; }
    }else{
      bag[key] = raw;
    }
  }

  // keep the convenient aliases
  for (const [k,arr] of Object.entries(lists)){
    bag[k] = Array.isArray(arr) ? arr.join('\n') : String(arr);
    bag[`${k}_list`]  = arr;
    bag[`${k}_items`] = arr;
    bag[`${k}_arr`]   = arr;
    if (Array.isArray(arr) && k.endsWith('s') && arr.length===1){
      const singular = k.replace(/s$/, '');
      if (singular && !(singular in bag)) bag[singular] = arr[0];
    }
  }

  return bag;
}


/* Extras — user text wins; otherwise boosters from the framework */
function wiz_extras(fw){
  // Has the user ever edited #extra this session?
  var userTouchedExtra = VALUES.has('extra');

  // Current values (survive when Extras step is unmounted)
  var rawExtra  = wiz_getVal('extra');      // user's text if any
  var extraMore = wiz_getVal('extraMore');  // appended after the labeled block

  // Default boosters (string; may be empty)
  var boosters = wiz_defaultBooster(fw);

  // Semantics:
  // - If user NEVER touched #extra: show boosters by default (even if the box is empty).
  // - If user HAS touched #extra:
  //     - use their text;
  //     - if they cleared it, omit the boosters (no "Additional instructions" unless extraMore exists).
  var chosen = userTouchedExtra
    ? (rawExtra ? rawExtra.trim() : '')                  // touched → user text wins; empty means "none"
    : ((rawExtra ? rawExtra.trim() : '') || boosters);   // untouched → boosters by default

  var hasChosen = !!chosen;
  var hasMore   = !!extraMore;

  var extraCombined = '';
  if (hasChosen && hasMore){
    extraCombined = 'Additional instructions: ' + chosen + '\n\n' + extraMore;
  } else if (hasChosen){
    extraCombined = 'Additional instructions: ' + chosen;
  } else if (hasMore){
    // Keep the label even if only extraMore exists
    extraCombined = 'Additional instructions: ' + extraMore;
  }

  return {
    boosterFallback: boosters,
    extraChosen:     chosen,
    extraMore:       extraMore,
    extraCombined:   extraCombined
  };
}

/* Compose final text in PB order: Header → Persona → Body → Extra */
function wiz_composePrompt(){
  const fw = CURRENT || {};                            // active template
  const label = String(fw.label || fw.slug || fw.id || 'template').trim();
  const def   = String(fw.definition || fw.help || '').trim();

  // 1) Common Context
  const CC  = wiz_collectCommonContext();

  // 2) Template data bag (fields + CC for templates that use it)
  const bag = Object.assign({ ctx: CC.ctx }, wiz_collectTemplateFields(fw));

  // 3) Template body — prefer framework.template(bag); fallback to simple echo
  let body = '';
  try{
    if (typeof fw.template === 'function'){
      body = String(fw.template(bag) || '').trim();
    }
  }catch(_){}
  if (!body){
    // Safe fallback: print filled fields in a friendly way
    const lines = [];
    for (const [k,v] of Object.entries(bag)){
      if (!v) continue;
      if (Array.isArray(v)) continue; // aliases handled above; we printed joined string on k
      lines.push(`${k}: ${v}`);
    }
    body = lines.join('\n');
  }

  // 4) Extras logic
  const EX = wiz_extras(fw);

  // 5) Header — self-describing
  const header = def ? `Using ${label}: ${def}` : `Using ${label}`;

  // 6) Persona fallback (only if body doesn’t already include persona markers)
  const personaNeeded = !!CC.persona && !/persona|audience/i.test(body);
  const personaBlock  = personaNeeded ? CC.persona : '';

  // 7) Assemble in fixed order; collapse excess blank lines
  const parts = [header, personaBlock, body, EX.extraCombined].filter(Boolean);
  const txt = parts.join('\n\n')
    .replace(/\n{3,}/g, '\n\n') // tidy
    .trim();

  return txt || '(no content yet)';
}

// Preview writer (Slice 1): always compose from wizard state
function renderPreviewMaybe(){
  const out = document.getElementById('out'); if (!out) return;

  // Compose our final text using CURRENT + field values + common context + extras
  const txt = wiz_composePrompt();

  // If the page later ships PB's official makePromptForTab and you want to prefer it,
  // you can gate it here, but for Slice 1 we rely on the shim for determinism.
  out.textContent = txt;
  
    // Slice 0 — keep the Preview drawer live
  const pvOut = document.getElementById('pvOut');
  if (pvOut) pvOut.textContent = txt;
}

  // ===== Steps (standalone renderer — uses template.fields directly) =====
// ===== Steps (guided wizard with shared first/penultimate/final) =====
function fieldInput(f){
  const fid   = computeFieldId(f);
  const label = f.label || f.name || f.key || 'field';
  const desc  = f.desc || f.description || '';
  const ph    = f.ph || f.placeholder || '';
  const t     = String(f.type || '').toLowerCase();

  // normalize options: strings or {value,label}
  const rawOpts = Array.isArray(f.options) ? f.options
                 : Array.isArray(f.choices) ? f.choices
                 : [];
  const opts = rawOpts.map(o => {
    if (o && typeof o === 'object') return { value: String(o.value ?? o.label ?? ''), label: String(o.label ?? o.value ?? '') };
    return { value: String(o ?? ''), label: String(o ?? '') };
  }).filter(o => o.value);

  // select / multiselect
  if (t === 'select' || t === 'dropdown' || t === 'multiselect'){
    const multiple = (t === 'multiselect') || !!f.multiple;
    const optHtml = [
      (!multiple ? `<option value="" disabled selected>${ph || '— choose —'}</option>` : ''),
      ...opts.map(o => `<option value="${o.value}">${o.label}</option>`)
    ].join('');
    return `
      <div class="field" data-field-id="${fid}">
        <label for="${fid}">${label}</label>
        <select id="${fid}" name="${fid}" data-key="${f.key||''}" ${multiple?'multiple size="'+Math.min(6, Math.max(3, opts.length))+'"':''}>
          ${optHtml}
        </select>
        ${desc?`<div class="desc muted" style="margin-top:6px">${desc}</div>`:''}
      </div>`;
  }

  // textarea/repeater stay as-is
  if (isTextAreaOrRepeater(f) || (ph && ph.length>60) || (desc && desc.length>80)){
    return `
      <div class="field" data-field-id="${fid}">
        <label for="${fid}">${label}</label>
        <textarea id="${fid}" name="${fid}" data-key="${f.key||''}" placeholder="${ph}"></textarea>
        ${desc?`<div class="desc muted" style="margin-top:6px">${desc}</div>`:''}
      </div>`;
  }

  // default short input
  return `
    <div class="field" data-field-id="${fid}">
      <label for="${fid}">${label}</label>
      <input type="text" id="${fid}" name="${fid}" data-key="${f.key||''}" placeholder="${ph}">
      ${desc?`<div class="desc muted" style="margin-top:6px">${desc}</div>`:''}
    </div>`;
}

let SHOW_ALL = false, STEP_INDEX = 0, STEPS = [], REQUIRED_FIDS = [];

function buildSteps(t){
  const fields = Array.isArray(t.fields) ? t.fields : [];

  // 1) Overview
  const steps = [{ title:'overview', special:'overview', fields:[], fids:[] }];

  // 2) Template-specific grouping — Step Condensation Engine (≤3 controls/step, no singletons, no select-only)
  (function condense(){
    const TOPIC = { WHO:'WHO', WHAT:'WHAT', WHY:'WHY', HOW:'HOW', WHEN:'WHEN', WHERE:'WHERE', PROCESS:'PROCESS', GOV:'GOV', MISC:'MISC' };
    const ORDER = [TOPIC.WHO,TOPIC.WHAT,TOPIC.WHY,TOPIC.HOW,TOPIC.WHEN,TOPIC.WHERE,TOPIC.PROCESS,TOPIC.GOV,TOPIC.MISC];
    const TOK = {
      WHO:     /\b(audience|persona|stakeholder|employer|missing voices|access|inclusion|users?)\b/i,
      WHAT:    /\b(title|mission|goal|deliverable|content|feature name|story|paste|seed( companies)?)\b/i,
      WHY:     /\b(purpose|success|metric|result|impact|kpi|evidence|proof|differentiator)\b/i,
      HOW:     /\b(tone|style|format|constraints?|guidelines?|tools?|methods?|channels?)\b/i,
      WHEN:    /\b(time|horizon|deadline|dates?|cadence|schedule|review)\b/i,
      WHERE:   /\b(location|region|platform|base ?url|channel)\b/i,
      PROCESS: /\b(actions?|steps?|background|scenario|given|when|then|agenda|stages?)\b/i,
      GOV:     /\b(wip|sle|retries|workers|reporting|policy|limits?|governance)\b/i
    };

    function getType(f){
      const t = String(f.type||'').toLowerCase();
      if (t==='dropdown' || t==='multiselect') return 'select';
      return t || 'text';
    }
    function isSelectish(f){ return getType(f)==='select'; }
    function isTextareaOnly(f){ return getType(f)==='textarea'; }
    function isRepeaterType(f){ return getType(f)==='repeater'; }

    function classifyTopic(f){
      const hay = [f.label||'', f.desc||f.description||'', f.key||''].join(' ').toLowerCase();
      if (TOK.WHO.test(hay))     return TOPIC.WHO;
      if (TOK.WHAT.test(hay))    return TOPIC.WHAT;
      if (TOK.WHY.test(hay))     return TOPIC.WHY;
      if (TOK.HOW.test(hay))     return TOPIC.HOW;
      if (TOK.WHEN.test(hay))    return TOPIC.WHEN;
      if (TOK.WHERE.test(hay))   return TOPIC.WHERE;
      if (TOK.PROCESS.test(hay)) return TOPIC.PROCESS;
      if (TOK.GOV.test(hay))     return TOPIC.GOV;
      return TOPIC.MISC;
    }

    function lengthClass(f){
      const ph   = String(f.ph||f.placeholder||'').trim();
      const desc = String(f.desc||f.description||'').trim();
      return (ph.length + desc.length) >= 140 ? 'long' : 'short';
    }
    function fieldWeight(f){
      if (isRepeaterType(f)) return 1.5;
      if (isTextareaOnly(f)) return (lengthClass(f)==='long' ? 2.0 : 1.5);
      if (isSelectish(f)) {
        const raw = Array.isArray(f.options) ? f.options
                 : Array.isArray(f.choices) ? f.choices : [];
        const n = raw.length;
        return n > 12 ? 1.5 : 1.0;
      }
      return 1.0;
    }
    function niceTitle(topic){
      switch(topic){
        case TOPIC.WHO:     return 'Audience & Context';
        case TOPIC.WHAT:    return 'Goals & Content';
        case TOPIC.WHY:     return 'Evidence & Outcomes';
        case TOPIC.HOW:     return 'Constraints & Guidance';
        case TOPIC.WHEN:    return 'Timing';
        case TOPIC.WHERE:   return 'Where/Channels';
        case TOPIC.PROCESS: return 'Scenarios & Steps';
        case TOPIC.GOV:     return 'Setup & Governance';
        default:            return 'Details';
      }
    }
    function sumW(arr){ return arr.reduce((s,x)=> s + x.__w, 0); }

    // Normalize fields → items with metadata
    const items = fields.map((f,i)=>({
      __idx:i,
      __topic: classifyTopic(f),
      __w: fieldWeight(f),
      __isSelect: isSelectish(f),
      data: f
    }));

    // Topic queues (stable by original order)
    const queues = new Map(); ORDER.forEach(k => queues.set(k, []));
    items.forEach(it => (queues.get(it.__topic) || queues.get(TOPIC.MISC)).push(it));

    // Build groups with budget ≤3 (prefer same-topic packing)
    const groups = [];
    const titles = [];

    ORDER.forEach(topic=>{
      const q = queues.get(topic);
      while (q.length){
        let budget = 3;
        const bag = [];
        const first = q.shift(); bag.push(first); budget -= first.__w;
        let j = 0;
        while (j < q.length){
          const cand = q[j];
          if (cand.__w <= budget){ bag.push(cand); budget -= cand.__w; q.splice(j,1); continue; }
          j++;
        }
        groups.push(bag);
        titles.push(niceTitle(topic));
      }
    });

    // Fix singletons by borrowing into them or merging them away
    for (let g=0; g<groups.length; g++){
      if (groups[g].length===1){
        const need = 3 - sumW(groups[g]);
        if (g+1<groups.length){
          const r = groups[g+1].find(x => x.__w <= need);
          if (r){ groups[g].push(r); groups[g+1].splice(groups[g+1].indexOf(r),1); continue; }
        }
        if (g-1>=0){
          const l = groups[g-1].find(x => x.__w <= need);
          if (l){ groups[g].push(l); groups[g-1].splice(groups[g-1].indexOf(l),1); continue; }
        }
        if (g+1<groups.length && (sumW(groups[g+1]) + groups[g][0].__w) <= 3){
          groups[g+1].push(groups[g][0]); groups.splice(g,1); titles.splice(g,1); g--;
        } else if (g-1>=0 && (sumW(groups[g-1]) + groups[g][0].__w) <= 3){
          groups[g-1].push(groups[g][0]); groups.splice(g,1); titles.splice(g,1); g--;
        }
      }
    }

    // Ensure no group is select-only (borrow a non-select if needed)
    for (let g=0; g<groups.length; g++){
      if (groups[g].length && groups[g].every(x => x.__isSelect)){
        const need = 3 - sumW(groups[g]);
        let donorIdx = -1, donorFrom = -1;
        if (g+1<groups.length){ donorFrom = g+1; donorIdx = groups[g+1].findIndex(x => !x.__isSelect && x.__w <= need); }
        if (donorIdx<0 && g-1>=0){ donorFrom = g-1; donorIdx = groups[g-1].findIndex(x => !x.__isSelect && x.__w <= need); }
        if (donorIdx>=0){
          const donor = groups[donorFrom][donorIdx];
          groups[g].push(donor);
          groups[donorFrom].splice(donorIdx,1);
        } else {
          if (g+1<groups.length && (sumW(groups[g+1]) + groups[g][0].__w) <= 3){
            groups[g+1].push(groups[g][0]); groups.splice(g,1); titles.splice(g,1); g--;
          } else if (g-1>=0 && (sumW(groups[g-1]) + groups[g][0].__w) <= 3){
            groups[g-1].push(groups[g][0]); groups.splice(g,1); titles.splice(g,1); g--;
          }
        }
      }
    }

    // Emit steps from groups
    for (let i=0;i<groups.length;i++){
      const group = groups[i]; if (!group || !group.length) continue;
      const fieldsInGroup = group.map(x => x.data);
      const fids = fieldsInGroup.map(f => computeFieldId(f));
      const title = titles[i] || (fieldsInGroup[0].label || 'fields');
      steps.push({ title, fields: fieldsInGroup, fids });
    }
  })();

  // 3) Extras (shared)
  steps.push({ title:'extra instructions', special:'extra', fields:[], fids:['extra','extraMore'] });

  // 4) Output (shared)
  steps.push({ title:'output', special:'output', fields:[], fids:[] });

  // Finalize
  STEPS = steps;
  STEP_INDEX = 0;
  REQUIRED_FIDS = steps.filter(s=>!s.special).flatMap(s=> s.fids||[]);

  // Seed boosters so Output shows default instructions by default
  if (!VALUES.has('extra') || (VALUES.get('extra')||'').trim()===''){
    const b = wiz_defaultBooster(t);
    if (b){ VALUES.set('extra', b); }
  }

  renderSteps(t);
  updateStepStates();
  updateTopProgress();
}

function renderSteps(t){
  // Rail
  const list = el('wizStepList');
  list.innerHTML = STEPS.map((s,i)=> `
    <li data-i="${i}" ${i===STEP_INDEX?'aria-current="true"':''}>
      <span class="pill">${i+1}</span>
      <span>${s.special ? s.title : (s.title||('step '+(i+1)))}</span>
    </li>`).join('');
  list.querySelectorAll('li').forEach(li=>{
    li.addEventListener('click', ()=>{
      const prev = STEP_INDEX;
      STEP_INDEX = +li.getAttribute('data-i');
      updateStepStates(prev);
      renderSteps(t);
      updateTopProgress();
    });
  });

  // Body
  const S = STEPS[STEP_INDEX]||{fields:[]};
  const body = el('wizStepBody');

  if (S.special === 'overview'){
    const lab = String((t && (t.label||t.slug||t.id)) || 'template');
    const def = String((t && (t.definition||t.help)) || '').trim();
    body.innerHTML = `
      <h3 class="subhead" style="margin-bottom:6px">${lab}</h3>
      <div class="muted" style="margin:0 0 10px">${def||'<em>no definition provided</em>'}</div>
  <div id="commonCtxHead" class="subhead" style="margin:8px 0 6px; display:flex; align-items:center; justify-content:space-between;">
  <span>common context <span class="muted">(optional — <span id="commonCtxCount">0</span>/4 filled; same across templates)</span></span>
  <button id="commonCtxToggle" class="btn sm" type="button" aria-expanded="false" aria-controls="commonCtxBody">show</button>
</div>
<div id="commonCtxBody" hidden>
  <div class="field"><label for="ctx_use">Use-case</label><input id="ctx_use" type="text" placeholder="what are you trying to do?"></div>
  <div class="field"><label for="ctx_aud">Audience</label><input id="ctx_aud" type="text" placeholder="who is this for?"></div>
  <div class="field"><label for="ctx_style">Style</label><input id="ctx_style" type="text" placeholder="e.g., concise, academic, playful"></div>
  <div class="field"><label for="ctx_tone">Tone</label><input id="ctx_tone" type="text" placeholder="e.g., supportive, neutral, assertive"></div>
</div>
    `;
      // 🔧 Repaint saved values for use/audience/style/tone
  wiz_hydrateFields(body);
  
} 



else if (S.special === 'extra'){
  // HTML only; placeholder/prefill will be set by wiz_bindExtrasUI(t)
  body.innerHTML = `
    <h3 class="subhead">extra instructions</h3>

    <div class="field" data-field-id="extra" style="margin-bottom:10px">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <label for="extra">Default included instructions</label>
        <div class="muted" id="extraCnt" style="font-size:12px"></div>
      </div>
      <textarea id="extra" placeholder="Write instructions to replace the template’s boosters (optional)"></textarea>
      <div class="desc muted" style="margin-top:6px; display:flex; gap:8px; align-items:center;">
        <button type="button" id="extraRestore" class="btn sm">Restore recommended text</button>
        <span class="muted" style="font-size:12px">Your text replaces the recommended boosters.</span>
      </div>
    </div>

    <div class="field" data-field-id="extraMore" style="margin-top:8px">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <label for="extraMore">Anything else to include (optional)</label>
        <div class="muted" id="extraMoreCnt" style="font-size:12px"></div>
      </div>
      <textarea id="extraMore" placeholder="Append any final details or constraints"></textarea>
    </div>
  `;
  // Wire counters, placeholder/prefill, and Restore behavior
   wiz_hydrateFields(body);
  wiz_bindExtrasUI(t);
} else if (S.special === 'output'){
  body.innerHTML = `
    <div class="out-head-row">
      <h3 class="subhead">output</h3>
      <div id="outActions" class="out-actions">
        <button id="copyBtn2" class="btn sm">Copy</button>
        <button id="openBtn2" class="btn sm ask" title="Ask ChatGPT">Ask ChatGPT</button>
      </div>
    </div>
    <pre id="out" class="wiz-output" aria-live="polite">(your generated prompt will appear here)</pre>
  `;
  // Wire Slice 1 actions for this step render
  wireOutputActions();
  renderPreviewMaybe();
} else {


    // Template fields step
    body.innerHTML = `<h3 class="subhead">${S.title||('step '+(STEP_INDEX+1))}</h3>` + S.fields.map(fieldInput).join('');
     wiz_hydrateFields(body);
  }
  
// In "show all" mode, render the entire flow in one page
if (SHOW_ALL){
  const lab = String((t && (t.label||t.slug||t.id)) || 'template');
  const def = String((t && (t.definition||t.help)) || '').trim();

  // 1) Overview
  let html = `
    <h3 class="subhead" style="margin-bottom:6px">${lab}</h3>
    <div class="muted" style="margin:0 0 10px">${def||'<em>no definition provided</em>'}</div>

<div id="commonCtxHead" class="subhead" style="margin:8px 0 6px; display:flex; align-items:center; justify-content:space-between;">
  <span>common context <span class="muted">(optional — <span id="commonCtxCount">0</span>/4 filled; same across templates)</span></span>
  <button id="commonCtxToggle" class="btn sm" type="button" aria-expanded="false" aria-controls="commonCtxBody">show</button>
</div>
<div id="commonCtxBody" hidden>
  <div class="field"><label for="ctx_use">Use-case</label><input id="ctx_use" type="text" placeholder="what are you trying to do?"></div>
  <div class="field"><label for="ctx_aud">Audience</label><input id="ctx_aud" type="text" placeholder="who is this for?"></div>
  <div class="field"><label for="ctx_style">Style</label><input id="ctx_style" type="text" placeholder="e.g., concise, academic, playful"></div>
  <div class="field"><label for="ctx_tone">Tone</label><input id="ctx_tone" type="text" placeholder="e.g., supportive, neutral, assertive"></div>
</div>
  `;

  // 2) All template-specific fields (each step’s fields, in order)
  for (const s of STEPS){
    if (s.special || !Array.isArray(s.fields)) continue;
    html += `<h3 class="subhead">${s.title||'fields'}</h3>` + s.fields.map(fieldInput).join('');
  }

  // 3) Extras (same UI as the single-step version)
  html += `
    <h3 class="subhead">extra instructions</h3>

    <div class="field" data-field-id="extra" style="margin-bottom:10px">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <label for="extra">Default included instructions</label>
        <div class="muted" id="extraCnt" style="font-size:12px"></div>
      </div>
      <textarea id="extra" placeholder="Write instructions to replace the template’s boosters (optional)"></textarea>
      <div class="desc muted" style="margin-top:6px; display:flex; gap:8px; align-items:center;">
        <button type="button" id="extraRestore" class="btn sm">Restore recommended text</button>
        <span class="muted" style="font-size:12px">Your text replaces the recommended boosters.</span>
      </div>
    </div>

    <div class="field" data-field-id="extraMore" style="margin-top:8px">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <label for="extraMore">Anything else to include (optional)</label>
        <div class="muted" id="extraMoreCnt" style="font-size:12px"></div>
      </div>
      <textarea id="extraMore" placeholder="Append any final details or constraints"></textarea>
    </div>
  `;

  // 4) Output preview (same preview hook)
  html += `
    <div class="out-head-row" style="margin-top:12px">
      <h3 class="subhead">output</h3>
      <div id="outActions" class="out-actions">
        <button id="copyBtn2" class="btn sm">Copy</button>
        <button id="openBtn2" class="btn sm ask" title="Ask ChatGPT">Ask ChatGPT</button>
      </div>
    </div>
    <pre id="out" class="wiz-output" aria-live="polite">(your generated prompt will appear here)</pre>
  `;

  body.innerHTML = html;

  wiz_hydrateFields(body);
  wiz_bindExtrasUI(t);
  wireOutputActions();      // ← add this for Show All parity
  renderPreviewMaybe();
}

// === Slice 1+2: upgrade single + repeater type-ahead fields in this step ===
{
  const S = STEPS[STEP_INDEX] || { fields: [] };
  const allFields = SHOW_ALL ? STEPS.flatMap(s => s.fields || []) : (S.fields || []);
  window.WIZ.setStepSchemas(allFields);
  window.WIZ.upgradeSingles(body);
  window.WIZ.upgradeRepeaters(body);
}

// Slice 1: common context collapse
if (typeof ensureCommonCtxCollapse === 'function') ensureCommonCtxCollapse();

  // Slice 0: optionality banner + preview buttons
  if (typeof insertOptionalityBanner === 'function') insertOptionalityBanner();
  if (typeof ensurePreviewButtons === 'function') ensurePreviewButtons();
  
  // Slice 2/3: Assist-lite (per-field “help fill this field”)
if (typeof ensureAssistLite === 'function') ensureAssistLite();

  // Nav buttons (hide vs. disable)
  const isFirst = STEP_INDEX<=0, isLast = STEP_INDEX>=STEPS.length-1;
  el('wizStepBack').style.display = isFirst ? 'none' : '';
  el('wizStepNext').style.display = isLast  ? 'none' : '';
  el('wizStepBack').disabled = isFirst;
  el('wizStepNext').disabled = isLast;
  // Toggle label and hide nav when in "show all"
el('wizShowAll').textContent = SHOW_ALL ? 'step-by-step' : 'show all';
if (SHOW_ALL){ el('wizStepBack').style.display='none'; el('wizStepNext').style.display='none'; }


  // Delegate inputs → track TOUCH/VALUES, update states + progress + preview
  const bodyEl = el('wizStepBody');
bodyEl.oninput = bodyEl.onchange = (ev)=>{
  const t = ev.target;
  if (!t || !t.id) return;

  // Keep VALUES in sync for all fields
  VALUES.set(t.id, t.value || '');

  // Persist Common Context across templates & sessions
  if (CC_IDS.includes(t.id)) ccPersistFromVALUES();

  const wrapper = t.closest('[data-field-id]');
  if (wrapper){ TOUCH.add(wrapper.getAttribute('data-field-id')); }

  updateStepStates();
  updateTopProgress();
  renderPreviewMaybe();
};
  bodyEl.onfocusin = (ev)=>{
    const w = ev.target.closest('[data-field-id]');
    if (w) TOUCH.add(w.getAttribute('data-field-id'));
  };

  updateStepStates();
}

// Step nav + show/hide top progress
el('wizStep0Start').addEventListener('click', ()=>{
  if (!CURRENT) return;
  buildSteps(CURRENT);
  showView('steps');
  el('wizTopProgress').classList.remove('hide');
  updateTopProgress();
});
el('wizExitSearch').addEventListener('click', ()=> { showView('startup'); el('wizTopProgress').classList.add('hide'); });
el('wizShowAll').addEventListener('click', ()=>{ SHOW_ALL=!SHOW_ALL; renderSteps(CURRENT); updateTopProgress(); });
el('wizStepBack').addEventListener('click', ()=>{
  if (STEP_INDEX>0){ const prev=STEP_INDEX; STEP_INDEX--; updateStepStates(prev); renderSteps(CURRENT); updateTopProgress(); }
});
el('wizStepNext').addEventListener('click', ()=>{
  if (STEP_INDEX<STEPS.length-1){ const prev=STEP_INDEX; STEP_INDEX++; updateStepStates(prev); renderSteps(CURRENT); updateTopProgress(); }
});
  
  el('btnExitSearch').addEventListener('click', ()=> showView('startup'));
  
  
  
/* ===== URL deep-linking (slug/id → Step 0) ============================== */
(function wireDeepLinking(){
  function readTargetFromURL(){
    const url = new URL(window.location.href);
    const p   = url.searchParams;
    let v = (p.get('slug') || p.get('id') || p.get('t') || '').trim();
    if (!v && url.hash) v = url.hash.replace(/^#/, '').trim();
    return v.toLowerCase();
  }

  function findTemplate(slugOrId){
    if (!slugOrId) return null;
    const s = slugOrId.toLowerCase();
    const T = allTemplates();
    return T.find(x =>
      String(x.slug||'').toLowerCase() === s ||
      String(x.id  ||'').toLowerCase() === s ||
      String(x.key ||'').toLowerCase() === s ||
      String(x.label||'').toLowerCase() === s
    ) || null;
  }

  function setURLForTemplate(t){
    try{
      const url = new URL(window.location.href);
      const canonical = (t.slug || t.id || '').toString().toLowerCase();
      // normalize to ?slug=… and drop ?id=…
      if (canonical){
        url.searchParams.set('slug', canonical);
        url.searchParams.delete('id');
      }else{
        url.searchParams.delete('slug');
        url.searchParams.delete('id');
      }
      history.replaceState({}, '', url);
    }catch(_){}
  }
  window.__setURLForTemplate = setURLForTemplate; // used when user clicks cards too

  function tryOpenFromURL(){
    const target = readTargetFromURL();
    if (!target) return;

    // immediate attempt
    const hit = findTemplate(target);
    if (hit){ openStep0(hit); setURLForTemplate(hit); return; }

    // datasets may still be loading → retry a few times
    let tries = 0;
    const iv = setInterval(()=>{
      const h = findTemplate(target);
      if (h){ clearInterval(iv); openStep0(h); setURLForTemplate(h); }
      else if (++tries >= 30){ clearInterval(iv); } // ~4.5s total
    }, 150);
  }

  // run after DOM is ready; safe with late-loading datasets thanks to retry loop
  window.addEventListener('DOMContentLoaded', tryOpenFromURL);
})();



// ===== Boot =====
buildIndex();
recompute('');                   // prime UI
setTimeout(()=>{ buildIndex(); recompute(el('wizQ').value); }, 300); // pick up late dataset


/* ===================== Slice 1: Copy modal logic ===================== */

/** Ensure cancel & close wiring for the action modal (idempotent). */
function ensureActionModalWired(){
  const dlg = document.getElementById('actionModal');
  if (!dlg || dlg._actionsWired) return;

  const actionCancel = document.getElementById('actionCancel');
  const actionCloseX = document.getElementById('actionClose');

  if (actionCancel) actionCancel.onclick = closeActionModal;
  if (actionCloseX) actionCloseX.onclick = closeActionModal;

  // Backdrop click (close when clicking outside dialog)
  if (!dlg._backdropBound){
    dlg.addEventListener('click', (e) => {
      const rect = dlg.getBoundingClientRect();
      const inDialog = (
        e.clientX >= rect.left && e.clientX <= rect.right &&
        e.clientY >= rect.top  && e.clientY <= rect.bottom
      );
      if (!inDialog) closeActionModal();
    });
    dlg._backdropBound = true;
  }

  dlg._actionsWired = true;
}

/** General opener: seeds and opens the shared Action Modal with provided text. */
function openCopyModal(textOverride){
  ensureActionModalWired(); // ← make sure cancel/close are wired

  const dlg     = document.getElementById('actionModal');
  const title   = document.getElementById('actionTitle');
  const ta      = document.getElementById('actionPreview');
  const primary = document.getElementById('actionCopy');
  const status  = document.getElementById('copyStatus');
  const note    = document.getElementById('actionNote');

  const text = (typeof textOverride === 'string' && textOverride.length)
    ? textOverride
    : (document.getElementById('out')?.textContent || (typeof window.wiz_composePrompt==='function' ? window.wiz_composePrompt() : ''));

  title.textContent = 'Copy prompt';
  ta.value = text;
  status.hidden = true;

  primary.textContent = 'Copy';
  primary.onclick = copyFromModal;

  if (note) note.hidden = true;

  if (typeof dlg.showModal === 'function') dlg.showModal();
  else dlg.setAttribute('open','');

  setTimeout(() => { ta.focus(); ta.select(); }, 0);
}

/** Seeds and opens the shared Action Modal in "Copy" mode (out→modal). */
function openCopyModalFromOut(){
  const outEl = document.getElementById('out');
  const text  = outEl && outEl.textContent
    ? outEl.textContent
    : (typeof window.wiz_composePrompt==='function' ? window.wiz_composePrompt() : '');
  openCopyModal(text);
}


/** Copies current modal textarea to clipboard, keeps dialog open, shows status. */
async function copyFromModal(){
  const ta = document.getElementById('actionPreview');
  const status = document.getElementById('copyStatus');
  try {
    await navigator.clipboard.writeText(ta.value);
    status.textContent = 'Copied to clipboard.';
  } catch(e){
    status.textContent = 'Copy failed. Select all and press ⌘/Ctrl+C.';
  }
  status.hidden = false;
}

/** Closes the action modal */
function closeActionModal(){
  const dlg = document.getElementById('actionModal');
  if (!dlg) return;
  dlg.close ? dlg.close() : dlg.removeAttribute('open');
}

/**
 * Wires buttons for the Output step (called after the Output HTML is injected).
 * Safe to call repeatedly; it rebinds current step's elements.
 */
function wireOutputActions(){
  const copyBtn = document.getElementById('copyBtn2');
  const askBtn  = document.getElementById('openBtn2'); // present, no behavior yet (Slice 2)

  const dlg = document.getElementById('actionModal');
  const actionCopy = document.getElementById('actionCopy');
  const actionCancel = document.getElementById('actionCancel');
  const actionCloseX = document.getElementById('actionClose');

  if (copyBtn){
    copyBtn.onclick = openCopyModalFromOut;
  }
if (askBtn){
  askBtn.onclick = openAskModalFromOut;
}


  if (actionCopy){
    actionCopy.onclick = copyFromModal;
  }
  if (actionCancel){
    actionCancel.onclick = closeActionModal;
  }
  if (actionCloseX){
    actionCloseX.onclick = closeActionModal;
  }

  // Optional: close on backdrop click
  if (dlg && !dlg._backdropBound){
    dlg.addEventListener('click', (e) => {
      const rect = dlg.getBoundingClientRect();
      const inDialog = (
        e.clientX >= rect.left && e.clientX <= rect.right &&
        e.clientY >= rect.top  && e.clientY <= rect.bottom
      );
      if (!inDialog) closeActionModal();
    });
    dlg._backdropBound = true;
  }
}

/* ===================== Slice 2: Ask ChatGPT (happy path) ===================== */

/** Returns ChatGPT URL and base given a prompt string. */
function buildChatURL(promptText){
  const base = 'https://chat.openai.com/'; // base ChatGPT entry
  const url  = base + '?prompt=' + encodeURIComponent(promptText || '');
  return { url, base };
}

/** Seeds and opens the shared Action Modal in "Ask ChatGPT" mode. */
function openAskModalFromOut(){
  ensureActionModalWired(); // ← make sure cancel/close are wired

  const dlg      = document.getElementById('actionModal');
  const title    = document.getElementById('actionTitle');
  const ta       = document.getElementById('actionPreview');
  const primary  = document.getElementById('actionCopy');     // reuse as primary
  const note     = document.getElementById('actionNote');

  const outEl = document.getElementById('out');
  const text  = outEl ? outEl.textContent : '';

  title.textContent = 'Ask ChatGPT';
  ta.value = text;

  // Primary button behaves as "Open in ChatGPT" in this mode
  primary.textContent = 'Open in ChatGPT';
  primary.onclick = openChatFromModal;

  // Show the advisory note (helpful hint; Slice 3 will drive fallbacks)
  if (note) note.hidden = false;

  // Open dialog
  if (typeof dlg.showModal === 'function') dlg.showModal();
  else dlg.setAttribute('open','');

  // Focus the textarea for quick edits
  setTimeout(() => { ta.focus(); ta.select(); }, 0);
}

/** Opens ChatGPT with the textarea contents in the URL (happy path), then closes modal. */
function openChatFromModal(){
  const dlg   = document.getElementById('actionModal');
  const ta    = document.getElementById('actionPreview');
  const text  = ta ? ta.value : '';
  const { url, base } = buildChatURL(text);

  // 1) Long URL guard → copy + open clean chat + post-launch helper
  if (url.length > MAX_URL_CHARS) {
    openBaseAndNotify(base, text, 'long-url');
    if (dlg && dlg.close) dlg.close(); else dlg.removeAttribute('open');
    return;
  }

  // 2) Try happy path
  const win = window.open(url, '_blank', 'noopener,noreferrer');

  // 3) Popup blocked or navigation refused → copy + open clean chat + post-launch helper
  if (!win) {
    openBaseAndNotify(base, text, 'popup-blocked');
    if (dlg && dlg.close) dlg.close(); else dlg.removeAttribute('open');
    return;
  }

  // 4) Happy path: close modal; if the user returns later and wants help,
  // they can still click Copy/Ask again. (No post-launch prompt in happy path.)
  if (dlg && dlg.close) dlg.close(); else dlg.removeAttribute('open');
}


/* ===================== Slice 3: Fallbacks & Post-Launch Helper ===================== */

const MAX_URL_CHARS = 7800; // conservative safety threshold for ?prompt= URLs
const POST_LAUNCH_KEY = 'postLaunchAsk';

/** Store post-launch payload so we can prompt the user when they return. */
function markPostLaunch(payload){
  try {
    sessionStorage.setItem(POST_LAUNCH_KEY, JSON.stringify({
      text: payload.text || '',
      base: payload.base || 'https://chat.openai.com/',
      reason: payload.reason || 'unknown',
      t: Date.now()
    }));
  } catch(e) {/* ignore */}
}

/** Try to open a clean chat, copy text, and record post-launch state. */
async function openBaseAndNotify(base, text, reason){
  try { await navigator.clipboard.writeText(text); } catch(e) {/* ignore */}
  window.open(base, '_blank', 'noopener,noreferrer');
  markPostLaunch({ text, base, reason });
}

/** If a post-launch payload exists (and we're back on this tab), show the helper once. */
function consumePostLaunchIfAny(){
  let raw = null;
  try { raw = sessionStorage.getItem(POST_LAUNCH_KEY); } catch(e) {}
  if (!raw) return;

  let data = null;
  try { data = JSON.parse(raw); } catch(e) {}
  if (!data) { try { sessionStorage.removeItem(POST_LAUNCH_KEY); } catch(_) {} ; return; }

  // Clear immediately so we only show once
  try { sessionStorage.removeItem(POST_LAUNCH_KEY); } catch(_) {}

  openPostLaunchDlg(data);
}

/** Open the helper dialog with buttons: Open clean chat, Copy again, Dismiss. */
function openPostLaunchDlg(data){
  const dlg   = document.getElementById('postLaunchDlg');
  const ta    = document.getElementById('postLaunchText');
  const openB = document.getElementById('postLaunchOpenBase');
  const copyB = document.getElementById('postLaunchCopy');
  const dismB = document.getElementById('postLaunchDismiss');
  const xBtn  = document.getElementById('postLaunchClose');
  const stat  = document.getElementById('postLaunchStatus');

  const text = (data && data.text) || '';
  const base = (data && data.base) || 'https://chat.openai.com/';

  ta.value = text;
  stat.hidden = true;

  openB.onclick = () => { window.open(base, '_blank', 'noopener,noreferrer'); };
  copyB.onclick = async () => {
    try { await navigator.clipboard.writeText(text); stat.textContent = 'Copied to clipboard.'; }
    catch(e){ stat.textContent = 'Copy failed. Select all and press ⌘/Ctrl+C.'; }
    stat.hidden = false;
  };
  const closeDlg = () => { dlg.close ? dlg.close() : dlg.removeAttribute('open'); };
  dismB.onclick = closeDlg;
  xBtn.onclick  = closeDlg;

  if (typeof dlg.showModal === 'function') dlg.showModal();
  else dlg.setAttribute('open','');

  // Focus textarea for quick manual copy
  setTimeout(() => { ta.focus(); ta.select(); }, 0);
}

/** Bind once: when the tab regains focus/visibility, check for post-launch payload. */
(function bindPostLaunchReturnHooks(){
  if (window.__postLaunchBound) return;
  window.__postLaunchBound = true;
  window.addEventListener('focus', consumePostLaunchIfAny, { passive: true });
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') consumePostLaunchIfAny();
  }, { passive: true });
})();



  </script>
  
  <script>
(function ensureIndexSkin(){
  const root = document.getElementById('wizViewStartup');
  if (!root) return;
  const apply = () => {
    document.getElementById('wizHdr')?.classList.add('searchWrap');
    root.querySelector('.wiz-searchShell')?.classList.add('search');
    root.querySelector('.quickRow')?.classList.add('searchCtas');
    const box = document.querySelector('#taSug .box');
    if (box) box.parentElement.classList.add('ta');
  };
  apply();
  // If your framework re-renders, keep it skinned.
  new MutationObserver(apply).observe(root, { childList:true, subtree:true });
})();
</script>

<script>
/* Slice 1: Wire AI Settings button (Startup Wizard) */
(function wireAISettingsButton(){
  function bind(){
    var btn = document.getElementById('aiSettingsBtn');
    if (!btn) return;
    if (btn.__aiSettingsWired) return;     // idempotence guard
    btn.__aiSettingsWired = true;

    btn.addEventListener('click', function(){
      try {
        if (window.AISettings && typeof AISettings.open === 'function'){
          AISettings.open();               // parity with Prompt Builder
        } else {
          console.warn('AISettings not ready yet.');
        }
      } catch (e){
        console.error('AI Settings open failed:', e);
      }
    }, { passive: true });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', bind, { once: true });
  } else {
    bind();
  }
})();
</script>


<script>
// === Slice 1+2: Type-ahead (single) + Repeater chips ======================
// Public surface:
//   window.WIZ.setStepSchemas(stepSchemasArray)
//   window.WIZ.upgradeSingles(rootEl)     // single type-ahead
//   window.WIZ.upgradeRepeaters(rootEl)   // repeater chips

(function(){
  // ---------- State (persist under pb.wizard.v1) ----------
  const LS_KEY = 'pb.wizard.v1';
  function loadState(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)||'{}'); }catch(_){ return {}; } }
  function saveState(s){ try{ localStorage.setItem(LS_KEY, JSON.stringify(s)); }catch(_){ } }
  const WIZ = (window.WIZ ||= {});
  WIZ.state ||= loadState();

  function getAtPath(obj, path){
    if (!path) return undefined;
    return String(path).split('.').reduce((o,k)=> (o && k in o ? o[k] : undefined), obj);
  }
  function setAtPath(obj, path, val){
    const parts = String(path).split('.');
    let cur = obj;
    for (let i=0;i<parts.length-1;i++){
      const k = parts[i]; if (!cur[k] || typeof cur[k] !== 'object') cur[k] = {};
      cur = cur[k];
    }
    cur[parts[parts.length-1]] = val;
  }

  // ---------- Dataset registry (personas default; biases explicit) ----------
  // Adapters must provide: filter(q, limit, filterUnit?) -> [{id,name,unit?,kind?,summary?}], getById(id)
  const DS = (WIZ.datasets ||= {});

  // Light stubs (safe to replace by dispatching wizard:dataset:<key>:loaded later)
  DS.personas ||= (function(){
    const base = [
      { id:'persona:exec', name:'Executive' },
      { id:'persona:designer', name:'Designer' },
      { id:'persona:pm', name:'Product Manager' },
      { id:'persona:dev', name:'Software Developer' },
      { id:'persona:marketer', name:'Marketer' },
      { id:'persona:student', name:'Student' },
    ];
    return {
      filter(q, limit=30){
        const s = String(q||'').toLowerCase().trim();
        const list = s ? base.filter(x => x.name.toLowerCase().includes(s)) : base.slice();
        return list.slice(0, limit);
      },
      getById(id){ return base.find(x => String(x.id)===String(id)) || null; }
    };
  })();

  DS.biases ||= (function(){
    const base = [
      { id:'bias:anchoring', name:'Anchoring', unit:'bias' },
      { id:'bias:confirmation', name:'Confirmation Bias', unit:'bias' },
      { id:'tech:premortem', name:'Pre-mortem', unit:'technique' },
    ];
    return {
      filter(q, limit=30, filterUnit){
        const s = String(q||'').toLowerCase().trim();
        let list = s ? base.filter(x => (x.name.toLowerCase().includes(s) || x.id.toLowerCase().includes(s))) : base.slice();
        if (filterUnit) list = list.filter(x => String(x.unit||'') === String(filterUnit));
        return list.slice(0, limit);
      },
      getById(id){ return base.find(x => String(x.id)===String(id)) || null; }
    };
  })();

  document.addEventListener('wizard:dataset:personas:loaded', (ev)=>{
    if (ev.detail && ev.detail.adapter){ WIZ.datasets.personas = ev.detail.adapter; }
  });
  document.addEventListener('wizard:dataset:biases:loaded', (ev)=>{
    if (ev.detail && ev.detail.adapter){ WIZ.datasets.biases = ev.detail.adapter; }
  });

  // ---------- Schema normalizer (PromptBuilder-aligned rules) ----------
function normalize(schema){
  const s = Object.assign({}, schema||{});
  const label = String(s.label||s.key||'').trim();
  const key   = String(s.key||s.name||'').trim() || slugify(label);

  // Only consider typeahead if schema EXPLICITLY marks it.
  const isRepeaterTA = (s.type === 'repeater' && s.itemType === 'typeahead');
  const isSingleTA   = (s.type === 'typeahead') || (!s.type && s.itemType === 'typeahead');

  if (!isRepeaterTA && !isSingleTA){
    // Everything else is NOT a typeahead. Do not upgrade.
    return {
      label, key,
      persistKey: s.persistKey || ('ctx.'+key),
      type: 'other',
      dataset: null,
      filterUnit: null,
      allowFreeform: false,
      placeholder: s.ph || s.placeholder || ''
    };
  }

  // Dataset inference ONLY for typeahead fields
  const hasBiasTag = /bias/i.test(s.dataset||'') || /^bias->/i.test(s.autofill||'') || /bias/i.test(label);
  const wantsBias  = hasBiasTag || /mitigation/i.test(label) || String(s.unit||'').toLowerCase()==='technique';

  let dataset = s.dataset ? String(s.dataset).toLowerCase() : '';
  if (dataset === 'bias') dataset = 'biases';
  if (!dataset) dataset = wantsBias ? 'biases' : 'personas'; // persona fallback

  const allowDefault  = (dataset === 'personas');
  const allowFreeform = (typeof s.allowFreeform === 'boolean') ? s.allowFreeform : allowDefault;

  return {
    label,
    key,
    persistKey: s.persistKey || ('ctx.'+key),
    type: isRepeaterTA ? 'repeater-typeahead' : 'typeahead',
    dataset,
    filterUnit: s.unit || s.itemLabel || null,
    allowFreeform,
    placeholder: s.ph || s.placeholder || ''
  };
}
  function slugify(s){
    return String(s||'').toLowerCase().replace(/&/g,' and ').replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'').replace(/-+/g,'-');
  }
  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  // ---------- Single type-ahead (Slice 1) ----------
 function upgradeSingle(root, meta){
  if (!root || !meta) return;
  if (meta.type !== 'typeahead') return; // hard guard: singles only
    const sel = `[name="${meta.key}"], [data-key="${meta.key}"]`;
    const input = root.querySelector(sel);
    if (!input) return;

    let shell = input.closest('.ta-shell');
    if (!shell){
      shell = document.createElement('div');
      shell.className = 'ta-shell';
      input.parentNode.insertBefore(shell, input);
      shell.appendChild(input);
    }
    let menu = shell.querySelector('.ta-menu');
    if (!menu){
      menu = document.createElement('div');
      menu.className = 'ta-menu';
      menu.setAttribute('role','listbox');
      menu.hidden = true;
      shell.appendChild(menu);
    }
    let hint = shell.querySelector('.ta-hint');
    if (!hint){
      hint = document.createElement('div');
      hint.className = 'ta-hint';
      hint.hidden = true;
      shell.appendChild(hint);
    }

    input.setAttribute('role','combobox');
    input.setAttribute('aria-expanded','false');
    const listboxId = `${meta.key}-menu`;
    menu.id = listboxId;
    input.setAttribute('aria-controls', listboxId);
    if (meta.placeholder) input.setAttribute('placeholder', meta.placeholder);

    const saved = getAtPath(WIZ.state, meta.persistKey);
    if (saved && typeof saved==='object'){
      input.value = saved.name || '';
      input.dataset.selectedId = saved.id || '';
    }

    let items = [], active = -1, open = false;
    const adapter = ()=> (WIZ.datasets[meta.dataset] || null);
    function refreshHint(){
      const ad = adapter();
      const missing = !ad || typeof ad.filter!=='function' || typeof ad.getById!=='function';
      if (meta.dataset==='biases' && missing && !meta.allowFreeform){
        hint.textContent = 'Bias library not loaded — suggestions unavailable.';
        hint.hidden = false;
      } else { hint.hidden = true; }
    }
    refreshHint();

    function renderMenu(q){
      const ad = adapter();
      const hasAdapter = ad && typeof ad.filter==='function';
      items = hasAdapter ? (ad.filter(q, 30, meta.filterUnit) || []) : [];
      if ((!items || !items.length) && meta.allowFreeform && q.trim().length){
        items = [{ id:'custom:'+q.trim(), name:q.trim() }];
      }
      if (!items.length){ close(); return; }
      menu.innerHTML = items.map((it,i)=>(
        `<div class="ta-item" role="option" data-idx="${i}" aria-selected="${i===0?'true':'false'}">
           <div class="name"><strong>${escapeHtml(it.name)}</strong></div>
           ${it.summary ? `<div class="muted" style="font-size:12px">${escapeHtml(String(it.summary))}</div>` : ''}
         </div>`
      )).join('');
      active = 0; openMenu();
    }
    function openMenu(){ menu.hidden = false; open = true; input.setAttribute('aria-expanded','true'); }
    function close(){ menu.hidden = true; open = false; active = -1; input.setAttribute('aria-expanded','false'); }
    function highlight(i){ [...menu.children].forEach((n,k)=> n.setAttribute('aria-selected', k===i?'true':'false')); active = i; }
    function pick(i){
      const it = items[i]; if (!it) return;
      input.value = it.name || '';
      input.dataset.selectedId = String(it.id||'').trim();
      setAtPath(WIZ.state, meta.persistKey, { id: input.dataset.selectedId, name: input.value });
      saveState(WIZ.state);
      close(); input.focus();
    }

    input.addEventListener('input', ()=>{ const q = input.value||''; if (!q.trim()){ close(); return; } renderMenu(q); });
    input.addEventListener('keydown', (e)=>{
      if (!open){
        if (e.key==='Enter' && meta.allowFreeform){
          const name = input.value.trim();
          if (name){
            const id = input.dataset.selectedId || ('custom:'+name);
            setAtPath(WIZ.state, meta.persistKey, { id, name }); saveState(WIZ.state);
          }
        }
        return;
      }
      const rows = [...menu.children];
      if (e.key==='ArrowDown'){ e.preventDefault(); highlight(Math.min(active+1, rows.length-1)); }
      else if (e.key==='ArrowUp'){ e.preventDefault(); highlight(Math.max(active-1, 0)); }
      else if (e.key==='Enter'){ e.preventDefault(); pick(active>=0?active:0); }
      else if (e.key==='Escape'){ e.preventDefault(); close(); }
    });
    menu.addEventListener('mousedown', (e)=>{ const row=e.target.closest('.ta-item'); if(!row)return; const i=+row.getAttribute('data-idx')||0; pick(i); });
    input.addEventListener('blur', ()=> setTimeout(close, 120));

    function onLoaded(){
      refreshHint();
      const val = getAtPath(WIZ.state, meta.persistKey);
      if (val && val.id && (!val.name || !input.value)){
        const ad = adapter(); const obj = ad && ad.getById ? ad.getById(val.id) : null;
        if (obj){ input.value=obj.name; setAtPath(WIZ.state, meta.persistKey, { id: val.id, name: obj.name }); saveState(WIZ.state); }
      }
      if (document.activeElement === input && input.value.trim()){ renderMenu(input.value); }
    }
    document.addEventListener(`wizard:dataset:${meta.dataset}:loaded`, onLoaded);
  }

  // ---------- Repeater type-ahead (Slice 2) ----------
function upgradeRepeater(root, meta){
  if (!root || !meta) return;
  if (meta.type !== 'repeater-typeahead') return; // hard guard: repeaters only
    const sel = `[name="${meta.key}"], [data-key="${meta.key}"]`;
    const hidden = root.querySelector(sel); // textarea from renderer
    if (!hidden) return;

    // hide the original textarea but KEEP it for storage + preview pipeline
    hidden.hidden = true;

    // Create shell
    let shell = hidden.nextElementSibling && hidden.nextElementSibling.classList?.contains('ta-shell')
      ? hidden.nextElementSibling
      : null;
    if (!shell){
      shell = document.createElement('div');
      shell.className = 'ta-shell';
      hidden.insertAdjacentElement('afterend', shell);
    }

    // Chips, input, menu, hint
    let chips = shell.querySelector('.chips'); if (!chips){ chips = document.createElement('div'); chips.className='chips'; shell.appendChild(chips); }
    let input = shell.querySelector('.chip-input'); if (!input){ input = document.createElement('input'); input.type='text'; input.className='chip-input'; shell.appendChild(input); }
    let menu  = shell.querySelector('.ta-menu'); if (!menu){ menu = document.createElement('div'); menu.className='ta-menu'; menu.setAttribute('role','listbox'); menu.hidden = true; shell.appendChild(menu); }
    let hint  = shell.querySelector('.ta-hint'); if (!hint){ hint = document.createElement('div'); hint.className='ta-hint'; hint.hidden = true; shell.appendChild(hint); }

    // A11y
    input.setAttribute('role','combobox');
    input.setAttribute('aria-expanded','false');
    const listboxId = `${meta.key}-menu`;
    menu.id = listboxId;
    input.setAttribute('aria-controls', listboxId);
    if (meta.placeholder) input.setAttribute('placeholder', meta.placeholder);

    // Rehydrate picks from state
    let picks = [];
    const saved = getAtPath(WIZ.state, meta.persistKey);
    if (Array.isArray(saved)){ picks = saved.map(x=> ({ id:String(x.id), name:String(x.name) })); }

    // Helpers
    const adapter = ()=> (WIZ.datasets[meta.dataset] || null);
    function refreshHint(){
      const ad = adapter();
      const missing = !ad || typeof ad.filter!=='function' || typeof ad.getById!=='function';
      if (meta.dataset==='biases' && missing && !meta.allowFreeform){
        hint.textContent = 'Bias library not loaded — suggestions unavailable.';
        hint.hidden = false;
      } else { hint.hidden = true; }
    }
    refreshHint();

    function hasId(id){ return picks.some(p => String(p.id)===String(id)); }
    function renderChips(){
      chips.innerHTML = picks.map(p =>
        `<span class="chip" data-id="${p.id}">${escapeHtml(p.name)} <button class="x" title="remove" aria-label="remove" data-id="${p.id}">×</button></span>`
      ).join('');
    }
    function persist(){
      setAtPath(WIZ.state, meta.persistKey, picks.map(p=>({ id:p.id, name:p.name })));
      saveState(WIZ.state);
      // keep original textarea in sync for the composer (newline-joined)
      hidden.value = picks.map(p=>p.name).join('\n');
      // dispatch an input event so the wizard’s oninput updates VALUES + preview
      hidden.dispatchEvent(new Event('input', { bubbles:true }));
    }
    function addPick(obj){
      const id = String(obj.id || ('custom:'+obj.name)).trim();
      const name = String(obj.name || obj.label || obj.id || '').trim();
      if (!id || !name || hasId(id)) return;
      picks.push({ id, name }); renderChips(); persist();
    }
    function removePick(id){
      picks = picks.filter(p => String(p.id)!==String(id));
      renderChips(); persist();
    }

    // Suggestions
    let items = [], active = -1, open = false;
    function openMenu(){ menu.hidden=false; open=true; input.setAttribute('aria-expanded','true'); }
    function close(){ menu.hidden=true; open=false; active=-1; input.setAttribute('aria-expanded','false'); }
    function highlight(i){ [...menu.children].forEach((n,k)=> n.setAttribute('aria-selected', k===i?'true':'false')); active=i; }

    function renderMenu(q){
      const ad = adapter();
      const hasAdapter = ad && typeof ad.filter==='function';
      items = hasAdapter ? (ad.filter(q, 30, meta.filterUnit) || []) : [];
      if ((!items || !items.length) && meta.allowFreeform && q.trim().length){
        items = [{ id:'custom:'+q.trim(), name:q.trim() }];
      }
      if (!items.length){ close(); return; }
      menu.innerHTML = items.map((it,i)=>(
        `<div class="ta-item" role="option" data-idx="${i}" aria-selected="${i===0?'true':'false'}">
           <div class="name"><strong>${escapeHtml(it.name)}</strong></div>
           ${it.summary ? `<div class="muted" style="font-size:12px">${escapeHtml(String(it.summary))}</div>` : ''}
         </div>`
      )).join('');
      active = 0; openMenu();
    }

    function pick(i){
      const it = items[i]; if (!it) return;
      addPick(it); input.value=''; close(); input.focus();
    }

    // Wire DOM
    renderChips(); persist(); // ensure hidden textarea mirrors any existing state

    input.addEventListener('input', ()=>{
      const q = input.value || '';
      if (!q.trim()){ close(); return; }
      renderMenu(q);
    });
    input.addEventListener('keydown', (e)=>{
      if (!open){
        // Backspace with empty → remove last chip
        if (e.key==='Backspace' && !input.value.trim() && picks.length){ e.preventDefault(); removePick(picks[picks.length-1].id); }
        // Enter with freeform allowed → add as custom
        if (e.key==='Enter' && meta.allowFreeform){
          const name = input.value.trim();
          if (name){ addPick({ id:'custom:'+name, name }); input.value=''; }
        }
        return;
      }
      const rows = [...menu.children];
      if (e.key==='ArrowDown'){ e.preventDefault(); highlight(Math.min(active+1, rows.length-1)); }
      else if (e.key==='ArrowUp'){ e.preventDefault(); highlight(Math.max(active-1, 0)); }
      else if (e.key===',' || e.key==='Enter'){ e.preventDefault(); pick(active>=0?active:0); }
      else if (e.key==='Escape'){ e.preventDefault(); close(); }
    });
    // Paste batch (only if freeform is allowed)
    input.addEventListener('paste', (e)=>{
      if (!meta.allowFreeform) return;
      const txt = (e.clipboardData && e.clipboardData.getData('text')) || '';
      if (!txt || !/[,\n;]/.test(txt)) return;
      e.preventDefault();
      txt.split(/[,\n;]+/).map(s=>s.trim()).filter(Boolean).forEach(name=>{
        addPick({ id:'custom:'+name, name });
      });
      input.value='';
    });

    menu.addEventListener('mousedown', (e)=>{
      const row = e.target.closest('.ta-item'); if (!row) return;
      const i = parseInt(row.getAttribute('data-idx')||'-1',10); if (i>=0) pick(i);
    });
    input.addEventListener('blur', ()=> setTimeout(close, 120));
    chips.addEventListener('click', (e)=>{
      const x = e.target.closest('.x'); if (!x) return;
      const id = x.getAttribute('data-id'); removePick(id);
    });

    function onLoaded(){
      refreshHint();
      // Rehydrate names from ids if dataset got richer
      const ad = adapter();
      if (ad && ad.getById){
        let changed = false;
        picks = picks.map(p=>{
          const hit = ad.getById(p.id);
          if (hit && hit.name && hit.name!==p.name){ changed = true; return { id:p.id, name:hit.name }; }
          return p;
        });
        if (changed){ renderChips(); persist(); }
      }
      if (document.activeElement === input && input.value.trim()){ renderMenu(input.value); }
    }
    document.addEventListener(`wizard:dataset:${meta.dataset}:loaded`, onLoaded);
  }

  // ---------- Public API ----------
  let STEP_SCHEMAS = [];
  WIZ.setStepSchemas = (arr)=>{ STEP_SCHEMAS = Array.isArray(arr)? arr : []; };

  WIZ.upgradeSingles = (rootEl)=>{
    const root = rootEl || document.getElementById('wizStepBody');
    const singles = STEP_SCHEMAS.map(normalize).filter(m => m.type==='typeahead');
    singles.forEach(m => upgradeSingle(root, m));
  };

  WIZ.upgradeRepeaters = (rootEl)=>{
    const root = rootEl || document.getElementById('wizStepBody');
    const reps = STEP_SCHEMAS.map(normalize).filter(m => m.type==='repeater-typeahead');
    reps.forEach(m => upgradeRepeater(root, m));
  };

})();
</script>

<style>
/* ==== Slice 0: Preview drawer + Optional pill ================================= */

/* Slice 1: Common Context toggle */
#commonCtxToggle { display:inline-block; width:auto; }

/* Top preview button: force inline size/placement */
#pvToggleTop{
  display: inline-block !important;
  width: auto !important;
  align-self: flex-start;
  margin: 6px 0 0 0;
}

/* Right-side drawer */
#pvDrawer{
  position: fixed;
  top: 0; right: 0;
  height: 100dvh;
  width: 38vw;
  max-width: 560px;
  min-width: 320px;
  background: var(--panel, #fff);
  box-shadow: -2px 0 12px rgba(0,0,0,.12);
  transform: translateX(100%);
  transition: transform .25s ease;
  z-index: 1000;
  display: flex;
  flex-direction: column;
}
#pvDrawer.open{ transform: translateX(0); }

#pvHead{
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 12px;
  border-bottom: 1px solid rgba(0,0,0,.08);
  position: sticky; top: 0; background: inherit;
}
#pvBody{ padding: 12px; overflow: auto; }
#pvOut{
  white-space: pre-wrap;
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  line-height: 1.35; font-size: 13px;
}
#pvActions{ display: flex; gap: 8px; align-items: center; }
#pvCopyStatus{ font-size: 12px; opacity: .75; margin-top: 6px; }

@media (max-width: 760px){ #pvDrawer{ width: 88vw; } }

/* Optional pill (scoped to Steps view body) */
#wizStepBody .field>label{
  display: flex; align-items: center; gap: 8px; flex-wrap: wrap;
}
#wizStepBody .field>label::after{
  content: 'optional';
  font-size: 11px; line-height: 1;
  padding: 2px 6px; border-radius: 999px;
  background: rgba(127,127,127,.12); color: var(--muted-fg, #555);
  border: 1px solid rgba(0,0,0,.08);
}

/* “Everything here is optional” banner */
#optMsg{
  margin: 0 0 8px; padding: 6px 10px; border-radius: 6px;
  background: rgba(127,127,127,.08); color: var(--muted-fg, #444);
  font-size: 13px;
}
</style>

<!-- ==== Slice 0: Preview Drawer ================================================= -->
<aside id="pvDrawer" aria-label="Prompt preview">
  <div id="pvHead">
    <strong>Output preview</strong>
    <div id="pvActions">
      <button id="pvCopy" class="btn sm" type="button">Copy</button>
      <button id="pvClose" class="btn sm" type="button">Close</button>
    </div>
  </div>
  <div id="pvBody">
    <pre id="pvOut" aria-live="polite">(your generated prompt will appear here)</pre>
    <div id="pvCopyStatus" class="muted" hidden></div>
  </div>
</aside>

<script>
/* ==== Slice 0: Preview toggle + drawer wiring ================================= */
(function(){
  const LS_KEY_PREVIEW = 'pb.wizard.previewOpen';

  function el(id){ return document.getElementById(id); }
  function isOpen(){ return localStorage.getItem(LS_KEY_PREVIEW) === '1'; }
  function setOpen(open){
    localStorage.setItem(LS_KEY_PREVIEW, open ? '1' : '0');
    const dr = el('pvDrawer');
    if (dr){ dr.classList.toggle('open', !!open); }
    setToggleTexts();
    updatePreview();
  }
  function setToggleTexts(){
    const txt = isOpen() ? 'hide output' : 'show output';
    const a = el('pvToggleTop');  if (a) a.textContent = txt;
    const b = el('pvToggleFoot'); if (b) b.textContent = txt;
  }
  function updatePreview(){
    const pvOut = el('pvOut');
    if (!pvOut) return;
    try{
      const txt = (typeof window.wiz_composePrompt === 'function') ? window.wiz_composePrompt() : '';
      pvOut.textContent = txt || '(no content yet)';
    }catch(_){ pvOut.textContent = '(no content yet)'; }
  }

  // Create/ensure the two toggle buttons (top bar + footer row)
window.ensurePreviewButtons = function ensurePreviewButtons(){
  // Top bar: append to #wizTopProgress, small & left-aligned
  const top = el('wizTopProgress');
  if (top && !el('pvToggleTop')){
    const btn = document.createElement('button');
    btn.id = 'pvToggleTop'; btn.className = 'btn sm'; btn.type = 'button';
    btn.style.display = 'inline-block';
    btn.style.width = 'auto';
    btn.style.marginTop = '6px';
    btn.addEventListener('click', () => setOpen(!isOpen()));
    top.appendChild(btn); // small, inline due to CSS override
  }

  // Footer: insert as the FIRST button (left side), so drawer on right won’t cover it
  const next = el('wizStepNext');
  if (next && !el('pvToggleFoot')){
    const btn = document.createElement('button');
    btn.id = 'pvToggleFoot'; btn.className = 'btn sm'; btn.type = 'button';
    btn.style.marginRight = '8px';
    btn.addEventListener('click', () => setOpen(!isOpen()));
    const wrap = next.parentElement;
    if (wrap) {
      wrap.insertBefore(btn, wrap.firstChild); // left-most
    }
  }

  setToggleTexts();
};

  // Insert the “Everything here is optional” banner at the top of the step body
  window.insertOptionalityBanner = function insertOptionalityBanner(){
    const body = el('wizStepBody');
    if (!body || el('optMsg')) return;
    const div = document.createElement('div');
    div.id = 'optMsg';
    div.textContent = 'Everything here is optional — fill only what helps.';
    body.insertAdjacentElement('afterbegin', div);
  };

  function bindDrawer(){
    const closeBtn = el('pvClose');
    if (closeBtn) closeBtn.addEventListener('click', () => setOpen(false));

const copyBtn = el('pvCopy');
if (copyBtn){
  copyBtn.addEventListener('click', ()=>{
    const text = (typeof window.wiz_composePrompt === 'function')
      ? window.wiz_composePrompt()
      : (el('pvOut')?.textContent || '');
    if (typeof window.openCopyModal === 'function'){
      window.openCopyModal(text);
    } else if (typeof window.openCopyModalFromOut === 'function'){
      window.openCopyModalFromOut();
    }
  });
}

    // Honor previous state
    setOpen(isOpen());
    updatePreview();
  }

  // Init on DOM ready
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      window.ensurePreviewButtons();
      bindDrawer();
    }, { once: true });
  } else {
    window.ensurePreviewButtons();
    bindDrawer();
  }

  // Keep the drawer live whenever the app recomputes preview
  const prevRender = window.renderPreviewMaybe;
  window.renderPreviewMaybe = function(){
    if (typeof prevRender === 'function') prevRender.apply(this, arguments);
    updatePreview();
  };
})();
</script>

<script>
/* ==== Slice 1: Common Context Collapse (persisted, live counter, a11y) ======= */
(function(){
  const LS_KEY = 'pb.wizard.cc.open';    // 1=open, 0=closed
  const IDS    = ['ctx_use','ctx_aud','ctx_style','ctx_tone'];

  function get(id){ return document.getElementById(id); }
  function readOpen(){ return localStorage.getItem(LS_KEY) === '1'; }
  function writeOpen(open){ try{ localStorage.setItem(LS_KEY, open?'1':'0'); }catch(_){ } }

  function countFilled(){
    // use existing fieldFilled(id) so it respects VALUES map across renders
    let n = 0;
    for (const id of IDS){ try{ if (typeof fieldFilled==='function' && fieldFilled(id)) n++; }catch(_){ /*noop*/ } }
    return n;
  }

  function updateCountText(){
    const el = get('commonCtxCount');
    if (el) el.textContent = String(countFilled());
  }

  function setOpen(open){
    const body = get('commonCtxBody');
    const btn  = get('commonCtxToggle');
    if (!body || !btn) return;

    body.hidden = !open;
    btn.setAttribute('aria-expanded', open ? 'true' : 'false');
    btn.textContent = open ? 'hide' : 'show';
    writeOpen(open);
  }

  function wireOnce(){
    const btn  = get('commonCtxToggle');
    const body = get('commonCtxBody');
    if (!btn || !body) return;
    if (btn._wired) { updateCountText(); setOpen(readOpen()); return; }

    // Toggle button
    btn.addEventListener('click', ()=>{
      const open = btn.getAttribute('aria-expanded') === 'true';
      setOpen(!open);
      if (!open){
        // moved to open state → focus first field
        const first = get('ctx_use') || body.querySelector('input,textarea,select,button,[tabindex]');
        if (first) first.focus();
      } else {
        // closed → return focus to toggle
        btn.focus();
      }
    });

    // Live counter (input/change)
    IDS.forEach(id=>{
      const el = get(id);
      if (!el) return;
      el.addEventListener('input',  updateCountText);
      el.addEventListener('change', updateCountText);
    });

    // Initial paint from persisted state + current values
    updateCountText();
    setOpen(readOpen());

    // Screen reader friendly: announce count updates politely
    const head = get('commonCtxHead');
    if (head) head.setAttribute('aria-live','polite');

    btn._wired = true;
  }

  // Public hook the renderer will call after each step paint
  window.ensureCommonCtxCollapse = function ensureCommonCtxCollapse(){
    // After DOM re-render, re-hydrate fields first (caller does), then wire.
    wireOnce();
  };
})();
</script>

<script>
/* ==== Slice 2/3: Assist-lite (“help fill this field”) =======================
   - Adds a left-aligned checkbox per .field (text, textarea, select).
   - When checked, appends a deterministic assist block to composed output.
   - Multiple checked → multiple blocks appended, separated by ---.
   - Idempotent, persists per-field across navigation (localStorage).
============================================================================= */
(function(){
  const LS_KEY = 'pb.wizard.assistLite.v1';        // { [fieldId]: true }
  const META   = new Map();                         // fieldId -> meta snapshot

  function $(id){ return document.getElementById(id); }
  function wizVal(id){
    try{
      if (typeof window.wiz_getVal === 'function') return window.wiz_getVal(id);
    }catch(_){}
    const el = $(id); return el ? (el.value || '') : '';
  }

  function loadAssist(){
    try{
      const o = JSON.parse(localStorage.getItem(LS_KEY) || '{}');
      return (o && typeof o==='object') ? o : {};
    }catch(_){ return {}; }
  }
  function saveAssist(mapObj){
    try{ localStorage.setItem(LS_KEY, JSON.stringify(mapObj||{})); }catch(_){}
  }

  /** Collect field meta from a .field wrapper (once per render). */
  function collectMeta(fieldWrap){
    if (!fieldWrap) return;
    // Prefer first control in the field
    const ctl = fieldWrap.querySelector('textarea, select, input[id]');
    if (!ctl || !ctl.id) return;

    const id   = ctl.id;
    const lab  = fieldWrap.querySelector(':scope > label')?.textContent?.trim() || '';
    const desc = fieldWrap.querySelector('.desc')?.cloneNode(true);
    let descText = '';
    if (desc){
      // get plain text without our assist control
      const assistNode = desc.querySelector('.assist-lite');
      if (assistNode) assistNode.remove();
      descText = desc.textContent.trim();
    }

    // normalize type
    let type = 'text';
    if (ctl.tagName === 'TEXTAREA') type = 'textarea';
    else if (ctl.tagName === 'SELECT') type = 'select';
    else if (ctl.tagName === 'INPUT') type = (ctl.getAttribute('type') || 'text').toLowerCase();

    // select options (labels)
    let options = [];
    if (type === 'select'){
      options = [...ctl.querySelectorAll('option')].map(o => (o.textContent||'').trim()).filter(Boolean);
    }

    META.set(id, {
      id, label: lab, type,
      placeholder: (ctl.getAttribute('placeholder') || '(none)'),
      desc: descText || '',
      options
    });
  }

  /** Build one deterministic assist block from meta + live value. */
  function buildBlock(meta){
    const val = wizVal(meta.id);
    let block = `I need help completing a form field.

[Field Meta]
Label: ${meta.label || '(unknown)'}
Key: ${meta.id}
Type: ${meta.type}
Placeholder: ${meta.placeholder || '(none)'}
Description: ${meta.desc || ''}
Current value: ${val || ''}

[What I need]
1) If the value is empty: briefly explain what belongs here (1–2 sentences), then ask up to 3 targeted questions that would let you complete it well, and propose 3 draft fills.
2) If the value exists: give a 1-line assessment, then provide 3 improved variants (refine/expand as appropriate).

[Type rules]
- text → 1 crisp sentence.
- textarea → 1–3 short paragraphs.
- select → 5–7 option labels with 1-line rationales, then recommend the best 1.
- tags → comma-separated list of 5–10 tags.
- number → a single number with a 1-line justification.
- url/email → a single valid value plus a 1-line justification.

[Output format]
Fill 1:
Fill 2:
Fill 3:
Questions: (only if needed)
Notes: (assumptions or tradeoffs)
`;
    if (meta.type === 'select' && Array.isArray(meta.options) && meta.options.length){
      block += `\n[Available options]\n` + meta.options.map(op => `- ${op}`).join('\n') + '\n';
    }
    return block;
  }

  /** Compose the concatenated assist blocks for all checked fields. */
  function composeAssistBlocks(){
    const state = loadAssist();
    const ids = Object.keys(state).filter(k => !!state[k]);
    if (!ids.length) return '';
    const parts = [];
    for (const id of ids){
      // If meta wasn't captured this session (e.g., field currently offscreen), try to collect now
      if (!META.has(id)){
        const el = $(id); if (el) collectMeta(el.closest('.field'));
      }
      const meta = META.get(id);
      if (!meta) continue;
      parts.push(buildBlock(meta));
    }
    return parts.join('\n---\n');
  }

  /** Inject a checkbox into each eligible .field on the current step body. */
  function decorateFieldsOnceIn(container){
    if (!container) return;
    const state = loadAssist();

    const fields = container.querySelectorAll('.field');
    fields.forEach(wrap=>{
      const ctl = wrap.querySelector('textarea, select, input[id]');
      if (!ctl || !ctl.id) return; // nothing to decorate

      // Only decorate text, textarea, select (as requested)
      const tag = ctl.tagName;
      const type = (ctl.getAttribute('type')||'text').toLowerCase();
      if (!(tag==='TEXTAREA' || tag==='SELECT' || (tag==='INPUT' && (type==='text' || type==='search' || type==='url' || type==='email' || type==='number')))) return;

      const desc = wrap.querySelector('.desc');
      // Create the control if not already present
      const existing = wrap.querySelector(`.assist-lite[data-for="${ctl.id}"]`);
      if (!existing){
        const lab = document.createElement('label');
        lab.className = 'assist-lite';
        lab.setAttribute('data-for', ctl.id);
        lab.innerHTML = `<input type="checkbox" aria-label="help fill this field"> help fill this field`;

        // Place inline with desc if present; otherwise create a desc holder
        if (desc){
          desc.appendChild(lab);
        }else{
          const d = document.createElement('div');
          d.className = 'desc';
          d.appendChild(lab);
          wrap.appendChild(d);
        }

        // Bind behavior
        const box = lab.querySelector('input[type="checkbox"]');
        box.checked = !!state[ctl.id];
        box.addEventListener('change', ()=>{
          const s = loadAssist();
          if (box.checked) s[ctl.id] = true; else delete s[ctl.id];
          saveAssist(s);
          // collect meta on first interaction
          if (!META.has(ctl.id)) collectMeta(wrap);
          // live preview update
          if (typeof window.renderPreviewMaybe === 'function') window.renderPreviewMaybe();
        });

        // On first paint, collect meta
        collectMeta(wrap);
      }else{
        // ensure checked state matches persisted state
        const box = existing.querySelector('input[type="checkbox"]');
        if (box) box.checked = !!state[ctl.id];
      }
    });
  }

  // Public hook called after each step render
  window.ensureAssistLite = function ensureAssistLite(){
    const body = document.getElementById('wizStepBody');
    decorateFieldsOnceIn(body);
  };

  // Wrap the composer ONCE to append assist blocks after the base prompt
  (function wrapComposerOnce(){
    const orig = window.wiz_composePrompt;
    if (!orig || orig._assistLiteWrapped) return;
    function wrapped(){
      const base = String(orig.apply(this, arguments) || '');
      const extra = composeAssistBlocks();
      if (!extra) return base;
      return base ? (base + '\n\n' + extra) : extra;
    }
    wrapped._assistLiteWrapped = true;
    window.wiz_composePrompt = wrapped;
  })();

})();
</script>



  <!-- ===== Only external deps (datasets) ===== -->
  <script src="./js/personas.data.js"></script>
<script src="./js/biases.data.js"></script>
     <script src="./js/aisettings.js" defer></script>
  <script src="./js/templates.data.js"></script>
  <script src="./js/templates.tasks.data.js"></script>
  
  <script>
// Slice 1: dataset bridges → build adapters from window.PERSONAS / window.BIASES
(function(){
  function toAdapter(list){
    // Normalize items → {id,name,unit,kind,summary}
    const norm = (x)=>({
      id:      x.id || x.slug || x.key || x.name,
      name:    x.name || x.label || x.id || '',
      unit:    x.unit || x.kind || '',
      kind:    x.kind || x.unit || '',
      summary: x.summary || x.description || x.def || ''
    });
    const L = Array.isArray(list) ? list.map(norm).filter(i => i.id && i.name) : [];
    const byId = new Map(L.map(i => [String(i.id).toLowerCase(), i]));

    return {
      filter(q, limit=30, filterUnit){
        const s = String(q||'').toLowerCase().trim();
        let arr = s ? L.filter(i => i.name.toLowerCase().includes(s) || String(i.id).toLowerCase().includes(s)) : L.slice();
        if (filterUnit){
          const want = String(filterUnit);
          arr = arr.filter(i => String(i.unit||i.kind||'') === want);
        }
        return arr.slice(0, limit);
      },
      getById(id){
        const key = String(id||'').toLowerCase();
        return byId.get(key) || L.find(i => String(i.id).toLowerCase() === key) || null;
      }
    };
  }

  // Personas → adapter → notify
  if (Array.isArray(window.PERSONAS)){
    const personasAdapter = toAdapter(window.PERSONAS);
    document.dispatchEvent(new CustomEvent('wizard:dataset:personas:loaded', {
      detail: { adapter: personasAdapter }
    }));
  }

  // Biases → adapter → notify
  if (Array.isArray(window.BIASES)){
    const biasesAdapter = toAdapter(window.BIASES);
    document.dispatchEvent(new CustomEvent('wizard:dataset:biases:loaded', {
      detail: { adapter: biasesAdapter }
    }));
  }
})();
</script>

<script>
(function injectTemplateIndex(){
  try{
    // Require these to exist; bail quietly if they don't
    if (typeof allTemplates !== 'function') return;

    var MAX = 50; // keep it light; bump later if you wish
    var base = 'https://jonathankhobson.github.io/AI/glossary/startup-wizard.html';
    var listEl = document.getElementById('templateIndexList');
    if (!listEl) return;

    // Utility: label, slug, and simple HTML escape
    function escapeHtml(s){ return String(s||'').replace(/[&<>"]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m])); }
    function slugifyLoose(s){
      return String(s||'').toLowerCase()
        .replace(/&/g,' and ')
        .replace(/[^a-z0-9]+/g,'-')
        .replace(/^-+|-+$/g,'')
        .replace(/-+/g,'-');
    }

    // Pull in all templates from your existing sources
    var T = allTemplates();

    // Filter out helper/picker meta-templates to keep the list useful
    var rows = T
      .filter(function(t){ return !(typeof isHelperTemplate === 'function' && isHelperTemplate(t)); })
      .map(function(t){
        var label = t.label || t.slug || t.id || 'template';
        var slug  = t.slug || t.id || slugifyLoose(label);
        return { label: String(label).trim(), slug: String(slug).trim() };
      })
      .filter(function(x){ return x.slug; })
      .sort(function(a,b){ return a.label.localeCompare(b.label); })
      .slice(0, MAX);

    // Render crawlable HTML list
    listEl.innerHTML = rows.map(function(r){
      var url = base + '?slug=' + encodeURIComponent(r.slug);
      return '<li><a href="'+url+'">'+escapeHtml(r.label)+'</a></li>';
    }).join('');

    // Also publish an ItemList JSON-LD with the same items
    var json = {
      "@context": "https://schema.org",
      "@type": "ItemList",
      "@id": base + "#templates",
      "name": "Startup Wizard Templates",
      "itemListElement": rows.map(function(r, i){
        return {
          "@type": "ListItem",
          "position": i + 1,
          "url": base + "?slug=" + encodeURIComponent(r.slug),
          "name": r.label
        };
      })
    };
    var tag = document.createElement('script');
    tag.type = 'application/ld+json';
    tag.textContent = JSON.stringify(json);
    document.head.appendChild(tag);
  }catch(_){}
})();

// Optional: deep-link to Step 0 or Steps if a hash is present.
// Example: startup-wizard.html?slug=template-slug#step0
(function enableDeepLinks(){
  try{
    var params = new URLSearchParams(location.search);
    var slug = params.get('slug') || '';
    var hash = (location.hash || '').toLowerCase();

    if (!slug) return;
    if (typeof allTemplates !== 'function') return;

    var T = allTemplates();
    var t = T.find(function(x){ return (x.slug||x.id||'').toString().toLowerCase() === slug.toLowerCase(); });
    if (!t) return;

    // Helper shims from your page (guarded)
    var toStep0 = (typeof openStep0 === 'function') ? openStep0 : null;
    var toSteps = (typeof showView  === 'function') ? showView  : null;
    if (typeof setCurrentTemplate === 'function') setCurrentTemplate(t);

    if (hash === '#step0' && toStep0){
      toStep0(t);
    }else if (hash === '#steps' && toSteps){
      // If your controller needs to open steps from t, add a hook here
      // e.g., ensure fields are built, then show steps view:
      try{ toStep0 && toStep0(t); }catch(_){}
      toSteps('steps');
    }
  }catch(_){}
})();
</script>
  
</body>
</html>
