<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prompt Template Builder (beta)</title>
  <style>
:root{
  /* Neutrals */
  --bg:      #fafafa;   /* page background */
  --fg:      #0f1720;   /* primary text (deep navy-slate) */
  --muted:   #506070;   /* secondary text */
  --chip:    #f3f6fa;   /* quiet chip surface */
  --border:  #e3e9f2;   /* hairline borders */
  --accent:  #1e293b;   /* strong headings / accents */

  /* Interaction + effects */
  --focus:   #0ea5e9;   /* focus ring (2px, offset 2px) */
  --shadow:  0 12px 40px rgba(0,0,0,.08); /* card/base shadow */
  --radius:  16px;      /* default large radius */

  /* Rainbow palette (for glimmer/hover)  */
  --r1:#ff007a; --r2:#ff8d00; --r3:#ffd600;
  --r4:#00dc82; --r5:#00d2ff; --r6:#7850ff;
    /* Primary/CTA fill that stays dark in both themes */
  --cta: #1e293b;
  
    /* Aliases to support existing rules in this file */
  --text: var(--fg);
  --card: #fff;
  --panel:#fff;
  --border-strong: var(--border);

  /* simple status colors already referenced below */
  --red:#ef4444; --green:#10b981; --yellow:#f59e0b; --purple:#8b5cf6;
}

/* === Dark theme overrides (restores dark mode) === */
html[data-theme="dark"]{
  /* Neutrals */
  --bg:     #0c1220;   /* deep navy background */
  --fg:     #e6ebf2;   /* primary text */
  --muted:  #9aa8b7;   /* secondary text */
  --chip:   #111827;   /* quiet chip surface */
   --border: #2f3f56;       /* a touch brighter than #233041 for visibility */
  --shadow: 0 8px 28px rgba(0,0,0,.50); /* slightly less chalky */
  --accent: #cbd5e1;   /* strong headings / accents */

  /* Surfaces (used by our aliases) */
  --card:   #0e1726;   /* card surfaces */
  --panel:  #0b1322;   /* panel / preview surfaces */

  /* Effects (slightly tighter shadow so it doesn't look chalky) */
  --shadow: 0 8px 28px rgba(0,0,0,.55);
  /* Keep --focus as-is; it reads well on dark. */
}

/* Slightly thicker borders in dark for readability */
html[data-theme="dark"] .btn,
html[data-theme="dark"] .chip,
html[data-theme="dark"] .tab,
html[data-theme="dark"] .panel,
html[data-theme="dark"] #out,
html[data-theme="dark"] .finder,
/* Slight contrast lift for small UI bits in dark */
html[data-theme="dark"] .finder,
html[data-theme="dark"] .tinyLabel,
html[data-theme="dark"] #tabContext,
html[data-theme="dark"] .step-hint{
  border-color: color-mix(in srgb, var(--border) 80%, var(--fg) 20%);
}
html[data-theme="dark"] .taList,
html[data-theme="dark"] select,
html[data-theme="dark"] input[type="text"],
html[data-theme="dark"] textarea {
  border-width: 1.25px;
}

/* === Dark-only surface fixes for legacy light styles === */
html[data-theme="dark"] .panel,
html[data-theme="dark"] #previewPanel,
html[data-theme="dark"] .outCard,
html[data-theme="dark"] .card,
html[data-theme="dark"] .modal-body,
html[data-theme="dark"] .dropdown,
html[data-theme="dark"] .taList,
html[data-theme="dark"] .finder,
html[data-theme="dark"] .input,
html[data-theme="dark"] select,
html[data-theme="dark"] input[type="text"],
html[data-theme="dark"] textarea {
  background: var(--card) !important;
  color: var(--fg) !important;
  border-color: var(--border) !important;
  box-shadow: var(--shadow);
}

/* Title chip & tiny pills gain a touch more contrast in dark */
html[data-theme="dark"] .block-title,
html[data-theme="dark"] .tinyLabel{
  border-color: color-mix(in srgb, var(--border) 70%, var(--fg) 30%);
}

/* Preview <pre> surface + border */
html[data-theme="dark"] #out{
  background: var(--panel) !important;
  color: var(--fg) !important;
  border: 1px solid var(--border) !important;
}

/* Typeahead rows hover state (keep it subtle on dark) */
html[data-theme="dark"] .taList .taItem:hover,
html[data-theme="dark"] .dropdown__row:hover{
  background: rgba(255,255,255,.04);
}

/* Chips, tabs, tiny pills — use dark chip surface + hairline border */
html[data-theme="dark"] .chip,
html[data-theme="dark"] .tabs .tab,
html[data-theme="dark"] .pill,
html[data-theme="dark"] .areaLabel{
  background: var(--chip);
  color: var(--fg);
  border-color: var(--border);
}

/* The little status dot inside .areaLabel — keep it visible on dark */
html[data-theme="dark"] .areaLabel .dot{
  background: var(--focus);
}

/* Headers/section titles keep readable contrast */
html[data-theme="dark"] h1, 
html[data-theme="dark"] h2, 
html[data-theme="dark"] h3, 
html[data-theme="dark"] .subhead, 
html[data-theme="dark"] .areaLabel{
  color: var(--fg);
}


/* Ambient rainbow glimmer (very subtle, behind everything) */
body::before{
  content:"";
  position: fixed;
  inset: auto auto 40% 0;                   /* top-left */
  width: min(70vw, 920px);
  height: min(70vh, 680px);
  pointer-events: none;
  z-index: -1;
  filter: blur(48px) saturate(115%);
  opacity: .08;  /* light */
  background:
    radial-gradient(120% 120% at 0% 0%, rgba(255,255,255,.85) 0 36%, transparent 52%),
    conic-gradient(from 210deg at 0% 0%,
      rgba(255,0,122,.22), rgba(255,141,0,.18),
      rgba(255,214,0,.18), rgba(0,220,130,.20),
      rgba(0,210,255,.18), rgba(120,80,255,.22), rgba(255,0,122,.22));
}
html[data-theme="dark"] body::before{ opacity: .06; } /* slightly softer in dark */

.modal::backdrop{ background: rgba(0,0,0,.4); }
.modal-body{ width:min(880px, 96vw); padding:16px; background:var(--bg); color:var(--text);
  border:1px solid var(--border); border-radius:12px; }
.modal-header{ display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; }
.modal-section .field{ margin:12px 0; }
.modal-footer{ display:flex; gap:8px; justify-content:flex-end; margin-top:8px; }
.modal .icon.close{ font-size:20px; line-height:1; }
#actionPreview{ width:100%; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
.scope-row{ display:flex; gap:24px; align-items:center; flex-wrap:wrap; }
.radio{ display:flex; gap:8px; align-items:center; }
.radio input{ transform: translateY(1px); }
.hint{ opacity:.7; font-weight:400; }
.note{ margin:6px 0 0; opacity:.75; font-size:.9em; }

.toast{
  position: fixed;
  right: 16px;
  bottom: 16px;
  max-width: 60ch;
  padding: 10px 12px;
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--chip);
  color: var(--text);
  box-shadow: 0 6px 20px rgba(0,0,0,.18);
  z-index: 9999;
  font-size: 13px;
}

.metaRow {
  display: flex;
  gap: 0.5rem;
}

.toast[hidden]{ display:none; }



    *{box-sizing:border-box}
    html,body{height:100%}
    html, body{
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
  color: var(--fg);
  background: var(--bg);
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
/* Section titles: lowercase vibe + subtle tracking */
h1, h2, h3, .subhead, .areaLabel {
  text-transform: lowercase;
  letter-spacing: 0.25px; /* within the 0.2–0.3px guidance */
  font-weight: 600;
}
    body{ margin:0; }
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}
    /* Buttons should never show link underlines */
a.btn,
a.btn:hover,
.btn,
.btn:hover,
.btn:focus,
.btn:active{
  text-decoration: none !important;
}

header{
  display:flex; align-items:center; gap:12px;
  padding:12px 16px;
  position:sticky; top:0; z-index:10;

  /* translucent surface + blur, with hairline bottom border */
  background: rgba(255,255,255,.78);
  -webkit-backdrop-filter: blur(10px);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid var(--border);
}

/* darker translucent header in dark mode */
html[data-theme="dark"] header{
  background: rgba(12,18,32,.65);
}

/* lowercase vibe for header labels/buttons only */
header .btn,
header strong,
header .pill,
header a{
  text-transform: lowercase;
  letter-spacing: .2px;
  font-weight: 600; /* crisp, not shouty */
}


    header .spacer{flex:1}
   .btn{
  cursor: pointer;
  display: inline-flex; align-items: center; justify-content: center; gap: .5ch;

  /* secondary by default (white surface) */
  background: var(--card);
  color: var(--fg);
  border: 1px solid var(--border);

  /* new shape/feel */
  padding: 9px 14px;
  border-radius: 999px;
  font-weight: 600;
  text-transform: lowercase;
  text-decoration: none;
  transition:
    transform .06s ease,
    box-shadow .12s ease,
    background-color .12s ease,
    color .12s ease,
    border-color .12s ease;
}

/* hover/active behavior (soft lift) */
.btn:hover{
  transform: translateY(-2px) scale(1.02);
  box-shadow: 0 12px 28px -14px rgba(0,0,0,.35), 0 4px 10px -6px rgba(0,0,0,.25);
}
.btn:active{
  transform: translateY(0);
  box-shadow: none;
}
.btn.primary{
  background: var(--cta);
  color: #fff;
  border: 1px solid transparent;
  box-shadow: none; /* no extra default puff; hover lift handles emphasis */
}



/* Subheader that matches our h3 section look */
.subhead{
  margin: 0 0 6px;
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
  padding-left: 12px;       /* aligns with the tabs' left pad */
}


.btn.sm{
  padding: 6px 12px;
  font-size: 14px;
  min-height: 32px;     /* NEW: consistent height */
}

/* Base button line-height & min-height for visual parity */
.btn{ min-height: 36px; line-height: 1.1; }
    
    /* Minimal, unobtrusive header toggles (Show/Hide beside section headers) */
.btn.ghost-min{
  background: transparent;
  border: 1px dashed var(--border);
  color: var(--muted);
  padding: 4px 10px;
  font-size: 12px;
  border-radius: 999px;
}
.btn.ghost-min:hover,
.btn.ghost-min:focus-visible{
  color: var(--fg);
  border-style: solid;
  box-shadow: none; /* global focus ring handles outline */
}
/* tiny chevron look for clarity */
.btn.ghost-min .chev{
  display:inline-block; transform: translateY(-1px);
  margin-right: 4px; opacity: .85;
}
    
    /* Danger button + helper text for save/reset */
.btn.danger{ background:var(--red); color:#fff; border:none }



/* Make Preview Show/Hide more visually distinct */
.btn.preview-toggle{
  border: 1px solid var(--border);
  background: var(--card);
  font-weight: 600;
}
/* Light-only: inverted look works fine here */
:root[data-theme="light"] .btn.preview-toggle.primary{
  background: var(--fg);
  color: #fff;
  border: 1px solid transparent;
}

/* Dark mode contrast fix for "Show Config" and "Show Preview" */
html[data-theme="dark"] .btn.preview-toggle.primary{
  background: var(--cta);   /* stays dark across themes */
  color: #fff;
  border: 1px solid transparent;
}

/* (optional) Slight hover lift that reads well on dark */
html[data-theme="dark"] .btn.preview-toggle.primary:hover,
html[data-theme="dark"] .btn.preview-toggle.primary:focus-visible{
  filter: brightness(1.05);
}



/* Motion language: springy ease for interactive bits */
.btn, .chip, .tab, .panel, .outCard{
  transition-timing-function: cubic-bezier(.2,.9,.2,1);
}
.btn:active, .chip:active, .tab:active{
  transform: translateY(1px) scale(0.995);
}


/* Make chips and tabs feel interactive */
.chip:hover, .tab:hover{ box-shadow:0 0 0 2px rgba(78,161,255,.20); }


.saveHelp{ margin-top:6px; }

   .toggle{
  display:inline-flex;align-items:center;gap:8px;
  border:1px solid var(--border);background:var(--chip);
  padding:6px 10px;border-radius:999px;
  color: var(--text); /* force readable text in both themes */
}
.toggle:hover, .toggle:focus-visible{
  box-shadow: 0 0 0 2px rgba(78,161,255,.25);
  outline: none;
}

    .dot{width:16px;height:16px;border-radius:50%;background:linear-gradient(180deg,#fdd835,#fbc02d);box-shadow:inset 0 -3px 6px rgba(0,0,0,.25)}
    :root[data-theme="light"] .dot{background:linear-gradient(180deg,#121621,#394554)}

.wrap{
  /* keep your 3-col grid exactly as-is */
  display:grid;
  grid-template-columns: var(--leftW, 360px) 6px 1fr; /* left | resizer | right */

  /* new: airy container */
  max-width: 1120px;
  margin: 0 auto;
  padding: 48px 20px 36px;
  gap: 24px;
}

/* Wide layout when Preview is visible (Show Preview clicked) */
.wrap:not(.preview-hidden){
  /* let the grid breathe across the viewport */
  max-width: none;          /* full-width container */
  margin-left: 0;
  margin-right: 0;
  /* keep comfortable page gutters */
padding-top: 40px;
padding-bottom: 28px;
}

/* Optional: cap extreme ultra-wide screens (comment out if you truly want 100% width) */
/*
@media (min-width: 1920px){
  .wrap:not(.preview-hidden){ max-width: 1600px; margin: 0 auto; }
}
*/

/* Slightly tighter vertical rhythm in wide mode */
.wrap:not(.preview-hidden){
  padding-top: 60px;   /* was 72px */
  padding-bottom: 32px;/* was 40px */
}

/* When the preview is hidden, give the left panel the whole stage */
.wrap.preview-hidden{ grid-template-columns: 1fr; }
.wrap.preview-hidden #resizer{ display:none; }
.wrap.preview-hidden #previewPanel{ display:none; }

/* Symmetric mode: hide the config panel and resizer */
.wrap.config-hidden{
  grid-template-columns: 1fr;
}
.wrap.config-hidden #resizer{ display:none; }
.wrap.config-hidden #configPanel{ display:none; }


/* Add breathing room to the right of the resizer only */
/* Extra breathing room between resizer and the right panel */
.wrap > #resizer + .panel{
  margin-left: 12px;     /* shifts panel away from the handle */
  padding-left: 12px;    /* shifts content away from the panel edge */
}



    /* Panels = white cards (token-driven), soft shadow, larger radius */
.panel{
  background: var(--card);                   /* #fff in light; dark token in dark */
  border: 1px solid var(--border);
  border-radius: 20px;                       /* ↑ from var(--radius) */
  box-shadow: var(--shadow);
}
    .panel h2{margin:0;padding:12px 14px;border-bottom:1px solid var(--border);font-size:18px}
    
    .panel h2{ display:flex; align-items:center; gap:10px; }
.panel h2 .spacer{ flex:1; }

    .panel section{padding:14px}

    label{display:block;margin:10px 0 6px;color:var(--muted);font-size:16px; font-weight:600;}
  
  /* Sub-blocks inside Configure: boxed with a “legend” notch */
.block{
  position: relative;
  margin: 12px 0;
  padding: 16px 12px 12px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 16px;
  box-shadow: var(--shadow);
  transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease;
}
.block:hover{
  transform: translateY(-1px) scale(1.01);
  box-shadow: 0 12px 44px rgba(0,0,0,.10);
}

/* Title row sits on the border to create a notch/gap */
/* Curved header chip that sits in the block border notch */
.block-title{
  position: absolute;
  top: -12px; left: 12px;
  display: inline-flex; align-items: center; gap: 8px;
  padding: 3px 8px;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 999px;              /* ← curved edges */
}
.block-title h3{
  margin: 0;
  font-size: 15px;
  font-weight: 600;
  text-transform: lowercase;
  letter-spacing: .2px;
  line-height: 1.1;
}
/* Make the Hide/Show fit neatly inside the chip */
.block-title .btn.ghost-min{
  padding: 2px 8px;
  height: 22px;
  font-size: 12px;
  line-height: 1;
}

/* A super-subtle complementary rainbow hairline on the chip itself */
.block-title::after{
  content:""; position:absolute; inset:-1px; border-radius:inherit;
  --angle:0deg;
  background: conic-gradient(from var(--angle),
    color-mix(in srgb, var(--r1) 25%, transparent),
    color-mix(in srgb, var(--r2) 20%, transparent),
    color-mix(in srgb, var(--r3) 20%, transparent),
    color-mix(in srgb, var(--r4) 22%, transparent),
    color-mix(in srgb, var(--r5) 20%, transparent),
    color-mix(in srgb, var(--r6) 22%, transparent),
    color-mix(in srgb, var(--r1) 25%, transparent));
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor; mask-composite: exclude;
  padding:1px; opacity:.35; pointer-events:none;
}
@media (prefers-reduced-motion: reduce){
  .block-title::after{ animation:none; }
}

/* optional: a whisper of rainbow aura on hover */
/* Minimal aura — whisper, not a shout */
.block::before{
  content:""; position:absolute; inset:-10px; z-index:-1; border-radius:22px;
  filter: blur(22px) saturate(110%);
  background: conic-gradient(from 200deg,
    var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  opacity:.04; transition:opacity .2s ease;
}
.block:hover::before{ opacity:.08; }
  
  
  
    
.resizer{
  width:6px;
  cursor: col-resize;
  background: transparent;
  position: relative;
}
.resizer::after{
  content:'';
  position:absolute; inset:0;
  background: linear-gradient(to bottom, transparent 0, transparent 20%, var(--border) 20%, var(--border) 80%, transparent 80%, transparent 100%);
  opacity:.6;
}
.resizer:hover::after{ opacity:1; }

/* Clearer grab handle inside the 6px resizer */
.resizer::before{
  content:'';
  position:absolute;
  top:50%; left:50%; transform:translate(-50%,-50%);
  width:6px; height:36px;                    /* tall enough to read */
  border-radius:3px;
  /* Three stacked dots using a repeating background */
  background-image:
    radial-gradient(currentColor 45%, transparent 46%),
    radial-gradient(currentColor 45%, transparent 46%),
    radial-gradient(currentColor 45%, transparent 46%);
  background-size: 6px 6px;
  background-repeat: no-repeat;
  background-position:
    50% calc(50% - 10px),
    50% 50%,
    50% calc(50% + 10px);
  opacity:.85;
  color: rgba(255,255,255,.88);              /* dark theme default */
}
:root[data-theme="light"] .resizer::before{
  background: rgba(0,0,0,72);              /* light mode default */
}
.resizer:hover::before,
.resizer:focus-visible::before{
  background: var(--accent);
  box-shadow: 0 0 0 2px rgba(78,161,255,.25);
}

/* Finder = pill container with shadow; input sits inside */
.finder{
  position: relative;
  margin-bottom: 8px;
  display: flex; align-items: center;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  padding: 0 6px; /* space for the tiny button on the right */
}

/* Inner input borrows the container's surface; no extra border */
.finder input{
  width: 100%;
  height: 44px;
  padding: 0 64px 0 12px; /* room for All button + hint */
  border: none;
  outline: none;
  background: transparent;
  color: var(--fg);
}

/* Tiny "All" button remains absolutely positioned */
.finder .btn.tiny{
  position: absolute; right: 6px; top: 50%; transform: translateY(-50%);
  padding: 4px 8px; font-size: 12px; border-radius: 999px;
}

/* "Showing N/M" hint in muted text, aligned inside pill */
.finder .hint{
  position: absolute;
  right: 56px;
  top: 50%; transform: translateY(-50%);
  font-size: 12px;
  color: var(--muted);
  opacity: .9;
  pointer-events: none;
}

/* --- Finder: "More filters" disclosure --- */
.filtersToggle{
  display:inline-flex; align-items:center; gap:6px;
  font-size:12px; color:var(--muted);
  background:transparent; border:none; cursor:pointer;
  padding:4px 2px; margin:2px 0 6px;
}
.filtersToggle .chev{ transition: transform .2s ease; }
.filtersToggle[aria-expanded="true"] .chev{ transform: rotate(90deg); }

.filtersRow{
  display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-bottom:8px;
}
@media (max-width: 720px){
  .filtersRow{ grid-template-columns: 1fr; }
}


.ta-menu {
  position: absolute; z-index: 50; margin-top: 4px; max-height: 240px; overflow:auto;
  border: 1px solid var(--border-color, #ddd); border-radius: 8px; background: var(--bg, #fff);
  box-shadow: 0 6px 24px rgba(0,0,0,.08); min-width: 260px;
}
.ta-menu .ta-item { padding: 8px 10px; cursor: pointer; }
.ta-menu .ta-item:hover, .ta-menu .ta-item.ta-active { background: rgba(0,0,0,.06); }




/* Not Using */
.useChips{ display:flex; flex-wrap:wrap; gap:8px; margin:6px 0 8px; }
.useChips .chip{ cursor:pointer; user-select:none; }
.useChips .chip.active{ outline:2px solid var(--accent); }

.suggestions{ display:flex; flex-wrap:wrap; gap:6px; margin:6px 0 12px; }
.suggestions .suggest{ cursor:pointer; padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:var(--chip); font-size:12px; }


/* Nice vertical rhythm between fields */
.field + .field{ margin-top:12px; }

/* Stepper progress + field nav */
.progress{
  height:6px; background:var(--border); border-radius:4px; margin:8px 0;
}
.progress > .bar{
  height:100%; background:var(--accent); width:0%; border-radius:4px; transition:width .25s;
}

.progressMeta{
  display:flex; align-items:center; gap:10px;
  margin:6px 0 4px; font-size:12px; color:var(--muted);
}
/* Ensure meta row really hides in “Show all” without touching anything else */
#fieldProgressMeta[hidden]{ display:none !important; }
/* Only the bar, still narrow-scoped (does not affect deck) */
#fieldProgress[hidden]{ display:none !important; }
.progressMeta .pct{ font-variant-numeric: tabular-nums; }
.progressMeta .nudge{ opacity:.9; }



.field-nav{
  display:flex; gap:8px; margin:8px 0 0;
  align-items:center; flex-wrap:wrap;
}

/* Bottom stepper hint */
.step-hint{
  margin: 8px 0 0;
  padding: 8px 10px;
  font-size: 12px;
  color: var(--muted);
  background: var(--chip);
  border: 1px solid var(--border);
  border-radius: 8px;
}

.field-nav .spacer{ flex:1; }



/* Inline counters inside inputs/textareas */
.fieldHolder{ position:relative; }
.counter{
  position:absolute; right:10px; bottom:8px;
  font-size:11px; color:var(--muted); opacity:0.85;
  pointer-events:none; user-select:none;
}
.hasCounter{ padding-right:76px !important; }   /* prevent overlap with typing */
textarea.hasCounter{ padding-right:84px !important; } /* a tad more room for multi-line */


/* Inputs = white surface, hairline border, crisp text */
input[type="text"], textarea, select{
  width: 100%;
  height: 48px;                 /* roomy control height */
  padding: 0 12px;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--card);
  color: var(--fg);
  outline: none;                /* global :focus-visible ring handles a11y */
  box-shadow: var(--shadow);
}

/* Textareas keep vertical space; override height */
textarea{
  min-height: 100px;
  height: auto;
  padding: 10px 12px;
  resize: vertical;
}
    
    /* Filled state: subtle border emphasis; no colored wash */
input.filled, textarea.filled{
  box-shadow: none;
  border-color: var(--accent);
  background: var(--card);
}

    textarea{min-height:100px;resize:vertical}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  
    .help{
  color:var(--muted);
  font-size:12px;          /* smaller than label (13px) */
  line-height:1.35;
  margin-top:6px;            /* space from input */
  opacity:0.9;               /* lighter than labels */
}



.desc{
  color:var(--muted);
  font-size:12px;       /* smaller than label */
  line-height:1.35;
  margin-top:6px;
  opacity:0.8;            /* a bit stronger than .help so it reads clearly */
}

.titledesc{
  color:var(--muted);
  font-size:13px;       /* smaller than label */
  line-height:1.35;
  margin-top:6px;
  opacity:0.8;            /* a bit stronger than .help so it reads clearly */
}

/* Meta block under the Glossary button */
.metaSection{
  margin-top:10px;
  font-size:12px;
  color:var(--muted);
  font-weight:700;
  text-transform: lowercase;
letter-spacing: .04em;
}

.metaGroup{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:8px;
  margin-top:6px;
}

.tinyLabel{
  font-size:11px;
  color:var(--muted);
  opacity:.85;
  padding:2px 8px;
  border:1px solid var(--border);
  border-radius:999px;
  background:var(--chip);
}

/* Dedicated meta box */
#metaChips{
  display:block !important;                 /* stop flex from .chips */
}
.metaBox{
  margin-top:12px;
  padding:12px;
  border:1px solid var(--border);
  border-radius: var(--radius);
  background: var(--card);
}
.metaRow{ margin-top:8px; }
.metaSectionTitle{
  margin-top:10px;
  font-size:12px;
  color:var(--muted);
  font-weight:700;
text-transform: lowercase;
letter-spacing: .04em;
}
.metaPills{
  display:flex; flex-wrap:wrap; gap:8px; margin-top:6px;
}
.metaLink{
  display:inline-flex; margin-bottom:4px;
}

/* Results header row (All Matches + live count) */
#resultsHeader {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}
#fwCount {
  font: 12px/1.2 system-ui;
  opacity: .85; /* harmonizes with your UI chrome */
}



.tinyLabel{
  font-size:11px; color:var(--muted); opacity:.85;
  padding:2px 8px; border:1px solid var(--border); border-radius:999px; background:var(--chip);
}

/* Tabs */
.tabs{ display:flex; gap:6px; margin:6px 0 10px; flex-wrap:wrap; padding-left:12px; }

.tab{
  display: inline-flex; align-items: center; gap: 8px;
  padding: 6px 10px;
  background: var(--chip);
  border: 1px solid var(--border);
  border-radius: 999px;
  cursor: pointer;
  font-size: 12px;
  color: var(--text);
  text-transform: lowercase;                 /* NEW */
  letter-spacing: .2px;                      /* NEW */
  transition:
    transform .12s cubic-bezier(.2,.9,.2,1),
    border-color .15s ease,
    box-shadow .15s ease,
    color .15s ease,
    background-color .15s ease;
}
.tab:hover{ transform: translateY(-1px) scale(1.01); border-color: var(--accent); }
.tab.active{
  outline: 2px solid var(--accent);         /* keep outline (not heavy fill) */
  outline-offset: 2px;
  font-weight: 600;                          /* clearer active affordance */
}
.tab .x{
  border:none; background:transparent; cursor:pointer; font-size:14px; line-height:1;
  color:var(--muted);
}
.tab .x:hover{ color:var(--text); }

.tab .x{ cursor: pointer; }
.tab .x:disabled{ cursor: not-allowed; opacity:.6; }

/* Output deck */
#outDeck{ display:flex; flex-direction:column; gap:12px; margin-top:12px; }
/* Ensure hidden really hides regardless of author styles */
#outDeck[hidden],
#deckLabel[hidden],
.tabs[hidden],
[hidden]{
  display: none !important;
}
/* Deck cards = same card look as panels */
.outCard{
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 20px;                       /* ↑ larger radius */
  box-shadow: var(--shadow);
  padding: 12px 14px;                        /* a hair roomier */
}

.panel:hover, .outCard:hover{
  transform: translateY(-1px) scale(1.01);
  transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease;
  box-shadow: 0 12px 44px rgba(0,0,0,.10);
}


.outHead{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  margin-bottom:8px; font-size:13px; color:var(--muted);
  padding-right:10px; /* NEW: gives breathing room so Clear isn't flush right */
}

.outHead .title{ font-weight:600; color:var(--text); }
.outHead .actions{
  display:flex; gap:8px;
  margin-right:2px; /* NEW: tiny inset for safety on narrow widths */
}


.outBody{ white-space:pre-wrap; font-family:inherit; font-size:13px; line-height:1.45; }
.outActions{ margin-top:10px; }

/* Subtle flash to signal the panel changed */
.fields-swap {
  animation: fieldsSwapFlash 280ms ease-out;
}
@keyframes fieldsSwapFlash {
  0%   { box-shadow: 0 0 0 2px var(--accent) inset; background: rgba(78,161,255,.06); }
  100% { box-shadow: none; background: transparent; }
}

/* A small context chip above the fields */
#tabContext {
  margin-bottom: 8px;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 999px;
  background: var(--chip);
  font-size: 12px;
  color: var(--muted);
}

    .chips{display:flex;flex-wrap:wrap;gap:8px}
.chip{
  background: var(--chip);
  border: 1px solid var(--border);
  border-radius: 999px;
  padding: 6px 10px;
  font-size: 12px;
  line-height: 1;
  color: var(--text);
  cursor: pointer;
  text-transform: lowercase;        /* NEW */
  letter-spacing: .2px;             /* NEW */
  transition:
    transform .12s cubic-bezier(.2,.9,.2,1),
    border-color .15s ease,
    box-shadow .15s ease,
    color .15s ease,
    background-color .15s ease;
}
.chip:hover{
  transform: translateY(-1px) scale(1.01);   /* NEW tiny lift */
  border-color: var(--accent);               /* subtle tint */
}

/* Extra guards for common dark-theme toggles */
[data-theme="dark"] .chip{ color:var(--text); }
.theme-dark .chip{ color:var(--text); }
.dark .chip{ color:var(--text); }

/* Subtle hover/focus to aid discoverability without hurting contrast */
.chip:hover{ border-color:var(--accent); }
.chip:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }

/* Space chips away from the search bar */
#datasetChips{ margin:8px 0 12px; }  /* top 8px, bottom 12px */


.chip[aria-pressed="true"]{
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(78,161,255,.2) inset;
  color: var(--text);
}

.chip[aria-pressed="false"]{ opacity:.92; }   /* still fully readable */
.chip[aria-pressed="true"]{ opacity:1; font-weight:600; }

/* Bias multi-select chips */
.chipsInput{ display:flex; flex-wrap:wrap; gap:6px; align-items:center; padding:6px; border:1px solid var(--border); border-radius:10px; background:var(--card); min-height:36px; }
.chipsInput input{ flex:1; min-width:140px; border:none; outline:none; background:transparent; padding:6px 8px; font-size:14px; }
.chipsInput .chip{ display:inline-flex; align-items:center; gap:6px; }
.chipsInput .chip .x{ margin-left:4px; border:none; background:transparent; cursor:pointer; font-size:14px; line-height:1; padding:0 4px; color:var(--muted); }
.chipsInput .dot{ width:8px; height:8px; border-radius:999px; display:inline-block; }
.dot.bias{ background:#d97706; }       /* amber */
.dot.technique{ background:#059669; }  /* green */
.dot.dilemma{ background:#7c3aed; }    /* purple */
.dot.custom{ background:#6b7280; }     /* gray */



    pre{margin:0;padding:14px;background:var(--card);border-top:1px solid var(--border);border-radius:0 0 var(--radius) var(--radius);overflow:auto;white-space:pre-wrap}

   .pill{
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: var(--chip);
  font-size: 12px;
  color: var(--muted);
  text-transform: lowercase;               /* NEW */
  letter-spacing: .2px;                    /* NEW */
}
    .pill[data-val="framework"]{color:var(--green)}
    .pill[data-val="pattern"]{color:var(--yellow)}
    
    .pill[data-val="tasks"]{color:var(--accent)}

    
   /* Additional instructions box spacing */
#extra{
  min-height: 72px;
  resize: vertical;
}
 
   /* --- Prompt totals under title --- */
.prompt-total{
  margin: -6px 0 8px 0;
  font-size:12px;
  color: var(--muted);
  opacity: 0.9;
}

/* Master total under the "Generated prompt" header */
.prompt-total--master{
  margin-top: 8px;
  padding-top: 6px;
  border-top: 1px solid var(--border);
}


/* --- Current preview inline counter (top-right of the big preview) --- */
/* We attach this inside the #out element */
#out{ position: relative; } /* harmless if already positioned elsewhere */
#out .outCounter{
  position:absolute;
  top:8px; right:8px;
  font-size:12px; color:var(--muted); opacity:0.9;
  pointer-events:none; user-select:none;
  background: transparent; /* stays invisible atop your preview */
}


/* ==== Context Coach (single, for current preview) ==== */
/* Sits inside #out, just below the top-right small counter */
#out .outCoach{
  position:absolute;
  right:8px; 
  top:30px; /* directly below .outCounter at top:8px */
  font-size:12px; 
  color:var(--muted); 
  opacity:0.95;
  pointer-events:none; 
  user-select:none;
}
#out .outCoach[hidden]{ display:none; }

/* Chip look with AA-safe colored left border */
#out .outCoach .pill{
  display:inline-flex; align-items:center;
  padding:2px 10px; border-radius:999px;
  background:var(--chip); border:1px solid var(--border);
  font-weight:700;
  /* color stays readable; accent via left border only */
}

/* State colors */
#out .outCoach[data-state="low"]     .pill{ border-left:4px solid var(--yellow); }
#out .outCoach[data-state="near"]    .pill{ border-left:4px solid var(--accent); }
#out .outCoach[data-state="good"]    .pill{ border-left:4px solid var(--green); }
#out .outCoach[data-state="perfect"] .pill{ border-left:4px solid var(--purple); }
#out .outCoach[data-state="high"]    .pill{ border-left:4px solid var(--red); }

/* Make room at the top of the preview when coach is visible */
#out.hasCoach{
  padding-top:52px;
  /* NEW: reserve horizontal space for the coach pill */
  padding-right: var(--coachPad, 160px) !important;
}

#out.hasCounter{
  padding-top:28px;
  /* NEW: reserve horizontal space for the corner counter */
  padding-right: var(--counterPad, 72px);
}
   
    /* Independent scroll for the left panel */
#configPanel{
  position: sticky;
  top: 48px; /* sits under the sticky header */
  max-height: calc(100vh - 60px - 16px); /* header + grid padding */
  overflow: auto; /* vertical & horizontal if needed */
}


/* Area labels to distinguish preview vs deck */
.areaLabel{
  display: inline-flex; align-items: center; gap: 6px;
  padding: 4px 8px; margin: 8px 0 6px;
  background: var(--chip);
  border: 1px solid var(--border);
  border-radius: 999px;
  font-size: 12px;
  color: var(--muted);
  text-transform: lowercase;               /* NEW */
  letter-spacing: .2px;                    /* NEW */
}
.areaLabel .dot{ width:6px; height:6px; border-radius:999px; background:var(--accent); }

/* Stronger section separation (dark-friendly) */
/* Preview content = card surface without gradients */
#out{
  background: var(--card);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 20px;
  box-shadow: var(--shadow);
}
.outCard{
  border-color: var(--border-strong);
}

/* Tabs close button: compact circular */
.tab .x{
  color: var(--text);
  background: var(--chip);
  border: 1px solid var(--border-strong);
  border-radius: 999px;
  width: 22px; height: 22px; line-height:1;
  display:inline-flex; align-items:center; justify-content:center;
}

.tab .x:hover{ border-color: var(--accent); }
.tab .x:focus-visible,


/* Deck Clear/Delete: danger pill */
.outHead .x{
  background: var(--red);
  color: #fff;
  border: none;
  border-radius: 999px;
  padding: 4px 10px; line-height:1;
  display:inline-flex; align-items:center; justify-content:center;
  width: auto; height: auto;       /* kill forced 22x22 circle */
  min-width: 0;
}
.outHead .x:hover{ filter: brightness(1.05); box-shadow:0 0 0 2px rgba(78,161,255,.20); }
.outHead .x:focus-visible{
  box-shadow: none;
  outline: 2px solid var(--focus);
  outline-offset: 2px;
}

/* Defensive: in light theme, never fall back to chip styles */
:root[data-theme="light"] .outHead .x{
  background: var(--red);
  color: #fff;
}

/* Card "Clear/Delete" (secondary pill): white surface + red outline/text */
.outHead .actions .x{
  min-width: auto;
  height: auto;
  padding: 2px 10px;
  border-radius: 999px;
  line-height: 1.2;
  background: var(--card);
  border: 1px solid var(--red);
  color: var(--red);
  cursor: pointer;
}
.outHead .actions .x:disabled{
  cursor: not-allowed; opacity: .6;
}

.outHead .actions .x:hover{
  filter: brightness(1.05);
  box-shadow: 0 0 0 2px rgba(78,161,255,.20);
}
.outHead .actions .x:focus-visible{
  box-shadow: none;
  outline: 2px solid var(--focus);
  outline-offset: 2px;
}

/* Typeahead dropdown = index-style dropdown panel */
.taWrap{ position: relative; }
.taList{
  position: absolute; left: 0; right: 0; top: 100%;
  margin-top: 6px; z-index: 50;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 16px;
  max-height: 260px; overflow: auto;
  box-shadow: var(--shadow);
}
.taList[hidden]{ display: none; }

.taItem{
  display: grid;
  grid-template-columns: 1fr;
  align-items: center;
  gap: 2px;
  padding: 10px 12px;
  cursor: pointer;
  border-bottom: 1px solid var(--border);
  font-size: 13px;
}
.taItem:last-child{ border-bottom: none; }

.taItem .name{
  color: var(--text);
  font-weight: 600;
  text-transform: lowercase;
  letter-spacing: .2px;
}
.taItem .sub{
  color: var(--muted);
  font-size: 12px;
}

/* Gentle hover (light); dark already has its own in your dark overrides */
.taItem:hover{ background: #f8fbff; }
.taItem:last-child{ border-bottom:none; }
.taItem .name{ color:var(--text); font-weight:600; }
.taItem .sub{ color:var(--muted); font-size:12px; }
.taItem.active{
  outline: 2px solid var(--accent);
  outline-offset: -2px;
  font-weight: 600;                 /* NEW: non-color cue */
}

/* Results <select> matches input styling */
.panel select{
  width: 100%;
  height: 44px;
  padding: 0 36px 0 10px;          /* room for chevron */
  border: 1px solid var(--border);
  border-radius: var(--radius);
  background: var(--card);
  color: var(--fg);
  outline: none;
  appearance: none;
  background-image:
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><path d='M4 6l4 4 4-4' fill='none' stroke='%2399AABB' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/></svg>");
  background-repeat: no-repeat;
  background-position: right 10px center;
  cursor: pointer;
  box-shadow: var(--shadow);
}

/* Dropdown helper cluster */
.pickerHelp { margin-top: 6px; }

/* First line: concise “how the list works” caption */
#fwListHelp.desc{
  margin: 0 0 6px;           /* space below this caption */
  font-size: 12px;
  line-height: 1.35;
  opacity: .9;
}

/* Second line: template definition/use-cases, visually separated */
#fwHelp.help{
  margin-top: 10px;
  padding-top: 10px;
  border-top: 2px dashed var(--border);
  line-height: 1.4;
}

/* No divider when there’s nothing to say */
#fwHelp.help:empty{
  margin-top: 0;
  padding-top: 0;
  border-top: none;
}


/* Make "Open in Glossary" look linky and stand out */
.metaLink {
  background: transparent;
  border: none;
  padding: 0;
  color: var(--accent);
  text-decoration: underline;
  cursor: pointer;
}
/* Non-clickable meta chips shouldn't look clickable */
.metaPills .chip { cursor: default; }


/* More breathing room between chips and search */
#kindChips{ margin: 6px 0 10px; }

/* Chips: readable in dark mode when not selected */
#kindChips .chip {
  background: var(--chip);
  color: var(--text);
  border: 1px solid var(--border);
}
/* Kind chips active → outline, not fill */
#kindChips .chip[aria-pressed="true"]{
  background: var(--chip);
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(78,161,255,.20) inset;
  color: var(--text);
}

:root[data-theme="light"] .btn.danger{ background: var(--red); color:#fff; }
:root[data-theme="dark"]  .btn.danger{ background: var(--red); color:#fff; }

/* Extra UI helpers */
.extraHelpers{
  display:flex; gap:10px; align-items:center; margin:6px 0 0;
  font-size:12px; color:var(--muted);
}
.extraHelpers .restore{
  background:none; border:none; padding:0; cursor:pointer;
  color:var(--accent); text-decoration:underline; font-size:12px;
}

/* Subhead without left padding (use with class="subhead no-pad") */
/* === Slice 1: global focus ring (standardize across widgets) === */
:focus-visible{
  outline: 2px solid var(--focus);
  outline-offset: 2px;
}

/* Neutralize legacy box-shadow focus styles so the ring is consistent */
.btn:focus, .btn:focus-visible,
input:focus, textarea:focus, select:focus,
.chip:focus, .tab:focus,
.tab .x:focus-visible,
.outHead .x:focus-visible,
.outHead .actions .x:focus-visible,
.toggle:focus-visible {
  box-shadow: none !important;
}
.subhead.no-pad { padding-left: 0; }



    @media (max-width: 960px){
      .wrap{grid-template-columns:1fr}
    }
    
    
    /* CTA clusters get a subtle rainbow border on hover/focus */
.ctaGroup .btn{ position: relative; }

/* Conic-gradient border that fades in and spins */
.ctaGroup .btn::after{
  content:"";
  position:absolute; inset:-2px; border-radius:inherit; padding:2px;
  --angle:0deg;
  background: conic-gradient(from var(--angle),
    var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  /* punch out middle → border effect */
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor; mask-composite: exclude;
  opacity:0; transition: opacity .2s ease, filter .2s ease; pointer-events:none; z-index:-1;
}
@keyframes spinRainbow{ to { --angle:360deg; } }

.ctaGroup .btn:hover,
.ctaGroup .btn:focus-visible{
  transform: translateY(-2px) scale(1.025);
  box-shadow: 0 16px 28px -14px rgba(0,0,0,.35), 0 4px 10px -6px rgba(0,0,0,.25);
}
.ctaGroup .btn:hover::after,
.ctaGroup .btn:focus-visible::after{
  opacity:1; filter:saturate(1.15); animation: spinRainbow 2.25s linear infinite;
}

/* motion safety */
@media (prefers-reduced-motion: reduce){
  .ctaGroup .btn, .ctaGroup .btn::after{ transition:none; animation:none; }
}


@media (prefers-reduced-motion: reduce){
  *{ animation: none !important; transition: none !important; }
  .btn, .chip, .tab, .panel, .outCard{ transform: none !important; }
}

/* --- Fix: keep typeahead menus above neighboring blocks --- */
#biasSuggestions.ta-menu { z-index: 400; }  /* beats default 50 */

/* While any ta-menu inside a block is open, float that block above siblings */
.block:has(.ta-menu:not([hidden])) {
  position: relative;
  z-index: 350;
}

/* (Optional) anchor absolute children locally if needed later */
#biasChipsWrap { position: relative; }

    
  </style>
</head>
<body>
  <header>
  <span class="ctaGroup">
    <a class="btn sm" href="../index.html" target="_blank" rel="noopener">← Back to Home</a>
    <a class="btn sm" href="./templates-glossary.html" target="_blank" rel="noopener">Open Template Glossary</a>
    </span>

    <strong>Prompt Template Builder</strong>
    <span class="spacer"></span>
<span class="ctaGroup">
  <a class="btn sm" href="./saved-sessions.html" title="Browse your saved snapshots">View Saved Sessions</a>
  <a href="./startup-wizard.html" class="btn sm" title="Guided, one-field-at-a-time mode" target="_blank" rel="noopener">Startup Wizard (alpha)</a>
    <button id="copyBtn" class="btn sm">Copy Prompt</button>
  <button id="openBtn" class="btn primary sm">💬 Ask ChatGPT</button>
<button id="aiSettingsBtn" class="btn sm" title="AI Assist Settings">AI Settings</button>

</span>
    <button id="theme" class="toggle" aria-pressed="false" title="Toggle theme"><span class="dot"></span><span>Light</span></button>
  </header>

 <div class="wrap preview-hidden" data-start="preview-hidden">
  <div class="panel" id="configPanel">
      <h2><span>Configure</span>
        <span class="spacer"></span>
        <button id="hideConfigBtn" class="btn sm" title="Hide the config panel">Hide Config</button>
        <button id="showPreviewBtn" class="btn sm preview-toggle primary" title="Show the preview panel" hidden>Show Preview</button>
        </h2>
      
<!-- Hidden until >1 template -->
<div class="block" id="activeTemplatesBlock" hidden>
  <div class="block-title">
    <h3 id="tabbarLabel" class="subhead no-pad">Active templates</h3>
  </div>
  <div id="tabbar" class="tabs" hidden></div>
</div>

      
      <section>
    <div class="block" id="pickerBlock">
<div id="pickerHeader" class="block-title" style="display:flex;align-items:center;gap:8px;margin:0">
    <h3 id="pickerHeader">Pick a Template</h3>
    <button id="pickerToggle" class="btn sm ghost-min" type="button"
          aria-expanded="true" aria-controls="pickerBody" title="Hide template picker">Hide</button>
</div>
<!-- Collapsible picker body (default: shown) -->
<div id="pickerBody">

    <label for="filterUse">Use Cases</label>
    <!-- Quick-select use-case chips (intent-first) -->
<div id="useChips" class="chips" role="toolbar" aria-label="Use cases"></div>
<input type="hidden" id="filterUse" value="all" />
    

 <div id="setstHelp" class=".titledesc">
    <label for="filterSearch">Search Bar</label>
    <div id="finderHelp" class="desc" style="margin:6px 0 8px">
  Type to filter the <b>dropdown list below</b>.
  </div>
  </div>
        
<div id="finderBar" class="finder">
  <input id="fwSearch" type="text" placeholder="Find a template by name, tag, or use case… (Ctrl/Cmd+K)">
  <!-- NEW: rich typeahead suggestions list (same style as persona typeahead) -->
  <div id="fwSuggest" class="taList" role="listbox" hidden></div>
  <span id="fwHint" class="hint" aria-live="polite" hidden></span>
  <button id="fwAll" type="button" class="btn tiny" title="Show full list">All</button>
</div>
<div id="finderHelp" class="desc" style="margin:6px 0 8px">
  <button id="filtersToggle" class="filtersToggle" type="button"
        aria-expanded="false" aria-controls="filtersWrap">
  <span class="chev">▸</span><span>More filters</span>
</button>
</div>



<div id="filtersWrap" hidden>

    <!-- Kind filter moved under More filters -->
<div class="field">
  <label class="sm">Kind</label>
<div id="kindChips" class="chips" role="toolbar" aria-label="Kinds"></div>
<input type="hidden" id="filterKind" value="__all__" />
</div>


  <div class="filtersRow">
    <div>
<label for="filterTag">Tag</label>
<select id="filterTag"></select>
    </div>
    <div>
      <label for="filterCategory">Category</label>
      <select id="filterCategory">
        <option value="__all__">All categories</option>
      </select>
    </div>
  </div>
  


  
</div>



<div id="setstHelp" class="titledesc">
  <div id="resultsHeader" class="metaRow">
    <span>All Matches</span>
    <span id="fwCount" class="tinyLabel" aria-live="polite" title="Filtered result count">Showing 0 of 0</span>
  </div>
  <div id="fwListHelp" class="desc">
    This dropdown shows matching templates. Click to open it, then pick one.
  </div>
  </div>
<select id="frameworkSel" aria-label="Search results: templates list"></select>
<div class="pickerHelp">

  <div id="fwHelp" class="help" aria-live="polite"></div>
</div>
</div>
</div>

      </section>
      
      

      <section>
      
 
      
      




      <!-- Common context header + toggle -->
      <div class="block" id="commonCtxBlock">
  <div id="commonCtxHeader" class="block-title" style="display:flex; align-items:center; gap:8px; margin:0">
  <h3 id="contextsHeader">Common context (optional)</h3>
  <button id="commonCtxToggle" class="btn sm ghost-min" type="button" aria-expanded="false" aria-controls="commonCtxBody" title="Show common context">Show</button>
</div>


<!-- Collapsible body (hidden by default) -->
<div id="commonCtxBody" hidden>

<div class="help" id="commonCtxScopeHelp" aria-live="polite">
  Not part of the template’s fields. Optional context for this prompt (each tab has its own).
</div>

  <div class="row">
    <div>
      <label for="usecase">Use-case / scenario</label>
      <input id="usecase" type="text" placeholder="e.g., Launch email for a new service" />
    </div>
    <div>
      <label for="audience">Audience</label>
      <div id="audienceChipsWrap" class="chipsInput">
        <div id="audienceChips" class="chips"></div>
        <input id="audience" type="text"
               placeholder="e.g., Busy SMB owners"
               autocomplete="off" data-typeahead="persona" />
      </div>
      <div id="audienceSuggestions" class="ta-menu" hidden></div>
    </div>
  </div>

  <div class="row">
    <div>
      <label for="style">Style</label>
      <input id="style" type="text" placeholder="e.g., Practical, plain language" />
    </div>
    <div>
      <label for="tone">Tone</label>
      <input id="tone" type="text" placeholder="e.g., Friendly, confident" />
    </div>
  </div>

  <div class="row">
    <div style="grid-column:1/-1">
      <div id="biasCtx" class="field">
        <label for="biasInput">Bias awareness &amp; mitigation</label>
        <div id="biasChipsWrap" class="chipsInput">
          <div id="biasChips" class="chips"></div>
          <input id="biasInput" type="text" placeholder="Type to add biases, tactics, or dilemmas…" autocomplete="off" />
        </div>
        <div id="biasSuggestions" class="ta-menu" hidden></div>
        <div class="help">Add biases to avoid, mitigation tactics to apply, or ethical dilemmas to consider. We’ll adapt the prompt accordingly.</div>
      </div>
    </div>
  </div>
</div>
    </div>    
      </section>

<section>
<!-- Fields header + toggle -->
<div class="block" id="fieldsBlock">
  <div id="fieldsHeaderRow" class="block-title" style="display:flex;align-items:center;gap:8px;margin:0">
  <h3 id="fieldsHeader">Template fields</h3>
  <button id="fieldsToggle" class="btn sm ghost-min" type="button"
          aria-expanded="true" aria-controls="fieldsBody" title="Hide template fields">Hide</button>
</div>

<div class="desc" style="margin:10px 0 6px">Fill in the template below. Only fill what helps. Empty fields are omitted in the prompt.</div>


<!-- Collapsible fields body (default: shown) -->
<div id="fieldsBody">


 <!-- Guided mode progress (hidden until step mode) -->
<div id="fieldProgressMeta" class="progressMeta" aria-live="polite" hidden>
  <span id="fieldStepPill" class="pill"></span>
  <span class="spacer"></span>
  <span id="fieldPct" class="pct">0%</span>
  <span id="fieldNudge" class="nudge">Let’s begin.</span>
</div>
<div id="fieldProgress" class="progress" role="progressbar" aria-valuemin="0" aria-valuemax="100" hidden>
  <div id="fieldProgressBar" class="bar" style="width:0%"></div>
</div>

    <!-- The fields panel (we'll slice these in JS when guided) -->
  <div id="fields"></div>

  <!-- Stepper hint (only in guided mode and not on last page) -->
  <div id="fieldStepHint" class="step-hint" aria-live="polite" hidden>
    More fields ahead — continue with <strong>Next</strong>.
  </div>

  <!-- Step controls (hidden until step mode) -->
  <div id="fieldNav" class="field-nav" hidden>
    <button id="fieldBack" class="btn sm" type="button" title="Previous">← Back</button>
    <button id="fieldNext" class="btn primary sm" type="button" title="Next">Next →</button>
    <span class="spacer"></span>
    <button id="fieldShowAll" class="btn sm" type="button" title="Show every field at once">Show all</button>
  </div>
  
   <div class="help"><br> Only fill what helps. Empty fields are omitted in the prompt.</div>

<!-- Additional instructions mount (content is rendered by JS) -->
<div id="extraWrap" class="field" hidden></div>


  <!-- Secondary quick actions: mirrors header actions -->
  <div class="actionsRow actionsRow--secondary ctaGroup" style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 14px">
    <button id="copyBtn2" class="btn sm" title="Copy active tab">Copy Prompt</button>
    <button id="openBtn2" class="btn primary sm" title="Open active tab in ChatGPT">💬 Ask ChatGPT</button>
    <button id="worksheetBtn2" class="btn sm" title="Open a printable worksheet for the active template">Print Worksheet</button>
    <button id="clearBtn2" class="btn sm danger" title="Clear just this prompt">Clear</button>
  </div>
  
  </div>
  </div>
</section>


      <section>
        <div class="chips" id="metaChips"></div>
      </section>
    </div>
<div id="resizer" class="resizer" role="separator" aria-orientation="vertical" aria-valuemin="280" aria-valuemax="900" tabindex="0"></div>
<div class="panel" id="previewPanel">

    <h2>
    <span>Generated prompt</span>
    <span class="spacer"></span>
     <button id="showConfigBtn" class="btn sm preview-toggle primary" title="Show the config panel" hidden>Show Config</button>
    <button id="hidePreviewBtn" class="btn sm preview-toggle" title="Hide the preview panel">Hide Preview</button>
  </h2>
      <div id="masterPromptTotal" class="prompt-total prompt-total--master" aria-live="polite"></div>

<div id="previewLabel" class="areaLabel"><span class="dot"></span><span>Preview • Active tab</span></div>
<pre id="out"></pre>

<div class="outActions" style="margin-top:8px">
  <button id="addPromptBtn" class="btn primary" title="Add another template to this session">+ Add template</button>
  <button id="copyAllBtnFooter" class="btn sm" data-action="copy-all">Copy Prompt</button>
<button id="openAllBtnFooter" class="btn primary sm" data-action="open-all">💬 Ask ChatGPT</button>
</div>

<div id="deckLabel" class="areaLabel" hidden><span class="dot"></span><span>Output deck • All prompts</span></div>



<div id="outDeck" class="out-deck" hidden></div>

<!-- New: add-template button under the preview/deck -->



    </div>

    
  </div>

  <dialog id="msg"><form method="dialog" style="margin:0">
    <section id="msgText" style="padding:16px">
    
    Prompt copied to clipboard. A new tab opened; if it didn’t prefill, paste with Cmd/Ctrl+V.
    
    </section>
    
    
    <footer style="display:flex;justify-content:flex-end;gap:8px;padding:12px;border-top:1px solid var(--border)">
    
    <button class="btn" type="button" id="dlgClose">Close</button>

  </form></dialog>
  
  
<dialog id="actionModal" class="modal">
  <form method="dialog" class="modal-body" id="actionForm" aria-labelledby="actionTitle">
    <header class="modal-header">
      <h3 id="actionTitle">Copy Prompt</h3>
      <button type="button" class="icon close" aria-label="Close" id="actionClose">×</button>
    </header>

    <section class="modal-section">
      <div class="field">
        <label>Which content?</label>
        <div class="scope-row" role="radiogroup" aria-label="Which content">
          <label class="radio">
            <input type="radio" name="scope" value="prompt" id="scopePrompt" checked>
            <span>Current prompt <small class="hint">(the active template)</small></span>
          </label>
          <label class="radio">
            <input type="radio" name="scope" value="all" id="scopeAll">
            <span>All prompts <small class="hint">(everything in your list)</small></span>
          </label>
        </div>
      </div>

      <div class="field">
        <label for="actionPreview">Preview (you can edit before confirming)</label>
        <textarea id="actionPreview" rows="14" spellcheck="false"></textarea>
      </div>

      <p id="actionNote" class="note" hidden></p>
    </section>

    <footer class="modal-footer">
      <button type="submit" class="btn primary" id="actionConfirm">Copy</button>
      <button type="button" class="btn" id="actionCancel">Cancel</button>
    </footer>
  </form>
</dialog>

<dialog id="postLaunchDlg" class="modal">
  <form method="dialog" class="modal-body" id="postLaunchForm" aria-labelledby="postLaunchTitle">
    <header class="modal-header">
      <h3 id="postLaunchTitle">Did the prompt appear in ChatGPT?</h3>
      <button type="button" class="icon close" aria-label="Close" id="postLaunchClose">×</button>
    </header>

    <section class="modal-section">
      <p id="postLaunchMsg">
        Sometimes ChatGPT opens with a blank box due to a very long URL or because it shows a previously cached draft.
        No worries—you can paste your prompt below.
      </p>
      <div class="field">
        <label for="postLaunchText">Your prompt</label>
        <textarea id="postLaunchText" rows="10" spellcheck="false" readonly></textarea>
      </div>
      <p class="note" id="postLaunchNote">
        Why this happens: 1) very long URLs can be ignored by the site/browser, and 2) ChatGPT sometimes restores your last draft instead of the passed-in prompt.
      </p>
    </section>

    <footer class="modal-footer">
      <button type="button" class="btn" id="postLaunchOpenBase">Open clean chat</button>
      <button type="button" class="btn" id="postLaunchCopy">Copy again</button>
      <button type="submit" class="btn" id="postLaunchDismiss">Dismiss</button>
    </footer>
  </form>
</dialog>


<div id="toast" class="toast" aria-live="polite" hidden></div>

   <script src="./js/aisettings.js" defer></script>
  <script src="./js/templates.data.js"></script>
  <script src="./js/glossary.data.js"></script>
  
    <script>
  // Frameworks DB (window.FRAMEWORKS) — safe to load even if absent
  (function tryLoadFrameworks(){
    const s = document.createElement('script');
    s.src = './js/templates.data.js';
    s.onerror = ()=>console.info('Template data not found at ./js/template.data.js.');
    document.head.appendChild(s);
  })();
</script>

  <!-- Load the glossary if available. Adjust the path to match your repo layout. -->
  <script>
    // If this file lives at /AI/tools/framework-template-builder.html,
    // the glossary may be at /AI/glossary/glossary.data.js. We try to load it dynamically.
    (function tryLoadGlossary(){
      const s = document.createElement('script');
      s.src = './js/glossary.data.js';
      s.onerror = ()=>console.info('Glossary not found at ./js/glossary.data.js — continuing without it.');
      document.head.appendChild(s);
    })();
  </script>
  
  <script>
  // Personas DB (window.PERSONAS) — safe to load even if absent
  (function tryLoadPersonas(){
    const s = document.createElement('script');
    s.src = './js/persona.data.js';
    s.onerror = ()=>console.info('Persona data not found at ./js/persona.data.js — typeahead will still allow free text.');
    document.head.appendChild(s);
  })();
</script>

<script>
// Biases DB (window.BIASES) — safe to load even if absent
(function tryLoadBiases(){
  function inject(path, final=false){
    const s = document.createElement('script');
    s.src = path;
    s.onload = ()=>{
      try{
        // Rebuild index if our helpers exist
        if (typeof buildBiasIndex === 'function') {
          window.__BIAS_IDX = null;
          buildBiasIndex();
        }
        // Let listeners (chips/typeahead) re-render suggestions
        document.dispatchEvent(new Event('biases-loaded'));
      }catch(e){}
    };
    s.onerror = ()=>{
      console.info('Bias data not found at', path);
      // Light fallbacks for common naming/paths
      if (!final) {
        const next = (path === './js/bias.data.js')
          ? './js/biases.data.js'
          : (path === '../js/biases.data.js')
            ? './js/biased.data.js'
            : null;
        if (next) { inject(next); return; }
      }
    };
    document.head.appendChild(s);
  }
  inject('./js/bias.data.js');
})();
</script>



<script>
// S4 — Lazy loader for tasks dataset (window.TASK_TEMPLATES)
function ensureTasksLoaded(onready){
  if (Array.isArray(window.TASK_TEMPLATES)) { onready && onready(); return; }
  const s = document.createElement('script');
  s.src = './js/templates.tasks.data.js';
  s.onload  = ()=> onready && onready();
  s.onerror = ()=> { console.info('Tasks dataset not found at ./js/templates.tasks.data.js'); onready && onready(); };
  document.head.appendChild(s);
}

/* === Unified templates adapter + FIND shim (add below the function) === */
// --- Canonical kinds (singular) + labels shown in chips ---
const KIND_ORDER  = ['helper','task','technique','framework','strategy','heuristic'];
const KIND_LABELS = {
  helper:     'Helpers',
  task:       'Tasks',
  technique:  'Techniques',
  framework:  'Frameworks',
  strategy:   'Strategies',
  heuristic:  'Heuristics'
};

// Map noisy/legacy inputs → canonical kind
function normalizeKind(raw, fallback='framework'){
  const k = String(raw || fallback || '').trim().toLowerCase();
  // plurals → singular
  const dePlural = {
    helpers: 'helper', tasks: 'task', techniques: 'technique',
    frameworks: 'framework', strategies: 'strategy', heuristics: 'heuristic',
    patterns: 'framework', pattern: 'framework'  // removed kind → framework
  };
  if (dePlural[k]) return dePlural[k];

  // common aliases
  const alias = {
    pattern: 'framework', // safety if someone slips it back in
    approach: 'strategy', playbook: 'strategy',
    rule: 'heuristic', rules: 'heuristic'
  };
  return alias[k] || k || 'framework';
}

function getAllTemplates(){
  // Accept several globals so "9/9" never happens because one dataset failed to load.
  const A = (Array.isArray(window.FRAMEWORKS) ? window.FRAMEWORKS :
            (Array.isArray(window.TEMPLATES)  ? window.TEMPLATES  :
            (Array.isArray(window.templates)  ? window.templates  : [])));

  const B = (Array.isArray(window.TASK_TEMPLATES) ? window.TASK_TEMPLATES :
            (Array.isArray(window.tasks)          ? window.tasks          : []));

  const normalize = (t, fbKind) => {
    const kind = normalizeKind(t.kind, fbKind);
    // normalize category/categories onto .categories for matching
    const cats = Array.isArray(t.categories) ? t.categories :
                 (t.category ? [t.category] : []);
    return { ...t, kind, categories: cats };
  };

  const fw = A.map(t => normalize(t, 'framework'));
  const tk = B.map(t => normalize(t, 'task'));
  return [...fw, ...tk];
}


function uniqueKinds(){
  const set = new Set(getAllTemplates().map(t => (t.kind || 'framework')));
  return [...set].sort((a,b)=> String(a).localeCompare(String(b)));
}
function uniqueCategories(){
  const cats = new Set();
  for (const t of getAllTemplates()){
    const c = Array.isArray(t.categories) ? t.categories : [];
    c.forEach(x => cats.add(String(x)));
  }
  return [...cats].sort((a,b)=> String(a).localeCompare(String(b)));
}

// --- Tag grouping (namespace:value → grouped, ordered, de-duped) ---
function collectAllTags(){
  const all = (typeof getAllTemplates === 'function') ? getAllTemplates() : (window.TEMPLATES || window.FRAMEWORKS || []);
  const tags = new Set();
  for (const t of all){
    (t.tags || []).forEach(x => { if (x && typeof x === 'string') tags.add(x.trim()); });
  }
  return [...tags];
}

function groupTagsByNamespace(){
  const raw = collectAllTags();
  const map = new Map(); // ns -> Set(values)
  for (const tag of raw){
    const m = String(tag).split(':');
    const ns = (m[0] || 'misc').toLowerCase().trim();
    const val = (m[1] || m[0] || '').toLowerCase().trim();
    if (!map.has(ns)) map.set(ns, new Set());
    if (val) map.get(ns).add(val);
  }

  // priority order for namespaces; unknowns follow alphabetically
  const order = ['topic','type','phase','level','use'];
  const rest = [...map.keys()].filter(ns => !order.includes(ns)).sort((a,b)=>a.localeCompare(b));

  const ordered = [...order, ...rest].filter(ns => map.has(ns));
  return ordered.map(ns => ({
    ns,
    values: [...map.get(ns)].sort((a,b)=> a.localeCompare(b))
  }));
}

// Build chips from actual kinds in data (e.g., framework, pattern, task, helper, etc.)
function renderKindChips(){
  const wrap = document.getElementById('kindChips');
  if (!wrap) return;

  const current = (document.getElementById('filterKind')?.value) || '__all__';

  // Always render the six canonical kinds in this order, preceded by "All".
  const chips = ['__all__', ...KIND_ORDER];

  wrap.innerHTML = chips.map(k=>{
    const label = (k === '__all__') ? 'All' : KIND_LABELS[k] || (k[0].toUpperCase()+k.slice(1));
    const pressed = current === k;
    return `<button class="chip" type="button" data-kind="${k}" aria-pressed="${pressed?'true':'false'}">${label}</button>`;
  }).join('');

  wrap.onclick = (e)=>{
    const btn = e.target.closest('button[data-kind]');
    if (!btn) return;
    const k = btn.getAttribute('data-kind');

    // sync hidden holder so filters can read it
    const hidden = document.getElementById('filterKind');
    if (hidden) hidden.value = k;

    // toggle visuals
    [...wrap.querySelectorAll('button[data-kind]')].forEach(b=>{
      b.setAttribute('aria-pressed', b === btn ? 'true' : 'false');
    });

    // rebuild list with new kind filter
    refreshTemplateList && refreshTemplateList();
    // keep category select in sync with the kind scope
    updateFilterOptions && updateFilterOptions();
  };
}


// Intent-first quick filters (left→right): All · Write · Plan · Decide · Ideate · Analyze
const USE_CASES = [
  { id:'all',    label:'All',    tokens: [] },
  { id:'write',  label:'Write',  tokens: ['write','writing','draft','compose','rewrite','copy','email','post','cta','script'] },
  { id:'plan',   label:'Plan',   tokens: ['plan','planning','roadmap','okr','milestone','timeline','strategy','raci','project'] },
  { id:'decide', label:'Decide', tokens: ['decide','decision','prioritization','prioritize','matrix','rank','score','tradeoff','kano','eisenhower','moscow'] },
  { id:'ideate', label:'Ideate', tokens: ['idea','ideate','ideation','brainstorm','generate','concept','diverge','explore'] },
  { id:'analyze',label:'Analyze',tokens: ['analyze','analysis','synthesis','synthesize','compare','contrast','summary','summarize','swot','research','report','brief','teardown'] }
];

function matchesUsePreset(t, useId){
  if (!useId || useId === 'all') return true;
  const preset = USE_CASES.find(p => p.id === useId);
  if (!preset || !preset.tokens || !preset.tokens.length) return true;

  const hay = [
    t.label, t.slug, t.id,
    (t.tags || []).join(' '),
    (t.categories || []).join(' '),
    (t.use_cases || []).join(' '),
    (t.definition || ''), (t.help || ''),
    ...((t.fields || []).flatMap(f => [f.label, f.desc, f.ph]))
  ].filter(Boolean).join(' ').toLowerCase();

  return preset.tokens.some(tok => hay.includes(String(tok).toLowerCase()));
}


// Count matches for a preset by scanning each template's text surface
function countUseMatches(preset){
  const all = (typeof getAllTemplates === 'function') ? getAllTemplates() : (window.TEMPLATES || window.FRAMEWORKS || []);
  if (!preset || preset.id === 'all' || !preset.tokens.length) return all.length;
  const toks = preset.tokens.map(t=>String(t).toLowerCase());
  return all.filter(t=>{
    const hay = [
      t.label, t.slug, t.id,
      (t.tags||[]).join(' '),
      (t.categories||[]).join(' '),
      (t.use_cases||[]).join(' '),
      (t.definition||''), (t.help||''),
      ...((t.fields||[]).flatMap(f=>[f.label,f.desc,f.ph]))
    ].filter(Boolean).join(' ').toLowerCase();
    return toks.some(tok => hay.includes(tok));
  }).length;
}

function renderUseChips(){
  const wrap = document.getElementById('useChips');
  if (!wrap) return;
  const cur = (document.getElementById('filterUse')?.value) || 'all';
  wrap.innerHTML = USE_CASES.map(p=>{
    const pressed = cur === p.id;
    const n = countUseMatches(p);
    const label = (p.id === 'all') ? 'All' : p.label;
    return `<button class="chip" type="button" data-use="${p.id}" aria-pressed="${pressed?'true':'false'}" title="${label} • ${n}">${label}</button>`;
  }).join('');

  wrap.onclick = (e)=>{
    const btn = e.target.closest('button[data-use]');
    if (!btn) return;
    const use = btn.getAttribute('data-use');
    const hidden = document.getElementById('filterUse');
    if (hidden) hidden.value = use;

    [...wrap.querySelectorAll('button[data-use]')].forEach(b=>{
      b.setAttribute('aria-pressed', b === btn ? 'true' : 'false');
    });
    refreshTemplateList && refreshTemplateList();
  };
}


// Populate Kind & Category selects from the unified list, then sync the chips
function updateFilterOptions(){
  const tagSel  = document.getElementById('filterTag');
  const catSel  = document.getElementById('filterCategory');
  const kindVal = document.getElementById('filterKind')?.value || '__all__';

  // 1) Tags, grouped by namespace
  if (tagSel){
    const groups = groupTagsByNamespace();
    const prev   = tagSel.value || '__all__';
    let html = `<option value="__all__">All tags</option>`;
    html += groups.map(g => {
      const label = g.ns[0].toUpperCase() + g.ns.slice(1);
      const opts  = g.values.map(v => `<option value="${g.ns}:${v}">${v}</option>`).join('');
      return `<optgroup label="${label}">${opts}</optgroup>`;
    }).join('');
    tagSel.innerHTML = html;
    const hasPrev = [...tagSel.options].some(o => o.value === prev);
    tagSel.value = hasPrev ? prev : '__all__';
  }

  // 2) Categories (scoped to current kind chip)
  if (catSel){
    const all = (typeof getAllTemplates === 'function') ? getAllTemplates() : (window.TEMPLATES || window.FRAMEWORKS || []);
    const curKind = (kindVal && kindVal !== '__all__') ? String(kindVal).toLowerCase() : null;
    const set = new Set();
    for (const t of all){
      const k = String(t.kind || 'framework').toLowerCase();
      if (curKind && k !== curKind) continue;
      (t.categories || []).forEach(c => set.add(String(c)));
    }
    const prev = catSel.value || '__all__';
    const cats = [...set].sort((a,b)=> String(a).localeCompare(String(b)));
    catSel.innerHTML = `<option value="__all__">All categories</option>` + cats.map(c => `<option value="${c}">${c.replace(/-/g,' ')}</option>`).join('');
    const hasPrev = [...catSel.options].some(o => o.value === prev);
    catSel.value = hasPrev ? prev : '__all__';
  }

// 3) (Re)render chips
if (typeof renderKindChips === 'function') renderKindChips();
if (typeof renderUseChips  === 'function') renderUseChips();

}

// Decide if a template matches the current search + filters
function templateMatches(t, q, kind, tagValue, catValue){
  const qq = (q || '').trim().toLowerCase();

  // text search across common fields
  const qok = (() => {
    if (!qq) return true;
    const hay = [
      t.label, t.slug, t.id,
      (t.tags || []).join(' '),
      (t.categories || []).join(' '),
      (t.use_cases || []).join(' '),
      (t.definition || ''), (t.help || ''),
      ...((t.fields || []).flatMap(f => [f.label, f.desc, f.ph]))
    ].filter(Boolean).join(' ').toLowerCase();
    return hay.includes(qq);
  })();

  // kind (from chips via hidden #filterKind)
// t.kind is already canonicalized by getAllTemplates()
const kok = (kind && kind !== '__all__') ? (t.kind === String(kind).toLowerCase()) : true;


  // tag exact match (namespace:value)
  const tok = (tagValue && tagValue !== '__all__')
    ? (t.tags || []).some(tag => String(tag).toLowerCase() === String(tagValue).toLowerCase())
    : true;

  // category match
  const cok = (catValue && catValue !== '__all__')
    ? (t.categories || []).map(String).some(c => c.toLowerCase() === String(catValue).toLowerCase())
    : true;

  return qok && kok && tok && cok;
}

// --- COMPAT: keep Kind/Tag/Category working no matter the signature ---
function templateMatchesCompat(t, q, kind, tagValue, catValue){
  try{
    // If templateMatches expects 6 args, we inject `use` from the hidden input
    if (templateMatches.length === 6){
      const use = document.getElementById('filterUse')?.value || 'all';
      return templateMatches(t, q, use, kind, tagValue, catValue);
    }
    // Legacy 5-arg version — pass through unchanged
    return templateMatches(t, q, kind, tagValue, catValue);
  }catch(e){
    // Fail closed (exclude) on unexpected errors
    return false;
  }
}

// --- Picker badges (kind / use-case) ---------------------------------------
// Choose how #frameworkSel options annotate items:
//   'kind'    → " • framework"
//   'use'     → " • problem-framing" (falls back to kind if no use tag found)
//   'both'    → " • framework • problem-framing"
const FW_OPTION_BADGE_MODE = 'both';   // change to 'kind' or 'use' if you prefer

// Optional: raw vs pretty casing for use tag display
//   'raw'    → "problem-framing"
//   'pretty' → "Problem framing"
const FW_USE_LABEL_STYLE = 'raw';

// Treat these as unhelpful "use" tags; skip them when choosing a badge.
const UNHELPFUL_USE_TAGS = new Set(['pattern', 'patterns', 'recipe', 'recipes']);


function firstUseTag(t){
  // Gather all candidate "use" values from tags and use_cases
  const usesFromTags = (t.tags || [])
    .map(String)
    .map(s => s.trim().toLowerCase())
    .filter(s => s.startsWith('use:'))
    .map(s => s.split(':', 2)[1])
    .filter(Boolean);

  const usesFromArray = Array.isArray(t.use_cases)
    ? t.use_cases.map(String).map(s => s.trim().toLowerCase()).filter(Boolean)
    : [];

  const candidates = [...usesFromTags, ...usesFromArray];

  // Return the first candidate that's not on the skip list
  const picked = candidates.find(u => !UNHELPFUL_USE_TAGS.has(u));
  return picked || '';
}


function friendlyUseTag(u){
  if (!u) return '';
  if (FW_USE_LABEL_STYLE === 'pretty'){
    const s = u.replace(/-/g,' ');
    return s.charAt(0).toUpperCase() + s.slice(1);
  }
  return u; // 'raw'
}



function refreshTemplateList(){
  const sel = document.getElementById('frameworkSel');
  if (!sel) return;

  const q    = document.getElementById('fwSearch')?.value || '';
  const kind = document.getElementById('filterKind')?.value || '__all__';   // from chips
  const tag  = document.getElementById('filterTag')?.value || '__all__';
  const cat  = document.getElementById('filterCategory')?.value || '__all__';

  const all  = (typeof getAllTemplates === 'function') ? getAllTemplates()
            : (window.TEMPLATES || window.FRAMEWORKS || []);

const use  = document.getElementById('filterUse')?.value || 'all';
const base = (use === 'all') ? all : all.filter(t => matchesUsePreset(t, use));

const hits = base.filter(t => templateMatchesCompat(t, q, kind, tag, cat));


  // “Showing N / M” hint
// Move the counter out of the search bar:
// 1) Silence the old inline hint inside the finder
const hint = document.getElementById('fwHint');
if (hint) {
  hint.hidden = true;
  hint.textContent = '';
}

// 2) Update the new counter next to "All Matches"
const countEl = document.getElementById('fwCount');
if (countEl) {
  countEl.textContent = `Showing ${hits.length} of ${all.length}`;
}


// Sort A→Z by a friendly label (case-insensitive) before rendering
const sorted = hits.slice().sort((a, b) => {
  const aa = String(a.label || a.name || a.slug || a.id || '').trim();
  const bb = String(b.label || b.name || b.slug || b.id || '').trim();
  return aa.localeCompare(bb, 'en', { sensitivity: 'base' });
});

sel.innerHTML = sorted.map(t => {
  const label = t.label || t.name || t.slug || t.id || 'Untitled';
  const kindBadge = t.kind ? ` • ${t.kind}` : '';

  const u0 = firstUseTag(t);
  const useBadge = u0 ? ` • ${friendlyUseTag(u0)}` : '';

  let suffix = kindBadge;
  if (FW_OPTION_BADGE_MODE === 'use')  suffix = useBadge || kindBadge;
  if (FW_OPTION_BADGE_MODE === 'both') suffix = `${kindBadge}${useBadge}`;

  const val = t.id || t.slug || label;
  return `<option value="${val}">${label}${suffix}</option>`;
}).join('');


  if (!sel.innerHTML){
    sel.innerHTML = `<option disabled>(No matches)</option>`;
  }
}



document.getElementById('fwHint')?.setAttribute('hidden','');


// Replace the older FIND with the unified one
window.FIND = function(id){
  const k = String(id||'').toLowerCase();
  return getAllTemplates().find(t =>
    String(t.id||'').toLowerCase()     === k ||
    String(t.slug||'').toLowerCase()   === k ||
    String(t.label||'').toLowerCase()  === k ||   // ← label support
    String(t.title||'').toLowerCase()  === k      // (back-compat if any old items use title)
  );
};
</script>

<script>
// === Slice 3: Resolver + apply-once guard ===================================
function resolveTemplate(value){
  if (!value) return null;
  const v = String(value).toLowerCase();
  const all = (typeof getAllTemplates === 'function') ? getAllTemplates() : [];

  // search helpers that compare a single prop across ALL templates
  const by = (prop) => all.find(t => String(t?.[prop] || '').toLowerCase() === v) || null;

  // strict precedence: id → slug → label → title
  return by('id') || by('slug') || by('label') || by('title') || null;
}

function isTabEmpty(tab){
  if (!tab) return true;
  const hasFields = tab.fields && Object.values(tab.fields).some(v => String(v||'').trim());
  const hasExtra  = !!String(tab.extra||'').trim();
  const hasCtx    = tab.common && Object.values(tab.common).some(v => String(v||'').trim());
  return !(hasFields || hasExtra || hasCtx);
}

function showToast(msg){
  const t = document.getElementById('toast');
  if (!t) return;
  t.textContent = msg;
  t.hidden = false;
  // auto-hide after ~2.4s
  clearTimeout(showToast._timer);
  showToast._timer = setTimeout(()=>{ t.hidden = true; }, 2400);
}

const DL_FLAG = 'pb.v1.deeplink_applied';

function applyDeeplinkIfAny(){
  const dl = window.__DEEPLINK__;
  if (!dl || sessionStorage.getItem(DL_FLAG)) return;

  const hit = resolveTemplate(dl.value);
  if (!hit){
    // Graceful failure: prime search and notify
    const q = document.getElementById('fwSearch');
    if (q) { q.value = dl.raw; q.focus(); }
    showToast(`Template “${dl.raw}” not found. Showing your last session.`);
    sessionStorage.setItem(DL_FLAG, '1');
    console.info('[deeplink] not found →', dl);
    return;
  }

  // Determine active tab and reuse/add per rule
  let tab = null, reused = false;
  try {
    tab = (window.state && Array.isArray(window.state.tabs))
      ? window.state.tabs[window.state.active || 0]
      : null;
  } catch(_) {}

  if (!tab || !isTabEmpty(tab)){
    // Add a new tab and activate it
    reused = false;
    if (typeof window.addTab === 'function'){
      window.addTab(false); // your addTab should switch active for us
      try { tab = window.state.tabs[window.state.active]; } catch(_) { tab = null; }
    } else if (window.state && Array.isArray(window.state.tabs)) {
      // Fallback safety: minimal tab object
      window.state.tabs.push({ id:'', fields:{}, extra:'', common:{} });
      window.state.active = window.state.tabs.length - 1;
      tab = window.state.tabs[window.state.active];
    }
  } else {
    reused = true;
  }

  // Apply the template to the chosen tab
  if (tab){
    tab.id     = hit.id || hit.slug || dl.value;
    tab.slug   = hit.slug || '';
    tab.kind   = hit.kind || tab.kind || 'framework';
    tab.fields = {};         // clear fields so boosters/UX are deterministic
    tab.extra  = '';         // use boosters unless user types later
  }

  // Minimal UI sync
  const sel = document.getElementById('frameworkSel');
  if (sel) {
    sel.value = (hit.id || hit.slug || '');
  }
  const q = document.getElementById('fwSearch');
  if (q) q.value = dl.raw;

  // Re-render panels
  try { if (typeof renderFields        === 'function') renderFields(); }        catch(_){}
  try { if (typeof emit               === 'function') emit(); else if (typeof emitAll === 'function') emitAll(); } catch(_){}
  try { if (typeof refreshTemplateList === 'function') refreshTemplateList(); } catch(_){}

  // Mark as applied (one-shot per load)
  sessionStorage.setItem(DL_FLAG, '1');

  console.info(`[deeplink] applying "${dl.raw}" → "${hit.id||hit.slug}" (${reused?'reuseTab':'newTab'})`);
}
</script>


<script>
// === Slice 2: Data-ready barrier ============================================
let __DATA_READY_PROMISE = null;

function whenDataReady(fn){
  if (!__DATA_READY_PROMISE){
    __DATA_READY_PROMISE = new Promise((resolve)=>{
      // A) DOMContentLoaded
      const domReady = (document.readyState === 'interactive' || document.readyState === 'complete')
        ? Promise.resolve()
        : new Promise(r => document.addEventListener('DOMContentLoaded', r, { once: true }));

      // B) Core templates present (FRAMEWORKS/TEMPLATES/templates)
      const coreReady = new Promise(r=>{
        let tries = 0;
        (function tick(){
          tries++;
          const hasCore =
            Array.isArray(window.FRAMEWORKS) ||
            Array.isArray(window.TEMPLATES)  ||
            Array.isArray(window.templates);
          if (hasCore) return r();
          if (tries < 200) { setTimeout(tick, 20); } // ~4s max
          else r(); // give up gracefully; we'll still proceed
        })();
      });

      // C) Tasks loader has fired its onready (even if file missing)
      const tasksReady = new Promise(r=>{
        try {
          // ensureTasksLoaded is defined earlier in this file
          ensureTasksLoaded(()=> r());
        } catch(_) {
          r(); // if missing, don't block boot
        }
      });

      Promise.all([domReady, coreReady, tasksReady]).then(resolve);
    });
  }

  return __DATA_READY_PROMISE.then(()=>{
    if (typeof fn === 'function') {
      try { fn(); } catch (e) { console.warn('[deeplink] handler error:', e); }
    }
  });
}
</script>


<script>
// === Slice 1: Deep-link parser (no side effects) ============================
function parseLinkTarget(){
  // 1) Prefer explicit search params (?id=.. or ?slug=..)
  const url   = new URL(location.href);
  const rawId = url.searchParams.get('id');
  const rawSl = url.searchParams.get('slug');

  // 2) Fallback to hash (#<id-or-slug>)
  const rawHash = (location.hash || '').replace(/^#/, '');

  // Resolve precedence: id > slug > hash
  const raw = (rawId || rawSl || rawHash || '').trim();
  if (!raw) return null;

  // Normalize & label the source
  const value = raw.toLowerCase();
  const type  = rawId ? 'id' : (rawSl ? 'slug' : 'hash');

  return { raw, value, type };
}

// Expose for devtools inspection (no side effects here)
window.__DEEPLINK__ = parseLinkTarget();
if (window.__DEEPLINK__) {
  console.info('[deeplink] detected →', window.__DEEPLINK__);
}
</script>


  <script>
  (function(){
    const $ = s=>document.querySelector(s);
    // Use the new Action Modal for copy/open flows
window.__USE_ACTION_MODAL__ = true;

// --- LENS catalog (prompt-safe, no CoT leakage) ---
window.__LENSES__ = [
  {
    lens_id: "analytical-algorithmic",
    label: "Logic",
    intent: "Plan before acting; produce verifiable steps.",
    stack: ["plan-and-solve", "least-to-most", "question-decomposition", "micro-checks"],
    interaction: {"clarify_threshold": "medium", "max_clarifying_questions": 1, "verification_cadence": "light"},
    output_hints: ["numbered procedures when allowed", "explicit assumptions", "sanity-check notes"],
    non_interference: ["yield_to_prior_format", "single_clarifying_question_max", "skip_ceremony_if_trivial", "do_not_reveal_chain_of_thought"],
    evaluation_hooks: ["subgoal_validation", "recompute_key_numbers", "uncertainty_bounds"],
    prompt: "LENS—Analytical-Algorithmic. Unless earlier instructions specify otherwise, do not change the requested format. Internally draft a short plan (subgoals → sequence), pick the simplest correct path, then execute. If ambiguity is material, ask one clarifying question; otherwise proceed and state any assumptions briefly. Keep detailed working private; present only the final result with tightly written numbered steps if allowed. For each major step, run a micro-sanity check (recompute key figures or confirm preconditions). If the task is trivial, skip ceremony and answer directly. Where relevant, report residual uncertainty in one short line."
  },
  {
    lens_id: "divergent-inventive",
    label: "Creative",
    intent: "Broaden the idea space, then converge with criteria.",
    stack: ["divergent-thinking", "lateral-reframing", "tree-of-thought-branching", "criteria-based-convergence"],
    interaction: {"clarify_threshold": "low", "max_clarifying_questions": 0, "verification_cadence": "light"},
    output_hints: ["shortlist of top options when allowed", "one explicit reframing", "trade-off micro-summary"],
    non_interference: ["yield_to_prior_format", "internal_brainstorm_then_concise_output", "cap_ideas_to_avoid_bloat", "do_not_reveal_chain_of_thought"],
    evaluation_hooks: ["distinctness_check_between_options", "selection_criteria_explicit", "why-these-win-over-nearby"],
    prompt: "LENS—Divergent-Inventive. Keep the user’s requested format intact. Privately generate several distinct approaches (different frames, not superficial variants), then choose the best 1–2 using simple, stated criteria (e.g., feasibility, impact, risk). Show only: the chosen approach (final answer) plus, if permitted by format, a micro-shortlist (≤3 lines) and one sentence that reframes the problem. Avoid idea bloat; prioritize originality with plausibility. Do not reveal raw brainstorming."
  },
  {
    lens_id: "skeptical-verifier",
    label: "Verify",
    intent: "Stress-test claims and minimize hallucinations.",
    stack: ["question-summarization", "chain-of-verification", "counterexample-attempt", "evidence-grounding"],
    interaction: {"clarify_threshold": "medium", "max_clarifying_questions": 1, "verification_cadence": "focused"},
    output_hints: ["claim–evidence–uncertainty triples", "discrepancy notes if sources disagree"],
    non_interference: ["yield_to_prior_format", "no_speculation", "admit_unknowns", "do_not_reveal_chain_of_thought"],
    evaluation_hooks: ["attempt_falsification_on_key_point", "cite_or_flag_needs_verification", "state_assumptions"],
    prompt: "LENS—Skeptical-Verifier. Preserve prior format. Silently restate the core question, then identify claims needing evidence or calculation. Try one concise falsification or counterexample where meaningful. Provide the final answer only if it survives the check; otherwise revise. When facts matter, ground key statements with concise citations if permitted, or clearly mark items as ‘needs verification’ rather than guessing. Include a one-line uncertainty note when appropriate. No speculation; do not fabricate sources."
  },
  {
    lens_id: "systems-integrator",
    label: "Systems",
    intent: "Expose interdependencies and second-order effects.",
    stack: ["systems-thinking", "causal-reasoning", "scenario-comparison", "boundary-setting"],
    interaction: {"clarify_threshold": "high", "max_clarifying_questions": 0, "verification_cadence": "light"},
    output_hints: ["concise causal notes", "two-scenario table when allowed", "explicit scope boundaries"],
    non_interference: ["yield_to_prior_format", "keep_diagrams_textual_if_needed", "avoid_scope_creep", "do_not_reveal_chain_of_thought"],
    evaluation_hooks: ["name_key_levers", "note_feedback_loops", "flag_unintended_consequences"],
    prompt: "LENS—Systems-Integrator. Do not alter the requested output format. Frame the problem with explicit boundaries (what’s in vs out). Internally map primary components, key levers, and feedback loops; then deliver the final answer with a short note on likely second-order effects and trade-offs. Where allowed, add a tiny two-scenario comparison (baseline vs alternative) in ≤4 lines to surface interdependencies. Avoid scope creep; keep mechanisms clear and succinct."
  },
  {
    lens_id: "human-centered-mediator",
    label: "Empathy",
    intent: "Preserve accuracy while optimizing for audience understanding and emotional safety.",
    stack: ["plain-language-translation", "audience-alignment", "empathic-mirroring", "dialogic-bridge", "narrative-reasoning", "nvc-lite", "choice-architecture"],
    interaction: {"clarify_threshold": "medium", "max_clarifying_questions": 1, "verification_cadence": "light"},
    output_hints: ["one-line empathy preface when allowed", "plain-language companion line", "2-option next steps", "jargon audit"],
    non_interference: ["yield_to_prior_format", "do_not_dilute_accuracy", "tone_respectful_succinct", "avoid_diagnosis_or_assumptions", "do_not_reveal_chain_of_thought"],
    evaluation_hooks: ["empathy_first_line_check", "reader_comprehension_test", "nonjudgmental_language_scan", "actionability_check", "accuracy_guardrail"],
    prompt: "LENS—Human-Centered Mediator (Empathy). Do not alter the requested output format. Empathy here means: briefly acknowledge the user’s situation or concern in neutral, nonjudgmental language; reflect likely feelings/needs without guessing facts; and choose wording that reduces blame and defensiveness. Maintain technical accuracy—do not soften or embellish facts. Use A→V→I→O micro-structure: Acknowledge (one line) → Validate relevance (why it matters) → Inform (the accurate content) → Offer options/next steps (1–2 items). Avoid diagnosing, platitudes, moralizing, or minimizing risk. If stakes are sensitive, prefer opt-in questions (e.g., “Would you like a quick summary or detailed steps?”). If the format disallows extra lines, integrate a single empathy phrase into the first sentence. Keep tone respectful, concise, and specific."
  }
];


(function ensureThemeToggle(){
  const btn = document.getElementById('theme');
  if (!btn) return;
  btn.addEventListener('click', ()=>{
    const root = document.documentElement;
    const cur  = root.getAttribute('data-theme') || 'dark';
    const next = (cur === 'light') ? 'dark' : 'light';
    root.setAttribute('data-theme', next);
    btn.setAttribute('aria-pressed', next === 'light' ? 'true' : 'false');
    const label = btn.querySelector('span:last-child');
    if (label) label.textContent = next === 'light' ? 'Dark' : 'Light';
    try{
      const ui = JSON.parse(localStorage.getItem('pb.v1.ui') || '{}');
      ui.theme = next;
      localStorage.setItem('pb.v1.ui', JSON.stringify(ui));
    }catch(_){}
    // Let your existing "saveUI after click" hook run too (it already exists).
  });
})();
    
    
    // --- Persistence (localStorage) ------------------------------
const LS_KEYS = {
  state: 'pb.v1.state',
  ui:    'pb.v1.ui'
};

// Clear all saved app data and reload
function resetSavedSession(){
  try{
    if (typeof clearCommonContext === 'function') clearCommonContext();
    localStorage.removeItem((LS_KEYS && LS_KEYS.state) || 'pb.v1.state');
    localStorage.removeItem((LS_KEYS && LS_KEYS.ui)    || 'pb.v1.ui');
    // also nuke any old per-field mirrors for good measure
    ['usecase','audience','style','tone'].forEach(id=> localStorage.removeItem('fw_'+id));
  }catch(e){ console.warn('Reset failed:', e); }
  location.reload();
}


function _safeParse(s){ try{ return JSON.parse(s); }catch(e){ return null; } }

function loadSavedState(){
  const raw = localStorage.getItem(LS_KEYS.state);
  return raw ? _safeParse(raw) : null;
}

let _saveTimer = null;
function saveNow(){
  try{
    // 'state' is our live app state (tabs, fields, active, etc.)
    localStorage.setItem(LS_KEYS.state, JSON.stringify(state));
    // --- optional: snapshot history (shows up in saved-sessions.html) ---
// --- snapshot history for saved-sessions.html ---
try {
  const key  = 'pb.v1.history';
  const ui   = JSON.parse(localStorage.getItem((LS_KEYS && LS_KEYS.ui) || 'pb.v1.ui') || '{}');
  const snap = {
    ts: Date.now(),
    kind: (window.__SAVE_KIND__ || 'unknown'), // 'manual' or 'auto'
    state: state,
    ui: ui
  };
  const hist = JSON.parse(localStorage.getItem(key) || '[]');
  hist.push(snap);
  const MAX = 50; // adjust if you want more or fewer snapshots
  while (hist.length > MAX) hist.shift();
  localStorage.setItem(key, JSON.stringify(hist));
} catch (_) { /* ignore quota/JSON errors */ }
  }catch(e){
    console.warn('localStorage save failed:', e);
  }finally{
    _saveTimer = null;
  }
}
function scheduleSave(){
  if (_saveTimer) clearTimeout(_saveTimer);
  _saveTimer = setTimeout(()=>{
    window.__SAVE_KIND__ = 'auto';
    try { saveNow(); } finally { window.__SAVE_KIND__ = undefined; }
  }, 300); // keep your debounce
}

// UI (theme + left panel width)
function applySavedUI(){
  const ui = _safeParse(localStorage.getItem(LS_KEYS.ui)) || {};
  
  // First-time defaults: preview hidden + LIGHT theme
const isFirstTime = !localStorage.getItem(LS_KEYS.ui);
if (isFirstTime){
  ui.previewHidden = true;
  ui.theme = 'light';
  document.documentElement.setAttribute('data-theme', 'light'); // paint correctly now
  try { localStorage.setItem(LS_KEYS.ui, JSON.stringify(ui)); } catch(_){}
}
  if (ui.leftW){
    document.documentElement.style.setProperty('--leftW', ui.leftW);
  }
  if (ui.theme){
    document.documentElement.setAttribute('data-theme', ui.theme);
    const tbtn = document.getElementById('theme');
    if (tbtn){
      const isLight = ui.theme === 'light';
      tbtn.setAttribute('aria-pressed', isLight ? 'true' : 'false');
      // optional label swap if your button shows "Light"/"Dark"
      const label = tbtn.querySelector('span:last-child');
      if (label) label.textContent = isLight ? 'Dark' : 'Light';
        // Restore Common context collapsed state (default: collapsed/hidden)
  const ccCollapsed = (ui && typeof ui.commonCollapsed === 'boolean') ? ui.commonCollapsed : true;
  setCommonCtxCollapsed(ccCollapsed);
    }
    // NEW: restore Picker + Fields collapsed state (defaults: expanded/shown)
const pkCollapsed = (ui && typeof ui.pickerCollapsed === 'boolean') ? ui.pickerCollapsed : false;
const fdCollapsed = (ui && typeof ui.fieldsCollapsed === 'boolean') ? ui.fieldsCollapsed : false;
setPickerCollapsed(pkCollapsed);
setFieldsCollapsed(fdCollapsed);

  }
  
// NEW: restore preview hidden state
if (ui.previewHidden){
  const wrap = document.querySelector('.wrap');
  wrap && wrap.classList.add('preview-hidden');

  // preview panel hint
  const previewPanel = document.getElementById('previewPanel');
  if (previewPanel) previewPanel.setAttribute('aria-hidden', 'true');

  // main toggle (in preview header if present)
  const pbtn = document.getElementById('previewToggle');
  if (pbtn){
    pbtn.setAttribute('aria-pressed', 'true');
    pbtn.textContent = 'Show Preview';
  }

  // Show button in configure header (left) — unhide it
  const showBtn = document.getElementById('showPreviewBtn');
  if (showBtn){
    showBtn.hidden = false;
    showBtn.setAttribute('aria-hidden', 'false');
  }
} else {
  // ensure left show button is hidden by default when preview visible
  const showBtn = document.getElementById('showPreviewBtn');
  if (showBtn){
    showBtn.hidden = true;
    showBtn.setAttribute('aria-hidden', 'true');
  }
}

  
  // Restore preview hidden state and sync the two buttons
const wrap = document.querySelector('.wrap');
const isHidden = !!( (_safeParse(localStorage.getItem(LS_KEYS.ui)) || {}).previewHidden );

if (wrap) wrap.classList.toggle('preview-hidden', isHidden);

const panel = document.getElementById('previewPanel');
if (panel) panel.setAttribute('aria-hidden', isHidden ? 'true' : 'false');

const showBtn = document.getElementById('showPreviewBtn');
const hideBtn = document.getElementById('hidePreviewBtn');
if (showBtn) showBtn.hidden = !isHidden;
if (hideBtn) hideBtn.hidden =  isHidden;
  
}


function saveUI(){
  try{
    const wrap = document.querySelector('.wrap');
    const cols = wrap ? getComputedStyle(wrap).gridTemplateColumns : '';
    const leftW = cols ? cols.split(' ')[0] : getComputedStyle(document.documentElement).getPropertyValue('--leftW') || '360px';
    const theme = document.documentElement.getAttribute('data-theme') || 'dark';
    const commonCollapsed = !!(document.getElementById('commonCtxBody')?.hidden);
    const previewHidden = !!(wrap && wrap.classList.contains('preview-hidden')); // <-- define BEFORE using
     const pickerCollapsed = !!(document.getElementById('pickerBody')?.hidden);
    const fieldsCollapsed = !!(document.getElementById('fieldsBody')?.hidden);

    localStorage.setItem(LS_KEYS.ui, JSON.stringify({ leftW, theme,
      previewHidden,
      commonCollapsed,
      pickerCollapsed,
      fieldsCollapsed, 
      ts: Date.now() 
      }));
  }catch(e){
    console.warn('localStorage UI save failed:', e);
  }
}

// Apply UI prefs ASAP (before building the UI)
applySavedUI();

// Global safety nets: save on input/changes and when leaving
document.addEventListener('input',  scheduleSave, { capture:true });
document.addEventListener('change', scheduleSave, { capture:true });
document.addEventListener('visibilitychange', ()=>{
  if (document.hidden){
    window.__SAVE_KIND__ = 'auto';
    try { saveNow(); } finally { window.__SAVE_KIND__ = undefined; }
  }
});
window.addEventListener('beforeunload', ()=>{
  window.__SAVE_KIND__ = 'auto';
  try { saveNow(); } finally { window.__SAVE_KIND__ = undefined; }
});

// Save UI when theme toggles or the resizer stops
window.addEventListener('load', ()=>{
  const themeBtn = document.getElementById('theme');
  if (themeBtn){
    themeBtn.addEventListener('click', ()=> setTimeout(saveUI, 0));
  }

// NEW: show/hide preview panel — wire both header buttons (preview header and left header)
const hidePreviewBtn  = document.getElementById('hidePreviewBtn');   // in preview panel header
const showPreviewBtn  = document.getElementById('showPreviewBtn');   // in Configure header (left)
const legacyToggleBtn = document.getElementById('previewToggle');    // old header button (optional)

function togglePreview(){
  const wrap  = document.querySelector('.wrap');
  if (!wrap) return;

  const nowHidden = !wrap.classList.contains('preview-hidden');
  wrap.classList.toggle('preview-hidden', nowHidden);

  // preview panel visibility (for a11y)
  const panel = document.getElementById('previewPanel');
  if (panel) panel.setAttribute('aria-hidden', nowHidden ? 'true' : 'false');

  // New buttons: hide/show live in the panel headers
  const hideBtn = document.getElementById('hidePreviewBtn');  // right-side header
  const showBtn = document.getElementById('showPreviewBtn');  // left-side header
  if (hideBtn) hideBtn.hidden = nowHidden;   // hidden when preview is hidden
  if (showBtn) showBtn.hidden = !nowHidden;  // shown when preview is hidden

  // Legacy header toggle (if still in DOM)
  const legacy = document.getElementById('previewToggle');
  if (legacy){
    legacy.setAttribute('aria-pressed', nowHidden ? 'true' : 'false');
    legacy.textContent = nowHidden ? 'Show Preview' : 'Hide Preview';
  }

  saveUI();
}


// wire both buttons (if present)
if (hidePreviewBtn)  hidePreviewBtn.addEventListener('click', togglePreview);
if (showPreviewBtn)  showPreviewBtn.addEventListener('click', togglePreview);
if (legacyToggleBtn) legacyToggleBtn.addEventListener('click', togglePreview); // optional


  const resizer = document.getElementById('resizer');
  if (resizer){
    resizer.addEventListener('pointerup', saveUI);
    resizer.addEventListener('keyup',     saveUI);
    
      // Common context show/hide toggle
  const ccToggle = document.getElementById('commonCtxToggle');
  if (ccToggle){
    ccToggle.addEventListener('click', ()=>{
      const body = document.getElementById('commonCtxBody');
      if (!body) return;
      const collapsed = !body.hidden ? true : false; // flip
      setCommonCtxCollapsed(collapsed);
      saveUI();
    });
  }
  
  // Picker show/hide toggle
const pickerToggle = document.getElementById('pickerToggle');
if (pickerToggle){
  pickerToggle.addEventListener('click', ()=>{
    const body = document.getElementById('pickerBody');
    if (!body) return;
    const collapsed = !body.hidden ? true : false;
    setPickerCollapsed(collapsed);
    saveUI();
  });
}

// Fields show/hide toggle
const fieldsToggle = document.getElementById('fieldsToggle');
if (fieldsToggle){
  fieldsToggle.addEventListener('click', ()=>{
    const body = document.getElementById('fieldsBody');
    if (!body) return;
    const collapsed = !body.hidden ? true : false;
    setFieldsCollapsed(collapsed);
    saveUI();
  });
}

    
  }
  
    // Init Kind/Category options on load
  if (document.getElementById('filtersWrap')) updateFilterOptions();
  
  // === Unified search + filters wiring (uses refreshTemplateList) ===
// === Unified search + filters wiring (uses refreshTemplateList) ===
const fwSearch   = document.getElementById('fwSearch');
const tagSel     = document.getElementById('filterTag');
const catSel     = document.getElementById('filterCategory');
const kindHidden = document.getElementById('filterKind');  // chips write here
const allBtn     = document.getElementById('fwAll');

fwSearch && fwSearch.addEventListener('input',  refreshTemplateList);
tagSel   && tagSel.addEventListener('change',   refreshTemplateList);
catSel   && catSel.addEventListener('change',   refreshTemplateList);

allBtn && allBtn.addEventListener('click', ()=>{
  if (fwSearch)   fwSearch.value = '';
  if (tagSel)     tagSel.value   = '__all__';
  if (catSel)     catSel.value   = '__all__';
  if (kindHidden) kindHidden.value = '__all__';

  const useHidden = document.getElementById('filterUse');
  if (useHidden) useHidden.value = 'all';

  if (typeof renderKindChips === 'function') renderKindChips();
  if (typeof renderUseChips  === 'function') renderUseChips();

  refreshTemplateList();
});


  // Deck visibility: show only when there are 2+ tabs
  updateDeckVisibility();

  // Keep deck visibility synced with tab changes without touching your tab code
  (function observeTabs(){
    const tabbar = document.getElementById('tabbar');
    if (!tabbar) return;
    const mo = new MutationObserver(() => updateDeckVisibility());
    mo.observe(tabbar, { childList: true }); // watch add/remove tab pills
  })();



// After the page is ready, make sure tasks are loaded, then (re)build filters & list
ensureTasksLoaded(()=>{
  try{
    updateFilterOptions();   // will rewrite below
    refreshTemplateList();   // will add below
    whenDataReady(applyDeeplinkIfAny);
  }catch(_){}
});
  
});


function setCommonCtxCollapsed(collapsed){
  const body   = document.getElementById('commonCtxBody');
  const toggle = document.getElementById('commonCtxToggle');
  if (!body || !toggle) return;
  body.hidden = !!collapsed;
  toggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
  toggle.textContent = collapsed ? 'Show' : 'Hide';
  toggle.title = collapsed ? 'Show common context' : 'Hide common context';
}

function setPickerCollapsed(collapsed){
  const body   = document.getElementById('pickerBody');
  const toggle = document.getElementById('pickerToggle');
  if (!body || !toggle) return;
  body.hidden = !!collapsed;
  toggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
  toggle.textContent = collapsed ? 'Show' : 'Hide';
  toggle.title = collapsed ? 'Show template picker' : 'Hide template picker';
}

function setFieldsCollapsed(collapsed){
  const body   = document.getElementById('fieldsBody');
  const toggle = document.getElementById('fieldsToggle');
  if (!body || !toggle) return;
  body.hidden = !!collapsed;
  toggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
  toggle.textContent = collapsed ? 'Show' : 'Hide';
  toggle.title = collapsed ? 'Show template fields' : 'Hide template fields';
}


function updateDeckVisibility(){
  const deckLabel = document.getElementById('deckLabel');
  const deck      = document.getElementById('outDeck');

  // Prefer state.tabs if available; else infer from #tabbar children
  let count = 0;
  try {
    if (state && Array.isArray(state.tabs)) {
      // ignore any soft-deleted tabs if you use that pattern
      count = state.tabs.filter(t => !t?._deleted).length;
    } else {
      const tabbar = document.getElementById('tabbar');
      count = tabbar ? tabbar.children.length : 0;
    }
  } catch(_) {}

  const show = count >= 2;

  [deckLabel, deck].forEach(el => {
    if (!el) return;
    el.hidden = !show;
    el.setAttribute('aria-hidden', String(!show));
  });
}


// Clear Common context across UI + state (all tabs)
function clearCommonContext(){
  // 1) Clear visible inputs
  const ids = ['usecase','audience','style','tone','biasInput'];
  ids.forEach(id=>{
    const el = document.getElementById(id);
    if (el){ el.value = ''; el.classList.remove('filled'); }
  });

  // 2) Clear chips UI
  const audienceChips = document.getElementById('audienceChips');
  const biasChips     = document.getElementById('biasChips');
  if (audienceChips) audienceChips.innerHTML = '';
  if (biasChips)     biasChips.innerHTML     = '';

  // 3) Clear per-tab Common context in state
  try{
    (state.tabs || []).forEach(t=>{
      t.common = t.common || {};
      t.common.ctx = '';
      t.common.audience = '';
      t.common.style = '';
      t.common.tone  = '';
      // persona/bias selections
      t.common.audience_persona  = null;
      t.common.audience_personas = [];
      t.common.bias_ids          = [];
      t.common.bias_names        = '';
    });
  }catch(_){}

  // 4) Clear any per-field localStorage mirrors
  try{
    ['usecase','audience','style','tone'].forEach(id=> localStorage.removeItem('fw_'+id));
  }catch(_){}

  // 5) Reflect immediately in preview
  if (typeof renderFields === 'function') renderFields();   // re-hydrate chips/inputs
  if (typeof emitAll      === 'function') emitAll();        // re-render preview + deck
}

    
    /* ===== Persona helpers ===== */
function personaIndex(){
  // Returns an array; empty if the data hasn't loaded yet.
  return Array.isArray(window.PERSONAS) ? window.PERSONAS : [];
}

function personaFilter(query, max=20){
  const q = (query||'').trim().toLowerCase();
  if (!q) return [];
  const toks = q.split(/\s+/).filter(Boolean);
  const src = personaIndex();

  // Score by token coverage + prefix boost on name/id
  const scored = src.map(p=>{
    const hay = (p.meta?.search_text || `${p.name||''} ${p.profession||''} ${(p.tags||[]).join(' ')}`).toLowerCase();
    let s = 0;
    for (const t of toks){
      if (hay.includes(t)) s += 2;
      if (String(p.name||'').toLowerCase().startsWith(t)) s += 4;
      if (String(p.id||'').toLowerCase().startsWith(t)) s += 3;
    }
    return {p, s};
  }).filter(x=>x.s>0)
    .sort((a,b)=> b.s - a.s || String(a.p.name).localeCompare(String(b.p.name)));

  return scored.slice(0,max).map(x=>x.p);
}

function personaText(p){
  const asList = v => Array.isArray(v) ? v : String(v||'').split(/[\n,]+/).map(s=>s.trim()).filter(Boolean);
  const bullets = arr => asList(arr).map(x=>'• ' + x).join('\n');
  const csv     = arr => asList(arr).join(', ');
  return [
    p.name && `Name: ${p.name}`,
    p.profession && `Profession: ${p.profession}`,
    p.summary && `Summary: ${p.summary}`,
    p.description && `Description: ${p.description}`,
    (p.core_tasks && asList(p.core_tasks).length) && `Core tasks:\n${bullets(p.core_tasks)}`,
    (p.skills && asList(p.skills).length) && `Skills: ${csv(p.skills)}`,
    (p.vocabulary && asList(p.vocabulary).length) && `Vocabulary: ${csv(p.vocabulary)}`,
    (p.goals && asList(p.goals).length) && `Goals:\n${bullets(p.goals)}`,
    (p.pain_points && asList(p.pain_points).length) && `Pain points:\n${bullets(p.pain_points)}`,
    (p.tools && asList(p.tools).length) && `Tools: ${csv(p.tools)}`
  ].filter(Boolean).join('\n');
}


function applyPersonaToTab(tab, persona){
  if (!tab || !persona) return;
  // Do NOT touch 'end' (user-supplied goal)
  tab.fields = {
    ...(tab.fields||{}),
    persona_name: persona.name || '',
    profession:   persona.profession || '',
    summary:      persona.summary || '',
    description:  persona.description || '',
    core_tasks:   (persona.core_tasks||[]).join('\n'),
    skills:       (persona.skills||[]).join(', '),
    vocabulary:   (persona.vocabulary||[]).join(', '),
    goals:        (persona.goals||[]).join('\n'),
    pain_points:  (persona.pain_points||[]).join('\n'),
    tools:        (persona.tools||[]).join(', ')
  };
}


// --- Persona string helpers (global) ---
// Build a compact inline string (defaults to Name/Profession/Summary with labels)
function personaInlineFlexible(p, opts = {}){
  const include = Array.isArray(opts.include) && opts.include.length
    ? opts.include : ['name','profession','summary'];
  const labels = opts.labels !== false;
  const sep = typeof opts.sep === 'string' ? opts.sep : ' · ';
  const labelMap = {
    name: labels ? 'Name: ' : '',
    profession: labels ? 'Profession: ' : '',
    role: labels ? 'Role: ' : '',
    title: labels ? 'Title: ' : '',
    summary: labels ? 'Summary: ' : '',
    bio: labels ? 'Bio: ' : '',
    expertise: labels ? 'Expertise: ' : ''
  };
  return include
    .map(k => ((p?.[k] ?? '').toString().trim() ? labelMap[k] + p[k] : ''))
    .filter(Boolean)
    .join(sep);
}

// Lightweight “just the name”
function personaInline(p){ return p?.name || ''; }

// Template fill utility (e.g., "Hello {name}")
function personaFillTemplate(tpl, p){
  return String(tpl||'').replace(/\{(\w+)\}/g, (_,k)=> (p?.[k] ?? ''));
}


// --- Persona datasource (expects window.PERSONAS or similar) ---
function getAllPersonas(){
  const raw = (window.PERSONAS || window.personas || window.PERSONA_LIBRARY || []);
  return Array.isArray(raw) ? raw : [];
}

function personaKeyFields(p){
  return [
    p.name || p.label || p.persona_name || '',
    p.profession || '',
    p.summary || '',
    (p.tags||[]).join(' '),
    (p.skills||''),
    (p.vocabulary||''),
    (p.goals||''),
    (p.pain_points||'')
  ].join(' ').toLowerCase();
}

// Tiny in-memory index
let __PERSONA_IDX = null;
function buildPersonaIndex(){
  const list = getAllPersonas();
  __PERSONA_IDX = list.map((p,i)=>({
    i, name: String(p.name || p.label || 'Unknown').trim(),
    hay: personaKeyFields(p), p
  }));
  return __PERSONA_IDX;
}
function searchPersonas(q){
  if (!__PERSONA_IDX) buildPersonaIndex();
  const toks = String(q||'').toLowerCase().split(/[^a-z0-9]+/).filter(Boolean);
  if (!toks.length) return __PERSONA_IDX.slice(0,8);
  return __PERSONA_IDX
    .map(r=>{
      let s = 0; for (const t of toks){ if (r.hay.includes(t)) s++; }
      return { ...r, s };
    })
    .filter(r => r.s > 0)
    .sort((a,b)=> b.s - a.s || a.name.localeCompare(b.name))
    .slice(0,8);
}

// Render a compact block for prompts (NOT the Audience field)
function formatPersonaForPrompt(p){
  const list = s => String(s||'').split(/[\n,]+/).map(x=>x.trim()).filter(Boolean);
  const bullets = (arr, label) => arr.length ? `${label}:\n` + arr.map(x=>`- ${x}`).join('\n') : '';
  return [
    `Audience profile — ${p.name || p.label || 'Selected Persona'}`,
    p.summary && `Summary: ${p.summary}`,
    bullets(list(p.core_tasks),'Core tasks'),
    bullets(list(p.skills),'Skills'),
    bullets(list(p.goals),'Goals'),
    bullets(list(p.pain_points),'Pain points'),
    bullets(list(p.vocabulary),'Vocabulary'),
    bullets(list(p.tools),'Tools')
  ].filter(Boolean).join('\n');
}

// Attach lightweight typeahead to the Audience input
function attachPersonaTypeahead(inputEl, menuEl, getActiveTab, onChange){
  function close(){ menuEl.hidden = true; menuEl.innerHTML = ''; active = -1; }
  let items = [], active = -1;

  inputEl.addEventListener('input', ()=>{
    const q = inputEl.value.trim();
    items = searchPersonas(q);
    if (!items.length){ close(); return; }
menuEl.innerHTML = items.map((r,idx)=>{
  const sum = (r.p && (r.p.summary || r.p.definition || '') || '').toString().trim();
  return `<div class="ta-item${idx===0?' ta-active':''}" data-idx="${idx}">
    <div class="name"><strong>${r.name}</strong></div>
    ${sum ? `<div class="sub">${sum}</div>` : ''}
  </div>`;
}).join('');
    active = 0;
    // position the menu under input
    const rect = inputEl.getBoundingClientRect();
    menuEl.style.minWidth = rect.width + 'px';
    menuEl.hidden = false;
  });

  inputEl.addEventListener('keydown', (e)=>{
    if (menuEl.hidden) return;
    if (e.key === 'ArrowDown'){ e.preventDefault(); active = Math.min(active+1, items.length-1); highlight(); }
    else if (e.key === 'ArrowUp'){ e.preventDefault(); active = Math.max(active-1, 0); highlight(); }
    else if (e.key === 'Enter' || e.key === ','){ e.preventDefault(); pick(active); }
    else if (e.key === 'Escape'){ close(); }
  });

  menuEl.addEventListener('mousedown', (e)=>{
    const el = e.target.closest('.ta-item'); if (!el) return;
    pick(parseInt(el.dataset.idx,10)||0);
  });

  function highlight(){
    [...menuEl.querySelectorAll('.ta-item')].forEach((n,i)=> n.classList.toggle('ta-active', i===active));
  }
function pick(i){
  const r = items[i]; if (!r) return;
  close();

  // Persist to the active tab (as before)
  const tab = getActiveTab && getActiveTab();
  let names = [];
  if (tab){
    tab.common = tab.common || {};
    const arr = Array.isArray(tab.common.audience_personas) ? tab.common.audience_personas : [];

    // De-dupe by id or name
    const exists = arr.some(p =>
      String(p.id||p.name).toLowerCase() === String(r.p.id||r.p.name).toLowerCase()
    );
    if (!exists) arr.push(r.p);

    tab.common.audience_personas = arr;
    tab.common.audience_persona  = arr[0]; // back-compat single
    names = arr.map(p => p.name).filter(Boolean);

    // What the user sees in the field (just the names, comma-sep)
    tab.common.audience = names.join(', ');
    if (onChange) onChange(tab);
  }

  // Replace the partial token with the normalized CSV
  inputEl.value = names.length ? names.join(', ') : (r.name || '');
  inputEl.classList.toggle('filled', !!inputEl.value);
  inputEl.focus();
}



  // Click-away to close
  document.addEventListener('click', (ev)=>{
    if (ev.target!==inputEl && !menuEl.contains(ev.target)) close();
  });
}

// Escape text for use inside HTML attributes (e.g., title="")
function attrEscape(s){
  return String(s ?? '')
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;');
}

// Build the tooltip text for a framework option
function optionTooltip(t){
  const src = (t.definition || t.help || ((t.use_cases||[])[0]) || '').toString().trim();
  const clean = src.replace(/\s+/g,' ');
  // Keep it short-ish; browsers render long titles but huge blobs feel janky
  return attrEscape(clean.length ? clean.slice(0, 300) : 'No description');
}


/* ===== Bias helpers ===== */
// Minimal, persona-parallel utilities. Won’t touch existing persona flows.

function biasIndex(){
  // Prefer window.* but gracefully accept a top-level BIASES const
  if (Array.isArray(window.BIASES))        return window.BIASES;
  if (Array.isArray(window.biases))        return window.biases;
  if (Array.isArray(window.BIAS_LIBRARY))  return window.BIAS_LIBRARY;
  if (Array.isArray(window.BIAS))          return window.BIAS;
  try { if (typeof BIASES !== 'undefined' && Array.isArray(BIASES)) return BIASES; } catch (e){}
  return [];
}


function _biasAsList(v){ return Array.isArray(v) ? v : String(v||'').split(/[\n,]+/).map(s=>s.trim()).filter(Boolean); }
function _biasBullets(arr){ return _biasAsList(arr).map(x=>'• '+x).join('\n'); }
function _biasCSV(arr){ return _biasAsList(arr).join(', '); }

function biasKeyFields(b){
  return [
    b.name || b.label || b.bias_name || '',
    b.kind || '',
    b.category || '',
    b.summary || b.definition || b.description || '',
    (b.tags||[]).join(' '),
    (b.contexts||''),
    (b.mitigations||''),
    (b.examples||'')
  ].join(' ').toLowerCase();
}

let __BIAS_IDX = null;
function buildBiasIndex(){
  const list = biasIndex();
  __BIAS_IDX = list.map((b,i)=>({
    i,
    name: String(b.name || b.label || 'Unknown bias').trim(),
    hay: biasKeyFields(b),
    b
  }));
  return __BIAS_IDX;
}

function searchBiases(q, max=30){
  // Build on first use; if we built too early (empty) but data is now present, rebuild.
  if (!__BIAS_IDX || (__BIAS_IDX.length === 0 && Array.isArray(biasIndex()) && biasIndex().length > 0)) {
    buildBiasIndex();
  }
  const toks = String(q||'').toLowerCase().split(/[^a-z0-9]+/).filter(Boolean);
  if (!toks.length) return (__BIAS_IDX || []).slice(0, Math.min(max, (__BIAS_IDX||[]).length)).map(r=>r.b);
  return (__BIAS_IDX || [])
    .map(r=>{
      let s=0; for (const t of toks){ if (r.hay.includes(t)) s++; if (r.name.toLowerCase().startsWith(t)) s+=2; }
      return { ...r, s };
    })
    .filter(r=> r.s>0)
    .sort((a,b)=> b.s - a.s || a.name.localeCompare(b.name))
    .slice(0, max)
    .map(r=> r.b);
}

// --- Bias lookup & kind helpers (used by chips + directive composer) ---
function getBiasById(id){
  if (!__BIAS_IDX || !__BIAS_IDX.length) buildBiasIndex && buildBiasIndex();
  const needle = String(id || '').toLowerCase();
  const hit = (__BIAS_IDX || []).find(r =>
    String(r.b.id || '').toLowerCase() === needle ||
    String(r.b.name || '').toLowerCase() === needle
  );
  return hit ? hit.b : null;
}
function biasKindOf(b){
  const k = String(b?.kind || '').toLowerCase();
  const c = Array.isArray(b?.category) ? b.category.join(' ').toLowerCase()
                                       : String(b?.category || '').toLowerCase();
  if (/mitigation|technique/.test(k) || /mitigation/.test(c)) return 'technique';
  if (/dilemma|ethical/.test(k)     || /dilemma|ethical/.test(c)) return 'dilemma';
  return 'bias';
}

// --- Autofill helpers (personas/bias/etc.) -------------------------------

function tryAutofillValue(field, sug) {
  // Only for typeahead fields with an autofill directive
  if (!field || !field.autofill) return null;

  // "bias->inline", "persona->inline", etc.
  const [domain, mode] = String(field.autofill).split('->');
  const dataset = field.dataset || field.source || field.autocomplete || ''; // robustness
  const key = sug && (sug.value || sug.id || sug.slug || sug.label);

  if (!key) return null;

  if (domain === 'persona' && mode === 'inline') {
    // Reuse your existing persona inline if present
    return personaInlineLookup(key);
  }

  if (domain === 'bias' && mode === 'inline') {
    return biasInlineLookup(key, dataset);
  }

  // Fallback: not recognized
  return null;
}

// Persona inline lookup (uses your existing store if available)
function personaInlineLookup(key) {
  const lib = (window.DATASETS && (window.DATASETS.persona || window.DATASETS.personas)) || [];
  const p = findByAnyKey(lib, key);
  if (!p) return key;
  // Example inline: "Name — profession; summary"
  const parts = [
    p.name,
    p.profession ? `— ${p.profession}` : null,
    p.summary ? `; ${p.summary}` : null
  ].filter(Boolean);
  return parts.join(' ').replace(/\s+/g,' ').trim();
}

// Bias inline lookup
function biasInlineLookup(key, datasetName) {
  // Prefer the bias dataset explicitly, then any global registry
  const lib =
    (window.DATASETS && window.DATASETS[datasetName || 'bias']) ||
    (window.LIB && (window.LIB.bias || window.LIB.biases)) ||
    (window.DATASETS && (window.DATASETS.bias || window.DATASETS.biases)) ||
    [];

  const b = findByAnyKey(lib, key);
  if (!b) return key;

  // Compose a SINGLE LINE summary similar in spirit to persona->inline
  // Tweak fields as your bias.data.js provides (kind/type/summary/aliases etc.)
  const kind = b.kind || b.type || (b.tags && b.tags.find(t=>/^kind:|^type:/.test(t))) || '';
  const kindInline = kind ? (String(kind).replace(/^.*?:/,'').trim()) : '';

  // Prefer a short summary; otherwise use first sentence of description/notes
  const summary =
    b.summary ||
    (b.description && String(b.description).split(/[.?!]\s/)[0]) ||
    (b.notes && String(b.notes).split(/\n/)[0]) ||
    '';

  const parts = [
    b.name,
    kindInline ? `— ${kindInline}` : null,
    summary ? `; ${summary}` : null
  ].filter(Boolean);

  return parts.join(' ').replace(/\s+/g,' ').trim();
}

// small utility: find object by various keys
function findByAnyKey(list, key) {
  const k = String(key).toLowerCase();
  return list.find(x =>
    (x.id && String(x.id).toLowerCase() === k) ||
    (x.slug && String(x.slug).toLowerCase() === k) ||
    (x.name && String(x.name).toLowerCase() === k) ||
    (x.label && String(x.label).toLowerCase() === k)
  );
}


// Mirror personaFilter signature
function biasFilter(query, max=20){
  const q = (query||'').trim();
  if (!q) return [];
  return searchBiases(q, max);
}

// Rich text block, inline string, and templated fill
function biasText(b){
  return [
    b.name && `Name: ${b.name}`,
    b.kind && `Kind: ${b.kind}`,
    b.category && `Category: ${b.category}`,
    b.summary && `Summary: ${b.summary}`,
    b.definition && `Definition: ${b.definition}`,
    (b.contexts && _biasAsList(b.contexts).length) && `Contexts:\n${_biasBullets(b.contexts)}`,
    (b.mitigations && _biasAsList(b.mitigations).length) && `Mitigations:\n${_biasBullets(b.mitigations)}`,
    (b.examples && _biasAsList(b.examples).length) && `Examples:\n${_biasBullets(b.examples)}`,
    (b.tags && _biasAsList(b.tags).length) && `Tags: ${_biasCSV(b.tags)}`
  ].filter(Boolean).join('\n');
}

function biasInlineFlexible(b, opts = {}){
  const include = Array.isArray(opts.include) && opts.include.length
    ? opts.include : ['name','category','summary'];
  const labels = opts.labels !== false;
  const sep = typeof opts.sep === 'string' ? opts.sep : ' · ';
  const labelMap = {
    name: labels ? 'Name: ' : '',
    kind: labels ? 'Kind: ' : '',
    category: labels ? 'Category: ' : '',
    summary: labels ? 'Summary: ' : ''
  };
  return include
    .map(k => ((b?.[k] ?? '').toString().trim() ? labelMap[k] + b[k] : ''))
    .filter(Boolean)
    .join(sep);
}

function biasFillTemplate(tpl, b){
  return String(tpl||'').replace(/\{(\w+)\}/g, (_,k)=> (b?.[k] ?? ''));
}

// Optional “spread into tab fields” (mirrors applyPersonaToTab)
function applyBiasToTab(tab, bias){
  if (!tab || !bias) return;
  tab.fields = {
    ...(tab.fields||{}),
    bias_name:        bias.name || '',
    bias_kind:        bias.kind || '',
    bias_category:    bias.category || '',
    bias_summary:     bias.summary || '',
    bias_definition:  bias.definition || '',
    bias_contexts:    _biasAsList(bias.contexts).join('\n'),
    bias_mitigations: _biasAsList(bias.mitigations).join('\n'),
    bias_examples:    _biasAsList(bias.examples).join('\n'),
    bias_tags:        _biasAsList(bias.tags).join(', ')
  };
}

/* ===== Bias directive composer ===== */
function composeBiasDirectives(ids){
  const list = Array.isArray(ids) ? ids : [];
  if (!list.length) return { combined:'', awareness:'', mitigations:'', ethics:'' };

  const asObj = id => getBiasById(id) || (String(id).startsWith('custom:') ? { id, name: String(id).slice(7), kind:'custom', summary:'' } : null);
  const items = list.map(asObj).filter(Boolean);

  const buckets = { awareness:[], mitigations:[], ethics:[] };
  for (const b of items){
    const kind = biasKindOf(b);
    if (kind === 'technique') buckets.mitigations.push(b);
    else if (kind === 'dilemma') buckets.ethics.push(b);
    else buckets.awareness.push(b);
  }

  const bullet = (n,s) => s ? `• ${n}: ${String(s).trim()}` : `• ${n}`;

  const aw = buckets.awareness.length
    ? ['Awareness', ...buckets.awareness.map(b => bullet(b.name, b.summary || b.definition || 'Avoid reinforcing; balance sources; ask a neutral clarifying question if risk is detected.'))].join('\n')
    : '';

  const mi = buckets.mitigations.length
    ? ['Mitigations', ...buckets.mitigations.map(b => bullet('Apply ' + b.name, b.summary || b.definition || 'Apply this tactic as appropriate.'))].join('\n')
    : '';

  const et = buckets.ethics.length
    ? ['Ethical considerations', ...buckets.ethics.map(b => bullet(b.name, b.summary || b.definition || 'Surface trade-offs and seek constraints before deciding.'))].join('\n')
    : '';

  const combined = [aw, mi, et].filter(Boolean).join('\n\n');
  return { combined: combined ? 'Bias directives —\n' + combined : '', awareness:aw, mitigations:mi, ethics:et };
}


    
    // --- helper: default booster for a framework id
function defaultBooster(id){
  const fw = FIND(id);
  if (!fw) return '';
  const arr = Array.isArray(fw.boosters) ? fw.boosters : [];
  return arr.join(' ').trim();
}

    const out = $('#out');
    const fieldsWrap = $('#fields');
    const help = $('#fwHelp');
    const chips = $('#metaChips');
    
    // Guided-mode DOM refs (progress + nav)
const progWrap = document.getElementById('fieldProgress');
const progBar  = document.getElementById('fieldProgressBar');
const navWrap  = document.getElementById('fieldNav');
const navBack  = document.getElementById('fieldBack');
const navNext  = document.getElementById('fieldNext');
const navAll   = document.getElementById('fieldShowAll');

const metaWrap = document.getElementById('fieldProgressMeta');
const metaStep = document.getElementById('fieldStepPill');
const metaPct  = document.getElementById('fieldPct');
const metaNudge= document.getElementById('fieldNudge');

// Additional instructions (lazy refs — content is rendered dynamically)
function extraRefs(){
  const wrap    = document.getElementById('extraWrap');
  const input   = wrap ? wrap.querySelector('#extra') : null;
  const counter = wrap ? wrap.querySelector('#extraCounter') : null;
  return { wrap, input, counter };
}

// Render the Default Included Instructions area (idempotent)
function renderExtraMount(){
  const { wrap } = extraRefs();
  if (!wrap) return;
  if (wrap.dataset.ready === '1') return;

  wrap.innerHTML = `
    <label for="extra">Default Included Instructions</label>
    <div class="help">Pre-filled with this template’s recommendations. Editing replaces the defaults in your prompt.</div>
    <div class="fieldHolder">
      <textarea id="extra" class="hasCounter" placeholder=""></textarea>
      <span id="extraCounter" class="counter">0 ch</span>
    </div>
    <div class="extraHelpers">
      <button type="button" id="extraRestore" class="restore" title="Restore this template’s recommended text">Restore recommended text</button>
    </div>

    <label for="extraMore" style="margin-top:12px">Anything else to include (optional)</label>
    <div class="help">Add any extra guidance you want appended to your prompt.</div>
    <div class="fieldHolder">
      <textarea id="extraMore" class="hasCounter" placeholder="Type any additional guidance…"></textarea>
      <span id="extraMoreCounter" class="counter">0 ch</span>
    </div>
  `;
  wrap.dataset.ready = '1';

  // Wire up local input handlers once
  const input       = wrap.querySelector('#extra');
  const inputMore   = wrap.querySelector('#extraMore');
  const counter     = wrap.querySelector('#extraCounter');
  const counterMore = wrap.querySelector('#extraMoreCounter');
  const restoreBtn  = wrap.querySelector('#extraRestore');

  function setCount(el, badge){
    if (!el || !badge) return;
    badge.textContent = (el.value || '').length + ' ch';
  }

  input?.addEventListener('input', ()=>{
    // Persist to active tab
    const t = _activeTabSafe(); if (!t) return;
    t.extra = input.value;
    input.classList.toggle('filled', !!input.value.trim());
    setCount(input, counter);
    if (typeof scheduleSave === 'function') scheduleSave();
    if (typeof renderPreview === 'function') renderPreview();
  });

  inputMore?.addEventListener('input', ()=>{
    const t = _activeTabSafe(); if (!t) return;
    t.extra_more = inputMore.value;
    inputMore.classList.toggle('filled', !!inputMore.value.trim());
    setCount(inputMore, counterMore);
    if (typeof scheduleSave === 'function') scheduleSave();
    if (typeof renderPreview === 'function') renderPreview();
  });

  restoreBtn?.addEventListener('click', ()=>{
    const t = _activeTabSafe(); if (!t) return;
    const def = defaultBooster(t.id) || '';
    t.extra = def;
    if (input){
      input.value = def;
      input.classList.toggle('filled', !!def.trim());
      setCount(input, counter);
    }
    if (typeof scheduleSave === 'function') scheduleSave();
    if (typeof renderPreview === 'function') renderPreview();
  });
}


// Bottom “next steps” helper
const stepHint = document.getElementById('fieldStepHint');


/* Bottom stepper hint — isolated so it can never break field rendering */
function updateStepHint(tab, total){
  try {
    const hint = stepHint;           // uses the global ref you already defined
    if (!hint) return;

    const guided = !!(tab && tab.showAll === false);
    const size   = (typeof stepSize === 'function') ? stepSize() : 4;
    const totalN = Number.isFinite(total) ? total : 0;
    const pages  = size > 0 ? Math.ceil(totalN / size) : 0;

    const cur = Number(tab?.step) || 0;
    const atEnd = pages <= 0 || cur >= (pages - 1);

    // show only when guided, not at end, and not in "Show all"
    const show = guided && !atEnd;

    hint.hidden = !show;
    hint.setAttribute('aria-hidden', String(!show));
    if (show){
      // textContent avoids accidental HTML injection; simple and robust
      hint.textContent = 'More fields ahead — continue with Next.';
    }
  } catch (e){
    // Fail closed: never let the hint crash the app
    try {
      stepHint.hidden = true;
      stepHint.setAttribute('aria-hidden','true');
    } catch (_) {}
  }
}

// Smoothly align the "Template fields" header to the top of the left panel
function scrollFieldsHeaderIntoView(smooth = true){
  const panel  = document.getElementById('configPanel');
  const header = document.getElementById('fieldsHeader');
  if (!panel || !header) return;

  const panelTop  = panel.getBoundingClientRect().top;
  const headerTop = header.getBoundingClientRect().top;
  const target    = headerTop - panelTop + panel.scrollTop - 6; // small padding nudge

  try {
    panel.scrollTo({ top: target, behavior: smooth ? 'smooth' : 'auto' });
  } catch (e) {
    panel.scrollTop = target; // fallback
  }
}

// Collapse/hide the picker and scroll to "Template fields"
function applyDeepLinkUI(){
  const run = ()=>{
    try { if (typeof setPickerCollapsed === 'function') setPickerCollapsed(true); } catch(_){}
    try {
      const block = document.getElementById('pickerBlock');
      if (block) block.hidden = true; // fully hide the entire picker section if present
    } catch(_){}
    try { if (typeof setFieldsCollapsed === 'function') setFieldsCollapsed(false); } catch(_){}
    try { if (typeof scrollFieldsHeaderIntoView === 'function') scrollFieldsHeaderIntoView(true); } catch(_){}
    try { if (typeof saveUI === 'function') saveUI(); } catch(_){}
  };
  // Run after render; a double-tap maximizes chances on slow layouts
  requestAnimationFrame(run);
  setTimeout(run, 60);
}



// === Guided-mode helpers ===
function isGuided(tab){ return !!tab && tab.showAll === false; }
function stepSize(){ return 4; } // show 4 per “page”

function sliceFieldsForStep(tab, all){
  if (!isGuided(tab)) return all;
  const size  = stepSize();
  const start = (tab.step || 0) * size;
  return all.slice(start, start + size);
}

// === Dependent-field helpers ===============================================

// Map a platform "value" to the human label key we use in optionsByPlatform.
function platformKeyFromValue(raw, fw){
  const s = String(raw || '').trim();

  // Fast path: substring match for common labels
  const KEYS = ['X / Twitter','Facebook','LinkedIn','Instagram','Reddit','Pinterest','TikTok','YouTube','Threads'];
  for (const k of KEYS){ if (s.includes(k)) return k; }

  // Try to read from the platform field's own options
  const platField = (fw?.fields || []).find(x => x.key === 'platform');
  if (platField && Array.isArray(platField.options)){
    for (const opt of platField.options){
      const val = (typeof opt === 'string') ? opt : (opt.value ?? '');
      const lab = (typeof opt === 'string') ? opt : (opt.label || opt.value || '');
      if (s === val) return lab;
      if (s.includes(lab)) return lab;
    }
  }

  // Last-chance parse: "Platform: NAME\n..."
  const m = s.match(/Platform:\s*([^\n]+)/i);
  if (m) return m[1].trim();

  return s; // shrug: best effort
}

// Build option list for a <select>, honoring optionsByPlatform/dependsOn.
function resolveSelectOptions(f, fw, tab){
  let base = Array.isArray(f.options) ? f.options.slice() : [];

  if (f.optionsByPlatform){
    const depKey = f.dependsOn || 'platform';
    const depVal = (tab?.fields && tab.fields[depKey]) || '';
    const platKey = platformKeyFromValue(depVal, fw);

    const extra = f.optionsByPlatform[platKey] || [];
    base = base.concat(extra);
  }
  return base;
}

// Evaluate simple visibility rules:
//   visibleIf: { key:'task_mode', equals:'Tailor' }  OR
//   visibleIf: { key:'task_mode', contains:'Brainstorm' }
function fieldIsVisible(visibleIf, tab){
  if (!visibleIf) return true;
  const val = String((tab?.fields || {})[visibleIf.key] || '');
  if (visibleIf.equals != null)   return val === String(visibleIf.equals);
  if (visibleIf.contains != null) return val.includes(String(visibleIf.contains));
  return true;
}

// Do any fields depend on a given key? (used to decide re-render on change)
function hasDependents(fw, key){
  return !!(fw?.fields || []).some(x =>
    x.dependsOn === key ||
    (x.visibleIf && x.visibleIf.key === key) ||
    (x.optionsByPlatform && (x.dependsOn || 'platform') === key)
  );
}


function encouragement(pct){
  if (pct >= 100) return 'Ready to generate!';
  if (pct >= 80)  return 'Almost there — nice!';
  if (pct >= 60)  return 'Momentum looks good.';
  if (pct >= 40)  return 'Keep going — you’ve got this.';
  if (pct >= 20)  return 'Great start.';
  return 'Let’s begin.';
}

function updateExtraUI(tab, total){
  renderExtraMount(); // ensure the mount exists exactly once
  const { wrap, input, counter } = extraRefs();
  if (!wrap) return;

  // Visibility: guided shows on last step; show-all always shows
  const guided = isGuided(tab);
  const size   = stepSize();
  const atEnd  = ((tab.step || 0) + 1) * size >= total;
  const show   = guided ? atEnd : true;

  wrap.hidden = !show;
  wrap.setAttribute('aria-hidden', String(!show));
  if (!show) return;

  // Prefill rule: if tab.extra is empty, prefill from boosters
  const def = defaultBooster(tab?.id) || '';
  const current = String(tab?.extra || '');

  if (!current && input){
    // Only prefill when empty (don’t clobber user edits)
    input.value = def;
    tab.extra = def;
  }

  // Sync UI for #extra
  if (input){
    const val = String(tab.extra || '');
    if (input.value !== val) input.value = val;
    input.classList.toggle('filled', !!val.trim());
    if (counter) counter.textContent = (val.length || 0) + ' ch';
    // Keep placeholder showing boosters if user completely clears the box
    input.placeholder = def || input.placeholder || '';
  }

  // Sync UI for #extraMore (new field)
  const inputMore   = wrap.querySelector('#extraMore');
  const counterMore = wrap.querySelector('#extraMoreCounter');
  if (inputMore){
    const moreVal = String(tab.extra_more || '');
    if (inputMore.value !== moreVal) inputMore.value = moreVal;
    inputMore.classList.toggle('filled', !!moreVal.trim());
    if (counterMore) counterMore.textContent = (moreVal.length || 0) + ' ch';
  }
}







function updateStepperUI(tab, total, visibleCount){
  if (!progWrap || !navWrap) return;

const guided = isGuided(tab);
if (metaWrap){
  metaWrap.hidden = !guided;
  metaWrap.setAttribute('aria-hidden', String(!guided));
}



  // Master visibility: hide BOTH progress pieces when not guided
  if (progWrap) progWrap.hidden = !guided;
  if (typeof metaWrap !== 'undefined' && metaWrap) metaWrap.hidden = !guided;

  if (guided){
    const size  = stepSize();
    const start = (tab.step || 0) * size;
    const done  = Math.min(start + visibleCount, total);
    const pct   = total ? (done / total) * 100 : 0;

    // bar + aria
    progBar.style.width = pct + '%';
    if (progWrap) progWrap.setAttribute('aria-valuenow', String(Math.round(pct)));

    // meta row (step pill, % and nudge)
    if (typeof metaWrap !== 'undefined' && metaWrap){
      const totalPages = Math.max(1, Math.ceil(total / size));
      const page = (tab.step || 0) + 1;
      if (typeof metaStep !== 'undefined' && metaStep) metaStep.textContent = `Step ${page} of ${totalPages}`;
      if (typeof metaPct  !== 'undefined' && metaPct)  metaPct.textContent  = `${Math.round(pct)}%`;
      if (typeof metaNudge!== 'undefined' && metaNudge)metaNudge.textContent = encouragement(pct);
    }
  }

  // Nav row stays visible so users can "Collapse" back to guided
  navWrap.hidden = false;

  // Back/Next: hide at edges (clarity tweak)
  const size  = stepSize();
  const step  = (tab.step || 0);
  const atStart = step <= 0;
  const atEnd   = ((step + 1) * size) >= total;

  if (typeof navBack !== 'undefined' && navBack){
    // Guided: hide Back on first step; otherwise show it
    const showBack = guided && !atStart;
    navBack.hidden   = !showBack;
    navBack.disabled = !showBack; // keep disabled in sync with visibility
  }

  if (typeof navNext !== 'undefined' && navNext){
    // Guided: hide Next on last step; otherwise show it
    const showNext = guided && !atEnd;
    navNext.hidden   = !showNext;
    navNext.disabled = !showNext; // keep disabled in sync with visibility
  }

  // Toggle button label + title (Show all vs Collapse)
  if (typeof navAll !== 'undefined' && navAll){
    if (guided){
      navAll.textContent = 'Show all';
      navAll.title = 'Show every field at once';
    }else{
      navAll.textContent = 'Collapse';
      navAll.title = 'Return to guided (few-at-a-time) view';
    }
    
    
    
  }

  // NEW: update the bottom hint (safe; won’t throw)
  updateStepHint(tab, total);
  // (extra UI handled directly in renderFields)

}



function _activeTabSafe(){ return (typeof activeTab === 'function') ? activeTab() : null; }

navBack && navBack.addEventListener('click', ()=>{
  const t = _activeTabSafe(); if (!t) return;
  t.step = Math.max((t.step||0) - 1, 0);
  if (typeof scheduleSave === 'function') scheduleSave();
  if (typeof renderFields === 'function') renderFields();
scrollFieldsHeaderIntoView();
});

navNext && navNext.addEventListener('click', ()=>{
  const t = _activeTabSafe(); if (!t) return;
  t.step = (t.step||0) + 1;
  if (typeof scheduleSave === 'function') scheduleSave();
  if (typeof renderFields === 'function') renderFields();
scrollFieldsHeaderIntoView();
});

navAll && navAll.addEventListener('click', ()=>{
  const t = _activeTabSafe(); if (!t) return;
  // Toggle: guided (showAll=false) → Show all; Show all → guided
  t.showAll = !t.showAll;
  // Optional: keep current step when collapsing back; no reset needed
  if (typeof scheduleSave === 'function') scheduleSave();
  if (typeof renderFields === 'function') renderFields();
scrollFieldsHeaderIntoView();
});




// Use external dataset loaded by templates.data.js.
// Prefer TEMPLATES, fall back to FRAMEWORKS for older files.
const FRAMEWORKS = (window.TEMPLATES || window.FRAMEWORKS || []);

// S4 — dataset accessors
const PATTERNS = FRAMEWORKS;
function TASKS(){ return Array.isArray(window.TASK_TEMPLATES) ? window.TASK_TEMPLATES : []; }

// Ensure the "— Select a template —" option exists at index 0
function withNone(list){
  return list.some(f=>f && f.id === 'none')
    ? list
    : [{ id:'none', label:'— Template Picker —' }, ...list];
}

// Cross-dataset lookup by id (works for Patterns or Tasks, independent of current chip)
function FIND(id){
  if (!id) return null;
  return (
    (PICKER().find(f => f.id === id)) ||       // prefer what's visible
    (PATTERNS || []).find(f => f.id === id) || // then legacy/patterns
    TASKS().find(f => f.id === id) ||          // then tasks (lazy loaded)
    null
  );
}


// S3 — dataset helpers (no behavior change yet)
// Keep existing S2 helpers if you already added them; these only fill gaps.
window.currentDataset = window.currentDataset || (()=>{
  try { return localStorage.getItem('fw_dataset') || 'patterns'; }
  catch(e){ return 'patterns'; }
});

window.setDataset = window.setDataset || ((ds)=>{
  try { localStorage.setItem('fw_dataset', ds); } catch(e){}
  // Note: S2 may also update chip visuals + pill; that’s fine to live elsewhere.
});

// For now, PICKER() = FRAMEWORKS (no behavior change).
// In S4 we’ll redefine this to return TASKS or PATTERNS based on currentDataset().
// S4 — PICKER now reflects currentDataset()
const PICKER = function(){
  const ds = (typeof currentDataset === 'function') ? currentDataset() : 'patterns';
  return ds === 'tasks' ? withNone(TASKS()) : withNone(PATTERNS);
};




const searchEl = document.getElementById('fwSearch');

/* === More filters (Kind/Category) — disclosure + wiring === */
const filtersToggle = document.getElementById('filtersToggle');
const filtersWrap   = document.getElementById('filtersWrap');
const kindSel       = document.getElementById('filterKind');
const catSel        = document.getElementById('filterCategory');

// Treat "kind:none" as framework; present "category:none" to the user as "helper"
function normalizeKind(k){
  const v = String(k||'').toLowerCase();
  return v === 'none' || !v ? 'framework' : v;
}
function normalizeCategory(c){
  const v = String(c||'').toLowerCase();
  return v === 'none' ? 'helper' : v;
}
function friendlyKind(k){ return k ? k[0].toUpperCase()+k.slice(1) : ''; }
function friendlyCategory(c){ return String(c||'').replace(/-/g,' '); }

// All items visible for the current dataset chip (Patterns/Tasks), including the picker "none"
function pickerBase(){
  const list = (typeof PICKER === 'function') ? PICKER() : [];
  return Array.isArray(list) ? list.filter(Boolean) : [];
}

function computeKindOptions(){
  const set = new Set();
  pickerBase().forEach(f => set.add(normalizeKind(f.kind)));
  // No "none" bucket in the UI (merged to framework by normalizeKind)
  return Array.from(set).sort();
}

function computeCategoryOptions(kind){
  let arr = pickerBase();
  if (kind && kind !== '__all__'){
    arr = arr.filter(f => normalizeKind(f.kind) === kind);
  }
  const set = new Set();
  arr.forEach(f => (f.categories||[]).forEach(c => set.add(normalizeCategory(c))));
  return Array.from(set).sort();
}

function updateFilterOptions__LEGACY(){
  if (!kindSel || !catSel) return;
  const prevKind = kindSel.value;
  const prevCat  = catSel.value;

  // Kinds
  const kinds = computeKindOptions();
  kindSel.innerHTML =
    `<option value="__all__">All kinds</option>` +
    kinds.map(k => `<option value="${k}">${friendlyKind(k)}</option>`).join('');
  if ([...kindSel.options].some(o=>o.value===prevKind)) kindSel.value = prevKind;

  // Categories (scoped by chosen kind)
  const k = kindSel.value === '__all__' ? null : kindSel.value;
  const cats = computeCategoryOptions(k);
  catSel.innerHTML =
    `<option value="__all__">All categories</option>` +
    cats.map(c => `<option value="${c}">${friendlyCategory(c)}</option>`).join('');
  if ([...catSel.options].some(o=>o.value===prevCat)) catSel.value = prevCat;
}

// Toggle the disclosure
filtersToggle?.addEventListener('click', ()=>{
  const expanded = filtersToggle.getAttribute('aria-expanded') === 'true';
  const next = !expanded;
  filtersToggle.setAttribute('aria-expanded', String(next));
  filtersWrap.hidden = !next;
  if (next) updateFilterOptions();
});

// React to dropdown changes
kindSel?.addEventListener('change', ()=>{
  updateFilterOptions();   // keep Category in sync
  refreshTemplateList();   // re-filter list
});
catSel?.addEventListener('change', ()=>{
  refreshTemplateList();
});


const allBtn   = document.getElementById('fwAll');
const sug      = document.getElementById('fwSuggest'); // NEW


// === Framework/Pattern/Task typeahead (rich suggestions under the search box) ===
let fwTaActive = -1;

function fwSubtext(f){
  const uc = (f.use_cases || []).filter(Boolean).slice(0,2).join(' • ');
  if (uc) return uc;
  const t = String(f.definition || f.help || '').trim().replace(/\s+/g,' ');
  return t.length > 140 ? t.slice(0,140) + '…' : t;
}

function rankFrameworks(q){
  const list = (typeof getAllTemplates === 'function') ? getAllTemplates() : (window.TEMPLATES || window.FRAMEWORKS || []);
  const toks = String(q||'').toLowerCase().split(/[^a-z0-9]+/).filter(Boolean);
  if (!toks.length) return list;

  function score(f){
    let s = 0;
    const label = String(f.label || '').toLowerCase();
    const slug  = String(f.slug  || '').toLowerCase();
    const usec  = (f.use_cases || []).map(x => String(x).toLowerCase());
    const tags  = (f.tags || []).map(x => String(x).toLowerCase());
    const cats  = (f.categories || []).map(x => String(x).toLowerCase());
    const def   = String(f.definition || '').toLowerCase();
    const help  = String(f.help || '').toLowerCase();

    for (const t of toks){
      // SUPER boost: exact token in any use_case
      if (usec.some(u => u === t)) s += 40;
      // Strong: token contained in a use_case phrase
      if (usec.some(u => u.includes(t))) s += 25;

      // Label/slug startsWith get strong boosts
      if (label.startsWith(t)) s += 12;
      if (slug.startsWith(t))  s += 8;

      // Any presence across label/tags/cats/def/help
      if (label.includes(t)) s += 6;
      if (tags.some(v => v.includes(t))) s += 4;
      if (cats.some(v => v.includes(t))) s += 3;
      if (def.includes(t) || help.includes(t)) s += 2;
    }
    return s;
  }

  return list
    .map(f => ({ f, s: score(f) }))
    .filter(x => x.s > 0)
    .sort((a,b)=> b.s - a.s || String(a.f.label||'').localeCompare(String(b.f.label||''),'en',{sensitivity:'base'}))
    .map(x => x.f);
}

function hideFwSuggestions(){
  if (!sug) return;
  sug.hidden = true;
  sug.innerHTML = '';
  fwTaActive = -1;
}

function commitFwPick(id){
  const sel = document.getElementById('frameworkSel');
  if (!sel) return;

  // 1) Switch the active template as before
  sel.value = id;
  if (typeof switchFramework === 'function') switchFramework(id);
  if (typeof updatePickerPreview === 'function') updatePickerPreview();

  // 2) Reflect the choice back into the search input for clear feedback
  const search = document.getElementById('fwSearch');
  if (search){
    // Resolve a friendly display name (label → slug → id)
    let picked = id;
    try{
      const all = (typeof getAllTemplates === 'function') ? getAllTemplates() : [];
      const hit = all.find(t =>
        String(t.id||'').toLowerCase()   === String(id).toLowerCase() ||
        String(t.slug||'').toLowerCase() === String(id).toLowerCase()
      ) || (typeof FIND === 'function' ? FIND(id) : null);

      picked = (hit && (hit.label || hit.slug || hit.id)) || id;
    }catch(_){ /* noop */ }

    search.value = picked;
    // Optional: style cue that it’s populated
    search.classList.toggle('filled', !!picked);
  }

  // 3) Recompute the dropdown + hint so users see “Showing 1 / M”
  if (typeof refreshTemplateList === 'function') refreshTemplateList();

  // 4) Close the suggestion popover
  hideFwSuggestions();
}


function renderFwSuggestions(q){
  if (!sug) return;
  const query = (q||'').trim();
  if (!query){ hideFwSuggestions(); return; }

  const doRender = ()=>{
    const ranked = rankFrameworks(query).slice(0,12);
    if (!ranked.length){ hideFwSuggestions(); return; }
    sug.innerHTML = ranked.map(f => `
      <div class="taItem" role="option" data-id="${f.id || f.slug}">
        <span class="name">${f.label || f.slug || f.id || 'Untitled'}</span>
        <span class="sub">${fwSubtext(f)}</span>
      </div>
    `).join('');
    fwTaActive = -1;
    sug.hidden = false;
  };

  // Always ensure tasks are present so the unified list is complete
  if (typeof ensureTasksLoaded === 'function') ensureTasksLoaded(doRender);
  else doRender();
}

// Mouse pick
sug?.addEventListener('mousedown', (e)=>{
  const it = e.target.closest('.taItem'); if (!it) return;
  commitFwPick(it.dataset.id);
});

// Close on outside click/blur (delay so clicks register)
document.addEventListener('click', (e)=>{
  if (!sug || sug.hidden) return;
  const inFinder = e.target.closest('#finderBar');
  if (!inFinder) hideFwSuggestions();
});
searchEl?.addEventListener('blur', ()=> setTimeout(hideFwSuggestions, 120));


// S2 — cosmetic dataset chips (no data swap yet)
const chipPatterns = document.getElementById('chipPatterns');
const chipTasks    = document.getElementById('chipTasks');
const modePill     = document.querySelector('span.pill');

// Helpers: persist + reflect pressed state
function currentDataset(){
  return localStorage.getItem('fw_dataset') || 'patterns';
}

// Update the header pill to match dataset mode
function updatePill(ds){
  if (!modePill) return;
  if (ds === 'tasks'){
    // Title & text for Tasks mode
    modePill.dataset.val = 'tasks';                 // safe new value; see optional CSS below
    modePill.title       = 'Specific Tasks';
    modePill.textContent = 'specific tasks';
  } else {
    // Title & text for Patterns/Thinking Structures mode
    modePill.dataset.val = 'framework';             // keep existing styling compatibility
    modePill.title       = 'Thinking Structures & Patterns';
    modePill.textContent = 'thinking structures + patterns';
  }
}

function setDataset(ds){
  localStorage.setItem('fw_dataset', ds);
  chipPatterns?.setAttribute('aria-pressed', String(ds === 'patterns'));
  chipTasks?.setAttribute('aria-pressed',    String(ds === 'tasks'));
  updatePill(ds); // ← NEW: keep the pill in sync
}

// Initialize pressed visuals + pill from storage (defaults to "patterns")
setDataset(currentDataset());

// Clicks flip visuals + persist choice (still purely cosmetic)
// S4 — actually switch the dataset used by the picker/search
chipPatterns?.addEventListener('click', ()=>{
  setDataset('patterns');
    updateFilterOptions();

  buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
  // optional: re-render fields if your UI depends on active list
  // renderFields(); emit();
});

chipTasks?.addEventListener('click', ()=>{
  ensureTasksLoaded(()=>{
    setDataset('tasks');
        updateFilterOptions();

    buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
    // optional: re-render fields if your UI depends on active list
    // renderFields(); emit();
  });
});



const norm = s => (s||'').toLowerCase();
function tokenize(s){ return norm(s).split(/[^a-z0-9]+/).filter(Boolean); }

function matchScore(fw, query){
  const q = (query||'').trim();
  if(!q) return 0;

  const qTokens = tokenize(q);
  if(!qTokens.length) return 0;

  const hayPieces = [
    fw.label, fw.slug, fw.definition, fw.help,
    ...(fw.categories||[]), ...(fw.tags||[]),
    ...(fw.use_cases||[]), ...(fw.boosters||[]),
    ...((fw.fields||[]).flatMap(f=>[f.label, f.desc, f.ph]))
  ].filter(Boolean);

  const hay = hayPieces.join(' ').toLowerCase();
  const hayTokens = tokenize(hay);
  const labelTokens = tokenize(fw.label || '');
  const slug = (fw.slug||'').toLowerCase();

  let score = 0;
  qTokens.forEach(t=>{
    // Strong: label token startsWith (e.g., "deci" → "Decision")
    if (labelTokens.some(tok => tok.startsWith(t))) score += 7;

    // Strong: whole label startsWith the token (old behavior)
    if ((fw.label||'').toLowerCase().startsWith(t)) score += 8;

    // Medium: slug starts with token
    if (slug.startsWith(t)) score += 5;

    // Medium: exact token present in any hay token
    if (hayTokens.includes(t)) score += 3;

    // Light: substring appears anywhere (lets "motiva" hit “motivation” in desc/tags)
    if (hay.includes(t)) score += 1;
  });

  return score;
}



// UI bootstrap
const sel = $('#frameworkSel');

// Live helper preview for the picker (uses def > help > first use_case)
function updatePickerPreview() {
  const el = document.getElementById('fwHelp');
  if (!el) return;
  const fw = typeof FIND === 'function' ? FIND(sel.value) : null;
  if (!fw) { el.textContent = ''; return; }

  const useCase = Array.isArray(fw.use_cases) && fw.use_cases.length ? `Use-case: ${fw.use_cases[0]}` : '';
  const text = (fw.definition || fw.help || useCase || '').toString().trim();
  el.textContent = text;
}

// Update the helper when the selection moves (keyboard or click)
sel.addEventListener('input',  updatePickerPreview);  // fires while the list is open in many browsers
sel.addEventListener('change', updatePickerPreview);  // always fires on commit


// Persist what users typed per-framework within the same tab.
function switchFramework(newId){
  const t = activeTab();
  if (!t) return;
  
    // Guided-mode defaults (defensive)
  if (typeof t.step !== 'number')   t.step = 0;
  if (typeof updateExtraUI === 'function'){
  updateExtraUI(activeTab && activeTab(), 0);
}
  if (typeof t.showAll !== 'boolean') t.showAll = false;
  // Safe: will only prefill if empty
if (typeof updateExtraUI === 'function'){
  // total may not be known here; pass 0 — visibility will be corrected on renderFields
  updateExtraUI(activeTab && activeTab(), 0);
}


  const oldId = t.id;
  // Save current draft under old framework id
  t._drafts = t._drafts || {};
  t._drafts[oldId] = {
    fields: { ...(t.fields || {}) },
    extra:  t.extra
  };

  // Switch to the new framework id
  t.id = newId;

// Restore prior fields, but ALWAYS reset the default-included instructions
// to this template’s boosters (acts like "Restore recommended text" on switch)
const prior = t._drafts[newId];
t.fields = prior ? { ...(prior.fields || {}) } : {};

// Hard reset the instructions to the new template’s boosters
t.extra = (typeof defaultBooster === 'function' ? (defaultBooster(newId) || '') : '');
// renderFields() below will rebuild #extra and counter consistently


  renderTabs(); renderFields(); emitAll(); nudgeFieldsSwap(); scheduleSave();
}


// --- Multi-tab state (with migration from single state) ---
let state = loadSavedState() || window.state || {};
window.state = state; // expose for action modal + other modules
state.common = state.common || {};



// --- URL param: pick framework by ?slug=... (supports slug or id, case-insensitive)
(()=>{
  const params = new URLSearchParams(window.location.search);
  const q = (params.get('slug') || '').trim().toLowerCase();
  if (!q) return;

  function applyPick(){
    // Prefer the unified list if present, else fall back to legacy globals
    const list = (typeof getAllTemplates === 'function')
      ? getAllTemplates()
      : (window.TEMPLATES || window.FRAMEWORKS || []);

    const pick =
      list.find(t =>
        (t.slug && t.slug.toLowerCase() === q) ||
        (t.id   && t.id.toLowerCase()   === q)
      ) || (typeof FIND === 'function' ? FIND(q) : null);

    if (!pick) return;

    // Flag: we'll collapse picker + scroll after the first render
    window.__PB_SLUG_LINKED__ = pick.id;

    // If tabs already exist, switch via the normal flow (saves drafts, resets boosters, re-renders)
    if (Array.isArray(state.tabs) && state.tabs.length){
      const i = Number.isInteger(state.active) ? state.active : 0;
      state.active = i;
      try {
        if (typeof switchFramework === 'function') {
          switchFramework(pick.id);
          return;
        }
      } catch(_) {}
      // Fallback (very early load): just set id; boot() will render
      state.tabs[i] = { ...(state.tabs[i] || {}), id: pick.id };
    } else {
      // Pre-tab migration path: seed id; migration below will pick it up
      state.id = pick.id;
    }
  }

  const ds = (typeof currentDataset === 'function') ? currentDataset() : 'patterns';
  if (ds === 'tasks' && typeof ensureTasksLoaded === 'function') {
    ensureTasksLoaded(applyPick);
  } else {
    applyPick();
  }
})();





// If already migrated, keep it. Otherwise wrap the old single-state into a tab.
if (!Array.isArray(state.tabs) || !state.tabs.length){
  // Prefer the Template Picker (id:'none') when seeding a fresh session.
const initialId = (typeof state.id === 'string')
  ? state.id
  : ((FRAMEWORKS.find(f => f && f.id === 'none')?.id) || (FRAMEWORKS[0]?.id) || null);
state.tabs = [{
  id: initialId,
  fields: state.fields || {},
  extra: (state.extra && state.extra[initialId]) ?? undefined,
  // NEW: per-tab common context 
  common: {
    ctx:       (state.common?.usecase ?? state.common?.ctx) ?? '',
    audience:  state.common?.audience ?? '',
    style:     state.common?.style ?? '',
    tone:      state.common?.tone ?? ''
  },
  // NEW: guided-mode state
  step: 0,
  showAll: false
}];
// Optional cleanup of legacy globals
delete state.common;
delete state.fields;

  state.active = 0;
  // clean up legacy keys (optional)
  delete state.id; delete state.fields;
}; // use let so we can set the id after we build options

function buildFrameworkOptions(filterText=''){
  // 1) Keep legacy callers working: treat the arg as "what's in the search box"
  const search = document.getElementById('fwSearch');
  if (search) search.value = filterText || '';

  // 2) Rebuild filters + dropdown from the unified source (both files)
  const afterReady = ()=>{
    // Rebuild Kind/Category from unified data and render kind chips
    if (typeof updateFilterOptions === 'function') updateFilterOptions();
    // Rebuild the <select id="frameworkSel"> from unified data
    if (typeof refreshTemplateList === 'function') refreshTemplateList();

    // 3) Preserve/repair selection like the old function did
    try {
      const sel = document.getElementById('frameworkSel');
      const t   = (typeof activeTab === 'function') ? activeTab() : null;
      if (!sel || !t) return;

      const optValues = Array.from(sel.options).map(o => o.value);
      if (!optValues.includes(t.id)) {
        // Pick the first real option
        const first = sel.options[0];
        if (first && !first.disabled) {
          sel.value = first.value;
          t.id = first.value;
          // Keep the helper preview in sync (like before)
          if (typeof updatePickerPreview === 'function') updatePickerPreview();
        }
      } else {
        // Keep the visual selection aligned with state
        sel.value = t.id;
        if (typeof updatePickerPreview === 'function') updatePickerPreview();
      }
    } catch(_) {}
  };

  if (typeof ensureTasksLoaded === 'function') {
    ensureTasksLoaded(afterReady);   // guarantees both datasets are present
  } else {
    afterReady();
  }
}


// Boot: render only after the active dataset is ready (handles lazy Tasks)
(function boot(){
const doInit = ()=>{
  buildFrameworkOptions('');
  renderTabs();
  renderFields();
  if (typeof syncCommonInputs === 'function') syncCommonInputs();
  emit();

  // If we arrived via ?slug=..., collapse picker and scroll to fields
  if (window.__PB_SLUG_LINKED__) {
    applyDeepLinkUI();
  }
};
  const ds = (typeof currentDataset === 'function') ? currentDataset() : 'patterns';
  if (ds === 'tasks' && typeof ensureTasksLoaded === 'function'){
    ensureTasksLoaded(doInit);  // waits for templates.tasks.data.js to populate window.TASK_TEMPLATES
  } else {
    doInit();
  }
})();



    function fieldInput(el, on){ el.addEventListener('input', on); el.addEventListener('change', on); }
    
    
    /* ==== Inline Counters (Stage 1) ==== */
function approxTokens(str){ return Math.ceil((str || '').length / 4); } // fast heuristic
function estimateTokens(str){
  try{
    if (typeof window.customTokenCounter === 'function') {
      const n = Number(window.customTokenCounter(String(str)));
      if (Number.isFinite(n) && n > 0) return Math.ceil(n);
    }
  }catch(e){ /* ignore */ }
  return approxTokens(str);
}


/* ==== Prompt totals: gather, compute, render ==== */
function gatherPreviewText(){
  // If you render a deck of cards, concatenate all visible outputs.
  const deck = document.getElementById('outDeck');
  if (deck && !deck.hidden){
    return Array.from(deck.querySelectorAll('.outBody'))
      .map(n => (n.textContent || '').trim())
      .filter(Boolean)
      .join('\n\n---\n\n');
  }
  // Fallback to the single current preview (the big one)
  const out = document.getElementById('out');
  return (out?.textContent || '').trim();
}

function updatePromptTotal(){
  const el = document.getElementById('promptTotal');
  if (!el) return;
  const text = gatherPreviewText();
  if (!text){ el.textContent = ''; return; }
  const chars = text.length;
  const toks  = estimateTokens(text);
  el.textContent = `${toks} tokens · ${chars} characters`;
}


/* ==== Context Coach (single, for current preview) ==== */
/* Token bands tuned for full prompt length (current preview only) */
const PROMPT_COACH_BANDS = [
  { /* Too little */          max:  79,  state:'low',     label:'Type more'    },
  { /* Not enough */          min:  80,  max: 150, state:'low',     label:'Not enough'   },
  { /* Almost there */        min: 151,  max: 250, state:'near',    label:'Almost there' },
  { /* Looking good */        min: 251,  max: 400, state:'good',    label:'Looking good' },
  { /* Great! */              min: 401,  max: 600, state:'good',    label:'Great!'       },
  { /* Perfect! */            min: 601,  max: 800, state:'perfect', label:'Perfect!'     },
  { /* Too much (long wall) */min: 1001,          state:'high',    label:'Too much'     }
];

function coachForPrompt(tokens){
  for (const r of PROMPT_COACH_BANDS){
    const okMin = (r.min == null) || (tokens >= r.min);
    const okMax = (r.max == null) || (tokens <= r.max);
    if (okMin && okMax) return { state: r.state, label: r.label };
  }
  return { state: 'good', label: 'Looking good' };
}

/* Create/update the coach node inside #out based on current preview tokens */
function updateOutCoach(){
  const out = document.getElementById('out');
  if (!out) return;

  // Create once
  let coach = out.querySelector('.outCoach');
  if (!coach){
    coach = document.createElement('div');
    coach.className = 'outCoach';
    coach.setAttribute('role','status');
    coach.setAttribute('aria-live','polite');
    const pill = document.createElement('span');
    pill.className = 'pill';
    coach._pill = pill;
    coach.appendChild(pill);
    out.appendChild(coach);
  }

  const text = (out.textContent || '').trim();
  if (!text){
    coach.hidden = true;
    out.classList.remove('hasCoach');
    return;
  }

  const tokens = estimateTokens(text); // uses your existing heuristic/precise counter
  const { state, label } = coachForPrompt(tokens);
  coach.dataset.state = state;
  coach._pill.textContent = label;
  coach.hidden = false;
  out.classList.add('hasCoach');
}


/* ==== Master totals: across ALL templates ==== */
function gatherMasterText(){
  const deck = document.getElementById('outDeck');
  if (deck){
    const bodies = deck.querySelectorAll('.outBody');
    if (bodies && bodies.length){
      return Array.from(bodies)
        .map(n => (n.textContent || '').trim())
        .filter(Boolean)
        .join('\n\n---\n\n')
        .trim();
    }
  }
  // Fallback to the single current preview (#out) if no deck/cards
  const out = document.getElementById('out');
  return (out?.textContent || '').trim();
}

function updateMasterPromptTotal(){
  const el = document.getElementById('masterPromptTotal');
  if (!el) return;
  const text = gatherMasterText();
  if (!text){ el.textContent = ''; return; }
  const chars = text.length;
  const toks  = estimateTokens(text); // uses your existing heuristic/precise token estimator
  el.textContent = `Total: ${toks} tokens · ${chars} characters`;
}

/* ==== Current preview counter (top-right inside #out) ==== */
function updateOutPreviewCounter(){
  const out = document.getElementById('out');
  if (!out) return;

  let node = out.querySelector('.outCounter');
  if (!node){
    node = document.createElement('div');
    node.className = 'outCounter';
    node.setAttribute('aria-hidden', 'true');
    out.appendChild(node);
  }

  const text = (out.textContent || '').trim();
  if (!text){
    node.textContent = '';
    node.hidden = true;
    out.classList.remove('hasCounter');
    return;
  }

  const chars = text.length;
  const toks  = estimateTokens(text);
  node.textContent = `${toks}t · ${chars}c`;
  node.hidden = false;
  out.classList.add('hasCounter');
}

/* === Counter refresh scheduler (debounced to next frame) === */
function refreshPromptCountersSoon(){
  if (refreshPromptCountersSoon._pending) return;
  refreshPromptCountersSoon._pending = true;
  requestAnimationFrame(()=>{
    refreshPromptCountersSoon._pending = false;
    // Keep the original per-current-prompt updater:
    updatePromptTotal && updatePromptTotal();
    // ADD the new master updater (do not replace the old call):
    updateMasterPromptTotal && updateMasterPromptTotal();
    // Keep the tiny current-preview corner counter:
    updateOutPreviewCounter && updateOutPreviewCounter();
      updateOutCoach && updateOutCoach();     
  });
}

function formatCounts(chars, tokens){ return `${tokens}t · ${chars}c`; }

function setupCounter(inputEl){
  // Only for text & textarea
  const tag = inputEl.tagName.toLowerCase();
  if (!(tag === 'input' || tag === 'textarea')) return;

  // Wrap input in a positioned holder (if not already)
  if (!inputEl.parentElement || !inputEl.parentElement.classList.contains('fieldHolder')){
    const holder = document.createElement('div');
    holder.className = 'fieldHolder';
    inputEl.parentElement.insertBefore(holder, inputEl);
    holder.appendChild(inputEl);
  }
  // Create the counter once
  if (!inputEl._counterNode){
    const n = document.createElement('span');
    n.className = 'counter';
    n.setAttribute('aria-hidden', 'true');
    inputEl._counterNode = n;
    inputEl.parentElement.appendChild(n);
    inputEl.classList.add('hasCounter');
  }

  const update = ()=>{
    const val = inputEl.value || '';
    const chars = val.length;
    const tokens = estimateTokens(val);
    inputEl._counterNode.textContent = (chars > 0) ? formatCounts(chars, tokens) : '';
    inputEl._counterNode.hidden = chars === 0;
  };

  // Initial + live updates
  update();
  inputEl.addEventListener('input', update);
  inputEl.addEventListener('change', update);
}


function enrichFromGlossary(fw){
  const hit = (window.GLOSSARY || []).find(x => x.slug === fw.slug);
  if (!hit) return fw; // no change if not found
  return {
    ...fw,
    label: hit.term || fw.label,             // prefer glossary term as label
    status: hit.status || fw.status,
    tags: Array.from(new Set([...(fw.tags||[]), ...(hit.tags||[])])),
    categories: Array.from(new Set([...(fw.categories||[]), ...(hit.categories||[])])),
    sources: hit.sources || fw.sources
  };
}

if (searchEl){
// Live filter + rich suggestions
searchEl.addEventListener('input', ()=>{
  const q = searchEl.value;
  refreshTemplateList();
  renderFwSuggestions(q);
});


// Keyboard niceties on the search box (now aware of suggestions)
searchEl.addEventListener('keydown', (e)=>{
  const sel = document.getElementById('frameworkSel');
  const items = Array.from(sug?.children || []);

  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') return; // handled globally

  if ((e.key === 'ArrowDown' || e.key === 'ArrowUp') && items.length){
    e.preventDefault();
    if (e.key === 'ArrowDown') fwTaActive = Math.min(items.length - 1, fwTaActive + 1);
    if (e.key === 'ArrowUp')   fwTaActive = Math.max(0, fwTaActive - 1);
    items.forEach((n,i)=> n.classList.toggle('active', i===fwTaActive));
    return;
  }

  if (e.key === 'Enter'){
    if (items.length && fwTaActive >= 0){
      e.preventDefault();
      const active = items[fwTaActive];
      if (active) commitFwPick(active.dataset.id);
      return;
    }
    // Fallback: commit the first filtered option as before
    refreshTemplateList();
    const first = sel?.options?.[0];
    if (first){
      e.preventDefault();
      commitFwPick(first.value);
    }
    return;
  }

  if (e.key === 'Escape'){
    e.preventDefault();
    hideFwSuggestions();
    searchEl.value = '';
    refreshTemplateList()
    const hint = document.getElementById('fwHint'); 
    if (hint){ hint.hidden = true; hint.textContent = ''; }
    sel?.focus();
    return;
  }

  // If suggestions aren’t open, ArrowDown still drops into the native select
  if (e.key === 'ArrowDown' && !items.length){
    e.preventDefault();
    sel?.focus();
  }
});


  // Global: Ctrl/Cmd+K focuses the search bar
  document.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if ((k === 'k') && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      searchEl.focus();
      searchEl.select();
    }
  });
}


if (allBtn){
allBtn.addEventListener('click', ()=>{
  searchEl.value = '';
  hideFwSuggestions(); // NEW
  buildFrameworkOptions('');
  sel.focus();
});

}

function activeTab(){ return state.tabs[state.active]; }

function tabLabel(t){
  const fw = FIND(t.id);
  return fw ? fw.label : 'Untitled';
}


function addTab(copyCurrent = false){
  const none = FRAMEWORKS.find(f => f.id === 'none') || FRAMEWORKS[0];
  const cur  = state.tabs?.[state.active];

  // Clone when explicitly duplicating; otherwise start truly blank
const next = (copyCurrent && cur) ? {
  id:     cur.id,
  fields: { ...(cur.fields || {}) },
  extra:  cur.extra,
  common: { ...(cur.common || {}) },
  modes:  { ...(cur.modes || {}) },           // ← keep toggle choices when duplicating
  step:   0,
  showAll:false
} : {
  id:     (none?.id || null),
  fields: {},
  extra:  undefined,
  common: { ctx:'', audience:'', style:'', tone:'' },   // per-tab
  modes:  { think:false, websearch:false, lens_on:false, lens_id:'' },
             // ← default: both OFF
  step:   0,
  showAll:false
};



  state.tabs.push(next);
  state.active = state.tabs.length - 1;

  renderTabs();
  buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
  renderFields();
  syncCommonInputs();          // NEW: hydrate the Common Context UI for this tab
  emitAll();
  scheduleSave();
    if (typeof updateDeckVisibility === 'function') updateDeckVisibility();
}

function syncCommonInputs(){
  const t = activeTab() || {};
  const c = t.common || {};
  const map = { usecase:'ctx', audience:'audience', style:'style', tone:'tone' };

  Object.entries(map).forEach(([id, key])=>{
    const el = document.getElementById(id);
    if (!el) return;

    const newVal = c[key] || '';
    const changed = el.value !== newVal;

    // 1) Apply the new value
    el.value = newVal;

    // 2) Keep the visual “filled” state in sync
    el.classList.toggle('filled', !!newVal);

    // 3) Nudge counters/listeners so the UI reflects the switch immediately
    if (changed){
      el.dispatchEvent(new Event('input',  { bubbles:true }));
      el.dispatchEvent(new Event('change', { bubbles:true }));
    }
  });
}




function closeTab(idx){
  if (state.tabs.length <= 1) return; // keep at least one
  state.tabs.splice(idx, 1);
  if (state.active >= state.tabs.length) state.active = state.tabs.length - 1;
  renderTabs(); buildFrameworkOptions(document.getElementById('fwSearch')?.value||'');
  renderFields(); emitAll();
    if (typeof updateDeckVisibility === 'function') updateDeckVisibility();
}

function clearOrCloseTab(idx){
  // If there is more than one tab, behave like close.
  if (state.tabs.length > 1){
    closeTab(idx);
    return;
  }

  // Single tab: reset this tab to the default "— Select a template —"
  
state.tabs[0] = {
  id: 'none',
  fields: {},
  extra: undefined,
  // keep common context if present
  common: { ...(state.tabs[0]?.common || { ctx:'', audience:'', style:'', tone:'' }) }
};

  state.active = 0;

  // Re-render UI
  renderTabs();
  buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
  renderFields();
  emitAll();
    if (typeof updateDeckVisibility === 'function') updateDeckVisibility();
}


function switchTab(idx){
  if (idx<0 || idx>=state.tabs.length) return;
  state.active = idx;
  renderTabs(); buildFrameworkOptions(document.getElementById('fwSearch')?.value||'');
  renderFields(); syncCommonInputs(); emitAll(); nudgeFieldsSwap();
  // notify auxiliary controls
  document.dispatchEvent(new Event('tab-switched'));
}


function renderTabs(){
const bar = document.getElementById('tabbar');
if (!bar) return;
bar.innerHTML = '';
const many = state.tabs.length > 1;
bar.hidden = !many;
const lab = document.getElementById('tabbarLabel');
if (lab) lab.hidden = !many;
if (!many) return;
// Ensure the outer “Active templates” block follows the same rule
const block = document.getElementById('activeTemplatesBlock');
if (block){
  block.hidden = !many;
  block.setAttribute('aria-hidden', String(!many));
}



  state.tabs.forEach((t, i)=>{
    const b = document.createElement('div');
    b.className = 'tab' + (i===state.active?' active':'');
    b.title = 'Switch to this template';
    b.addEventListener('click', (e)=>{
      // ignore clicks on the close button itself
      if (e.target.closest('.x')) return;
      switchTab(i);
    });

    const title = document.createElement('span');
    title.textContent = tabLabel(t);
    b.appendChild(title);

const x = document.createElement('button');
x.className = 'x'; x.type='button';
x.textContent = '×';
x.title = 'Remove this template';

    x.addEventListener('click', (e)=>{ e.stopPropagation(); closeTab(i); });
    b.appendChild(x);

    bar.appendChild(b);
  });
  
    if (typeof updateDeckVisibility === 'function') updateDeckVisibility();
}

      function nudgeFieldsSwap(){
  const f = document.getElementById('fields');
  if (!f) return;
  f.classList.remove('fields-swap');
  // reflow to restart animation
  void f.offsetWidth;
  f.classList.add('fields-swap');
}

function updateDeckVisibility(){
  const deckLabel = document.getElementById('deckLabel');
  const deck      = document.getElementById('outDeck');

  // How many tabs are actually present?
  let count = 0;
  try { count = Array.isArray(state?.tabs) ? state.tabs.length : 0; } catch(_) {}

  const show = count >= 2;
  [deckLabel, deck].forEach(el=>{
    if (!el) return;
    el.hidden = !show;
    el.setAttribute('aria-hidden', String(!show));
  });
}
      

function makePromptForTab(t){
const fw = FIND(t.id);
const hasRealFields = fw && Array.isArray(fw.fields) && fw.fields.length > 0;
if (!fw || (fw.id === 'none' && !hasRealFields)) return '';

  const meta = enrichFromGlossary ? enrichFromGlossary(fw) : fw; // safe if enrichment not present
const c = (t.common || {});
let ctxPlus = ctxStringFromTab(t);

// Multi-select aware: include all selected persona blocks; fallback to legacy single
const persons = Array.isArray(c.audience_personas) && c.audience_personas.length
  ? c.audience_personas
  : (c.audience_persona ? [c.audience_persona] : []);

if (persons.length){
  const blocks = persons
    .map(p => formatPersonaForPrompt(p))
    .filter(Boolean)
    .join('\n\n');
  ctxPlus = [ctxPlus, blocks].filter(Boolean).join('\n\n');
}


const merged = {
  ctx: ctxPlus,
  ...(t.fields || {})
};

// Normalize repeater/dynamic_tasks fields so task templates can iterate them.
// We keep the original string at merged[f.key] (back-compat) and expose an array at merged[f.key + '_list'].
try {
  const defs = Array.isArray(fw.fields) ? fw.fields : [];
  for (const f of defs) {
    if (!f || !(f.key)) continue;
    if (f.type === 'repeater' || f.type === 'dynamic_tasks') {
      const raw = String((t.fields || {})[f.key] || '');
      if (!raw) continue;

      // Textarea blocks use a visible '---' divider; one-line items use simple newlines.
      const isBlocky = (f.itemType === 'typeahead_textarea' || f.itemType === 'textarea' || f.blockJoin === '---');
      const parts = isBlocky ? raw.split(/\n\s*---\s*\n/) : raw.split(/\n+/);
      const list  = parts.map(s => s.trim()).filter(Boolean);

      // Expose array variant(s)
      merged[f.key + '_list']  = list;
      merged[f.key + '_items'] = list;      // friendly alias
      merged[f.key + '_arr']   = list;      // another alias

      // Convenience: if key ends with 's' and there is exactly one entry, expose a singular too.
      if (/_s$|s$/.test(f.key) && list.length === 1) {
        const singular = f.key.replace(/s$/, '');
        if (!(singular in merged)) merged[singular] = list[0];
      }
    }
  }
} catch (e) { /* no-op: defensive */ }


// === Bias directives (from Common Context) ===
let biasSection = '';
{
  const ids = (t.common && Array.isArray(t.common.bias_ids)) ? t.common.bias_ids : [];
  const blocks = composeBiasDirectives(ids);
  merged.bias_awareness_block   = blocks.awareness || '';
  merged.bias_mitigations_block = blocks.mitigations || '';
  merged.ethics_block           = blocks.ethics || '';
  merged.bias_directives        = blocks.combined || '';
}

// Build body AFTER merged is enriched
const body = fw.template(merged);


// Persona profile fallback — if the template does NOT render ctx,
// we still inject a neat persona section right after the header.
let personaSection = '';
if (c.audience_persona) {
  const block = formatPersonaForPrompt(c.audience_persona);
  if (block && !body.includes('Audience profile —')) {
    personaSection = block;
  }
}

// If the user hasn't typed anything, fall back to the framework's boosters
const boosterFallback = Array.isArray(fw.boosters) ? fw.boosters.join(' ') : '';
const rawExtra = (t.extra ?? '').trim();
const extra = rawExtra.length ? rawExtra : boosterFallback;
const extraText = extra ? `Additional instructions: ${extra}` : '';

// New: append the “Anything else to include (optional)” box if present
const extraMore = (t.extra_more ?? '').trim();
// Keep the label if the ONLY thing present is extra_more
const extraCombined =
  (extraText && extraMore) ? `${extraText}\n\n${extraMore}` :
  (extraText)              ?  extraText :
  (extraMore)              ? `Additional instructions: ${extraMore}` :
                              '';

// === Toggle-driven appended directives ===
const thinkBlock = (t.modes?.think) ? `

{
DELIBERATIVE MODE (Reflective Pausing)
- First, think hard & silently: plan multiple approaches, pick the best, and execute. 
- Ensure you use chain-of-thought. Output only the final result plus concise justification.

REASONING / SELF-REFINE (Maieutic)
After producing a draft answer, silently critique it once, then revise. Use this checklist:
- RACCCA: Relevance, Accuracy, Completeness, Clarity, Coherence, Appropriateness.
- Assumptions & biases: identify hidden assumptions; note any bias risks.
- Verification: 
  - Math/logic: recompute key numbers; try a simple counterexample or alternative derivation.
  - Code: dry-run on a small example; list expected I/O and edge cases.
  - Facts: prefer citing 2–3 reputable sources if available; if not, mark as “needs verification.”

AMBIGUITY
- If information is missing, choose the most reasonable assumption and state it briefly before the answer.

OUTPUT FORMAT (concise, no chain-of-thought)
1) Final Answer: [the solution in the requested format].
2) Rationale (3–6 tight bullets): key reasons/evidence and trade-offs.
3) Assumptions & Constraints: [bulleted].
4) Alternatives Considered: [1–3 very brief lines with why not chosen].
5) Self-Check Results: [what you verified; any fixes from the critique].
6) Residual Uncertainty & Next Steps: [what to verify, how].
}
` : '';

const webBlock = (t.modes?.websearch) ? `
{
SEARCH ONLINE 
You may not have the answer to this question in your internal knowledge, and I do NOT want speculation or made up facts. Please do a comprehensive search online for the most reliable and up-to-date information. Be accurate and factual.

Provide:
1) A direct summary of the factual findings.
2) A citation to the original source (with link, author, and date if available).
3) A note explaining whether multiple sources agree or if there are discrepancies.
4) Provide your level of confidence in the information and your reasoning for that confidence.

If you cannot find a trustworthy external source, say so clearly instead of inventing an answer. Do not rely only on your training data; confirmation from external evidence is required.
}
` : '';

// Lens block (optional): appended after Extra/Think/Web, before Bias
let lensBlock = '';
try {
  const on = !!(t.modes && t.modes.lens_on);
  const id = t.modes?.lens_id || '';
  const L  = on ? (window.__LENSES__ || []).find(x => x.lens_id === id) : null;
  if (L && L.prompt) lensBlock = `\n${L.prompt}\n`;
} catch(_) {}


const header = meta.definition ? `Using ${meta.label}: ${meta.definition}` : `Using ${meta.label}.`;

// If the template didn’t render a bias block, append a compact one at the end.
const biasAuto = merged.bias_directives || '';
const biasTail = (biasAuto && !String(body).includes('Bias directives') && !String(extraText).includes('Bias directives'))
  ? biasAuto : '';

// Assemble: Header → Persona → Body → Extra → (Think?) → (Search?) → (Bias?)
return [header, personaSection, body, extraCombined, thinkBlock, webBlock, lensBlock, biasTail]
  .filter(Boolean)
  .join('\n')
  .replace(/\n{3,}/g,'\n\n')
  .trim();



}

window.makePromptForTab = makePromptForTab;


function emitAll(){
  // keep legacy preview in #out (active tab)
  const out = document.getElementById('out');
  if (out){
    const txt = makePromptForTab(activeTab() || {});
    out.textContent = txt || '';
    
 refreshPromptCountersSoon(); // keep counters in sync with any preview update

  }

  // render all cards
  const deck = document.getElementById('outDeck');
  if (!deck) return;
  deck.innerHTML = '';
  state.tabs.forEach((t, i)=>{
    const card = document.createElement('div');
    card.className = 'outCard';

    const head = document.createElement('div');
    head.className = 'outHead';
    const title = document.createElement('div');
    title.className = 'title';
    title.textContent = tabLabel(t);
    head.appendChild(title);

    const actions = document.createElement('div');
    actions.className = 'actions';

  // Clear from the card (resets when only one tab; closes when multiple)
const x = document.createElement('button');
x.className = 'x'; 
x.type = 'button'; 
x.textContent = (state.tabs.length > 1) ? 'Delete' : 'Clear';
x.title = (state.tabs.length > 1) ? 'Remove this template' : 'Clear this template';
x.addEventListener('click', ()=>{
  const isDelete = state.tabs.length > 1;
  const msg = isDelete
    ? 'Remove this template from your deck?'
    : 'Clear this prompt (reset to “— Select a template —”)?';
  if (!confirm(msg)) return;
  clearOrCloseTab(i);
});
actions.appendChild(x);


    head.appendChild(actions);
    card.appendChild(head);

    const body = document.createElement('div');
    body.className = 'outBody';
    body.textContent = makePromptForTab(t);
    card.appendChild(body);

    deck.appendChild(card);
  });
}


    function renderFields(){
      const t = activeTab();
const fw = FIND(t?.id);
fieldsWrap.innerHTML = '';
const hasRealFields = fw && Array.isArray(fw.fields) && fw.fields.length > 0;
if (!fw || (fw.id === 'none' && !hasRealFields)){
  help.textContent = 'Pick a template above to get started.';



  // Show a little context chip even when empty
  const ctx = document.createElement('div');
  ctx.id = 'tabContext';
  const idx = (Number.isInteger(state.active) ? state.active : 0) + 1;
  ctx.textContent = `Editing: Tab ${idx} • No template`;
  fieldsWrap.appendChild(ctx);
  return;
}
help.textContent = fw.help || '';

      
// Tab context chip
{
  const ctx = document.createElement('div');
  ctx.id = 'tabContext';
  const idx = (Number.isInteger(state.active) ? state.active : 0) + 1;
  ctx.textContent = `Editing: Tab ${idx} • ` + (fw ? fw.label : 'No template');
  fieldsWrap.appendChild(ctx);
}

const tabNow     = activeTab();
const allFields  = Array.isArray(fw.fields) ? fw.fields : [];
const visFields  = sliceFieldsForStep(tabNow, allFields);

      
visFields.forEach(f=>{

  // Skip fields hidden by a visibility rule (e.g., Tailor-only blocks)
  if (!fieldIsVisible(f.visibleIf, tabNow)) return;


  const wrap = document.createElement('div');
  wrap.className = 'field';

  // Label
  const lab = document.createElement('label');
  lab.textContent = f.label;
  lab.htmlFor = `${f.id || f.key}`;
  wrap.appendChild(lab);

  // Special case: dynamic tasks list (repeatable textareas)
  if (f.type === 'dynamic_tasks'){
    const list = document.createElement('div');
    list.className = 'tasksList';

    // Helper to read/write the field into state as a single newline-joined string
    const getValues = () =>
      Array.from(list.querySelectorAll('textarea'))
        .map(ta => ta.value.trim());

    const sync = ()=>{
      const tvals = getValues().filter(Boolean).join('\n');
      (t.fields || (t.fields = {}))[f.key] = tvals;
      emit();
    };

    const addTask = (value='')=>{
      const idx = list.querySelectorAll('textarea').length + 1;

      const item = document.createElement('div');
      item.style.marginTop = idx === 1 ? '0' : '10px';

      const small = document.createElement('div');
      small.className = 'tinyLabel';
      small.textContent = `Task ${idx}`;
      item.appendChild(small);

      const ta = document.createElement('textarea');
      ta.placeholder = f.ph ? `${f.ph}` : `Describe task ${idx}…`;
      ta.value = value;
      item.appendChild(ta);

      // Live updates + inline counter on each task field
      fieldInput(ta, sync);
      setupCounter(ta);

      list.appendChild(item);
      addBtn.parentElement.appendChild(addBtn); // keep button under the newest
      ta.focus();
    };
    
    function activeTab(){ return state.tabs[state.active]; }



    // Seed from any saved value (newline-separated), else start with one empty
    const seed = (t.fields && t.fields[f.key]) ? String(t.fields[f.key]) : '';
const parts = seed
  ? seed.split(/\n+/).map(s => s.trim()).filter(Boolean)
  : [];


    parts.forEach(v => addTask(v));
    // Ensure state is synced even if initial values came from seed
    sync();

    // Add Task button
    const addBtn = document.createElement('button');
    addBtn.type = 'button';
    addBtn.className = 'btn sm';
    addBtn.textContent = '+ Add task';
    addBtn.style.marginTop = '8px';
    addBtn.addEventListener('click', ()=> addTask(''));

    wrap.appendChild(list);
    wrap.appendChild(addBtn);

    // Optional helper text
    if (f.desc){
      const d = document.createElement('div');
      d.className = 'desc';
      d.textContent = f.desc;
      wrap.appendChild(d);
    }

    fieldsWrap.appendChild(wrap);
    return; // important: skip the default single-input branch
  }
  
  // --- Universal repeater (multi-row inputs; supports typeahead) ---
if (f.type === 'repeater'){
  const list   = document.createElement('div');
  list.className = 'repWrap';

  const max    = Number.isFinite(f.max) ? f.max : 10;             // cap (optional)
  const itType = f.itemType || 'text';                            // 'text' | 'textarea' | 'typeahead' | 'typeahead_textarea'

  // Read/Write helpers (store as newline-joined string for compatibility with templates that .split(/\n+/))
  const readValues = () =>
    Array.from(list.querySelectorAll('[data-item] textarea, [data-item] input'))
      .map(el => (el.value || '').trim())
      .filter(Boolean);

  const sync = ()=>{
    // Preserve multi-line rows: use a block joiner for textarea rows
const joiner = (itType === 'typeahead_textarea') ? '\n\n---\n\n' : '\n';
(t.fields || (t.fields = {}))[f.key] = readValues().join(joiner);

    emit();
  };

  const addBtn = document.createElement('button');
  addBtn.type = 'button';
  addBtn.className = 'btn sm';
  addBtn.textContent = `+ Add ${f.unit || 'row'}`;

  function addItem(value=''){
    const count = list.querySelectorAll('[data-item]').length;
    if (count >= max) return;

    const item = document.createElement('div');
    item.className = 'repItem';
    item.setAttribute('data-item', '');
    item.style.marginTop = count === 0 ? '0' : '10px';

    const holder = document.createElement('div');
    holder.className = 'fieldHolder';

    // input kind
    let input;
    if (itType === 'textarea' || itType === 'typeahead_textarea'){
      input = document.createElement('textarea');
    } else {
      input = document.createElement('input');
      input.type = 'text';
    }
    input.placeholder = f.ph || '';
    input.value = value;

    // delete button
    const del = document.createElement('button');
    del.type = 'button';
    del.className = 'btn sm danger';
    del.textContent = '– Remove';
    del.style.marginTop = '6px';
del.addEventListener('click', ()=>{
  if (!confirm('Remove this field value?')) return;
  item.remove();
  sync();
});


    holder.appendChild(input);
    item.appendChild(holder);
    item.appendChild(del);

    // Inline counter
    setupCounter(input);

    // Wire saving
    fieldInput(input, sync);

    // Persona-backed typeahead per row (reuses same behavior as single-field typeahead)
// Source-backed typeahead per row (persona or bias)
if (itType === 'typeahead' || itType === 'typeahead_textarea'){
  const source = (f.dataset || f.source || f.autocomplete || 'persona'); // 'persona' | 'bias'
  holder.classList.add('taWrap');

  const listEl = document.createElement('div');
  listEl.className = 'taList';
  listEl.hidden = true;
  holder.appendChild(listEl);
  
  // Prevent input blur from closing menu before selection
['pointerdown','mousedown'].forEach(evt=>{
  listEl.addEventListener(evt, (e)=> e.preventDefault());
});


  let activeIndex = -1;

  function renderSuggestions(q){
    const hits = (source === 'bias') ? biasFilter(q, 30) : personaFilter(q, 30);
    listEl.innerHTML = '';
    activeIndex = -1;
    if (!hits.length){ listEl.hidden = true; return; }

    hits.forEach((obj)=>{
      const it = document.createElement('div');
      it.className = 'taItem';

      // Render line 2 differently per source
      const sub = (source === 'bias')
        ? `${obj.category || obj.kind || ''}${(obj.tags && obj.tags.length) ? (' • ' + obj.tags.join(', ')) : ''}`
        : `${obj.profession || ''}${(obj.tags && obj.tags.length) ? (' • ' + obj.tags.join(', ')) : ''}`;

      it.innerHTML = `
        <span class="name">${obj.name}</span>
        <span class="sub">${sub}</span>
      `.trim();

      it.addEventListener('click', ()=>{
if (source === 'bias'){
  // Mirror single-field modes for biases
  const wantsTextarea = (f.autofill === 'bias->textarea') || (itType === 'typeahead_textarea');
  const modeInline    = (f.autofill === 'bias->inline');
  const modeTemplate  = (f.autofill === 'bias->template');

  if (wantsTextarea){
    input.value = biasText(obj);
  } else if (modeTemplate){
    input.value = biasFillTemplate(f.bias_template, obj);
  } else if (modeInline){
    input.value = biasInlineFlexible(obj, {
      labels:  f?.inline_labels !== false,
      sep:     f?.separator || ' · ',
      include: Array.isArray(f?.include) ? f.include : undefined
    });
  } else {
    input.value = obj.name || '';
  }
} else {
  // keep persona behavior identical to before
  const txt = (typeof personaStringFor === 'function')
    ? personaStringFor({ ...f, type: itType }, obj)
    : (itType === 'typeahead_textarea'
        ? (typeof personaText === 'function' ? personaText(obj) : (obj.summary || obj.name || ''))
        : (f?.autofill === 'persona->inline'
            ? (typeof personaInlineFlexible === 'function'
                ? personaInlineFlexible(obj, {
                    labels: f?.inline_labels !== false,
                    sep:    f?.separator || ' · ',
                    include: Array.isArray(f?.include) ? f.include : undefined
                  })
                : (obj.name || ''))
            : (obj.name || '')));
  input.value = txt;
}


        listEl.hidden = true;
        sync();
      });
      
      // Make first click reliable across browsers
it.addEventListener('pointerdown', (e)=>{ e.preventDefault(); it.click(); });
it.addEventListener('mousedown',   (e)=>{ e.preventDefault(); it.click(); });


      listEl.appendChild(it);
    });

    listEl.hidden = false;
  }

  input.addEventListener('input', ()=>{
    if (input.value.trim().length === 0){ listEl.hidden = true; sync(); return; }
    renderSuggestions(input.value);
    sync();
  });

  input.addEventListener('keydown', (e)=>{
    const items = Array.from(listEl.children);
    if (listEl.hidden || !items.length) return;
    if (e.key === 'ArrowDown'){ e.preventDefault(); activeIndex = Math.min(items.length-1, activeIndex+1); }
    if (e.key === 'ArrowUp'){   e.preventDefault(); activeIndex = Math.max(0, activeIndex-1); }
    if (e.key === 'Escape'){ listEl.hidden = true; return; }
    if (e.key === 'Enter' && activeIndex >= 0){
      e.preventDefault();
      items[activeIndex].dispatchEvent(new Event('click', {bubbles:true}));
      return;
    }
    items.forEach((n,i)=> n.classList.toggle('active', i===activeIndex));
  });

  input.addEventListener('blur', ()=> setTimeout(()=> listEl.hidden = true, 120));
}


    list.appendChild(item);
    // Keep add button at the bottom
    addBtn.parentElement && addBtn.parentElement.appendChild(addBtn);
    input.focus();
  }

  // Seed from saved newline list or start with one blank
  const seed = (t.fields && t.fields[f.key]) ? String(t.fields[f.key]) : '';
const parts = seed
  ? (itType === 'typeahead_textarea'
      ? seed.split(/\n\s*---\s*\n/)
      : seed.split(/\n+/)
    ).map(s=>s.trim()).filter(Boolean)
  : [''];

  parts.forEach(v => addItem(v));
  sync();

  // Add button wiring
  addBtn.addEventListener('click', ()=> addItem(''));

  // Attach to the field wrapper
  wrap.appendChild(list);
  wrap.appendChild(addBtn);

  // Optional helper text
  if (f.desc){
    const d = document.createElement('div');
    d.className = 'desc';
    d.textContent = f.desc;
    wrap.appendChild(d);
  }

  fieldsWrap.appendChild(wrap);
  return; // important: skip the default branch
}

  
    // SELECT (dropdown) branch
  if (f.type === 'select'){
    const holder = document.createElement('div');
    holder.className = 'fieldHolder';

    const sel = document.createElement('select');
    sel.id = f.key;

    // Build options (supports optionsByPlatform + dependsOn)
    const optList = resolveSelectOptions(f, fw, tabNow);
    optList.forEach(opt => {
      const o = document.createElement('option');
      if (typeof opt === 'string'){
        o.value = opt; o.textContent = opt;
      } else {
        o.value = opt.value;
        o.textContent = opt.label || opt.value;
      }
      sel.appendChild(o);
    });


    // Initialize & wire state
    const current = (t.fields && t.fields[f.key]) || sel.options[0]?.value || '';
    // If previous value vanished after a dependency change, fallback to first option
    if (![...sel.options].some(o => o.value === current)){
      sel.value = sel.options[0]?.value || '';
    } else {
      sel.value = current;
    }
    (t.fields || (t.fields = {}))[f.key] = sel.value;


    sel.addEventListener('change', ()=>{
      (t.fields || (t.fields = {}))[f.key] = sel.value;
      const needsRerender = hasDependents(fw, f.key);
      if (needsRerender){
        renderFields(); // rebuild dependents (like Length options) immediately
      }
      emit();
    });


    holder.appendChild(sel);
    wrap.appendChild(holder);

    // Optional helper text
    if (f.desc){
      const d = document.createElement('div');
      d.className = 'desc';
      d.textContent = f.desc;
      wrap.appendChild(d);
    }

    fieldsWrap.appendChild(wrap);
    return; // skip default branch
  }


  // DEFAULT single input/textarea branch
  const holder = document.createElement('div');
  holder.className = 'fieldHolder';
let input;
if (f.type === 'textarea' || f.type === 'typeahead_textarea'){
  input = document.createElement('textarea');
} else {
  input = document.createElement('input');
  input.type = 'text';
}


input.placeholder = f.ph || '';
input.id = f.key;
input.value = (t.fields && t.fields[f.key]) || '';

/* -- Typeahead (persona- or bias-backed) -- */
if (f.type === 'typeahead' || f.type === 'typeahead_textarea'){

  const source = (f.dataset || f.source || f.autocomplete || 'persona'); // 'persona' | 'bias'
  holder.classList.add('taWrap');

  const list = document.createElement('div');
  list.className = 'taList';
  list.hidden = true;

  holder.appendChild(input);
  holder.appendChild(list);
  
  // Keep focus while interacting with suggestions (prevents input blur race)
['pointerdown','mousedown'].forEach(evt=>{
  list.addEventListener(evt, (e)=> e.preventDefault());
});


  let activeIndex = -1;

  function renderSuggestions(q){
    const hits = (source === 'bias') ? biasFilter(q, 30) : personaFilter(q, 30);
    list.innerHTML = '';
    activeIndex = -1;
    if (!hits.length){ list.hidden = true; return; }

    hits.forEach((obj, idx)=>{
      const item = document.createElement('div');
      item.className = 'taItem';

      const sub = (source === 'bias')
        ? `${obj.category || obj.kind || ''}${(obj.tags && obj.tags.length) ? (' • ' + obj.tags.join(', ')) : ''}`
        : `${obj.profession || ''}${(obj.tags && obj.tags.length) ? (' • ' + obj.tags.join(', ')) : ''}`;

      item.innerHTML = `
        <span class="name">${obj.name}</span>
        <span class="sub">${sub}</span>
      `.trim();

      item.addEventListener('click', ()=>{
        (t.fields || (t.fields = {}));

        if (source === 'bias'){
          // Spread into mapped fields when requested
          if (f.autofill === 'bias->spread' || f.key === 'bias_name'){
            applyBiasToTab(t, obj);
            list.hidden = true;
            renderFields();
            emit();
            return;
          }

          // Fill strategies
          const wantsTextarea = (f.autofill === 'bias->textarea') || (f.type === 'typeahead_textarea');
          const modeInline    = (f.autofill === 'bias->inline');
          const modeTemplate  = (f.autofill === 'bias->template');

          if (wantsTextarea){
            const txt = biasText(obj);
            input.value = txt;
            t.fields[f.key] = txt;
          } else if (modeTemplate){
            const txt = biasFillTemplate(f.bias_template, obj);
            input.value = txt;
            t.fields[f.key] = txt;
          } else if (modeInline){
            const txt = biasInlineFlexible(obj, {
              labels: f?.inline_labels !== false,
              sep:    f?.separator || ' · ',
              include: Array.isArray(f?.include) ? f.include : undefined
            });
            input.value = txt;
            t.fields[f.key] = txt;
          } else {
            input.value = obj.name || '';
            t.fields[f.key] = input.value;
          }

          list.hidden = true;
          emit();
          return;
        }

        // === persona (existing behavior preserved) ===
        const isPersona = (f.key === 'persona_name');
        const wantsPersonaTextarea = (f.autofill === 'persona->textarea') || (f.type === 'typeahead_textarea');

        if (isPersona){
          applyPersonaToTab(t, obj);
          t.fields.end = (t.fields.end || '');
          list.hidden = true;
          renderFields();
          emit();
          const endInput = document.querySelector('#end'); if (endInput) endInput.focus();
          return;
        }

        if (wantsPersonaTextarea){
          const txt = personaText(obj);
          input.value = txt;
          t.fields[f.key] = txt;
        } else if (f.autofill === 'persona->template'){
          const txt = personaFillTemplate(f.persona_template, obj);
          input.value = txt;
          t.fields[f.key] = txt;
        } else if (f.autofill === 'persona->inline'){
          const txt = personaInlineFlexible(obj, {
            labels: f?.inline_labels !== false,
            sep:    f?.separator || ' · ',
            include: Array.isArray(f?.include) ? f.include : undefined
          });
          input.value = txt;
          t.fields[f.key] = txt;
        } else {
          input.value = obj.name || '';
          t.fields[f.key] = input.value;
        }

        list.hidden = true;
        emit();
      });
      
      // Commit on pointerdown too; prevents first-click miss on some browsers
item.addEventListener('pointerdown', (e)=>{ e.preventDefault(); item.click(); });
item.addEventListener('mousedown',   (e)=>{ e.preventDefault(); item.click(); });


      list.appendChild(item);
    });

    list.hidden = false;
  }

  input.addEventListener('input', ()=>{
    (t.fields || (t.fields = {}))[f.key] = input.value;
    if (input.value.trim().length === 0){ list.hidden = true; emit(); return; }
    renderSuggestions(input.value);
    emit();
  });

  input.addEventListener('keydown', (e)=>{
    const items = Array.from(list.children);
    if (list.hidden || !items.length) return;

    if (e.key === 'ArrowDown'){ e.preventDefault(); activeIndex = Math.min(items.length-1, activeIndex+1); }
    if (e.key === 'ArrowUp'){   e.preventDefault(); activeIndex = Math.max(0, activeIndex-1); }
    if (e.key === 'Escape'){ list.hidden = true; return; }

    if (e.key === 'Enter' && activeIndex >= 0){
      e.preventDefault();
      items[activeIndex].dispatchEvent(new Event('click', {bubbles:true}));
      return;
    }

    items.forEach((n,i)=> n.classList.toggle('active', i===activeIndex));
  });

  // Hide on blur (delay so clicks register)
  input.addEventListener('blur', ()=> setTimeout(()=> list.hidden = true, 120));

} else {
  // Normal field (text/textarea)
  holder.appendChild(input);
}


// Save + preview updates (works for both normal and typeahead)
wrap.appendChild(holder);
fieldInput(input, ()=>{
  (t.fields || (t.fields = {}))[f.key] = input.value;
  emit(); // will call emitAll() + totals
});

function personaInline(p){
  const parts = [];
  if (p.name) parts.push(`Name: ${p.name}`);
  if (p.profession) parts.push(`Profession: ${p.profession}`);
  if (p.summary) parts.push(`Summary: ${p.summary}`);
  return parts.join(' ');
}

// Fill arbitrary "{name}" "{profession}" "{summary}" etc.
function personaFillTemplate(tpl, p){
  return String(tpl||'').replace(/\{(\w+)\}/g, (_,k)=> (p?.[k] ?? ''));
}

// Build a clean one-liner with options
function personaInlineFlexible(p, opts = {}){
  const include = Array.isArray(opts.include) && opts.include.length
    ? opts.include
    : ['name','profession','summary']; // default order

  const labels = (opts.labels !== false); // default: show "Name:", etc.
  const sep    = (typeof opts.sep === 'string') ? opts.sep : ' · ';

  const labelMap = {
    name:       labels ? 'Name: '       : '',
    profession: labels ? 'Profession: ' : '',
    role:       labels ? 'Role: '       : '',
    title:      labels ? 'Title: '      : '',
    summary:    labels ? 'Summary: '    : '',
    bio:        labels ? 'Bio: '        : '',
    expertise:  labels ? 'Expertise: '  : ''
  };

  const parts = include.map(k => {
    const v = (p?.[k] ?? '').toString().trim();
    return v ? (labelMap[k] + v) : '';
  }).filter(Boolean);

  return parts.join(sep);
}

// Single router for all persona insertions
function personaStringFor(field, p){
  // mode: 'name' | 'inline' | 'textarea' | 'template'
  let mode = 'name';
  if (typeof field?.autofill === 'string' && field.autofill.startsWith('persona->')) {
    mode = field.autofill.split('persona->')[1];
  } else if (field?.type === 'typeahead_textarea') {
    mode = 'textarea';
  }

  if (mode === 'textarea') return (typeof personaText === 'function') ? personaText(p) : (p?.summary || '');
  if (mode === 'template') return personaFillTemplate(field?.persona_template, p);

  if (mode === 'inline') {
    return personaInlineFlexible(p, {
      labels: field?.inline_labels !== false,             // default true
      sep:    field?.separator || ' · ',                  // default " · "
      include: Array.isArray(field?.include) ? field.include : undefined
    });
  }

  // 'name' default
  return p?.name || '';
}




  // Inline counter (Stage 1)
  setupCounter(input);

  // Optional helper text (unchanged)
  if (f.desc){
    const d = document.createElement('div');
    d.className = 'desc';
    d.textContent = f.desc;
    wrap.appendChild(d);
  }

  fieldsWrap.appendChild(wrap);
});

    // After rendering the current slice, sync the stepper UI
updateStepperUI(tabNow, allFields.length, visFields.length);
  
      

// --- Default Included Instructions + “Anything else” box ---
// Render into the fixed under-stepper mount (#extraWrap), not the scrolling fields list.
{
  const mount = document.getElementById('extraWrap');
  if (mount){
    mount.innerHTML = '';           // rebuild each render for the active tab

    // 2.3 — Label rename
    const label = document.createElement('label');
    label.textContent = 'Default Included Instructions';
    label.setAttribute('for', 'extra');

    // Main textarea (prefill boosters as placeholder; user text wins if present)
    const holder = document.createElement('div');
    holder.className = 'fieldHolder';

    const ta = document.createElement('textarea');
    ta.id = 'extra';
    ta.rows = 3;

    const def = defaultBooster(t.id);
    const cur = (t.extra || '').trim();
    if (cur) ta.value = cur;
    if (!cur && def) ta.placeholder = def;

    holder.appendChild(ta);
    mount.appendChild(label);
    mount.appendChild(holder);

    // Helper line (keeps deterministic behavior obvious)
    const tip = document.createElement('div');
    tip.className = 'help';
    tip.textContent = 'Pre-filled with this template’s recommendations. Editing replaces the defaults in your prompt.';
    mount.appendChild(tip);

    // Restore button (small, optional)
    const helpers = document.createElement('div');
    helpers.className = 'extraHelpers';
    const restore = document.createElement('button');
    restore.type = 'button';
    restore.id = 'extraRestore';
    restore.className = 'restore';
    restore.textContent = 'Restore recommended text';
    helpers.appendChild(restore);
    mount.appendChild(helpers);

    // Save + preview updates for main box
    fieldInput(ta, ()=>{
      t.extra = ta.value.trim();
      ta.classList.toggle('filled', !!t.extra);
      if (typeof scheduleSave === 'function') scheduleSave();
      emit();
    });

    setupCounter(ta);
    if (ta._counterNode) ta._counterNode.id = 'extraCounter';

    restore.addEventListener('click', ()=>{
      const txt = defaultBooster(t.id) || '';
      t.extra = txt;
      ta.value = txt;
      ta.classList.toggle('filled', !!txt);
      if (ta._counterNode) ta._counterNode.textContent = txt.length ? `${Math.ceil(txt.length/4)}t · ${txt.length}c` : '';
      if (typeof scheduleSave === 'function') scheduleSave();
      emit();
    });

    // 2.4 — Second textarea (blank by default; appended to the prompt)
    const label2 = document.createElement('label');
    label2.setAttribute('for', 'extraMore');
    label2.style.marginTop = '12px';
    label2.textContent = 'Anything else to include (optional)';

    const holder2 = document.createElement('div');
    holder2.className = 'fieldHolder';

    const ta2 = document.createElement('textarea');
    ta2.id = 'extraMore';
    ta2.rows = 3;
    ta2.placeholder = 'Type any additional guidance for the AI…';
    ta2.value = (t.extra_more || '');

    holder2.appendChild(ta2);
    mount.appendChild(label2);
    mount.appendChild(holder2);

    const tip2 = document.createElement('div');
    tip2.className = 'help';
    tip2.textContent = 'This text will be appended after the default instructions (if any).';
    mount.appendChild(tip2);
    
    // 3) Reasoning & research toggles (per-tab)
// Shows two yes/no checkboxes that append directive blocks into the output when enabled.
{
  // ensure bag exists
  const modes = (t.modes ||= { think:false, websearch:false });

  const wrap = document.createElement('div');
  wrap.className = 'field';

  const lab = document.createElement('label');
  lab.textContent = 'Reasoning & research (optional)';
  wrap.appendChild(lab);

  const holder = document.createElement('div');
  holder.className = 'fieldHolder';
  holder.style.display = 'grid';
  holder.style.gridTemplateColumns = '1fr 1fr';
  holder.style.gap = '8px';

  function makeToggle(id, labelText, checked, onChange){
    const lbl = document.createElement('label');
    lbl.className = 'check';
    const inp = document.createElement('input');
    inp.type = 'checkbox';
    inp.id = id;
    inp.checked = !!checked;
    const span = document.createElement('span');
    span.textContent = labelText;
    lbl.appendChild(inp);
    lbl.appendChild(span);
    inp.addEventListener('change', ()=>{
      onChange(inp.checked);
      if (typeof scheduleSave === 'function') scheduleSave();
      emit(); // refresh preview/deck
    });
    return lbl;
  }

  holder.appendChild(
    makeToggle('toggleThink',
      'Ask model to think (deliberative mode)',
      modes.think,
      v => { modes.think = v; }
    )
  );

  holder.appendChild(
    makeToggle('toggleWeb',
      'Ask model to search online',
      modes.websearch,
      v => { modes.websearch = v; }
    )
  );
  
    // --- LENS: enable + picker (renders under the two toggles) ---
  modes.lens_on = !!modes.lens_on;
  modes.lens_id = modes.lens_id || '';

  // 1) Enable toggle
  holder.appendChild(
    makeToggle('toggleLens',
      'Add a reasoning lens',
      modes.lens_on,
      v => {
        modes.lens_on = v;
        selWrap.hidden = !v;
        if (!v) modes.lens_id = '';
        if (typeof scheduleSave === 'function') scheduleSave();
        emit(); // refresh preview/deck
      }
    )
  );

  // 2) Full-width selector
  const selWrap = document.createElement('div');
  selWrap.style.gridColumn = '1 / -1';
  selWrap.hidden = !modes.lens_on;

  const lensSel = document.createElement('select');
  lensSel.id = 'lensSel';
  lensSel.innerHTML = [
    '<option value="">— Select a lens —</option>',
    ...(Array.isArray(window.__LENSES__) ? window.__LENSES__ : []).map(L =>
      `<option value="${L.lens_id}" title="${(L.intent||'').replace(/"/g,'&quot;')}">${L.label}</option>`
    )
  ].join('');

  lensSel.value = modes.lens_id || '';
  lensSel.addEventListener('change', ()=>{
    modes.lens_id = lensSel.value || '';
    if (typeof scheduleSave === 'function') scheduleSave();
    emit(); // refresh preview/deck
  });

  selWrap.appendChild(lensSel);
  holder.appendChild(selWrap);
  // -------------------------------------------------------------


  // hint
  const hint = document.createElement('div');
  hint.className = 'help';
  hint.textContent = 'These add instruction blocks to the end of your prompt. Toggle per template.';
  wrap.appendChild(holder);
  wrap.appendChild(hint);
  mount.appendChild(wrap);
}


    fieldInput(ta2, ()=>{
      t.extra_more = ta2.value;
      ta2.classList.toggle('filled', !!ta2.value.trim());
      if (typeof scheduleSave === 'function') scheduleSave();
      emit();
    });

    setupCounter(ta2);
    if (ta2._counterNode) ta2._counterNode.id = 'extraMoreCounter';
  }

  // Visibility (same rule you had before): in guided mode, show on last step; in show-all, always show
  const guided = isGuided(t);
  const size   = stepSize();
  const atEnd  = ((t.step || 0) + 1) * size >= (Array.isArray(fw?.fields) ? fw.fields.length : 0);
  const show   = guided ? atEnd : true;

  if (mount){
    mount.hidden = !show;
    mount.setAttribute('aria-hidden', String(!show));
  }
}
// --- end Default Included Instructions + “Anything else” box ---




// meta box (enriched from glossary when available)
chips.innerHTML = '';
const meta = enrichFromGlossary(fw);

// Build a boxed section so everything stacks nicely
const box = document.createElement('div');
box.className = 'metaBox';
chips.appendChild(box);

// Row 0: Save & Reset session controls (above Glossary)
{
  const row = document.createElement('div');
  row.className = 'metaRow';

  const controls = document.createElement('div');
  controls.className = 'metaGroup';

  // Save button
  const saveBtn = document.createElement('button');
  saveBtn.type = 'button';
  saveBtn.className = 'btn sm';
  saveBtn.id = 'saveSessionBtn';
  saveBtn.textContent = 'Save session';

  // Reset button (red, with confirm)
  const resetBtn = document.createElement('button');
  resetBtn.type = 'button';
  resetBtn.className = 'btn sm danger';
  resetBtn.id = 'resetSessionBtn';
  resetBtn.textContent = 'Reset (wipe all)';

  controls.appendChild(saveBtn);
  controls.appendChild(resetBtn);
  row.appendChild(controls);
  box.appendChild(row);

  // Helper text (plain-language)
  const saveHelp = document.createElement('div');
  saveHelp.className = 'help saveHelp';
  saveHelp.textContent = 'Saves to your browser only. Clearing site data/cookies, switching browsers, or using private mode will remove it.';
  box.appendChild(saveHelp);

  // Wire up behavior
// Wire up behavior
const doImmediateSave = () => {
  // Prefer immediate save (no debounce) so the snapshot timestamp matches the click
  if (typeof window.saveNow === 'function') return window.saveNow();
  if (typeof window.scheduleSave === 'function') return window.scheduleSave();
  // Fallback: write state directly
  try{ localStorage.setItem((LS_KEYS && LS_KEYS.state) || 'pb.v1.state', JSON.stringify(state)); }catch(e){}
};

saveBtn.addEventListener('click', ()=>{
  const original = saveBtn.textContent;
  saveBtn.disabled = true;
  saveBtn.textContent = 'Saving…';

  try {
    // Tag this one as a MANUAL save (consumed inside saveNow → history)
    window.__SAVE_KIND__ = 'manual';
    doImmediateSave();
  } finally {
    window.__SAVE_KIND__ = undefined;
    // lightweight “it saved” feedback
    setTimeout(()=>{
      saveBtn.textContent = 'Saved ✓';
      setTimeout(()=>{
        saveBtn.disabled = false;
        saveBtn.textContent = original;
      }, 900);
    }, 400);
  }
});

  resetBtn.addEventListener('click', ()=>{
    const msg =
      'This will clear all tabs, fields, and saved preferences for Prompt Builder in this browser.\n\nStart fresh?';
    if (!confirm(msg)) return;
    
      // NEW: clear Common context immediately so the UI reflects it
  if (typeof clearCommonContext === 'function') clearCommonContext();

    if (typeof window.resetSavedSession === 'function'){
      window.resetSavedSession();
      return;
    }
    // Fallback reset if helper isn’t present for any reason
    try{
      localStorage.removeItem((LS_KEYS && LS_KEYS.state) || 'pb.v1.state');
      localStorage.removeItem((LS_KEYS && LS_KEYS.ui)    || 'pb.v1.ui');
    }catch(e){}
    location.reload();
  });
}


// Row 1: Open in Glossary (two links: Full + Template)
if (meta?.slug){
  const row = document.createElement('div');
  row.className = 'metaRow';
  row.style.gap = '0.5rem'; // adds spacing between glossary chips

  // Full Glossary (existing behavior, just relabeled)
  const fullA = document.createElement('a');
  fullA.className = 'chip metaLink';
  fullA.href = `../glossary/index.html#${meta.slug}`;
  fullA.textContent = 'Open in Full Glossary';
  fullA.title = meta.label;
  row.appendChild(fullA);

  // Template Glossary (new, deep-links by slug as well)
  const tplA = document.createElement('a');
  tplA.className = 'chip metaLink';
  tplA.href = `./Templates-Glossary.html#${meta.slug}`;
  tplA.textContent = 'Open in Template Glossary';
  tplA.title = meta.label;
  row.appendChild(tplA);

  box.appendChild(row);
}


// Optional status (still small, under its own row)
if (meta?.status){
  const row = document.createElement('div');
  row.className = 'metaRow';
  row.style.gap = '0.5rem'; // adds spacing between glossary chips
  const st = document.createElement('span');
  st.className = 'chip';
  st.textContent = `Status: ${meta.status}`;
  row.appendChild(st);
  box.appendChild(row);
}

// Helper to group tags by key
function groupTags(list){
  const groups = {};
  (list || []).forEach(t=>{
    const [k, v] = String(t).split(':');
    if (!k || v === undefined) return;
    (groups[k] ||= []).push(v);
  });
  return groups;
}

// Row 2: CATEGORIES (title line + its own pill row)
if (meta?.categories?.length){
  const title = document.createElement('div');
  title.className = 'metaSectionTitle';
  title.textContent = 'Categories';
  box.appendChild(title);

  const row = document.createElement('div');
  row.className = 'metaPills';
  meta.categories.forEach(cat=>{
    const s = document.createElement('span');
    s.className = 'chip';
    s.textContent = cat;
    row.appendChild(s);
  });
  box.appendChild(row);
}

// Row 3: TAGS grouped by key (type/topic/phase/level/…)
const tagGroups = groupTags(meta?.tags);
const keys = Object.keys(tagGroups);
if (keys.length){
  const title = document.createElement('div');
  title.className = 'metaSectionTitle';
  title.textContent = 'Tags';
  box.appendChild(title);

  keys.sort().forEach(key=>{
    const row = document.createElement('div');
    row.className = 'metaPills';

    const k = document.createElement('span');
    k.className = 'tinyLabel';
    k.textContent = key;
    row.appendChild(k);

    tagGroups[key].forEach(val=>{
      const s = document.createElement('span');
      s.className = 'chip';
      s.textContent = val;
      row.appendChild(s);
    });

    box.appendChild(row);
  });
}


    }

function ctxStringFromTab(t){
  // Live DOM is authoritative to avoid “ghost” values from stale saved state.
  const c = (t && t.common) || {};
  const pick = (id, fb='')=>{
    const el = document.getElementById(id);
    // If the input exists, use exactly what the user sees (including blank)
    if (el) return (el.value || '').trim();
    // Fallback to saved state only if the field doesn’t exist in DOM
    return (fb || '').trim();
  };

  const u  = pick('usecase',  c.ctx);
  const a  = pick('audience', c.audience);
  const s  = pick('style',    c.style);
  const tn = pick('tone',     c.tone);

  const bits = [];
  if (u)  bits.push(`Use-case: ${u}`);
  if (a)  bits.push(`Audience: ${a}`);
  if (s)  bits.push(`Style: ${s}`);
  if (tn) bits.push(`Tone: ${tn}`);

  return bits.join(' | ');
}


function emit(){
  emitAll();
  updatePromptTotal();
  updateOutPreviewCounter();
}

sel.addEventListener('change', () => {
  switchFramework(sel.value);
  if (typeof updatePickerPreview === 'function') updatePickerPreview();
});


// New: one-click commit of the top search hit when a filter is active.
// This avoids the awkward "pick something else, then come back" dance.
sel.addEventListener('mousedown', () => {
  const q = (document.getElementById('fwSearch')?.value || '').trim();
  if (!q) return; // only intervene when filtering
  const first = sel.options[0];
  if (!first) return;
  const t = activeTab();
  if (t.id !== first.value) {
    // Mirror UI and commit selection
sel.value = first.value;
switchFramework(first.value);

  }
});


['usecase','audience','style','tone'].forEach(id=>{
  const el = document.getElementById(id);
  if (!el) return;
  const key = (id === 'usecase') ? 'ctx' : id;

  const on = () => {
    const t = activeTab();
    if (!t) return;
    t.common = t.common || { ctx:'', audience:'', style:'', tone:'' };
    t.common[key] = el.value || '';

    // Only clear persona if the Audience text diverges from the bound persona's name.
   if (id === 'audience') {
  const current = (el.value || '').trim();
  if (!current) {
    // Only clear bindings if the field is actually blank
    t.common.audience_persona  = null;
    t.common.audience_personas = [];
  }
  // Otherwise keep whatever was selected via the typeahead
}


    el.classList.toggle('filled', !!el.value);
    emitAll();
  };

  el.addEventListener('input', on);
  el.addEventListener('change', on);
});


// (removed) Audience single-input typeahead — superseded by chips multi-select

// === Audience multi-select (chips + persona typeahead) ===
(function(){
  const input = document.getElementById('audience');               // same id as before
  const wrap  = document.getElementById('audienceChipsWrap');
  const chips = document.getElementById('audienceChips');
  const menu  = document.getElementById('audienceSuggestions');
  if (!input || !chips || !menu) return;

  let items = [];      // current search hits from personas
  let active = -1;     // highlighted index in menu
  let picks  = [];     // [{ id, name, p }], where p = full persona object

  function close(){
  menu.hidden = true;
  menu.innerHTML = '';
  active = -1;
  const blk = menu.closest('.block'); if (blk) blk.classList.remove('z-top');
}

  function renderChips(){
    chips.innerHTML = '';
    for (const it of picks){
      const el = document.createElement('span');
      el.className = 'chip';
      el.setAttribute('data-id', it.id);
      el.innerHTML = `<span class="nm">${it.name}</span><button class="x" title="Remove">×</button>`;
      el.querySelector('.x').addEventListener('click', ()=>{ removePick(it.id); });
      chips.appendChild(el);
    }
  }

  function syncCommon(){
    const t = (typeof activeTab === 'function') ? activeTab() : null;
    if (!t) return;
    t.common = t.common || {};
    // authoritative: full persona objects
    t.common.audience_personas = picks.map(p=>p.p);
    // legacy back-compat: first selection
    t.common.audience_persona  = picks[0]?.p || null;
    // inline context chip (CSV of names)
    t.common.audience          = picks.map(p=>p.name).join(', ');
    if (typeof emitAll === 'function') emitAll();
    if (typeof scheduleSave === 'function') scheduleSave();
    // mirror filled state on the input
    input.classList.toggle('filled', !!t.common.audience);
  }

  function hasId(id){ return picks.some(p=>String(p.id).toLowerCase() === String(id).toLowerCase()); }
  function addPick(res){
    const p = res?.p || null;
    if (!p) return;
    const id   = String(p.id || p.name || '').trim() || Math.random().toString(36).slice(2);
    const name = String(p.name || p.label || p.persona_name || id).trim();
    if (hasId(id)) return;
    picks.push({ id, name, p });
    input.value = '';  // clear token after add
    renderChips(); syncCommon(); close(); input.focus();
  }
  function removePick(id){
    picks = picks.filter(p=>p.id !== id);
    renderChips(); syncCommon();
  }

  function highlight(){
    [...menu.querySelectorAll('.ta-item')].forEach((n,i)=> n.classList.toggle('ta-active', i===active));
  }

  function renderMenu(q){
    items = (typeof searchPersonas === 'function') ? searchPersonas(q) : [];
    if (!items.length){ close(); return; }
    menu.innerHTML = items.map((r,idx)=>{
      const sum = (r.p && (r.p.summary || r.p.definition || '') || '').toString().trim();
      return `<div class="ta-item${idx===0?' ta-active':''}" data-idx="${idx}">
        <div class="name"><strong>${r.name}</strong></div>
        ${sum ? `<div class="sub">${sum}</div>` : ''}
      </div>`;
    }).join('');
    active = 0;
    const rect = input.getBoundingClientRect();
    menu.style.minWidth = rect.width + 'px';
    menu.hidden = false;
const blk = menu.closest('.block'); if (blk) blk.classList.add('z-top');

  }

  input.addEventListener('input', ()=>{
    const q = input.value.trim();
    if (!q){ close(); return; }
    renderMenu(q);
  });

  input.addEventListener('keydown', (e)=>{
    // Backspace to pop last chip when menu is closed and input is empty
    if (menu.hidden){
      if (e.key === 'Backspace' && !input.value && picks.length){
        e.preventDefault(); removePick(picks[picks.length-1].id); return;
      }
      // not navigating a menu
      return;
    }
    if (e.key === 'ArrowDown'){ e.preventDefault(); active = Math.min(active+1, items.length-1); highlight(); }
    else if (e.key === 'ArrowUp'){ e.preventDefault(); active = Math.max(active-1, 0);           highlight(); }
    else if (e.key === 'Enter' || e.key === ','){ e.preventDefault(); addPick(items[Math.max(0,active)]); }
    else if (e.key === 'Escape'){ e.preventDefault(); close(); }
  });

  menu.addEventListener('mousedown', (e)=>{
    const el = e.target.closest('.ta-item'); if (!el) return;
    const idx = parseInt(el.dataset.idx,10) || 0;
    addPick(items[idx]);
  });

  document.addEventListener('click', (ev)=>{
    if (ev.target!==input && !menu.contains(ev.target)) close();
  });

  // Rehydrate chips on tab switch
  function refreshFromTab(){
    const t = (typeof activeTab === 'function') ? activeTab() : null;
    const arr = Array.isArray(t?.common?.audience_personas) ? t.common.audience_personas : [];
    if (arr.length){
      picks = arr.map(p=>({ id: String(p.id || p.name || '').trim() || Math.random().toString(36).slice(2),
                            name: String(p.name || p.label || p.persona_name || 'Persona'),
                            p }));
    } else {
      picks = []; // no fallback to arbitrary CSV; we want dataset-backed personas
    }
    renderChips(); syncCommon();
  }
  refreshFromTab();
  document.addEventListener('tab-switched', refreshFromTab);
})();

function showToast(msg, ms=1600){
  const el = document.getElementById('toast');
  if (!el) return;
  el.textContent = msg;
  el.hidden = false;
  clearTimeout(showToast._t);
  showToast._t = setTimeout(()=>{ el.hidden = true; }, ms);
}



// === Bias multi-select (chips + typeahead) ===
(function(){
  const input = document.getElementById('biasInput');
  const wrap  = document.getElementById('biasChipsWrap');
  const chips = document.getElementById('biasChips');
  const menu  = document.getElementById('biasSuggestions');
  if (!input || !chips || !menu) return;

  let items = [];       // current search hits
  let active = -1;      // index in items
  let picks  = [];      // array of {id,name,kind}

  function kindDot(k){ return ['bias','technique','dilemma','custom'].includes(k) ? k : 'bias'; }
  function close(){ menu.hidden = true; menu.innerHTML=''; active=-1; }

  function syncCommon(){
    const t = (typeof activeTab === 'function') ? activeTab() : null;
    if (!t) return;
    t.common = t.common || {};
    t.common.bias_names = picks.map(p=>p.name).join(', ');
    t.common.bias_ids   = picks.map(p=>p.id);
    if (typeof emitAll === 'function') emitAll();
    if (typeof scheduleSave === 'function') scheduleSave();
  }

  function hasId(id){ return picks.some(p=>p.id === id); }
  function renderChips(){
    chips.innerHTML = '';
    for (const p of picks){
      const el = document.createElement('span');
      el.className = 'chip';
      el.setAttribute('data-id', p.id);
      el.innerHTML = `<span class="dot ${kindDot(p.kind)}" title="${p.kind}"></span><span class="nm">${p.name}</span><button class="x" title="Remove">×</button>`;
      el.querySelector('.x').addEventListener('click', ()=>{ removePick(p.id); });
      chips.appendChild(el);
    }
  }
  function addPick(obj){
    const id = String(obj.id || obj.name || '').trim() || ('custom:' + Math.random().toString(36).slice(2));
    const kind = (obj.kind ? String(obj.kind).toLowerCase() : 'bias');
    const name = String(obj.name || obj.label || obj.id || '').trim() || 'Custom item';
    if (hasId(id)) return;
    picks.push({id, name, kind});
    renderChips(); syncCommon();
  }
  function removePick(id){
    picks = picks.filter(p=>p.id !== id);
    renderChips(); syncCommon();
  }

  function renderMenu(q){
    items = biasFilter(q, 30) || [];
    if ((!items || !items.length) && q.trim().length){
      items = [{ id:'custom:'+q.trim(), name:q.trim(), kind:'custom', summary:'' }];
    }
    if (!items.length){ close(); return; }
    menu.innerHTML = items.map((b,i)=>{
      const sub = (b.category || b.kind || '');
      const dot = kindDot(b.kind);
const sum = (b.summary || b.definition || '').toString().trim();
return `<div class="ta-item${i===0?' ta-active':''}" data-idx="${i}">
  <div class="name"><span class="dot ${dot}"></span> <strong>${b.name}</strong></div>
  ${sum ? `<div class="sub">${sum}</div>` : ''}
</div>`;

    }).join('');
    active = 0;
    const rect = input.getBoundingClientRect();
    menu.style.minWidth = rect.width + 'px';
    menu.hidden = false;
  }
  function pick(i){
    const b = items[i]; if (!b) return;
    addPick(b);
    input.value = '';
    close();
    input.focus();
  }

  input.addEventListener('input', ()=>{
    const q = input.value.trim();
    if (!q){ close(); return; }
    renderMenu(q);
  });
  input.addEventListener('keydown', (e)=>{
    if (menu.hidden){
      if (e.key === 'Backspace' && !input.value && picks.length){
        removePick(picks[picks.length-1].id);
        e.preventDefault();
      }
      return;
    }
    const els = Array.from(menu.children);
    if (e.key === 'ArrowDown'){ e.preventDefault(); active = Math.min(active+1, els.length-1); }
    else if (e.key === 'ArrowUp'){ e.preventDefault(); active = Math.max(active-1, 0); }
    else if (e.key === 'Enter' || e.key === ','){ e.preventDefault(); pick(active>=0?active:0); }
    else if (e.key === 'Escape'){ e.preventDefault(); close(); return; }
    els.forEach((n,i)=> n.classList.toggle('ta-active', i===active));
  });
  menu.addEventListener('mousedown', (e)=>{
    const el = e.target.closest('.ta-item'); if (!el) return;
    pick(parseInt(el.dataset.idx,10)||0);
  });
  document.addEventListener('click', (ev)=>{
    if (ev.target!==input && !menu.contains(ev.target)) close();
  });

  // Refresh when tabs switch
  function refreshFromTab(){
    const t = (typeof activeTab === 'function') ? activeTab() : null;
    picks = Array.isArray(t?.common?.bias_ids)
      ? (t.common.bias_ids.map(id=>{
          const obj = getBiasById(id) || (String(id).startsWith('custom:') ? {id, name:String(id).slice(7), kind:'custom'} : null);
          return obj ? { id: obj.id || id, name: obj.name || String(id), kind: biasKindOf(obj) } : null;
        }).filter(Boolean))
      : [];
    renderChips();
    if (t){ t.common.bias_names = picks.map(p=>p.name).join(', '); if (typeof emitAll==='function') emitAll(); }
  }

  // on load
  refreshFromTab();
  
  // When the dataset finishes loading late, rebuild menu/chips immediately
document.addEventListener('biases-loaded', ()=>{
  try {
    if (typeof buildBiasIndex === 'function') { window.__BIAS_IDX = null; buildBiasIndex(); }
    refreshFromTab();
    const q = input.value.trim();
    if (q) { // if the user is already typing, show fresh suggestions
      // Re-open menu with current query
      (function renderMenuImmediate(){ 
        // reuse the existing renderMenu
        if (typeof renderMenu === 'function') renderMenu(q);
      })();
    }
  } catch(e){}
});


  // listen for our custom event (slice 5 adds it)
  document.addEventListener('tab-switched', refreshFromTab);
})();



    
    // Persist common fields + visual filled state
const COMMON_IDS = ['usecase','audience','style','tone'];
function toggleFilled(el){ el.classList.toggle('filled', !!el.value.trim()); }
COMMON_IDS.forEach(id=>{
  const el = document.getElementById(id);
  const saved = localStorage.getItem('fw_'+id);
  if (saved !== null) el.value = saved;
  toggleFilled(el);
  el.addEventListener('input', ()=>{
    localStorage.setItem('fw_'+id, el.value);
    toggleFilled(el);
    emit();
  });
});

function getAllGeneratedText(){
  const deck = document.getElementById('outDeck');
  if (deck && deck.children.length){
    const titles = deck.querySelectorAll('.outCard .title');
    const bodies  = deck.querySelectorAll('.outCard .outBody');
    const parts = [];
    titles.forEach((t,i)=>{
      const head = (t.textContent || '').trim();
      const body = (bodies[i]?.textContent || '').trim();
      parts.push(`### ${head}\n${body}`);
    });
    return parts.join('\n\n').trim();
  }
  // fallback to single preview
  const out = document.getElementById('out');
  return (out?.textContent || '').trim();
}

 function buildFrameworkDigest() {
    const all = Array.isArray(window.TEMPLATES) ? window.TEMPLATES
      : (Array.isArray(window.FRAMEWORKS) ? window.FRAMEWORKS
      : (Array.isArray(FRAMEWORKS) ? FRAMEWORKS : []));
    const base = (all||[]).filter(f => f && f.id && f.id !== 'none');

    // Deduplicate by slug → label
    const seen = new Set();
    const list = [];
    for (const f of base) {
      const key = String(f.slug || f.label || f.id).trim().toLowerCase();
      if (seen.has(key)) continue;
      seen.add(key);
      list.push(f);
    }

    // Sort alphabetically by label
    list.sort((a,b)=> String(a.label).localeCompare(String(b.label)));

    // Clean + pick up to 2 tags (prefix-stripped)
    function pickTags(f){
      const raw = (f.tags||[]).map(t => {
        const s = String(t||'');
        const idx = s.indexOf(':');
        return idx >= 0 ? s.slice(idx+1) : s;
      }).filter(Boolean);

      const uniq = [];
      for (const t of raw) { if (!uniq.includes(t)) uniq.push(t); }

      // lightweight preference: topic/use near front
      uniq.sort((a,b)=>{
        const prio = (x) => (/^(creativity|analysis|writing|marketing|planning|prioritization|decision|evaluation)$/i.test(x) ? 0 : 1);
        return prio(a) - prio(b) || a.localeCompare(b);
      });

      return uniq.slice(0,2);
    }

    const lines = list.map(f => {
      const t = pickTags(f);
      return t.length ? `- ${f.label} (${t.join(', ')})` : `- ${f.label}`;
    }).join('\n');

    return 'Framework digest (for the assistant; do not invent new ones):\n' + lines;
  } 
  
// Actions
$('#copyBtn').addEventListener('click', async (e)=>{ if (window.__USE_ACTION_MODAL__) return;
  const deck = document.getElementById('outDeck');
  let text = '';

  if (deck && !deck.hidden) {
    // === Copy All Mode ===
    const nodes = Array.from(deck.querySelectorAll('.outBody'));
    const pieces = [];

    for (let i = 0; i < nodes.length; i++) {
      let tabText = nodes[i].textContent.trim();

      // Match node to tab (assuming window.TABS holds your tab objects in order)
      const tab = (state && state.tabs) ? state.tabs[i] : null;
      if (tab && tab.id === 'none') {
        tabText = tabText + '\n\n' + buildFrameworkDigest();
      }

      if (tabText) pieces.push(tabText);
    }

    text = pieces.join('\n\n---\n\n');
  } else {
    // === Copy Single Mode ===
    text = (document.getElementById('out')?.textContent || '');
    const active = (typeof activeTab === 'function' ? activeTab() : (state && state.tabs ? state.tabs[state.active] : null));
    if (active && active.id === 'none') {
      text = text + '\n\n' + buildFrameworkDigest();
    }
  }

  try { await navigator.clipboard.writeText(text); }
  catch(e){ console.warn('Copy failed', e); }

  const dlg = document.getElementById('msg'); 
  dlg?.showModal();
});



   $('#openBtn').addEventListener('click', async (e)=>{ if (window.__USE_ACTION_MODAL__) return;
  const txt = getAllGeneratedText();
  const dlg = $('#msg');
  // 1) Copy to clipboard (primary guarantee)
  let copied = false;
  try { await navigator.clipboard.writeText(txt); copied = true; }
  catch(e){ console.warn('Clipboard write failed:', e); }
  try {
    const url = 'https://chat.openai.com/?q=' + encodeURIComponent(txt);
    window.open(url, '_blank', 'noopener,noreferrer');
    markPostLaunch(txt, (localStorage.getItem('chatgpt_target') || 'https://chatgpt.com/'), false);
  } catch(e){ console.warn('Open failed', e); }
  // message text is updated just below in your existing code





      // 2) Attempt to open ChatGPT with a prefilled query param (best-effort)
      function buildChatURL(prompt){
        const base = localStorage.getItem('chatgpt_target') || 'https://chatgpt.com/';
        try{
          const u = new URL(base);
          // Try multiple param names — ChatGPT may ignore them, but harmless.
          u.searchParams.set('q', prompt);
          u.searchParams.set('prompt', prompt);
          u.searchParams.set('input', prompt);
          return u.toString();
        }catch(err){
          console.warn('Bad chat target URL; falling back.', err);
          return 'https://chatgpt.com/';
        }
      }
      const url = buildChatURL(txt);
      window.open(url, '_blank', 'noopener');

      // 3) User feedback
      const msg = copied
        ? 'Prompt copied to clipboard. A ChatGPT tab opened. If the prompt did not auto-appear, paste with Cmd/Ctrl+V.'
        : 'Opened ChatGPT. Could not auto-copy the prompt (browser denied). Please select the text in the preview and copy it manually.';
      const msgEl = document.getElementById('msgText');
      if(msgEl) msgEl.textContent = msg; else console.info(msg);
      dlg.showModal();
    });
    
    // Add template (single, guarded wiring)
(function wireAddTemplate(){
  if (window.__addTemplateWired) return;
  window.__addTemplateWired = true;
  const btn = document.getElementById('addPromptBtn');
  if (!btn) return;
btn.addEventListener('click', (e)=>{
  e.preventDefault();
  if (typeof addTab === 'function') addTab(false);
});

})();



    
    // --- Dialog: make it closable via button and backdrop ---
const dlg = document.getElementById('msg');
const dlgClose = document.getElementById('dlgClose');

// Close when clicking the "Close" button
if (dlgClose) dlgClose.addEventListener('click', () => dlg.close());

// Close when clicking the backdrop (outside the dialog content)
dlg.addEventListener('click', (e) => {
  // If the click target is the <dialog> itself, it's the backdrop
  if (e.target === dlg) dlg.close();
});

// Optional: ensure Esc always closes (most browsers do this by default)
dlg.addEventListener('cancel', () => {
  // no-op; letting the default behavior close the dialog
});

// --- Draggable vertical resizer for the left panel ---
(function(){
  const resizer = document.getElementById('resizer');
  const root = document.documentElement;
  const MIN = 280, MAX = 900;

  // restore saved width if present
  const saved = parseInt(localStorage.getItem('fw_leftW') || '', 10);
  if (!isNaN(saved)) root.style.setProperty('--leftW', saved + 'px');

  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

  let dragging = false;

  function onMove(clientX){
    const wrapRect = document.querySelector('.wrap').getBoundingClientRect();
    const x = clientX - wrapRect.left;           // position inside the grid
    const newW = clamp(x, MIN, MAX);             // left column width
    root.style.setProperty('--leftW', newW + 'px');
    localStorage.setItem('fw_leftW', String(newW));
  }

  resizer.addEventListener('mousedown', (e)=>{
    dragging = true; e.preventDefault();
    document.body.style.userSelect = 'none';
  });
  window.addEventListener('mousemove', (e)=>{ if(dragging) onMove(e.clientX); });
  window.addEventListener('mouseup', ()=>{
    if(dragging){ dragging=false; document.body.style.userSelect=''; }
  });

  // Touch support
  resizer.addEventListener('touchstart', (e)=>{
    dragging = true; document.body.style.userSelect='none';
  }, {passive:true});
  window.addEventListener('touchmove', (e)=>{
    if(!dragging) return;
    const t = e.touches[0]; if(t) onMove(t.clientX);
  }, {passive:true});
  window.addEventListener('touchend', ()=>{
    if(dragging){ dragging=false; document.body.style.userSelect=''; }
  });

  // Keyboard resizing for accessibility
  resizer.addEventListener('keydown', (e)=>{
    const step = (e.shiftKey ? 40 : 20);
    const cur = parseInt(getComputedStyle(root).getPropertyValue('--leftW') || '360', 10);
    if (e.key === 'ArrowLeft'){ const w = clamp(cur - step, MIN, MAX); root.style.setProperty('--leftW', w + 'px'); localStorage.setItem('fw_leftW', String(w)); }
    if (e.key === 'ArrowRight'){ const w = clamp(cur + step, MIN, MAX); root.style.setProperty('--leftW', w + 'px'); localStorage.setItem('fw_leftW', String(w)); }
  });
})();

// init happens in boot() below (deferred if Tasks dataset is active)


// Mirror header actions in the secondary action row (no code duplication)
(function wireSecondaryActions(){ if (window.__USE_ACTION_MODAL__) return;
  const copy2  = document.getElementById('copyBtn2');
  const open2  = document.getElementById('openBtn2');
  const clear2 = document.getElementById('clearBtn2');
  
  
  
  
  

  function activePromptText(){
    try{
      const t = (typeof activeTab === 'function') ? activeTab() : null;
      if (!t) return '';
      let text = (typeof makePromptForTab === 'function') ? makePromptForTab(t) : '';
      if (t.id === 'none' && typeof buildFrameworkDigest === 'function'){
        const dig = buildFrameworkDigest();
        if (dig) text = [text, dig].filter(Boolean).join('\n\n');
      }
      return String(text || '').trim();
    }catch(e){
      console.warn('activePromptText failed:', e);
      return '';
    }
  }

  // Helper: reset a tab to the picker (never deletes)
  function resetTabToPicker(idx){
    try{
      const prevCommon = (state.tabs?.[idx]?.common) || { ctx:'', audience:'', style:'', tone:'' };
      state.tabs[idx] = { id:'none', fields:{}, extra: undefined, common: { ...prevCommon } };
      state.active = idx;
      renderTabs();
      buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
      renderFields();
      emitAll();
      if (typeof scheduleSave === 'function') scheduleSave();
    }catch(e){
      console.warn('resetTabToPicker failed:', e);
    }
  }

  copy2 && copy2.addEventListener('click', async ()=>{
    const text = activePromptText();
    try { await navigator.clipboard.writeText(text); } catch(e){ console.warn('Copy failed', e); }
    const dlg = document.getElementById('msg'); const msg = document.getElementById('msgText');
    if (msg) msg.textContent = 'Prompt copied to clipboard.';
    dlg && dlg.showModal && dlg.showModal();
  });

  open2 && open2.addEventListener('click', async ()=>{
    const text = activePromptText();
    let copied = false;
    try { await navigator.clipboard.writeText(text); copied = true; } catch(e){}
    const base = localStorage.getItem('chatgpt_target') || 'https://chatgpt.com/';
    let url = base;
    try { const u = new URL(base); u.searchParams.set('q', text); u.searchParams.set('prompt', text); u.searchParams.set('input', text); url = u.toString(); } catch(e){}
    try { window.open(url, '_blank', 'noopener,noreferrer'); } catch(e){}
    markPostLaunch(text, (localStorage.getItem('chatgpt_target') || 'https://chatgpt.com/'), false);
    const dlg = document.getElementById('msg'); const msg = document.getElementById('msgText');
    if (msg) msg.textContent = copied
      ? 'Prompt copied. A ChatGPT tab opened. If it didn’t prefill, paste with Cmd/Ctrl+V.'
      : 'Opened ChatGPT. Could not auto-copy; please paste your prompt manually.';
    dlg && dlg.showModal && dlg.showModal();
  });

  clear2 && clear2.addEventListener('click', ()=>{
    const idx = Number.isInteger(state.active) ? state.active : 0;
    const fw  = typeof FIND === 'function' ? FIND(state.tabs?.[idx]?.id) : null;
    const label = fw?.label || 'this prompt';
    const msg = `Clear ${label}? This will reset just the active prompt to “— Select a template —”.`;
    if (!confirm(msg)) return;
    resetTabToPicker(idx);
  });
})();

// === Core button re-bind (safe even if called multiple times) ===
(function wireCoreButtons(){ if (window.__USE_ACTION_MODAL__) return;
  const $ = s => document.querySelector(s);

  // Header buttons (original)
  const copyHeader = $('#copyBtn');
  const openHeader = $('#openBtn');
  const addHeader  = $('#addPromptBtn');
  const themeBtn   = $('#theme');

  // Footer mirrors we just renamed
  const copyFooter = $('#copyAllBtnFooter');
  const openFooter = $('#openAllBtnFooter');

  // Reuse existing app handlers if present; otherwise fall back gracefully
  const doCopyAll = (window.copyAllPrompts || window.copyDeck || window.copyAll || function(){
    // Fallback: copy whatever is visible (deck or single preview)
    const deck = document.getElementById('outDeck');
    const solo = document.getElementById('out');
    let text = '';
    if (deck && !deck.hidden) {
      text = Array.from(deck.querySelectorAll('.outCard .outBody, .outCard pre'))
        .map(n => n.textContent || '')
        .filter(Boolean)
        .join('\n\n');
    } else if (solo) {
      text = solo.textContent || '';
    }
    text = text.trim();
    if (!text) return;
    navigator.clipboard.writeText(text).then(()=> showMsg('Prompt copied to clipboard.'));
  });

  const doOpenAll = (window.openAllInChatGPT || window.openDeck || function(){
    // Fallback: open current preview in ChatGPT
    const solo = document.getElementById('out');
    const text = (solo ? solo.textContent : '').trim();
    if (!text) return;
    const url = 'https://chat.openai.com/?q=' + encodeURIComponent(text.slice(0, 7000));
    window.open(url, '_blank', 'noopener');
    showMsg('Opened ChatGPT. If it didn’t prefill, paste with Cmd/Ctrl+V.');
  });

  const doAddTemplate = (window.addTemplate || window.addPrompt || function(){
    // Fallback: focus the template picker
    document.getElementById('frameworkSel')?.focus();
  });

  function showMsg(s){
    const dlg = document.getElementById('msg');
    const txt = document.getElementById('msgText');
    if (dlg && txt){ txt.textContent = s; dlg.showModal(); }
  }
  function bind(btn, fn){
    if (btn && fn) btn.addEventListener('click', e=>{ e.preventDefault(); fn(); });
  }

  // Bind header
  bind(copyHeader, doCopyAll);
  bind(openHeader, doOpenAll);
  bind(addHeader,  doAddTemplate);

  // Bind footer mirrors
  bind(copyFooter, doCopyAll);
  bind(openFooter, doOpenAll);

  // Theme toggle — keep label + aria in sync, persist to localStorage
  if (themeBtn){
    themeBtn.addEventListener('click', ()=>{
      const root = document.documentElement;
      const cur  = root.getAttribute('data-theme') || 'dark';
      const next = cur === 'light' ? 'dark' : 'light';
      root.setAttribute('data-theme', next);
      themeBtn.setAttribute('aria-pressed', next === 'light' ? 'true' : 'false');
      const label = themeBtn.querySelector('span:last-child');
      if (label) label.textContent = next === 'light' ? 'Dark' : 'Light';
      try{
        const ui = JSON.parse(localStorage.getItem('pb.v1.ui') || '{}');
        ui.theme = next;
        localStorage.setItem('pb.v1.ui', JSON.stringify(ui));
      }catch(e){}
    });
  }
})();

// Global: build a ChatGPT URL with best-effort prefill
// Build a ChatGPT URL; prefer ?prompt= only. Also return a length hint.
function buildChatURL(prompt){
  const base = (localStorage.getItem('chatgpt_target') || 'https://chatgpt.com/').trim();
  const txt  = String(prompt || '');
  let url = 'https://chatgpt.com/';
  try {
    const u = new URL(base);
    // Only set ?prompt=. Do NOT also set q/input (those can bloat and cause 431).
    u.search = ''; // clear any previous search
    u.searchParams.set('prompt', txt);
    url = u.toString();
  } catch(_) {
    url = 'https://chatgpt.com/?prompt=' + encodeURIComponent(txt);
  }
  // Conservative headroom: warn if the URL exceeds ~7.8k chars (varies by browser/server).
  const TOO_LONG = url.length > 7800;
  return { url, tooLong: TOO_LONG, base: (new URL((() => {
    try { return base; } catch(_) { return 'https://chatgpt.com/'; }
  })())).origin + '/' };
}
window.buildChatURL = buildChatURL;


 // Stash info so we can show the helper when the user returns to this tab.
  function markPostLaunch(txt, base, tooLong){
    try{
      sessionStorage.setItem('pb.v1.postLaunch', JSON.stringify({
        t: Date.now(),
        txt: String(txt || ''),
        base: (base || 'https://chatgpt.com/').trim(),
        tooLong: !!tooLong
      }));
    }catch(_){}
  }
  window.markPostLaunch = window.markPostLaunch || markPostLaunch;

// ===== Action Modal v2 — unified, conflict-safe =====
(function(){
  const dlg = document.getElementById('actionModal');
  if (!dlg) return;

  const $ = (sel)=> document.querySelector(sel);
  const title   = $('#actionTitle');
  const closeX  = $('#actionClose');
  const cancelB = $('#actionCancel');
  const confirm = $('#actionConfirm');
  const form    = $('#actionForm');
  const ta      = $('#actionPreview');
  const note    = $('#actionNote');
  const rPrompt = $('#scopePrompt');
  const rAll    = $('#scopeAll');

  // --- conflict shield ---
  // Use capture-phase listeners + stopImmediatePropagation to prevent old handlers from firing.
  function bindCapture(el, fn){
    if (!el) return;
    el.addEventListener('click', (ev)=>{
      ev.preventDefault();
      ev.stopPropagation();
      ev.stopImmediatePropagation();
      fn(ev);
    }, {capture:true});
    // also nuke inline onclicks if any
    el.onclick = null;
  }

  // --- text builders ---
  function getActiveTab(){
    const s = window.state || {};
    const i = Number.isInteger(s.active) ? s.active : 0;
    return (s.tabs && s.tabs[i]) ? s.tabs[i] : null;
  }
  function promptLabel(t, idx){
    const meta = (window.FRAMEWORKS_BY_ID && t?.id) ? window.FRAMEWORKS_BY_ID[t.id] : null;
    const name = meta?.label || t?.id || 'Prompt';
    return `## ${idx+1}. ${name}`;
  }
  function textForSingle(tOverride){
    try{
      const t = tOverride || getActiveTab();
      if (!t) return '';
      if (typeof window.makePromptForTab === 'function'){
        return window.makePromptForTab(t) || '';
      }
      return '';
    }catch(_){ return ''; }
  }
  function textForAll(){
    try{
      const tabs = (window.state && Array.isArray(window.state.tabs)) ? window.state.tabs : [];
      if (!tabs.length) return textForSingle();
      if (typeof window.makePromptForTab === 'function'){
        return tabs.map((t, idx)=>{
          const body = window.makePromptForTab(t) || '';
          return body ? `${promptLabel(t, idx)}\n${body}` : '';
        }).filter(Boolean).join('\n\n---\n\n');
      }
      return '';
    }catch(_){ return ''; }
  }
  function buildText(scope){
    return (scope === 'all') ? textForAll() : textForSingle();
  }

  function setScope(scope){
    rPrompt.checked = (scope === 'prompt');
    rAll.checked    = (scope === 'all');
    const txt = buildText(scope);
    ta.value = txt;
    // soft URL length hint for ChatGPT
const built = window.buildChatURL(txt);
note.hidden = !built.tooLong;
if (built.tooLong){
  note.textContent = 'This prompt is very long. We’ll copy it and open ChatGPT so you can paste (Ctrl/Cmd+V).';
}

  }

  // --- launcher ---
  let modalAction = 'copy'; // 'copy' | 'ask'
  function openModal(kind, defaultScope){
    modalAction = kind;
    title.textContent = (kind === 'ask') ? '💬 Ask ChatGPT' : 'Copy Prompt';
    confirm.textContent = (kind === 'ask') ? 'Open in ChatGPT' : 'Copy';
    setScope(defaultScope || 'prompt');
      ta.value = ta.value || buildText(rAll.checked ? 'all' : 'prompt'); // fallback if anything races
    if (typeof dlg.showModal === 'function') dlg.showModal();
    setTimeout(()=> ta.focus(), 30);
  }

  // radio changes
  rPrompt.addEventListener('change', ()=> setScope('prompt'));
  rAll   .addEventListener('change', ()=> setScope('all'));

  // close/cancel
  function closeModal(){ try{ dlg.close(); }catch(_){ dlg.open=false; } }
  closeX.addEventListener('click', closeModal);
  cancelB.addEventListener('click', closeModal);
  dlg.addEventListener('cancel', (e)=>{ e.preventDefault(); closeModal(); });

  // confirm
form.addEventListener('submit', async (e)=>{
  e.preventDefault();
  const txt = ta.value || '';
  if (!txt.trim()) return;

  if (modalAction === 'copy'){
    try { await navigator.clipboard.writeText(txt); } catch(_){}
    showToast('Copied to clipboard.');
    closeModal();
    return;
  }

  // Ask ChatGPT
  let built;
  try { built = window.buildChatURL(txt); } catch(_) { built = { url:'https://chatgpt.com/?prompt='+encodeURIComponent(txt), tooLong:false, base:'https://chatgpt.com/' }; }

  if (built.tooLong){
    // URL would be too long; fallback: copy then open a clean chat for paste.
    try { await navigator.clipboard.writeText(txt); } catch(_){}
    showToast('Text copied. ChatGPT opened — paste (Ctrl/Cmd+V).', 2600);
    window.open(built.base, '_blank', 'noopener,noreferrer');
markPostLaunch(txt, built.base, true);

    closeModal();
    return;
  }

  window.open(built.url, '_blank', 'noopener,noreferrer');
markPostLaunch(txt, built.base, false);

  closeModal();
});


  // --- wire triggers in CAPTURE (kills prior handlers) ---
  function wire(id, kind, defaultScope){
    const el = document.getElementById(id);
    if (!el) return;
    // Only wire Copy here; Ask flows are handled by provider-aware wiring.
    if (kind !== 'copy') return;
    bindCapture(el, ()=> openModal(kind, defaultScope));
  }
  // Header (defaults to All)
  wire('copyBtn', 'copy', 'all');
  // Configure (defaults to Current)
  wire('copyBtn2', 'copy', 'prompt');
  // Footer duplicates if present (All)
  wire('copyAllBtnFooter', 'copy', 'all');

  // Inline chips (per-card) — give them class .js-inline-copy and data-idx (card index)
  document.addEventListener('click', function onChip(e){
    const btn = e.target.closest('.js-inline-copy');
    if (!btn) return;
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();

    const ix = Number(btn.getAttribute('data-idx'));
    const prev = window.state?.active;
    if (Number.isInteger(ix) && window.state?.tabs?.[ix]){
      window.state.active = ix;
      // Build once with that active index, then restore
      setScope('prompt');
      window.state.active = prev;
    } else {
      setScope('prompt');
    }
    openModal('copy', 'prompt');
  }, {capture:true}); // capture to preempt old handlers
})();


(function wirePostLaunchDialog(){
  const dlg   = document.getElementById('postLaunchDlg');
  if (!dlg) return;

  const $     = (sel)=> document.querySelector(sel);
  const ta    = $('#postLaunchText');
  const btnCp = $('#postLaunchCopy');
  const btnOp = $('#postLaunchOpenBase');
  const btnX  = $('#postLaunchClose');
  const form  = $('#postLaunchForm');
  let last    = null;

  function openDialog(data){
    last = data || last;
    if (!last) return;
    if (ta) ta.value = String(last.txt || '');
    try { dlg.showModal(); } catch(_){ dlg.open = true; }
    setTimeout(()=> btnCp?.focus(), 50);
  }

  function consumePending(){
    try{
      const raw = sessionStorage.getItem('pb.v1.postLaunch');
      if (!raw) return;
      const data = JSON.parse(raw);
      sessionStorage.removeItem('pb.v1.postLaunch');
      openDialog(data);
    }catch(_){}
  }

  // Show when user returns to this tab; also try once shortly after launch
  document.addEventListener('visibilitychange', ()=>{
    if (document.visibilityState === 'visible') consumePending();
  });
  setTimeout(consumePending, 900);

  btnCp?.addEventListener('click', async ()=>{
    try { await navigator.clipboard.writeText(ta?.value || ''); showToast('Copied to clipboard.'); } catch(_){}
  });
  btnOp?.addEventListener('click', ()=>{
    const href = (last && last.base) || 'https://chatgpt.com/';
    try { window.open(href, '_blank', 'noopener,noreferrer'); } catch(_){}
  });
  btnX?.addEventListener('click', ()=>{ try{ dlg.close(); }catch(_){ dlg.open=false; } });
  form?.addEventListener('cancel', (e)=>{ e.preventDefault(); try{ dlg.close(); }catch(_){ dlg.open=false; } });
})();


/* === Panel Show/Hide (mutually exclusive) =============================== */
(function wirePanelToggles(){
  const wrap = document.querySelector('.wrap');
  if (!wrap) return;

  // Buttons (guarded)
  const btnHideConfig   = document.getElementById('hideConfigBtn');
  const btnShowConfig   = document.getElementById('showConfigBtn');
  const btnHidePreview  = document.getElementById('hidePreviewBtn');
  const btnShowPreview  = document.getElementById('showPreviewBtn');

  const UI_KEY = 'pb.v1.ui';
  const readUI = ()=>{ try{ return JSON.parse(localStorage.getItem(UI_KEY)||'{}'); }catch(_){ return {}; } };
  const saveUI = (patch)=>{ try{
    const ui = readUI();
    localStorage.setItem(UI_KEY, JSON.stringify({ ...ui, ...patch }));
  }catch(_){} };

  const isPreviewHidden = ()=> wrap.classList.contains('preview-hidden');
  const isConfigHidden  = ()=> wrap.classList.contains('config-hidden');

  function enforceAtLeastOneVisible(){
    // Never allow both hidden. If both present, prefer preview hidden.
    if (isPreviewHidden() && isConfigHidden()){
      wrap.classList.remove('config-hidden');
    }
  }

  function syncButtons(){
    if (btnShowPreview) btnShowPreview.hidden = !isPreviewHidden();
    if (btnHidePreview) btnHidePreview.hidden =  isPreviewHidden();

    if (btnShowConfig)  btnShowConfig.hidden  = !isConfigHidden();
    if (btnHideConfig)  btnHideConfig.hidden  =  isConfigHidden();
  }

  function showPreview(){
    wrap.classList.remove('preview-hidden');
    saveUI({ previewHidden:false });
    enforceAtLeastOneVisible();
    syncButtons();
  }

  function hidePreview(){
    if (isConfigHidden()) wrap.classList.remove('config-hidden'); // can't hide both
    wrap.classList.add('preview-hidden');
    saveUI({ previewHidden:true, configHidden:false });
    enforceAtLeastOneVisible();
    syncButtons();
  }

  function showConfig(){
    wrap.classList.remove('config-hidden');
    saveUI({ configHidden:false });
    enforceAtLeastOneVisible();
    syncButtons();
  }

  function hideConfig(){
    if (isPreviewHidden()) wrap.classList.remove('preview-hidden'); // can't hide both
    wrap.classList.add('config-hidden');
    saveUI({ configHidden:true, previewHidden:false });
    enforceAtLeastOneVisible();
    syncButtons();
  }

  // Wire events (only if buttons exist)
  btnHideConfig  && btnHideConfig.addEventListener('click', hideConfig);
  btnShowConfig  && btnShowConfig.addEventListener('click', showConfig);
  btnHidePreview && btnHidePreview.addEventListener('click', hidePreview);
  btnShowPreview && btnShowPreview.addEventListener('click', showPreview);

  // --- Initial state on boot ---
// --- Initial state on boot (authoritative default) ---
(function init(){
  // Always start with: Preview hidden, Config shown
  wrap.classList.add('preview-hidden');
  wrap.classList.remove('config-hidden');

  // Persist this as the baseline so refreshes stay consistent
  saveUI({ previewHidden: true, configHidden: false });

  enforceAtLeastOneVisible();
  syncButtons();
})();
})();


  })();
  </script>
  
  
  <script>
/* === Print Worksheet — full wiring (works with or without Action Modal) === */
(function wireWorksheetButton(){
  function getKind(){
    try { return (typeof currentDataset === 'function')
      ? currentDataset()
      : (localStorage.getItem('fw_dataset') || 'patterns'); }
    catch(_) { return 'patterns'; }
  }
  function getActive(){
    try {
      if (typeof activeTab === 'function') return activeTab();
      const s = window.state;
      if (s && Array.isArray(s.tabs)) return s.tabs[s.active];
    } catch(_) {}
    return null;
  }
  function collectFromTab(t){
    const bag = { common:{}, fields:{} };
    // Per-tab common in your app: { ctx, audience, style, tone }
    try {
      const c = t?.common || {};
      if (c.ctx)       bag.common.usecase  = c.ctx;
      if (c.audience)  bag.common.audience = c.audience;
      if (c.style)     bag.common.style    = c.style;
      if (c.tone)      bag.common.tone     = c.tone;
    } catch(_){}
    try { Object.assign(bag.fields, t?.fields || {}); } catch(_){}
    // Bias chips from UI (optional)
    try{
      const chips = Array.from(document.querySelectorAll('#biasChips .chip'))
        .map(c => (c.textContent||'').trim()).filter(Boolean);
      if (chips.length) bag.common.biases = chips;
    }catch(_){}
    return bag;
  }
function openWorksheet(){
  const t  = getActive();
  const id = t?.id || document.getElementById('frameworkSel')?.value || '';
  if (!id || id === 'none'){ alert('Pick a template first.'); return; }

  const kind = getKind(); // 'patterns' | 'tasks'
  const key  = `pb.v1.xfer.${kind}.${id}`;

  // 1) Gather tab data
  const bag = collectFromTab(t);           // returns { common:{}, fields:{} }

  // 2) Reshape to what the worksheet expects
  const payload = { common: bag.common, values: bag.fields };

  // 3) Use localStorage so the new tab can see it
  try { localStorage.setItem(key, JSON.stringify(payload)); } catch(_) {}

  // 4) Open the worksheet with the transfer key
  const url = new URL('./prompt-worksheet.html', location.href);
  url.searchParams.set('kind', kind);
  url.searchParams.set('id',   id);
  url.searchParams.set('xfer', key);
  window.open(url.toString(), '_blank', 'noopener');
}


  // Event delegation so it works regardless of when the row is rendered
  document.addEventListener('click', function onClick(e){
    const btn = e.target.closest('#worksheetBtn2, #worksheetBtnHeader');
    if (!btn) return;
    e.preventDefault();
    e.stopPropagation();
    openWorksheet();
  }, { capture:true });
})();
</script>

  
  <!-- In your Prompt Builder page JS -->
<script>
  // Collect all field values from the current template form
  function collectTemplateValues(templateId, kind) {
    const values = {};

    // Example selectors. Prefer a consistent data-field="key" attribute.
    document.querySelectorAll('[data-field]').forEach(node => {
      const key = node.dataset.field || node.name || node.id;
      if (!key) return;

      if (node.type === 'checkbox') {
        // group checkboxes by key into an array of checked option values/labels
        const arr = values[key] || (values[key] = []);
        if (node.checked) arr.push(node.value || node.getAttribute('data-label') || node.labels?.[0]?.textContent || '✓');
      } else if (node.tagName === 'SELECT') {
        if (node.multiple) {
          values[key] = Array.from(node.selectedOptions).map(o => o.value || o.textContent.trim());
        } else {
          values[key] = node.value || node.selectedOptions[0]?.textContent.trim() || '';
        }
      } else {
        values[key] = node.value ?? '';
      }
    });

    return {
      id: templateId,
      kind: kind || 'patterns',  // or 'tasks' to match your dataset
      common: {
        // Optional meta that your worksheet page can surface
        title: document.querySelector('[data-template-title]')?.textContent?.trim() || '',
        usecase: document.querySelector('[data-usecase]')?.value?.trim() || ''
      },
      values
    };
  }

  // Call this from your “Print worksheet” click handler
  function openPrintableWorksheet(templateId, kind) {
    const payload = collectTemplateValues(templateId, kind);
    const xferKey = `xfer:${payload.kind}:${payload.id}:${Date.now()}`;
    localStorage.setItem(xferKey, JSON.stringify(payload));

    const url = `./prompt-worksheet.html?id=${encodeURIComponent(payload.id)}&kind=${encodeURIComponent(payload.kind)}&xfer=${encodeURIComponent(xferKey)}`;
    window.open(url, '_blank'); // new tab is fine, same-origin keeps sessionStorage accessible
  }

  // Example button hookup:
  document.getElementById('printWorksheetBtn')?.addEventListener('click', () => {
    const templateId = window.currentTemplateId; // however you track it
    openPrintableWorksheet(templateId, 'patterns'); // or 'tasks'
  });
</script>

<script>
// Preview/Config show–hide: bulletproof wiring
(function(){
  const wrap = document.querySelector('.wrap');
  if (!wrap) return;

  // Helpers
  const isPreviewHidden = ()=> wrap.classList.contains('preview-hidden');
  const isConfigHidden  = ()=> wrap.classList.contains('config-hidden');

  const btnHidePreview = document.getElementById('hidePreviewBtn');
  const btnShowPreview = document.getElementById('showPreviewBtn');
  const btnHideConfig  = document.getElementById('hideConfigBtn');
  const btnShowConfig  = document.getElementById('showConfigBtn');

  function syncButtons(){
    if (btnShowPreview) btnShowPreview.hidden = !isPreviewHidden();
    if (btnHidePreview) btnHidePreview.hidden =  isPreviewHidden();
    if (btnShowConfig)  btnShowConfig.hidden  = !isConfigHidden();
    if (btnHideConfig)  btnHideConfig.hidden  =  isConfigHidden();
  }

  function showPreview(){
    wrap.classList.remove('preview-hidden');
    syncButtons();
  }

  function hidePreview(){
    // never allow both hidden
    if (isConfigHidden()) wrap.classList.remove('config-hidden');
    wrap.classList.add('preview-hidden');
    syncButtons();
  }

  function showConfig(){
    wrap.classList.remove('config-hidden');
    syncButtons();
  }

  function hideConfig(){
    // never allow both hidden
    if (isPreviewHidden()) wrap.classList.remove('preview-hidden');
    wrap.classList.add('config-hidden');
    syncButtons();
  }

  // De-dupe any old inline handlers
  if (btnHidePreview) btnHidePreview.onclick = null;
  if (btnShowPreview) btnShowPreview.onclick = null;
  if (btnHideConfig)  btnHideConfig.onclick  = null;
  if (btnShowConfig)  btnShowConfig.onclick  = null;

  // Capture-phase listeners so nothing else can swallow the click
  document.addEventListener('click', function(e){
    const t = e.target.closest('#hidePreviewBtn');
    if (!t) return;
    e.preventDefault(); e.stopImmediatePropagation();
    hidePreview();
  }, true);

  document.addEventListener('click', function(e){
    const t = e.target.closest('#showPreviewBtn');
    if (!t) return;
    e.preventDefault(); e.stopImmediatePropagation();
    showPreview();
  }, true);

  document.addEventListener('click', function(e){
    const t = e.target.closest('#hideConfigBtn');
    if (!t) return;
    e.preventDefault(); e.stopImmediatePropagation();
    hideConfig();
  }, true);

  document.addEventListener('click', function(e){
    const t = e.target.closest('#showConfigBtn');
    if (!t) return;
    e.preventDefault(); e.stopImmediatePropagation();
    showConfig();
  }, true);

  // Normalize initial state (honors the class we just added)
  syncButtons();
})();
</script>

<script>
(function(){
  // ---- helpers you already have or can adapt ----
function activePromptText(scope = 'prompt'){
  try{
    // If asking for "all", prefer the deck text
    if (scope === 'all' && typeof getAllGeneratedText === 'function'){
      const all = getAllGeneratedText();
      if (all) return all;
    }
    // Build from the active tab via your real builder
    const t = (typeof activeTab === 'function') ? activeTab()
            : (window.state?.tabs?.[window.state?.active] || null);
    let text = (typeof makePromptForTab === 'function' && t) ? makePromptForTab(t) : '';
    // If picker tab, append framework digest for clarity
    if (t && t.id === 'none' && typeof buildFrameworkDigest === 'function'){
      const dig = buildFrameworkDigest();
      if (dig) text = [text, dig].filter(Boolean).join('\n\n');
    }
    // Fallback to the legacy preview node
    if (!text) {
      const out = document.getElementById('out');
      text = (out?.textContent || '').trim();
    }
    return String(text || '').trim();
  }catch(e){
    console.warn('activePromptText failed:', e);
    return '';
  }
}


function buildAskURL(provider, prompt){
  const txt = String(prompt || '');

  // Gemini
  if (provider === 'gemini'){
    const base = 'https://gemini.google.com/app'; // no stable ?prompt param
    let url = base;
    try { const u = new URL(base); u.searchParams.set('q', txt); url = u.toString(); } catch(_){}
    const tooLong = url.length > 7800;
    return { url, base: base + '/', tooLong };
  }

  // Apertus
  if (provider === 'apertus'){
    const ai = AISettings.get();
    const route = (ai && ai.apertusRoute) ? ai.apertusRoute : 'publicai';

    if (route === 'huggingface'){
      // Model card — cannot prefill; just open and rely on clipboard
      const base = 'https://huggingface.co/swiss-ai/Apertus-8B-Instruct-2509';
      return { url: base, base, tooLong: false };
    } else {
      // PublicAI chat — attempt a ?q= prefill; fall back to clipboard if too long
      const base = 'https://chat.publicai.co/';
      let url = base;
      try { const u = new URL(base); u.searchParams.set('q', txt); url = u.toString(); } catch(_){}
      const tooLong = url.length > 7800;
      return { url, base: base + '/', tooLong };
    }
  }

  // ChatGPT (OpenAI) — best-effort ?prompt=
  const base = 'https://chat.openai.com';
  let url = base + '/?prompt=' + encodeURIComponent(txt);
  const tooLong = url.length > 7800;
  return { url, base: base + '/', tooLong };
}

function setAskLabels(){
  const ai = AISettings.get();
  const labelMap = {
    openai:  '💬 Ask ChatGPT',
    gemini:  '💬 Ask Gemini',
    apertus: '💬 Ask Apertus'
  };
  const label = labelMap[ai.provider] || labelMap.openai;

  const targets = [
    document.getElementById('openBtn'),
    document.getElementById('openBtn2'),
    document.getElementById('openAllBtnFooter')
  ].filter(Boolean);

  targets.forEach(btn => {
    btn.textContent = label;
    btn.title = label;
    btn.setAttribute('aria-label', label);
  });

  document.querySelectorAll('.ask-btn').forEach(btn => {
    btn.textContent = label;
    btn.title = label;
    btn.setAttribute('aria-label', label);
  });
}



  // ---- provider-aware Action modal wiring ----
 function openAskModalWith(text, defaultScope = 'prompt'){
  const ai = AISettings.get();
  const dlg = document.getElementById('actionModal');
  const form = document.getElementById('actionForm');
  const title = document.getElementById('actionTitle');
  const previewWrap = dlg?.querySelector('.field');
  const preview = document.getElementById('actionPreview');
  const note = document.getElementById('actionNote');
  const confirm = document.getElementById('actionConfirm');
  const cancel = document.getElementById('actionCancel');
  const closeX = document.getElementById('actionClose');
  const rPrompt = document.getElementById('scopePrompt');
  const rAll    = document.getElementById('scopeAll');

  if (!dlg || !form || !title || !preview || !confirm) {
    return openDirect(text); // safety fallback
  }

const providerName =
  ai.provider === 'gemini'  ? 'Gemini'  :
  ai.provider === 'apertus' ? 'Apertus' :
  'ChatGPT';

  title.textContent = `💬 Ask ${providerName}`;
  confirm.textContent = `Open in ${providerName}`;
  if (previewWrap) previewWrap.style.display = '';

  // Seed by desired scope
  const scope = (defaultScope === 'all') ? 'all' : 'prompt';
  if (rPrompt) rPrompt.checked = (scope === 'prompt');
  if (rAll)    rAll.checked    = (scope === 'all');
  const seed = (typeof activePromptText === 'function') ? activePromptText(scope) : String(text || '');
  preview.value = seed;
  note.hidden = true;

  // Fresh confirm listener
  const newConfirm = confirm.cloneNode(true);
  confirm.parentNode.replaceChild(newConfirm, confirm);

  // Radio => live regenerate preview
  function regen(){
    const sc = (rAll && rAll.checked) ? 'all' : 'prompt';
    preview.value = (typeof activePromptText === 'function') ? activePromptText(sc) : preview.value;
  }
  if (rPrompt) { rPrompt.onchange = regen; rPrompt.onclick = regen; }
  if (rAll)    { rAll.onchange    = regen; rAll.onclick    = regen; }

  newConfirm.addEventListener('click', (e)=>{
    e.preventDefault();
    const finalTxt = (preview.value || '').trim();
    const built = buildAskURL(ai.provider, finalTxt);
    if (built.tooLong){
      try { navigator.clipboard.writeText(finalTxt); } catch {}
      openBaseAndNotify(built.base, providerName, true, finalTxt);
    } else {
      window.open(built.url, '_blank', 'noopener,noreferrer');
      openBaseAndNotify(built.base, providerName, false, finalTxt);
    }
    try { dlg.close(); } catch {}
  });

  cancel && cancel.addEventListener('click', ()=>{ try { dlg.close(); } catch {} }, {once:true});
  closeX && closeX.addEventListener('click', ()=>{ try { dlg.close(); } catch {} }, {once:true});
  try { dlg.showModal(); } catch { dlg.open = true; }
}


function openBaseAndNotify(base, providerName, copied, txt){
  const post    = document.getElementById('postLaunchDlg');
  const title   = document.getElementById('postLaunchTitle');
  const msg     = document.getElementById('postLaunchMsg');
  const note    = document.getElementById('postLaunchNote');
  const openBase= document.getElementById('postLaunchOpenBase');
  const ta      = document.getElementById('postLaunchText');
  const copyBtn = document.getElementById('postLaunchCopy');
  const closeX  = document.getElementById('postLaunchClose');
  const form    = document.getElementById('postLaunchForm');

  if (post && post.showModal){
    if (title) title.textContent = `Did the prompt appear in ${providerName}?`;
    if (msg)   msg.textContent = copied
      ? `Prompt copied. A ${providerName} tab opened. If it didn’t prefill, paste (Cmd/Ctrl+V).`
      : `A ${providerName} tab opened. If it didn’t prefill, paste with Cmd/Ctrl+V.`;
    if (note)  note.textContent = `Why this happens: very long URLs can be ignored, and ${providerName} can restore a cached draft.`;
    if (openBase) openBase.onclick = ()=> window.open(base, '_blank','noopener,noreferrer');

    if (ta) ta.value = String(txt || '');        // ← populate the textarea

    if (copyBtn) copyBtn.onclick = async ()=>{
      try { await navigator.clipboard.writeText(ta?.value || ''); showToast('Copied to clipboard.'); } catch {}
    };
    if (closeX)  closeX.onclick  = ()=> { try { post.close(); } catch {} };
    if (form)    form.addEventListener('cancel', (e)=>{ e.preventDefault(); try { post.close(); } catch {} });

    post.showModal();
    return;
  }
  try { showToast(`${providerName} opened. Paste your prompt if it didn’t prefill.`); } catch {}
}

  function openDirect(text){
    const ai = AISettings.get();
    const providerName = (
  ai.provider === 'gemini'  ? 'Gemini'  :
  ai.provider === 'apertus' ? 'Apertus' : 'ChatGPT'
);
const isHF = (ai.provider === 'apertus' && (ai.apertusRoute || 'publicai') === 'huggingface');
const msg = isHF
  ? `${providerName} page opened on Hugging Face. Prompt is on your clipboard; paste it where appropriate.`
  : `${providerName} opened. Paste your prompt if it didn’t prefill.`;
try { showToast(msg); } catch {}
    const built = buildAskURL(ai.provider, text);
    if (built.tooLong){
      try { navigator.clipboard.writeText(text); } catch {}
      window.open(built.base, '_blank', 'noopener,noreferrer');
    } else {
      window.open(built.url, '_blank', 'noopener,noreferrer');
    }
    try { showToast(`${providerName} opened. Paste your prompt if it didn’t prefill.`); } catch {}
  }

  // ---- wire header + ask buttons ----
  function wirePage(){
    // Header: Settings launcher
    const settingsBtn = document.getElementById('aiSettingsBtn');
    settingsBtn && settingsBtn.addEventListener('click', ()=> AISettings.open());

    // Secondary Ask (Template Fields): provider-aware modal open
// Secondary Ask (Template Fields): provider-aware modal open
const openBtn2  = document.getElementById('openBtn2');
const footerAsk = document.getElementById('openAllBtnFooter');

if (openBtn2){
  openBtn2.onclick = async ()=>{
    const txt = activePromptText('prompt');
    try { await navigator.clipboard.writeText(txt); } catch {}
    openAskModalWith(txt, 'prompt');
  };
}

if (footerAsk){
  footerAsk.onclick = async ()=>{
    const txt = activePromptText('all');
    try { await navigator.clipboard.writeText(txt); } catch {}
    openAskModalWith(txt, 'all');
  };
}



    // Initial label set + subscribe to changes
    setAskLabels();
    AISettings.onSaved(setAskLabels);
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', wirePage);
  } else wirePage();
})();
</script>



</body>
</html>
