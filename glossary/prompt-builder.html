<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prompt Template Builder (beta)</title>
  <style>
:root{
  --bg:#0b0f14; --panel:#121821; --card:#0f151d; --muted:#9db0c3; --text:#e7eff7;
  --accent:#4ea1ff; --chip:#1b2533; --border:#1b2838; --radius:14px; --gap:14px;
  --green:#2ecc71; --yellow:#f1c40f; --red:#e74c3c; --purple:#a78bfa;
  /* new */
  --border-strong:#2a3a4f; /* darker/lighter than --border for better separation in dark */
}
:root[data-theme="light"]{
  --bg:#f7fafc; --panel:#ffffff; --card:#ffffff; --muted:#5a6b7b; --text:#121621;
  --accent:#2563eb; --chip:#f1f5f9; --border:#d8e0ea;
  /* new: slightly stronger than light border for clear separation */
  --border-strong:#b9c6d6;
}

    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans",sans-serif}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}

    header{
      display:flex;align-items:center;gap:12px;padding:12px 16px;position:sticky;top:0;z-index:10;
      background:linear-gradient(180deg,var(--panel),rgba(0,0,0,0));border-bottom:1px solid var(--border);
      backdrop-filter: blur(8px);
    }
    header .spacer{flex:1}
    .btn{cursor:pointer;border:1px solid var(--border);background:var(--chip);color:var(--text);padding:8px 12px;border-radius:10px}
    .btn.primary{background:var(--accent);color:#061422;border:none}
    /* default (dark theme): keep dark text on light accent */
.btn.primary{ color:#061422; }

/* light theme: white text on darker accent for AA contrast */
:root[data-theme="light"] .btn.primary{ color:#ffffff; }

    .btn.sm{padding:6px 10px;font-size:14px;border-radius:8px}
   .toggle{
  display:inline-flex;align-items:center;gap:8px;
  border:1px solid var(--border);background:var(--chip);
  padding:6px 10px;border-radius:999px;
  color: var(--text); /* force readable text in both themes */
}
.toggle:hover, .toggle:focus-visible{
  box-shadow: 0 0 0 2px rgba(78,161,255,.25);
  outline: none;
}

    .dot{width:16px;height:16px;border-radius:50%;background:linear-gradient(180deg,#fdd835,#fbc02d);box-shadow:inset 0 -3px 6px rgba(0,0,0,.25)}
    :root[data-theme="light"] .dot{background:linear-gradient(180deg,#121621,#394554)}

    .wrap{
  display:grid;
  grid-template-columns: var(--leftW, 360px) 6px 1fr; /* left | resizer | right */
  gap:16px;
  padding:16px;
}

    .panel{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius)}
    .panel h2{margin:0;padding:12px 14px;border-bottom:1px solid var(--border);font-size:18px}
    .panel section{padding:14px}

    label{display:block;margin:10px 0 6px;color:var(--muted);font-size:16px; font-weight:600;}
    
.resizer{
  width:6px;
  cursor: col-resize;
  background: transparent;
  position: relative;
}
.resizer::after{
  content:'';
  position:absolute; inset:0;
  background: linear-gradient(to bottom, transparent 0, transparent 20%, var(--border) 20%, var(--border) 80%, transparent 80%, transparent 100%);
  opacity:.6;
}
.resizer:hover::after{ opacity:1; }

/* Clearer grab handle inside the 6px resizer */
.resizer::before{
  content:'';
  position:absolute;
  top:12px; bottom:12px;
  left:50%; transform:translateX(-50%);
  width:2px; border-radius:2px;
  background: rgba(255,255,255,.30);        /* dark mode default */
}
:root[data-theme="light"] .resizer::before{
  background: rgba(0,0,0,.28);              /* light mode default */
}
.resizer:hover::before,
.resizer:focus-visible::before{
  background: var(--accent);
  box-shadow: 0 0 0 2px rgba(78,161,255,.25);
}

.finder{ margin-bottom:8px; }
.finder input{ width:100%; }


.finder{ position:relative; margin-bottom:8px; }
.finder input{ width:100%; padding-right:64px; }
.finder .btn.tiny{
  position:absolute; right:6px; top:50%; transform:translateY(-50%);
  padding:4px 8px; font-size:12px; border-radius:999px;
}

/* Hint: shows "Showing N/M" when filtered */
.finder .hint{
  position:absolute;
  right:56px;              /* sits just to the left of the All button */
  top:50%; transform:translateY(-50%);
  font-size:12px;
  color:var(--muted);
  opacity:.9;
  pointer-events:none;     /* don't steal clicks from the input */
}




/* Not Using */
.useChips{ display:flex; flex-wrap:wrap; gap:8px; margin:6px 0 8px; }
.useChips .chip{ cursor:pointer; user-select:none; }
.useChips .chip.active{ outline:2px solid var(--accent); }

.suggestions{ display:flex; flex-wrap:wrap; gap:6px; margin:6px 0 12px; }
.suggestions .suggest{ cursor:pointer; padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:var(--chip); font-size:12px; }


/* Nice vertical rhythm between fields */
.field + .field{ margin-top:12px; }


/* Inline counters inside inputs/textareas */
.fieldHolder{ position:relative; }
.counter{
  position:absolute; right:10px; bottom:8px;
  font-size:11px; color:var(--muted); opacity:0.85;
  pointer-events:none; user-select:none;
}
.hasCounter{ padding-right:76px !important; }   /* prevent overlap with typing */
textarea.hasCounter{ padding-right:84px !important; } /* a tad more room for multi-line */


    input[type="text"], textarea, select{
      width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);
      background:var(--card);color:var(--text);outline:none;
    }
    
    input.filled, textarea.filled{
  box-shadow: 0 0 0 2px var(--accent) inset;
  background: rgba(78,161,255,.08);
}
:root[data-theme="light"] input.filled,
:root[data-theme="light"] textarea.filled{
  background: rgba(37,99,235,.06);
}

    textarea{min-height:100px;resize:vertical}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  
    .help{
  color:var(--muted);
  font-size:12px;          /* smaller than label (13px) */
  line-height:1.35;
  margin-top:6px;            /* space from input */
  opacity:0.9;               /* lighter than labels */
}

.desc{
  color:var(--muted);
  font-size:13px;       /* smaller than label */
  line-height:1.35;
  margin-top:6px;
  opacity:0.8;            /* a bit stronger than .help so it reads clearly */
}

/* Meta block under the Glossary button */
.metaSection{
  margin-top:10px;
  font-size:12px;
  color:var(--muted);
  font-weight:700;
  text-transform:uppercase;
  letter-spacing:.04em;
}

.metaGroup{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:8px;
  margin-top:6px;
}

.tinyLabel{
  font-size:11px;
  color:var(--muted);
  opacity:.85;
  padding:2px 8px;
  border:1px solid var(--border);
  border-radius:999px;
  background:var(--chip);
}

/* Dedicated meta box */
#metaChips{
  display:block !important;                 /* stop flex from .chips */
}
.metaBox{
  margin-top:12px;
  padding:12px;
  border:1px solid var(--border);
  border-radius: var(--radius);
  background: var(--card);
}
.metaRow{ margin-top:8px; }
.metaSectionTitle{
  margin-top:10px;
  font-size:12px;
  color:var(--muted);
  font-weight:700;
  text-transform:uppercase;
  letter-spacing:.04em;
}
.metaPills{
  display:flex; flex-wrap:wrap; gap:8px; margin-top:6px;
}
.metaLink{
  display:inline-flex; margin-bottom:4px;
}
.tinyLabel{
  font-size:11px; color:var(--muted); opacity:.85;
  padding:2px 8px; border:1px solid var(--border); border-radius:999px; background:var(--chip);
}

/* Tabs */
.tabs{ display:flex; gap:6px; margin:6px 0 10px; flex-wrap:wrap; }
.tab{
  display:inline-flex; align-items:center; gap:8px;
  padding:6px 10px; border:1px solid var(--border); border-radius:999px;
  background:var(--chip); cursor:pointer; font-size:12px;
}
.tab.active{ outline:2px solid var(--accent); }
.tab .x{
  border:none; background:transparent; cursor:pointer; font-size:14px; line-height:1;
  color:var(--muted);
}
.tab .x:hover{ color:var(--text); }

/* Output deck */
#outDeck{ display:flex; flex-direction:column; gap:12px; margin-top:12px; }
.outCard{
  border:1px solid var(--border); border-radius:var(--radius); background:var(--card);
  padding:10px 12px;
}
.outHead{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  margin-bottom:8px; font-size:13px; color:var(--muted);
  padding-right:10px; /* NEW: gives breathing room so Clear isn't flush right */
}

.outHead .title{ font-weight:600; color:var(--text); }
.outHead .actions{
  display:flex; gap:8px;
  margin-right:2px; /* NEW: tiny inset for safety on narrow widths */
}

.outHead .x{
  border:1px solid var(--border); background:var(--chip); border-radius:8px;
  padding:2px 8px; cursor:pointer;
}
.outBody{ white-space:pre-wrap; font-family:inherit; font-size:13px; line-height:1.45; }
.outActions{ margin-top:10px; }

/* Subtle flash to signal the panel changed */
.fields-swap {
  animation: fieldsSwapFlash 280ms ease-out;
}
@keyframes fieldsSwapFlash {
  0%   { box-shadow: 0 0 0 2px var(--accent) inset; background: rgba(78,161,255,.06); }
  100% { box-shadow: none; background: transparent; }
}

/* A small context chip above the fields */
#tabContext {
  margin-bottom: 8px;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 999px;
  background: var(--chip);
  font-size: 12px;
  color: var(--muted);
}


    .chips{display:flex;flex-wrap:wrap;gap:8px}
    .chip{background:var(--chip);border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:12px}

    pre{margin:0;padding:14px;background:var(--card);border-top:1px solid var(--border);border-radius:0 0 var(--radius) var(--radius);overflow:auto;white-space:pre-wrap}

    .pill{padding:4px 8px;border-radius:999px;border:1px solid var(--border);font-size:12px}
    .pill[data-val="framework"]{color:var(--green)}
    .pill[data-val="pattern"]{color:var(--yellow)}
    
   /* Additional instructions box spacing */
#extra{
  min-height: 72px;
  resize: vertical;
}
 
   /* --- Prompt totals under title --- */
.prompt-total{
  margin: -6px 0 8px 0;
  font-size:12px;
  color: var(--muted);
  opacity: 0.9;
}

/* --- Current preview inline counter (top-right of the big preview) --- */
/* We attach this inside the #out element */
#out{ position: relative; } /* harmless if already positioned elsewhere */
#out .outCounter{
  position:absolute;
  top:8px; right:8px;
  font-size:12px; color:var(--muted); opacity:0.9;
  pointer-events:none; user-select:none;
  background: transparent; /* stays invisible atop your preview */
}


/* ==== Context Coach (single, for current preview) ==== */
/* Sits inside #out, just below the top-right small counter */
#out .outCoach{
  position:absolute;
  right:8px; 
  top:30px; /* directly below .outCounter at top:8px */
  font-size:12px; 
  color:var(--muted); 
  opacity:0.95;
  pointer-events:none; 
  user-select:none;
}
#out .outCoach[hidden]{ display:none; }

/* Chip look with AA-safe colored left border */
#out .outCoach .pill{
  display:inline-flex; align-items:center;
  padding:2px 10px; border-radius:999px;
  background:var(--chip); border:1px solid var(--border);
  font-weight:700;
  /* color stays readable; accent via left border only */
}

/* State colors */
#out .outCoach[data-state="low"]     .pill{ border-left:4px solid var(--yellow); }
#out .outCoach[data-state="near"]    .pill{ border-left:4px solid var(--accent); }
#out .outCoach[data-state="good"]    .pill{ border-left:4px solid var(--green); }
#out .outCoach[data-state="perfect"] .pill{ border-left:4px solid var(--purple); }
#out .outCoach[data-state="high"]    .pill{ border-left:4px solid var(--red); }

/* Make room at the top of the preview when coach is visible */
#out.hasCoach{
  padding-top:52px;
  /* NEW: reserve horizontal space for the coach pill */
  padding-right: var(--coachPad, 160px) !important;
}



#out.hasCounter{
  padding-top:28px;
  /* NEW: reserve horizontal space for the corner counter */
  padding-right: var(--counterPad, 72px);
}
   
    /* Independent scroll for the left panel */
#configPanel{
  position: sticky;
  top: 60px; /* sits under the sticky header */
  max-height: calc(100vh - 60px - 16px); /* header + grid padding */
  overflow: auto; /* vertical & horizontal if needed */
}


/* Area labels to distinguish preview vs deck */
.areaLabel{
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 8px; margin:8px 0 6px;
  border:1px solid var(--border);
  background:var(--chip);
  border-radius:999px; font-size:12px; color:var(--muted);
}
.areaLabel .dot{ width:6px; height:6px; border-radius:999px; background:var(--accent); }

/* Stronger section separation (dark-friendly) */
#out{
  border:1px solid var(--border-strong);
  background:linear-gradient(180deg, rgba(78,161,255,.05), transparent 45%);
  border-radius: var(--radius);
}
.outCard{
  border-color: var(--border-strong);
}

/* High-contrast remove buttons (tabs + deck) */
.tab .x,
.outHead .x{
  color: var(--text);
  background: var(--chip);
  border: 1px solid var(--border-strong);
  border-radius: 999px;
  padding: 4px 10px;               /* room for “Clear” */
    line-height: 1;
  width: 22px; height: 22px;
  display: inline-flex; align-items: center; justify-content: center;
}
.tab .x:hover, .outHead .x:hover{
  box-shadow: 0 0 0 2px rgba(78,161,255,.25);
}
.tab .x:focus-visible, .outHead .x:focus-visible{
  outline:none;
  box-shadow: 0 0 0 2px rgba(78,161,255,.45);
}

/* === Typeahead (persona picker) === */
.taWrap{ position:relative; }
.taList{
  position:absolute; left:0; right:0; top:100%;
  margin-top:6px; z-index:50;
  background:var(--card); border:1px solid var(--border); border-radius:10px;
  max-height:220px; overflow:auto;
  box-shadow: 0 6px 18px rgba(0,0,0,.25);
}
.taList[hidden]{ display:none; }
.taItem{
  padding:8px 10px; cursor:pointer; border-bottom:1px solid var(--border);
  font-size:13px; display:flex; flex-direction:column; gap:2px;
}
.taItem:last-child{ border-bottom:none; }
.taItem .name{ color:var(--text); font-weight:600; }
.taItem .sub{ color:var(--muted); font-size:12px; }
.taItem.active{ outline:2px solid var(--accent); outline-offset:-2px; }


    @media (max-width: 960px){
      .wrap{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <header>
    <a class="btn sm" href="../glossary/index.html">← Back to Glossary</a>
    <strong>Prompt Framework Builder</strong>
    <span class="pill" data-val="framework" title="Frameworks & Patterns">frameworks + patterns</span>
    <span class="spacer"></span>
    <button id="copyBtn" class="btn sm">Copy all prompts</button>
    <button id="openBtn" class="btn primary sm">Open in ChatGPT</button>
    <button id="theme" class="toggle" aria-pressed="false" title="Toggle theme"><span class="dot"></span><span>Light</span></button>
  </header>

  <div class="wrap">
  <div class="panel" id="configPanel">
      <h2>Configure</h2>
      
      <div id="tabbar" class="tabs" hidden></div>
      
      <section>
        <label for="frameworkSel">Templates</label>
        
<div id="finderBar" class="finder">
  <input id="fwSearch" type="text" placeholder="Find a template by name, tag, or use case… (Ctrl/Cmd+K)">
  <span id="fwHint" class="hint" aria-live="polite" hidden></span>
  <button id="fwAll" type="button" class="btn tiny" title="Show full list">All</button>
</div>



        <select id="frameworkSel"></select>
        <div id="fwHelp" class="help" aria-live="polite"></div>
      </section>

      <section>
      
      <!-- Hidden until >1 template -->
<div id="tabbar" class="tabs" hidden></div>
        <h3 style="margin:0 0 6px;font-size:14px">Common context (optional)</h3>
        <div class="row">
          <div>
            <label for="usecase">Use‑case / scenario</label>
            <input id="usecase" type="text" placeholder="e.g., Launch email for a new service" />
          </div>
          <div>
            <label for="audience">Audience</label>
            <input id="audience" type="text" placeholder="e.g., Busy SMB owners" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="style">Style</label>
            <input id="style" type="text" placeholder="e.g., Practical, plain language" />
          </div>
          <div>
            <label for="tone">Tone</label>
            <input id="tone" type="text" placeholder="e.g., Friendly, confident" />
          </div>
        </div>
      </section>

      <section>
        <h3 style="margin:0 0 6px;font-size:14px">Template fields</h3>
        <div id="fields"></div>
        <div class="help"><br> Only fill what helps. Empty fields are omitted in the prompt.</div>
      </section>

      <section>
        <div class="chips" id="metaChips"></div>
      </section>
    </div>
<div id="resizer" class="resizer" role="separator" aria-orientation="vertical" aria-valuemin="280" aria-valuemax="900" tabindex="0"></div>
    <div class="panel">
      <h2>Generated prompt</h2>
      <div id="masterPromptTotal" class="prompt-total prompt-total--master" aria-live="polite"></div>

<div id="previewLabel" class="areaLabel"><span class="dot"></span><span>Preview • Active tab</span></div>
<pre id="out"></pre>

<div id="deckLabel" class="areaLabel" hidden><span class="dot"></span><span>Output deck • All templates</span></div>
<div id="outDeck" class="out-deck" hidden></div>

<!-- New: add-template button under the preview/deck -->
<div class="outActions" style="margin-top:8px">
  <button id="addPromptBtn" class="btn">+ Add template</button>
</div>

    </div>

    
  </div>

  <dialog id="msg"><form method="dialog" style="margin:0">
    <section id="msgText" style="padding:16px">
    
    Prompt copied to clipboard. A new tab opened; if it didn’t prefill, paste with Cmd/Ctrl+V.
    
    </section>
    
    
    <footer style="display:flex;justify-content:flex-end;gap:8px;padding:12px;border-top:1px solid var(--border)">
    
    <button class="btn" type="button" id="dlgClose">Close</button>

  </form></dialog>

  <!-- Load the glossary if available. Adjust the path to match your repo layout. -->
  <script>
    // If this file lives at /AI/tools/framework-template-builder.html,
    // the glossary may be at /AI/glossary/glossary.data.js. We try to load it dynamically.
    (function tryLoadGlossary(){
      const s = document.createElement('script');
      s.src = '../glossary/glossary.data.js';
      s.onerror = ()=>console.info('Glossary not found at ../glossary/glossary.data.js — continuing without it.');
      document.head.appendChild(s);
    })();
  </script>
  
  <script>
  // Personas DB (window.PERSONAS) — safe to load even if absent
  (function tryLoadPersonas(){
    const s = document.createElement('script');
    s.src = './persona.data.js';
    s.onerror = ()=>console.info('Persona data not found at ./persona.data.js — typeahead will still allow free text.');
    document.head.appendChild(s);
  })();
</script>


  <script>
  (function(){
    const $ = s=>document.querySelector(s);
    
    /* ===== Persona helpers ===== */
function personaIndex(){
  // Returns an array; empty if the data hasn't loaded yet.
  return Array.isArray(window.PERSONAS) ? window.PERSONAS : [];
}

function personaFilter(query, max=20){
  const q = (query||'').trim().toLowerCase();
  if (!q) return [];
  const toks = q.split(/\s+/).filter(Boolean);
  const src = personaIndex();

  // Score by token coverage + prefix boost on name/id
  const scored = src.map(p=>{
    const hay = (p.meta?.search_text || `${p.name||''} ${p.profession||''} ${(p.tags||[]).join(' ')}`).toLowerCase();
    let s = 0;
    for (const t of toks){
      if (hay.includes(t)) s += 2;
      if (String(p.name||'').toLowerCase().startsWith(t)) s += 4;
      if (String(p.id||'').toLowerCase().startsWith(t)) s += 3;
    }
    return {p, s};
  }).filter(x=>x.s>0)
    .sort((a,b)=> b.s - a.s || String(a.p.name).localeCompare(String(b.p.name)));

  return scored.slice(0,max).map(x=>x.p);
}

function applyPersonaToTab(tab, persona){
  if (!tab || !persona) return;
  // Do NOT touch 'end' (user-supplied goal)
  tab.fields = {
    ...(tab.fields||{}),
    persona_name: persona.name || '',
    profession:   persona.profession || '',
    summary:      persona.summary || '',
    description:  persona.description || '',
    core_tasks:   (persona.core_tasks||[]).join('\n'),
    skills:       (persona.skills||[]).join(', '),
    vocabulary:   (persona.vocabulary||[]).join(', '),
    goals:        (persona.goals||[]).join('\n'),
    pain_points:  (persona.pain_points||[]).join('\n'),
    tools:        (persona.tools||[]).join(', ')
  };
}

    
    
    // --- helper: default booster for a framework id
function defaultBooster(id){
  const fw = FRAMEWORKS.find(f => f.id === id);
  if (!fw) return '';
  const arr = Array.isArray(fw.boosters) ? fw.boosters : [];
  return arr.join(' ').trim();
}

    const out = $('#out');
    const fieldsWrap = $('#fields');
    const help = $('#fwHelp');
    const chips = $('#metaChips');
    



const FRAMEWORKS = [
  
    {
    id:'none',
    slug:'none',
    label:'— Select a template —',
    kind:'none',
    categories:['none'],
    tags:[
  'type:none'
],
use_cases: [
  'none'
],
boosters: [
  ""
],
    definition:'',
    help:'',
    fields:[
      {},
    
    ],
    template:({product,key_benefit,cta,constraints,ctx,audience,style,tone})=>[
      ``,
      ctx&&`Context: ${ctx}`,
      product&&`Offer: ${product}`,
      audience&&`Audience: ${audience}`,
      key_benefit&&`Key benefit/value: ${key_benefit}`,
      style&&`Style: ${style}`,
      tone&&`Tone: ${tone}`,
      constraints&&`Constraints: ${constraints}`,
      cta&&`End with this CTA: ${cta}`
    ].filter(Boolean).join('\n')
  },
  {
    id:'aida',
    slug:'aida-model',
    label:'AIDA — Attention · Interest · Desire · Action',
    kind:'framework',
    categories:['messaging frameworks','prompt development techniques'],
    tags:[
  'type:framework','topic:messaging','phase:apply','level:beginner',
  'use:ad-copy','use:landing-page','use:email-campaign','use:social-post'
],
use_cases: [
  'ad copy',
  'landing page messaging',
  'email campaign copy',
  'social post copy',
  'ad headlines & CTAs',
  'video script teaser',
  'push notification blurb'
],
boosters: [
  "Return 3 headline/CTA variants; rank them and state the top-1 reason in one short line."
],
    definition:'A classic four-stage persuasion model that moves an audience from attention to action.',
    help:'Classic marketing flow for persuasive outputs.',
    fields:[
      {key:'product',     label:'Product/offer',            type:'text',     desc:'What you are promoting.',           ph:'e.g., Email warmup tool'},
      {key:'key_benefit', label:'Key benefit',              type:'text',     desc:'Primary value to highlight.',      ph:'e.g., Better deliverability in 2 weeks'},
      {key:'cta',         label:'Primary call-to-action',   type:'text',     desc:'The action to take.',              ph:'e.g., Start free trial'},
      {key:'constraints', label:'Constraints',              type:'textarea', desc:'Rules/limits to follow.',          ph:'e.g., <=120 words; no jargon'}
    ],
    template:({product,key_benefit,cta,constraints,ctx,audience,style,tone})=>[
      `Use AIDA to craft a persuasive message.`,
      ctx&&`Context: ${ctx}`,
      product&&`Offer: ${product}`,
      audience&&`Audience: ${audience}`,
      key_benefit&&`Key benefit/value: ${key_benefit}`,
      style&&`Style: ${style}`,
      tone&&`Tone: ${tone}`,
      constraints&&`Constraints: ${constraints}`,
      cta&&`End with this CTA: ${cta}`
    ].filter(Boolean).join('\n')
  },
  {
    id:'clear',
    slug:'clear-framework',
    label:'CLEAR — Challenge · Limitation · Effect · Action · Result',
    kind:'framework',
    categories:['analysis frameworks','prompt development techniques'],
    tags:[
  'type:framework','topic:analysis','phase:apply','level:beginner',
  'use:problem-framing','use:retrospective','use:decision-record'
],
use_cases: [
  'problem framing',
  'decision record',
  'risk assessment',
  'root-cause write-up',
  'retrospective summary',
  'proposal justification',
  'change request rationale'
],
boosters: [
  "End with a one-paragraph “Decision record” that links Action→Effect→Result explicitly."
],
    definition:'A problem-framing flow that surfaces constraints and outcomes.',
    help:'Problem-framing flow to surface constraints and outcomes.',
    fields:[
      {key:'challenge',  label:'Challenge',  type:'textarea', desc:'Problem context.',      ph:'e.g., Low onboarding completion'},
      {key:'limitation', label:'Limitation', type:'textarea', desc:'Constraints/risks.',    ph:'e.g., No in-app messaging yet'},
      {key:'effect',     label:'Effect',     type:'textarea', desc:'Observed impact.',      ph:'e.g., High drop-off at step 2'},
      {key:'action',     label:'Action',     type:'textarea', desc:'Intervention/plan.',    ph:'e.g., Add email nudge + tooltip'},
      {key:'result',     label:'Result',     type:'textarea', desc:'Outcome/measure.',      ph:'e.g., Onboarding completion +15%'}
    ],
    template:({challenge,limitation,effect,action,result,ctx})=>[
      ctx&&`Context: ${ctx}`,
      `Use the CLEAR framing to structure the answer.`,
      challenge&&`Challenge: ${challenge}`,
      limitation&&`Limitation: ${limitation}`,
      effect&&`Effect: ${effect}`,
      action&&`Action: ${action}`,
      result&&`Result: ${result}`
    ].filter(Boolean).join('\n')
  },
  
  {
  id:'clear_path',
  slug:'clear-path-forward-framework',
  label:'CLEAR Path Forward — Concise · Logical · Explicit · Adaptive · Reflective',
  kind:'framework',
  categories:['prompt development techniques','prompt literacy'],
  tags:[
    'type:framework','topic:prompting','phase:apply','level:beginner',
    'use:prompt-optimization','use:prompt-iteration','use:clarifying-questions','use:next-step'
  ],
  use_cases: [
    'prompt optimization','clarifying prompts','next-step planning',
    'teaching prompt literacy','debugging failed prompts'
  ],
  definition:'An AI prompt literacy framework that shapes a next best prompt via concise goals, logical steps, explicit constraints, adaptive context, and reflective checks.',
  help:'Use to tighten a messy prompt and identify the next concrete step.',
  fields:[
    {key:'concise',   label:'Concise (goal in one line)',       type:'text',     desc:'Single-sentence objective.',         ph:'e.g., Summarize the paper for a lay audience'},
    {key:'logical',   label:'Logical (steps/structure)',        type:'textarea', desc:'Outline reasoning or steps.',         ph:'e.g., Read → Extract key claims → Simplify → Check terms'},
    {key:'explicit',  label:'Explicit (rules/format/defs)',     type:'textarea', desc:'Constraints, definitions, formats.',  ph:'e.g., 120–150 words; define “overfitting”; Markdown'},
    {key:'adaptive',  label:'Adaptive (audience/context)',      type:'textarea', desc:'Who/where this applies; edge cases.', ph:'e.g., For non-technical policy analysts; US context'},
    {key:'reflective',label:'Reflective (checks/criteria)',     type:'textarea', desc:'Quality checks or acceptance tests.', ph:'e.g., No jargon; 2 factual references; no policy claims'}
  ],
  boosters:[
    'Propose an improved next prompt (≤3 lines) and one concrete next action.'
  ],
  template:({concise,logical,explicit,adaptive,reflective,ctx})=>[
    `Apply the CLEAR Path Forward framework to optimize the prompt and next action.`,
    ctx&&`Context: ${ctx}`,
    concise&&`Concise goal: ${concise}`,
    logical&&`Logical plan: ${logical}`,
    explicit&&`Explicit constraints/format: ${explicit}`,
    adaptive&&`Adaptive context: ${adaptive}`,
    reflective&&`Reflective checks: ${reflective}`
  ].filter(Boolean).join('\n')
},

{
  id:'clear_pm',
  slug:'clear-prompting-method',
  label:'CLEAR Prompting Method — Clarity · Length · Empathy · Actionability · Relevance',
  kind:'framework',
  categories:['prompt development techniques'],
  tags:[
    'type:framework','topic:prompting','phase:apply','level:beginner',
    'use:prompt-hygiene','use:length-control','use:audience-empathy','use:scope-management'
  ],
  use_cases: [
    'prompt hygiene','length control','audience fit',
    'scope management','instruction cleanup'
  ],
  definition:'A prompting checklist to improve clarity, respect length, empathize with the reader, ensure actionability, and maintain relevance.',
  help:'Use to “clean up” instructions before sending to a model.',
  fields:[
    {key:'clarity',       label:'Clarity (must-include info)', type:'textarea', desc:'Remove ambiguity; define terms.',      ph:'e.g., Define “qualified lead”; include timeframe'},
    {key:'length',        label:'Length (limit)',               type:'text',     desc:'Word/token/section limits.',          ph:'e.g., ≤150 words'},
    {key:'empathy',       label:'Empathy (audience needs)',     type:'textarea', desc:'Reader persona/concerns.',            ph:'e.g., Busy execs; prefer bullet points'},
    {key:'actionability', label:'Actionability (doable steps)', type:'textarea', desc:'What the model should do/produce.',   ph:'e.g., Provide 3 options + 1 pick with rationale'},
    {key:'relevance',     label:'Relevance (in/out of scope)',  type:'textarea', desc:'Focus and exclusions.',               ph:'e.g., Focus on onboarding; exclude pricing'}
  ],
  boosters:[
    'Return an edited, tightened prompt honoring the length; list any removed ambiguity in one line.'
  ],
  template:({clarity,length,empathy,actionability,relevance,ctx})=>[
    `Apply the CLEAR Prompting Method to refine the instructions.`,
    ctx&&`Context: ${ctx}`,
    clarity&&`Clarity requirements: ${clarity}`,
    length&&`Length limit: ${length}`,
    empathy&&`Audience empathy: ${empathy}`,
    actionability&&`Actionability: ${actionability}`,
    relevance&&`Relevance (scope): ${relevance}`
  ].filter(Boolean).join('\n')
},

  
  {
    id:'costar',
    slug:'costar-framework',
    label:'COSTAR — Context · Objective · Style · Tone · Audience · Response',
    kind:'pattern',
    categories:['prompt development techniques','messaging frameworks'],
    tags:[
  'type:pattern','topic:prompting','phase:apply','level:beginner',
  'use:creative-brief','use:message-brief','use:content-brief'
],
use_cases: [
  'creative brief',
  'message brief',
  'content brief',
  'campaign brief',
  'UX copy brief',
  'press/news announcement brief'
],
boosters: [
  "Verify each COSTAR element is addressed; then output the final message under “Final response:”"
],
    definition:'A context-first messaging recipe encoding context, objective, style, tone, audience, and response format.',
    help:'Popular structure that bakes in style/tone and output format.',
    fields:[
      {key:'context',  label:'Context',  type:'textarea', desc:'Background, problem, scenario.',           ph:'e.g., Announcing a new feature to free users'},
      {key:'objective',label:'Objective',type:'text',     desc:'What the message must achieve.',           ph:'e.g., Drive upgrades to Pro'},
      {key:'style',    label:'Style (overrides common)', type:'text',  desc:'Writing style.',               ph:'e.g., Practical, plain language'},
      {key:'tone',     label:'Tone (overrides common)',  type:'text',  desc:'Emotional flavor.',            ph:'e.g., Friendly, confident'},
      {key:'audience', label:'Audience (overrides common)', type:'text', desc:'Who this is for.',           ph:'e.g., Busy SMB owners'},
      {key:'response', label:'Response format', type:'text', desc:'Desired output structure.',             ph:'e.g., Markdown outline with H2s'}
    ],
    template:({context,objective,style,tone,audience,response,ctx})=>[
      (ctx||context)&&`Context: ${ctx?ctx:context}`,
      objective&&`Objective: ${objective}`,
      (style)&&`Style: ${style}`,
      (tone)&&`Tone: ${tone}`,
      audience&&`Audience: ${audience}`,
      response&&`Response format: ${response}`,
      `Follow COSTAR. Ask clarifying Qs only if blocking.`
    ].filter(Boolean).join('\n')
  },
  
  {
  id:'few_shot',
  slug:'few-shot-examples',
  label:'Examples / Few-Shot Prompting',
  kind:'pattern',
  categories:['prompt development techniques','prompt literacy'],
  tags:[
    'type:pattern','topic:examples','topic:few-shot','phase:apply','level:beginner',
    'use:format-guidance','use:style-transfer','use:output-shaping'
  ],
  use_cases:[
    'show ideal output format with 1+ shots',
    'demonstrate style/voice to imitate',
    'constrain outputs to examples'
  ],
  definition:'Guide the model by supplying one or more example outputs (“shots”) to anchor format and tone.',
  help:'Add a main brief/goal, then list examples (one per line). The model mirrors structure/style from the shots.',
  boosters:[
    'Begin with a short description of the desired format before listing examples.',
    'Number the examples and refer back to them explicitly.',
    'Prefer short, high-signal examples over long rambles.'
  ],
  fields:[
    { key:'main',     label:'Main brief / goal',     type:'textarea',
      desc:'What you want, in plain language.',
      ph:'e.g., Generate a product description in the style below.' },
    { key:'examples', label:'Examples / shots (one per line)', type:'textarea',
      desc:'Provide one example per line (short is fine).',
      ph:'Example 1…\nExample 2…\nExample 3…' },
    { key:'dos',      label:"Do's (must do)",        type:'textarea',
      desc:'Positive constraints the output must follow.',
      ph:'Use the given headings; keep under 200 words; cite the example number used.' },
    { key:'donts',    label:"Don'ts / constraints",  type:'textarea',
      desc:'Things to avoid or hard limits.',
      ph:"Don't invent facts; avoid slang; no emojis." }
  ],
  template: ({ main, examples, dos, donts, ctx, audience, style, tone }) => [
    'Use few-shot prompting. Mirror the structure/style demonstrated by the examples.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    main && `Goal: ${main}`,
    examples && (
      'Examples:\n' + String(examples)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((ex,i)=> `${i+1}. ${ex}`)
        .join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don't:\n${donts}`,
    'First restate the intended format in one line, then produce the output consistent with the examples.'
  ].filter(Boolean).join('\n')
},

{
  id:'goal_breakdown',
  slug:'goal-breakdown-decomposition',
  label:'Goal Breakdown (Prompt/Question Decomposition)',
  kind:'pattern',
  categories:['planning','prompt development techniques'],
  tags:[
    'type:pattern','topic:decomposition','topic:questions','phase:plan','level:beginner',
    'use:breakdown','use:micro-tasks','use:research-questions'
  ],
  use_cases:[
    'break a complex goal into micro-tasks',
    'turn a vague prompt into concrete sub-questions',
    'plan-first before execution'
  ],
  definition:'Break a complex goal/prompt into smaller, verifiable sub-tasks and sub-questions before doing the work.',
  help:'Enter a complex goal or prompt. The model will decompose it into a deep, numbered hierarchy and propose a minimal execution plan.',
  boosters:[
    'Show a numbered hierarchy (1, 1.1, 1.1.1…) before any deliverable.',
    'Flag assumptions and unknowns as explicit sub-questions.',
    'Suggest the smallest next action at the end.'
  ],
  fields:[
    { key:'main',  label:'Goal / complex task', type:'textarea',
      desc:'The overarching task or question to decompose.',
      ph:'e.g., Build a go-to-market plan for a B2B SaaS in 6 weeks.' },
    { key:'dos',   label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Use numbered hierarchy; identify dependencies.' },
    { key:'donts', label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No speculative claims; ≤500 words in plan.' }
  ],
  template: ({ main, dos, donts, ctx, audience, style, tone }) => [
    'Perform prompt/question decomposition for the goal into micro-tasks and sub-questions.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    main && `Goal/complex task: ${main}`,
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output format:\n1) Decomposition (numbered hierarchy)\n2) Minimal execution plan\n3) Assumptions & unknowns\n4) Next action'
  ].filter(Boolean).join('\n')
},

{
  id:'goal_composition',
  slug:'goal-composition',
  label:'Goal Composition (Prompt/Question Composition)',
  kind:'pattern',
  categories:['planning','prompt development techniques'],
  tags:[
    'type:pattern','topic:composition','topic:goals','phase:plan','level:beginner',
    'use:synthesis','use:roadmap','use:prioritization'
  ],
  use_cases:[
    'compose a broader goal from many sub-prompts/actions',
    'derive an objective and plan from granular tasks',
    'summarize scattered asks into one coherent brief'
  ],
  definition:'Synthesize a broader objective from a list of sub-prompts/actions, then propose a coherent plan.',
  help:'List sub-prompts/actions one per line. Optionally add an intended direction for the composed goal.',
  boosters:[
    'Cluster similar actions before composing.',
    'State explicit success criteria for the composed goal.',
    'End with one “north-star” metric.'
  ],
  fields:[
    { key:'direction', label:'Intended direction (optional)', type:'textarea',
      desc:'Theme or constraints to guide composition.',
      ph:'e.g., Emphasize ROI and low lift.' },
    { key:'actions',   label:'Sub-prompts / actions (one per line)', type:'textarea',
      desc:'Granular items to synthesize into a broader goal.',
      ph:'Draft FAQ page…\nInterview 5 users…\nDefine ICP…' },
    { key:'dos',       label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Quantify effort; produce a one-paragraph composed goal.' },
    { key:'donts',     label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No jargon; ≤300 words total.' }
  ],
  template: ({ direction, actions, dos, donts, ctx, audience, style, tone }) => [
    'Compose a broader goal from specific sub-prompts/actions, then produce a concise plan.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    direction && `Intended direction: ${direction}`,
    actions && (
      'Inputs (actions):\n' + String(actions)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((a,i)=> `${i+1}. ${a}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output:\n1) Composed goal (1 paragraph)\n2) 3–5 key objectives\n3) High-level plan by objective\n4) Single next action'
  ].filter(Boolean).join('\n')
},


{
  id:'goal_prompting',
  slug:'goal-prompting',
  label:'Goal Prompting',
  kind:'pattern',
  categories:['planning','prompt development techniques'],
  tags:[
    'type:pattern','topic:goals','phase:plan','level:beginner',
    'use:brainstorm','use:roadmap','use:prioritize'
  ],
  use_cases:[
    'state a primary goal and supporting goals',
    'ask the model to prioritize or plan',
    'structure outputs around explicit objectives'
  ],
  definition:'Center the request on a primary goal, with optional supporting goals listed separately.',
  help:'Write the main brief/goal, then list additional goals one per line, plus do/don’t guardrails.',
  boosters:[
    'Ask for a numbered plan tied to each goal.',
    'Request a brief risk or dependency note per goal.',
    'End with a next-action recommendation.'
  ],
  fields:[
    { key:'main',   label:'Primary goal (brief)', type:'textarea',
      desc:'One clear objective in your own words.',
      ph:'e.g., Launch a newsletter in 4 weeks.' },
    { key:'goals',  label:'Additional goals (one per line)', type:'textarea',
      desc:'List zero or more supporting goals.',
      ph:'Audience growth to 1k…\n≥40% open rate…\nMonetize by week 8…' },
    { key:'dos',    label:"Do's (must do)", type:'textarea',
      desc:'Positive constraints.',
      ph:'Quantify time/effort; provide a week-by-week outline.' },
    { key:'donts',  label:"Don'ts / constraints", type:'textarea',
      desc:'Limits or exclusions.',
      ph:"Don't exceed 700 words; avoid paid tools." }
  ],
  template: ({ main, goals, dos, donts, ctx, audience, style, tone }) => [
    'Focus on explicit objectives and produce a concise, actionable plan.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    main && `Primary goal: ${main}`,
    goals && (
      'Additional goals:\n' + String(goals)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((g,i)=> `${i+1}. ${g}`)
        .join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don't:\n${donts}`,
    'Provide a short plan tied to each goal, then a single next action.'
  ].filter(Boolean).join('\n')
},

  
  {
    id:'golden',
    slug:'golden-circle-framework',
    label:'Golden Circle — Why · How · What',
    kind:'framework',
    categories:['messaging frameworks','prompt development techniques'],
    tags:[
  'type:framework','topic:messaging','phase:overview','level:beginner',
  'use:brand-messaging','use:mission-vision','use:pitch-deck'
],
use_cases: [
  'brand messaging',
  'mission/vision alignment',
  'about page narrative',
  'investor pitch framing',
  'employer brand messaging',
  'product purpose statement'
],
boosters: [
  "Lead with “Why”; keep each section 2–3 sentences; end with a one-line “Because…” summary."
],
    definition:'A purpose-first communication model that moves from belief (why) to methods (how) to concrete offerings (what).',
    help:'Purpose-first messaging scaffold.',
    fields:[
      {key:'why', label:'Why (purpose/belief)',         type:'textarea', desc:'Belief/purpose.',     ph:'e.g., Everyone deserves privacy by default'},
      {key:'how', label:'How (principles/approach)',    type:'textarea', desc:'Methods/approach.',   ph:'e.g., Strong encryption; zero-knowledge design'},
      {key:'what',label:'What (products/services/actions)', type:'textarea', desc:'Offerings/actions.', ph:'e.g., Encrypted email; secure file share'}
    ],
    template:({why,how,what,ctx})=>[
      ctx&&`Context: ${ctx}`,
      `Craft a message using the Golden Circle.`,
      why&&`Why: ${why}`,
      how&&`How: ${how}`,
      what&&`What: ${what}`
    ].filter(Boolean).join('\n')
  },
  
  {
  id:'hmw_statements',
  slug:'how-might-we-statements-hmw',
  label:'How Might We Statements (HMW)',
  kind:'pattern',
  categories:['design thinking','ideation'],
  tags:[
    'type:pattern','topic:problem-framing','topic:ideation','phase:explore','level:beginner',
    'use:brainstorm','use:problem-statement','use:workshop'
  ],
  use_cases:[
    'frame challenges as opportunities', 
    'product design', 'ux', 'problem solving',
    'generate multiple solution directions',
    'align teams around a crisp, positive prompt'
  ],
  definition:'A guiding question that reframes a need into an opportunity: “How might we [action] for [who] so that [outcome]?”',
  help:'Provide a concise need/challenge, who is affected, and the positive outcome you want.',
  boosters:[
    'Offer 3–5 phrasing variants that change the verb or scope.',
    'Keep each statement ≤20 words.',
    'Avoid embedded solutions—stay problem-oriented.'
  ],
  fields:[
    { key:'need',   label:'Need / challenge',        type:'textarea',
      desc:'What problem or opportunity are we framing?',
      ph:'Low onboarding completion for new users…' },
    { key:'action', label:'Action to explore',       type:'text',
      desc:'Open-ended action (no baked-in solution).',
      ph:'improve onboarding clarity' },
    { key:'who',    label:'Who is affected?',        type:'text',
      desc:'Audience or segment.',
      ph:'new SaaS signups' },
    { key:'outcome',label:'Positive outcome',        type:'text',
      desc:'Intended impact.',
      ph:'reach value in the first session' },
    { key:'dos',    label:"Do's (must do)",          type:'textarea',
      desc:'Positive guardrails.',
      ph:'Make variants; keep neutral tone.' },
    { key:'donts',  label:"Don\'ts / constraints",   type:'textarea',
      desc:'Limits to respect.',
      ph:'No solutioning; avoid jargon.' }
  ],
  template: ({ need, action, who, outcome, dos, donts, ctx, audience, style, tone }) => [
    'Create a clear, positive How-Might-We statement and a few concise variants.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    need && `Need/challenge: ${need}`,
    (action || who || outcome) && `HMW: How might we ${action||'[action]'} for ${who||'[who]'} so that ${outcome||'[outcome]'}?`,
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Provide 3–5 short variant phrasings with different verbs/scope.'
  ].filter(Boolean).join('\n')
},

  
  {
  id:'kwy_vector',
  slug:'keywords-why-tasks-vector',
  label:'Keywords + Why + Tasks — Vector Priming',
  kind:'pattern',
  categories:['prompt development techniques','planning'],
  tags:[
    'type:pattern','topic:keywords','topic:why','topic:tasking','phase:plan','level:intermediate',
    'use:vector-priming','use:context-packing','use:negative-avoidance'
  ],
  use_cases:[
    'prime the model with topical vectors via keywords',
    'explain situational “why” for better alignment',
    'list actionable tasks and explicit negatives to avoid'
  ],
  definition:'Prime with keywords (vector hinting) and a clear “why,” list tasks, and name what to avoid.',
  help:'Fill the goal, why/context, comma-separated keywords, and tasks (one per line). Add avoid/constraints as needed.',
  boosters:[
    'Normalize keywords to canonical forms (singulars, lowercase) before using them.',
    'Tie each task to at least one keyword.',
    'Call out conflicts between “why” and constraints in one line.'
  ],
  fields:[
    { key:'goal',     label:'Goal / request', type:'textarea',
      desc:'The core ask in plain language.',
      ph:'e.g., Draft a press release for our seed round.' },
    { key:'why',      label:'Why / context', type:'textarea',
      desc:'Situation, constraints, or motivation that explains the request.',
      ph:'Positioning shift, investor expectations, embargo timing…' },
    { key:'keywords', label:'Keywords (comma-separated)', type:'text',
      desc:'Topical terms to prime the model’s “vector space.”',
      ph:'fintech, compliance, SOC2, runway, ARR, seed, product-market-fit' },
    { key:'tasks',    label:'Tasks (one per line)', type:'textarea',
      desc:'Concrete actions the model should take.',
      ph:'Draft headline…\nWrite summary paragraph…\nAdd 3 quotes…' },
    { key:'avoid',    label:'Avoid (comma-separated negatives)', type:'text',
      desc:'Phrases, angles, or topics to avoid.',
      ph:'hype, unverified metrics, jargon, inside jokes' },
    { key:'dos',      label:"Do's (must do)", type:'textarea',
      desc:'Positive constraints.',
      ph:'Cite sources; 150–250 words; AP style.' },
    { key:'donts',    label:"Don'ts / constraints", type:'textarea',
      desc:'Hard limits beyond “Avoid.”',
      ph:"Don't mention confidential partners; no sensitive data." }
  ],
  template: ({ goal, why, keywords, tasks, avoid, dos, donts, ctx, audience, style, tone }) => [
    'Use vector priming (keywords) plus explicit why/context and actionable tasks.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    goal && `Goal: ${goal}`,
    why && `Why/context: ${why}`,
    keywords && ('Keywords: ' + String(keywords).split(',').map(s=>s.trim()).filter(Boolean).join(', ')),
    tasks && (
      'Tasks:\n' + String(tasks)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((t,i)=> `${i+1}. ${t}`)
        .join('\n')
    ),
    avoid && ('Avoid: ' + String(avoid).split(',').map(s=>s.trim()).filter(Boolean).join(', ')),
    dos && `Do:\n${dos}`,
    donts && `Don't:\n${donts}`,
    'Execute the tasks, honoring keywords and avoid lists; if conflicts appear, state them briefly before proceeding.'
  ].filter(Boolean).join('\n')
},

{
  id:'least_to_most',
  slug:'least-to-most-ltm',
  label:'Least to Most (LtM)',
  kind:'pattern',
  categories:['reasoning','planning'],
  tags:[
    'type:pattern','topic:progressive-complexity','topic:reasoning','phase:solve','level:intermediate',
    'use:scaffolding','use:math','use:algorithms','use:teaching'
  ],
  use_cases:[
    'tackle problems by escalating from simple to complex',
    'derive a general method from trivial and small cases',
    'surface edge cases after building intuition'
  ],
  definition:'Solve by starting with the simplest instances, generalizing patterns, and stepping up complexity until the full problem is solved.',
  help:'Enter the problem, optionally outline a “complexity ladder” (one per line) from simplest to hardest, and add guardrails.',
  boosters:[
    'Keep each rung to one or two sentences.',
    'State the rule learned at each rung before moving up.',
    'End with a single, general solution and a quick edge-case check.'
  ],
  fields:[
    { key:'problem', label:'Problem / goal', type:'textarea',
      desc:'What should be solved or decided?',
      ph:'e.g., Explain and implement a function to validate parentheses.' },
    { key:'ladder',  label:'Complexity ladder (one per line, optional)', type:'textarea',
      desc:'From simplest to most complex cases.',
      ph:'Trivial case…\nSmall inputs…\nGeneral case…\nEdge cases…' },
    { key:'dos',     label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Show the rule discovered at each rung; keep total under 300 words.' },
    { key:'donts',   label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No lengthy proofs; avoid unexplained jumps.' }
  ],
  template: ({ problem, ladder, dos, donts, ctx, audience, style, tone }) => [
    'Use Least-to-Most reasoning: start with simple instances, extract a rule, scale up, then solve the full problem.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    problem && `Problem: ${problem}`,
    ladder && (
      'Complexity ladder:\n' + String(ladder)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((r,i)=> `${i+1}. ${r}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output format:\n1) Rungs (least→most) with the rule learned at each\n2) General solution\n3) Quick edge-case check'
  ].filter(Boolean).join('\n')
},


  {
    id:'par',
    slug:'par-method',
    label:'PAR — Problem · Action · Result',
    kind:'framework',
    categories:['storytelling frameworks','prompt development techniques'],
    tags:[
  'type:framework','topic:storytelling','phase:apply','level:beginner',
  'use:resume-bullet','use:case-study','use:status-update'
],
use_cases: [
  'resume bullet',
  'performance review note',
  'status update',
  'case study snapshot',
  'incident summary',
  'customer story outline'
],
boosters: [
  "Quantify results where possible (%, Δ, time); if no metrics given, propose proxy metrics."
],
    definition:'A compressed alternative to STAR that focuses on the core: problem, action, and result.',
    help:'Concise alternative to STAR.',
    fields:[
      {key:'problem', label:'Problem', type:'textarea', desc:'The obstacle or issue.', ph:'e.g., High churn after trial'},
      {key:'action',  label:'Action',  type:'textarea', desc:'What you did.',         ph:'e.g., Onboarding emails + in-app tips'},
      {key:'result',  label:'Result',  type:'textarea', desc:'Outcome/impact.',       ph:'e.g., Churn reduced from 14%→8%'}
    ],
    template:({problem,action,result,ctx})=>[
      ctx&&`Context: ${ctx}`,
      problem&&`Problem: ${problem}`,
      action&&`Action: ${action}`,
      result&&`Result: ${result}`,
      `Format the response as short bullets.`
    ].filter(Boolean).join('\n')
  },

  
  {
  id:'peas',
  slug:'peas-framework',
  label:'PEAS — Performance measure · Environment · Actuators · Sensors',
  kind:'framework',
  categories:['AI systems design','analysis frameworks'],
  tags:[
    'type:framework','topic:ai-systems','phase:design','level:intermediate',
    'use:agent-spec','use:task-modeling','use:benchmarking','use:requirements-doc'
  ],
  use_cases: [
    'agent specification','requirements doc','benchmark design',
    'task environment mapping','simulation setup'
  ],
  definition:'A canonical way to specify intelligent agents by defining success metrics, the environment, possible actions, and percepts.',
  help:'Use to design/evaluate agents or tools before building.',
  fields:[
    {key:'performance', label:'Performance measure', type:'textarea', desc:'Metrics, goals, constraints.',  ph:'e.g., Success@K, latency < 500ms, ≤2% hallucination rate'},
    {key:'environment', label:'Environment',        type:'textarea', desc:'World, resources, interfaces.', ph:'e.g., Web browser + internal docs + API with rate-limits'},
    {key:'actuators',   label:'Actuators',          type:'textarea', desc:'Actions the agent can take.',   ph:'e.g., Click, type, call API, write file'},
    {key:'sensors',     label:'Sensors',            type:'textarea', desc:'Observations/inputs.',          ph:'e.g., DOM snapshot, API responses, tool outputs'},
    {key:'assumptions', label:'Assumptions (opt.)', type:'textarea', desc:'Assumptions/risks/trust model.',ph:'e.g., Auth tokens valid; pages stable; tool outputs reliable'}
  ],
  boosters:[
    'Summarize as a PEAS tuple and include two evaluation scenarios with success/failure traces.'
  ],
  template:({performance,environment,actuators,sensors,assumptions,ctx})=>[
    `Define the agent using the PEAS framework.`,
    ctx&&`Context: ${ctx}`,
    performance&&`Performance measure: ${performance}`,
    environment&&`Environment: ${environment}`,
    actuators&&`Actuators: ${actuators}`,
    sensors&&`Sensors: ${sensors}`,
    assumptions&&`Assumptions/risks: ${assumptions}`
  ].filter(Boolean).join('\n')
},

{
  id:'persona',
  slug:'persona-actas',
  label:'Persona — ActAs / Simulate',
  kind:'pattern',
  categories:['prompt development techniques','persona prompting'],
  tags:[
    'type:pattern','topic:persona','phase:apply','level:beginner',
    'use:act-as','use:simulation','use:roleplay','use:agent-spec'
  ],
  boosters:[
    "Stay in-character. Prefer precise, domain-correct terminology. Cite trade-offs briefly before final answer."
  ],
  definition:'Simulate a specific persona (role) with domain skills, vocabulary, and constraints; then apply it to the user’s end goal.',
  help:'Type to search a persona. Picking one autofills the rest; or type your own persona free-form.',
  fields:[
    { key:'end',           label:'End goal / Task to Complete', type:'text',     ph:'e.g., Draft a 5-step onboarding plan' },

    // The special typeahead field (wired in renderFields)
    { key:'persona_name',  label:'Persona (who the AI will be)', type:'typeahead', ph:'e.g., UX designer, Data scientist, PM' },

    // Autofilled when a suggestion is chosen (editable)
    { key:'profession',    label:'Profession',   type:'text',     ph:'e.g., Designer' },
    { key:'summary',       label:'Summary',      type:'textarea', ph:'1–2 lines that define this persona' },
    { key:'description',   label:'Additional Description (optional)', type:'textarea', ph:'Longer narrative if available' },
    { key:'core_tasks',    label:'Core tasks (one per line)', type:'textarea', ph:'Plan tests\nWireframe flows\nSynthesize insights' },
    { key:'skills',        label:'Skills (comma or one per line)', type:'textarea', ph:'Wireframing, Prototyping, IA' },
    { key:'vocabulary',    label:'Vocabulary (comma or one per line)', type:'textarea', ph:'affordance, heuristic, persona' },
    { key:'goals',         label:'Goals (one per line)', type:'textarea', ph:'Improve task success\nReduce friction' },
    { key:'pain_points',   label:'Pain points (one per line)', type:'textarea', ph:'Stakeholder misalignment\nLegacy systems' },
    { key:'tools',         label:'Tools (comma or one per line)', type:'textarea', ph:'Figma, Lookback, Maze' }
  ],
  template:({ end, persona_name, profession, summary, description, core_tasks, skills, vocabulary, goals, pain_points, tools, ctx })=>{
    const asList = s => String(s||'').split(/[\n,]+/).map(v=>v.trim()).filter(Boolean);
    const asCSV  = s => asList(s).join(', ');
    const asBul  = s => asList(s).map(x=>'• ' + x).join('\n');

    return [
      ctx && `Context: ${ctx}`,
      (persona_name || profession) && `You are ${persona_name || 'the requested persona'}${profession ? `, a ${profession}` : ''}.`,
      summary && `Persona Summary: ${summary}`,
      description && `Persona Description: ${description}`,
      core_tasks && `You commonly do:\n${asBul(core_tasks)}`,
      skills && `Core skills: ${asCSV(skills)}`,
      vocabulary && `Vocabulary keywords: ${asCSV(vocabulary)}`,
      goals && `Common goals:\n${asBul(goals)}`,
      pain_points && `Common pain points:\n${asBul(pain_points)}`,
      tools && `Tools: ${asCSV(tools)}`,
      end && `\nUnderstanding your persona, complete this end goal objective: ${end}`
    ].filter(Boolean).join('\n');
  }
},

{
  id:'plan_solve',
  slug:'plan-and-solve-ps',
  label:'Plan and Solve (P&S)',
  kind:'pattern',
  categories:['reasoning','planning'],
  tags:[
    'type:pattern','topic:plan-first','topic:execution','topic:verification','phase:solve','level:intermediate',
    'use:math','use:coding','use:ops-procedures'
  ],
  use_cases:[
    'create a short plan before executing a solution',
    'separate planning from working to reduce errors',
    'verify results against explicit checks'
  ],
  definition:'Draft a minimal plan, execute it, and verify the result against stated checks.',
  help:'Enter the problem. Optionally provide a plan (one per line) and verification checks (one per line). The model will plan → solve → verify.',
  boosters:[
    'Keep the plan to 2–5 concise steps.',
    'Separate planning text from solution text.',
    'Verify against explicit checks; note any discrepancies.'
  ],
  fields:[
    { key:'problem', label:'Problem / question', type:'textarea',
      desc:'What needs to be solved?',
      ph:'e.g., Given an array, return indices of two numbers that add up to target.' },
    { key:'plan',    label:'Plan (one per line, optional)', type:'textarea',
      desc:'High-level steps before solving.',
      ph:'Understand inputs…\nOutline approach…\nExecute steps…\nValidate…' },
    { key:'checks',  label:'Verification checks (one per line, optional)', type:'textarea',
      desc:'Tests or criteria to validate the result.',
      ph:'Test with empty input…\nCheck off-by-one…\nTime complexity ≤ O(n log n)…' },
    { key:'dos',     label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'State assumptions; keep total under 300 words.' },
    { key:'donts',   label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No hidden reasoning; avoid unnecessary jargon.' }
  ],
  template: ({ problem, plan, checks, dos, donts, ctx, audience, style, tone }) => [
    'Use Plan-and-Solve: draft a minimal plan, execute it, then verify the result.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    problem && `Problem: ${problem}`,
    plan && (
      'Plan:\n' + String(plan)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((p,i)=> `${i+1}. ${p}`).join('\n')
    ),
    checks && (
      'Verification checks:\n' + String(checks)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((c,i)=> `${i+1}. ${c}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output format:\n1) Plan\n2) Solution/working\n3) Verification (reference the checks)'
  ].filter(Boolean).join('\n')
},

  {
  id:'prompt_augmentation',
  slug:'prompt-augmentation-demonstration-learning',
  label:'Prompt Augmentation (Demonstration Learning)',
  kind:'pattern',
  categories:['prompt development techniques','prompt literacy'],
  tags:[
    'type:pattern','topic:examples','topic:demonstrations','phase:apply','level:intermediate',
    'use:format-guidance','use:style-transfer','use:pattern-learning'
  ],
  use_cases:[
    'teach the model a Q→A pattern by example',
    'lock in output format and tone via paired demonstrations',
    'evaluate consistency against provided answers'
  ],
  definition:'Provide multiple prompt→answer pairs so the model infers and follows the desired pattern.',
  help:'Enter your current brief (optional), then list prompts and answers line-by-line in parallel.',
  boosters:[
    'Keep pairs short and high-signal; avoid ambiguity.',
    'Use consistent structure across all answers.',
    'If counts mismatch, ignore extra lines.'
  ],
  fields:[
    { key:'main',     label:'Brief / request (optional)', type:'textarea',
      desc:'What you want now, guided by the examples.',
      ph:'e.g., Classify the following support ticket.' },
    { key:'prompts',  label:'Example prompts (one per line)', type:'textarea',
      desc:'Each line is a prompt/question.',
      ph:'Prompt A…\nPrompt B…\nPrompt C…' },
    { key:'answers',  label:'Example answers (one per line)', type:'textarea',
      desc:'Each line is the corresponding answer. Keep counts aligned with prompts.',
      ph:'Answer A…\nAnswer B…\nAnswer C…' },
    { key:'dos',      label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Follow the demonstrated headings exactly.' },
    { key:'donts',    label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No extra commentary; ≤150 words per answer.' }
  ],
  template: ({ main, prompts, answers, dos, donts, ctx, audience, style, tone }) => [
    'Use demonstration learning: infer the desired format and tone from the prompt→answer pairs, then apply consistently.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    main && `Brief: ${main}`,
    (prompts || answers) && (function(){
      const ps = String(prompts||'').split(/\n+/).map(s=>s.trim()).filter(Boolean);
      const as = String(answers||'').split(/\n+/).map(s=>s.trim()).filter(Boolean);
      const n = Math.min(ps.length, as.length);
      if (!n) return null;
      return 'Demonstrations:\n' + ps.slice(0,n).map((p,i)=>`${i+1}. Prompt: ${p}\n   Answer: ${as[i]}`).join('\n');
    })(),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'After the demonstrations, respond in the same pattern.'
  ].filter(Boolean).join('\n')
},

  
  {
  id:'raccca',
  slug:'raccca-framework',
  label:'RACCCA — Relevance · Accuracy · Completeness · Clarity · Coherence · Appropriateness',
  kind:'framework',
  categories:['evaluation frameworks','prompt development techniques'],
  tags:[
    'type:framework','topic:evaluation','phase:evaluate','level:beginner',
    'use:output-evaluation','use:rubric-scoring','use:quality-review','use:model-comparison'
  ],
  use_cases: [
    'quality review','rubric evaluation','model comparison',
    'content audit','risk screening'
  ],
  definition:'A rubric to evaluate generative outputs across six dimensions: relevance, accuracy, completeness, clarity, coherence, and appropriateness.',
  help:'Use to score or compare outputs and identify concrete fixes.',
  fields:[
    {key:'artifact',        label:'Artifact to evaluate', type:'textarea', desc:'Paste or describe the output.',      ph:'e.g., The draft blog intro…'},
    {key:'scale',           label:'Scale',                type:'text',     desc:'Scoring scale.',                    ph:'e.g., 1–5'},
    {key:'weights',         label:'Weights (opt.)',       type:'text',     desc:'Criterion weights.',                ph:'e.g., R:1,A:2,C:2,Cl:1,Co:1,Ap:1'},
    {key:'context',         label:'Context/requirements', type:'textarea', desc:'Intended use and constraints.',     ph:'e.g., Audience: Dev managers; tone: practical'},
    {key:'improvement_goal',label:'Improvement goal',     type:'textarea', desc:'Desired fix or target quality.',    ph:'e.g., Make it accurate and concise'}
  ],
  boosters:[
    'Return a table with RACCCA scores (on your scale) + 1-line justifications, a weighted overall score, and top-3 fixes. If suitable, include a revised draft.'
  ],
  template:({artifact,scale,weights,context,improvement_goal,ctx})=>[
    `Evaluate using the RACCCA framework.`,
    ctx&&`Context: ${ctx}`,
    artifact&&`Artifact: ${artifact}`,
    scale&&`Scale: ${scale}`,
    weights&&`Weights: ${weights}`,
    context&&`Requirements: ${context}`,
    improvement_goal&&`Improvement goal: ${improvement_goal}`
  ].filter(Boolean).join('\n')
},
  
  {
    id:'ratio',
    slug:'ratio-framework',
    label:'RATIO — Role · Audience · Task · Instructions · Output',
    kind:'pattern',
    categories:['prompt development techniques'],
   tags:[
  'type:pattern','topic:prompting','phase:apply','level:beginner',
  'use:prompt-spec','use:instructional-prompt','use:task-brief'
],
use_cases: [
  'prompt specification',
  'instructional prompt',
  'task brief',
  'agent/system prompt',
  'handoff brief',
  'template for graded output'
],
boosters: [
  "Validate format exactly (schema first, then fill); if schema can’t be met, output a minimal valid stub and list missing fields."
],
    definition:'An audience-centered prompt that captures role, target audience, the task, guiding instructions, and the required output shape.',
    help:'Audience-centered prompt with explicit output spec.',
    fields:[
      {key:'role',         label:'Role',         type:'text',     desc:'Who the model should emulate.', ph:'e.g., Product marketer'},
      {key:'audience',     label:'Audience',     type:'text',     desc:'Who this is for.',              ph:'e.g., New parents'},
      {key:'task',         label:'Task',         type:'textarea', desc:'What should be produced.',      ph:'e.g., Write a landing-page headline and 3 benefit bullets.'},
      {key:'instructions', label:'Instructions', type:'textarea', desc:'Constraints/steps to follow.',  ph:'e.g., Avoid jargon; use active voice; 120 words max.'},
      {key:'output',       label:'Output',       type:'text',     desc:'Exact deliverable shape.',      ph:'e.g., 1 headline + 3 bullets + CTA'}
    ],
    template:({role,audience,task,instructions,output,ctx})=>[
      role&&`You are ${role}.`,
      ctx&&`Context: ${ctx}`,
      audience&&`Target audience: ${audience}`,
      task&&`Task: ${task}`,
      instructions&&`Instructions: ${instructions}`,
      output&&`Output: ${output}`,
      `Use the RATIO pattern. Validate assumptions briefly before final output.`
    ].filter(Boolean).join('\n')
  },
  {
    id:'risen',
    slug:'risen-framework',
    label:'RISEN — Role · Instructions · Steps · End goal · Narrowing',
    kind:'pattern',
    categories:['prompt development techniques'],
    tags:[
  'type:pattern','topic:prompting','phase:plan','level:intermediate',
  'use:project-plan','use:workflow-design','use:research-plan'
],
use_cases: [
  'project plan',
  'research plan',
  'workflow design',
  'content production plan',
  'experiment plan',
  'learning plan'
],
boosters: [
  "State the 1–2 biggest tradeoffs; confirm the narrowed scope."
],
    definition:'A plan-then-focus scaffold: set role and instructions, outline steps, state the end goal, then narrow scope and priorities.',
    help:'Good for complex tasks with stepwise planning then focus.',
    fields:[
      {key:'role',        label:'Role',        type:'text',     desc:'Who the model should be.',          ph:'e.g., Program manager'},
      {key:'instructions',label:'Instructions',type:'textarea', desc:'Rules/constraints to honor.',       ph:'e.g., Prioritize clarity; reference internal style guide.'},
      {key:'steps',       label:'Steps',       type:'textarea', desc:'High-level plan or checklist.',     ph:'e.g., Research → Outline → Draft → Review → Finalize'},
      {key:'end_goal',    label:'End goal',    type:'text',     desc:'Definition of success.',            ph:'e.g., Publishable first draft by Friday EOD'},
      {key:'narrowing',   label:'Narrowing',   type:'textarea', desc:'Prioritization/scope cuts.',        ph:'e.g., Focus on onboarding, skip billing edge cases'}
    ],
    template:({role,instructions,steps,end_goal,narrowing,ctx})=>[
      role&&`You are ${role}.`,
      ctx&&`Context: ${ctx}`,
      instructions&&`Instructions: ${instructions}`,
      steps&&`Proposed steps: ${steps}`,
      end_goal&&`End goal: ${end_goal}`,
      narrowing&&`Focus/narrowing: ${narrowing}`,
      `Follow RISEN. Reflect on tradeoffs before final.`
    ].filter(Boolean).join('\n')
  },
  {
    id:'rodes',
    slug:'rodes-framework',
    label:'RODES — Role · Objective · Details · Examples · Sense check',
    kind:'pattern',
    categories:['prompt development techniques'],
    tags:[
  'type:pattern','topic:prompting','phase:apply','level:intermediate',
  'use:example-guided-writing','use:ux-microcopy','use:quality-check'
],
use_cases: [
  'example-guided rewriting',
  'UX microcopy',
  'tone/style adaptation',
  'product messaging variants',
  'quality check against criteria',
  'rubric-guided output'
],
boosters: [
  "Run the sense-check as a bullet list tied to the acceptance criteria, then deliver Final."
],
    definition:'Evidence-guided production: set role and objective, supply details and examples, then perform a brief sense-check before delivery.',
    help:'When you have exemplars and want a final self-check.',
    fields:[
      {key:'role',        label:'Role',        type:'text',     desc:'Who the model should be.',            ph:'e.g., UX writer'},
      {key:'objective',   label:'Objective',   type:'text',     desc:'Primary goal of the output.',         ph:'e.g., Improve sign-up microcopy'},
      {key:'details',     label:'Details',     type:'textarea', desc:'Key facts, constraints, resources.',  ph:'e.g., Product is mobile-only; support link must appear once.'},
      {key:'examples',    label:'Examples',    type:'textarea', desc:'Short exemplars to imitate.',         ph:'e.g., “Welcome aboard!” → concise, friendly tone'},
      {key:'sense_check', label:'Sense check', type:'textarea', desc:'Acceptance criteria/guardrails.',      ph:'e.g., At most 25 words; no slang; include link text'}
    ],
    template:({role,objective,details,examples,sense_check,ctx})=>[
      role&&`You are ${role}.`,
      ctx&&`Context: ${ctx}`,
      objective&&`Objective: ${objective}`,
      details&&`Details: ${details}`,
      examples&&`Examples: ${examples}`,
      sense_check&&`Sense-check before final: ${sense_check}`,
      `Apply RODES. Show brief reasoning if uncertain.`
    ].filter(Boolean).join('\n')
  },
  
  {
  id:'root_cause',
  slug:'root-cause-analysis',
  label:'Root Cause Analysis',
  kind:'pattern',
  categories:['quality','operations','reasoning'],
  tags:[
    'type:pattern','topic:5-whys','topic:causality','phase:diagnose','level:beginner',
    'use:incident-review','use:bug-analysis','use:process-improvement'
  ],
  use_cases:[
    'identify primary causes vs symptoms',
    'propose targeted countermeasures',
    'document verification steps'
  ],
  definition:'Identify the underlying cause of a problem (e.g., via 5 Whys), then propose countermeasures and checks.',
  help:'State the problem, list observed symptoms/evidence, and any guardrails.',
  boosters:[
    'Run at least 3–5 “Why?” steps until causes stop being actionable.',
    'Tie each countermeasure to a specific cause.',
    'Include verification and owner for each action.'
  ],
  fields:[
    { key:'problem',   label:'Problem statement', type:'textarea',
      desc:'What went wrong or what is undesired?',
      ph:'App crash rate spiked after v1.2…' },
    { key:'symptoms',  label:'Symptoms / evidence (one per line)', type:'textarea',
      desc:'Observed facts supporting the problem.',
      ph:'Crash logs show null ptr at …\nSpike at 10:42 UTC…' },
    { key:'dos',       label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Quantify impact; assign owners.' },
    { key:'donts',     label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No blame; ≤400 words.' }
  ],
  template: ({ problem, symptoms, dos, donts, ctx, audience, style, tone }) => [
    'Perform Root Cause Analysis using the 5 Whys and propose targeted countermeasures.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    problem && `Problem: ${problem}`,
    symptoms && (
      'Symptoms / evidence:\n' + String(symptoms)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((s,i)=> `${i+1}. ${s}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output:\n1) 5 Whys chain\n2) Root cause(s)\n3) Countermeasures (owner, due, verification)\n4) Residual risks'
  ].filter(Boolean).join('\n')
},

  
  {
    id:'rtf',
    slug:'rtf-framework',
    label:'RTF — Role · Task · Format',
    kind:'pattern',
    categories:['prompt development techniques'],
    tags:[
  'type:pattern','topic:prompting','phase:apply','level:beginner',
  'use:general-purpose','use:format-enforcement','use:starter-prompt'
],
use_cases: [
  'general-purpose prompting',
  'format enforcement',
  'role simulation',
  'structured data output',
  'template scaffold',
  'API-doc-style response',
  'quickstarter prompt'
],
boosters: [
  "Validate format exactly (schema first, then fill); if schema can’t be met, output a minimal valid stub and list missing fields."
],
    definition:'A general-purpose scaffold that specifies who the model is, what to do, and how to format the answer.',
    help:'General-purpose scaffold: define who the model is, what to do, and the response shape.',
    fields:[
      {key:'role',   label:'Role',   type:'text',     desc:'Who the model should act as.', ph:'e.g., Senior technical writer'},
      {key:'task',   label:'Task',   type:'textarea', desc:'Describe the work to be done.', ph:'e.g., Draft a user guide section explaining 2FA setup.'},
      {key:'format', label:'Format', type:'text',     desc:'The structure/shape of the output.', ph:'e.g., Markdown with H2s and code blocks'}
    ],
    template:({role,task,format,ctx})=>[
      role&&`You are ${role}.`,
      ctx&&`Context: ${ctx}`,
      task&&`Task: ${task}`,
      format&&`Respond in this format: ${format}`,
      `Follow the RTF pattern. Ask concise clarifying questions if needed.`
    ].filter(Boolean).join('\n')
  },
  
  {
  id:'six_hats',
  slug:'six-thinking-hats',
  label:'Six Thinking Hats',
  kind:'pattern',
  categories:['decision-making','ideation'],
  tags:[
    'type:pattern','topic:perspective-taking','topic:facilitation','phase:explore','level:beginner',
    'use:workshops','use:brainstorm','use:alignment'
  ],
  use_cases:[
    'explore multiple perspectives on a topic',
    'structure a discussion or solo reasoning',
    'surface risks, data, feelings, creativity, control'
  ],
  definition:'A role-play model (White, Red, Black, Yellow, Green, Blue) to examine a topic from six perspectives.',
  help:'Provide the topic and (optionally) the hat order (one per line).',
  boosters:[
    'Keep each hat’s notes to 2–3 bullets.',
    'End with a Blue hat summary decision.',
    'If no order is given, use White→Red→Black→Yellow→Green→Blue.'
  ],
  fields:[
    { key:'topic', label:'Topic / decision', type:'textarea',
      desc:'What are we evaluating or deciding?',
      ph:'Should we sunset Feature X?' },
    { key:'order', label:'Hat order (one per line, optional)', type:'textarea',
      desc:'Any subset/order of: White, Red, Black, Yellow, Green, Blue.',
      ph:'White\nRed\nBlack\nYellow\nGreen\nBlue' },
    { key:'dos',   label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'2–3 bullets per hat; be concrete.' },
    { key:'donts', label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No digressions; ≤350 words total.' }
  ],
  template: ({ topic, order, dos, donts, ctx, audience, style, tone }) => [
    'Use Six Thinking Hats to examine the topic from multiple perspectives, then conclude.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    topic && `Topic: ${topic}`,
    order && (
      'Hat order:\n' + String(order)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((h,i)=> `${i+1}. ${h}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output each hat with 2–3 bullets, then a Blue-hat summary decision.'
  ].filter(Boolean).join('\n')
},

{
  id:'soar',
  slug:'soar-analysis',
  label:'SOAR Analysis',
  kind:'pattern',
  categories:['strategy','planning'],
  tags:[
    'type:pattern','topic:strategy','topic:positive-deviance','phase:plan','level:beginner',
    'use:offsites','use:visioning','use:roadmapping'
  ],
  use_cases:[
    'forward-looking strategic discussion',
    'align aspirations with measurable results',
    'find opportunity in strengths'
  ],
  definition:'Strengths, Opportunities, Aspirations, Results—an appreciative, forward-looking alternative to SWOT.',
  help:'Provide context (optional) and list SOAR elements (one per line each).',
  boosters:[
    'Tie each Aspiration to at least one Strength and Opportunity.',
    'Make Results measurable (metric, target, date).',
    'End with next steps.'
  ],
  fields:[
    { key:'context',       label:'Context (optional)', type:'textarea',
      desc:'Brief background or scope.',
      ph:'Q4 planning for self-serve growth…' },
    { key:'strengths',     label:'Strengths (one per line)', type:'textarea',
      desc:'What we already do well.',
      ph:'Fast release cadence…\nHighly engaged community…' },
    { key:'opportunities', label:'Opportunities (one per line)', type:'textarea',
      desc:'External possibilities to leverage.',
      ph:'Partnership with …\nUntapped EDU market…' },
    { key:'aspirations',   label:'Aspirations (one per line)', type:'textarea',
      desc:'Where we want to go.',
      ph:'Be the default for …\nNPS ≥ 50…' },
    { key:'results',       label:'Results (one per line)', type:'textarea',
      desc:'Measurable outcomes (metric & target).',
      ph:'ARR $5M by Q4; DAU 50k…' },
    { key:'dos',           label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Be specific and measurable.' },
    { key:'donts',         label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'Avoid vague aspirations.' }
  ],
  template: ({ context, strengths, opportunities, aspirations, results, dos, donts, ctx, audience, style, tone }) => [
    'Run a SOAR analysis (forward-looking strategy).',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    context && `Scope/context: ${context}`,
    strengths && (
      'Strengths:\n' + String(strengths)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    opportunities && (
      'Opportunities:\n' + String(opportunities)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    aspirations && (
      'Aspirations:\n' + String(aspirations)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    results && (
      'Results (measurable):\n' + String(results)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Close with 3 next steps linked to the SOAR items.'
  ].filter(Boolean).join('\n')
},

{
  id:'socratic',
  slug:'socratic-questioning',
  label:'Socratic Questioning',
  kind:'pattern',
  categories:['reasoning','critical thinking'],
  tags:[
    'type:pattern','topic:socratic','topic:assumptions','phase:explore','level:beginner',
    'use:analysis','use:teaching','use:debiasing'
  ],
  use_cases:[
    'interrogate claims and assumptions',
    'separate knowledge from belief',
    'surface implications and alternatives'
  ],
  definition:'A disciplined questioning method to clarify, probe assumptions, test evidence, explore viewpoints, and examine implications.',
  help:'Provide a claim/topic, plus any assumptions, evidence, or alternatives (one per line).',
  boosters:[
    'Keep questions sharp and answerable.',
    'Avoid leading or loaded wording.',
    'End with a synthesis and next inquiry.'
  ],
  fields:[
    { key:'claim',       label:'Claim / topic', type:'textarea',
      desc:'What are we questioning?',
      ph:'“We must pivot to enterprise immediately.”' },
    { key:'assumptions', label:'Assumptions (one per line, optional)', type:'textarea',
      desc:'Suspected premises.',
      ph:'SMB cannot pay…\nSales cycle is too long…' },
    { key:'evidence',    label:'Evidence (one per line, optional)', type:'textarea',
      desc:'Facts or data offered.',
      ph:'Churn 12%…\n2/5 enterprise pilots failed…' },
    { key:'alternatives',label:'Alternatives (one per line, optional)', type:'textarea',
      desc:'Other viewpoints/paths.',
      ph:'PLG focus…\nMid-market first…' },
    { key:'dos',         label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Neutral tone; concrete questions.' },
    { key:'donts',       label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No ad hominem; ≤300 words.' }
  ],
  template: ({ claim, assumptions, evidence, alternatives, dos, donts, ctx, audience, style, tone }) => [
    'Apply Socratic questioning to probe the topic and synthesize a position.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    claim && `Topic: ${claim}`,
    assumptions && (
      'Assumptions:\n' + String(assumptions)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    evidence && (
      'Evidence:\n' + String(evidence)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    alternatives && (
      'Alternatives:\n' + String(alternatives)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output:\n1) Clarification questions\n2) Probe assumptions\n3) Test evidence\n4) Explore viewpoints\n5) Implications\n6) Synthesis & next inquiry'
  ].filter(Boolean).join('\n')
},

  
  {
    id:'star',
    slug:'star-technique',
    label:'STAR — Situation · Task · Action · Result',
    kind:'framework',
    categories:['storytelling frameworks','prompt development techniques'],
   tags:[
  'type:framework','topic:storytelling','phase:apply','level:beginner',
  'use:behavioral-interview','use:resume-bullet','use:case-study'
],
use_cases: [
  'behavioral interview answer',
  'resume bullet',
  'case study write-up',
  'performance self-review',
  'success story for stakeholders',
  'incident/postmortem story'
],
boosters: [
  "Quantify results where possible (%, Δ, time); if no metrics given, propose proxy metrics."
],
    definition:'A structured storytelling method for accomplishments and case studies.',
    help:'Great for case studies, resumes, performance stories.',
    fields:[
      {key:'situation', label:'Situation', type:'textarea', desc:'Context and constraints.', ph:'e.g., Missed quarterly target; low trial conversions'},
      {key:'task',      label:'Task',      type:'textarea', desc:'Goal or responsibility.',   ph:'e.g., Improve conversion rate by 20%'},
      {key:'action',    label:'Action',    type:'textarea', desc:'What you did.',            ph:'e.g., Ran pricing test; rewrote trial emails'},
      {key:'result',    label:'Result',    type:'textarea', desc:'Outcome/impact.',          ph:'e.g., +24% conversions; +18% MRR'}
    ],
    template:({situation,task,action,result,ctx,audience})=>[
      ctx&&`Context: ${ctx}`,
      audience&&`Target reader: ${audience}`,
      `Narrative using STAR:`,
      situation&&`• Situation: ${situation}`,
      task&&`• Task: ${task}`,
      action&&`• Action: ${action}`,
      result&&`• Result: ${result}`
    ].filter(Boolean).join('\n')
  },
  {
    id:'swot',
    slug:'swot-analysis',
    label:'SWOT — Strengths · Weaknesses · Opportunities · Threats',
    kind:'framework',
    categories:['analysis frameworks','prompt development techniques'],
    tags:[
  'type:framework','topic:analysis','phase:overview','level:beginner',
  'use:competitive-analysis','use:market-analysis','use:product-strategy'
],
use_cases: [
  'competitive analysis',
  'market scan',
  'product strategy snapshot',
  'business strategy review',
  'go-to-market assessment',
  'campaign planning snapshot'
],
boosters: [
  "Sort each list most-specific → least; avoid duplicates; flag any misclassified items (internal vs external)."
],
    definition:'A 2×2 strategic scan that separates internal factors (S/W) from external forces (O/T).',
    help:'Strategic scan of an idea, product, or org.',
    fields:[
      {key:'subject',      label:'Subject',            type:'text',     desc:'What we are analyzing.', ph:'e.g., New B2B email tool'},
      {key:'strengths',    label:'Known strengths',    type:'textarea', desc:'Optional seed inputs.',   ph:'e.g., Easy setup; strong analytics'},
      {key:'weaknesses',   label:'Known weaknesses',   type:'textarea', desc:'Optional seed inputs.',   ph:'e.g., Limited integrations'},
      {key:'opportunities',label:'Known opportunities',type:'textarea', desc:'Optional seed inputs.',   ph:'e.g., Growing SMB market'},
      {key:'threats',      label:'Known threats',      type:'textarea', desc:'Optional seed inputs.',   ph:'e.g., Mailbox policy changes'}
    ],
    template:({subject,strengths,weaknesses,opportunities,threats,ctx})=>[
      `Conduct a SWOT analysis${subject?` of ${subject}`:''}.`,
      ctx&&`Context: ${ctx}`,
      (strengths||weaknesses||opportunities||threats)?`Seed facts to consider:`:null,
      strengths&&`• Strengths (given): ${strengths}`,
      weaknesses&&`• Weaknesses (given): ${weaknesses}`,
      opportunities&&`• Opportunities (given): ${opportunities}`,
      threats&&`• Threats (given): ${threats}`,
      `Return as four labeled lists with 3–6 bullets each, most specific first.`
    ].filter(Boolean).join('\n')
  },

{
  id:'task_breakdown',
  slug:'task-recipe-cot',
  label:'Task Prompt Breakdown — Task/Recipe + Do/Don’t (CoT)',
  kind:'pattern',
  categories:['prompt development techniques','planning'],
  tags:[
    'type:pattern','topic:tasking','topic:reasoning','phase:plan','level:beginner',
    'use:project-steps','use:recipe','use:breakdown','use:delegation'
  ],
  use_cases: [
    'break a goal into concrete steps',
    'write a procedural recipe',
    'handoff a task with crisp Do/Don’t guardrails',
    'guide short “explain-your-steps” reasoning'
  ],
  definition:'Decompose a goal into explicit steps (tasks), with optional Do/Don’t constraints, then produce the deliverable.',
  help:'Provide a main brief, enumerate tasks (add as many as needed), then add Do/Don’t guardrails.',
  boosters:[
    'Show the step plan as a numbered list before the final deliverable.',
    'Keep reasoning concise and procedural (no hidden chain-of-thought).',
    'List assumptions in one line if any are required.'
  ],
  fields:[
    { key:'main',  label:'Main brief / goal', type:'textarea',
      desc:'High-level objective or problem statement.',
      ph:'e.g., Create a study plan for a 6-week data structures course.'
    },
    // You can switch this to "dynamic_tasks" after Step 2
    { key:'tasks', label:'Tasks (one per line)', type:'textarea',
      desc:'Enter one task/step per line.',
      ph:'Task 1…\nTask 2…\nTask 3…'
    },
    { key:'dos',   label:'Do’s (must do)', type:'textarea',
      desc:'Positive guardrails the output must follow.',
      ph:'e.g., Use simple language; include references; keep under 500 words.'
    },
    { key:'donts', label:'Don’ts / Constraints', type:'textarea',
      desc:'Negative guardrails or constraints.',
      ph:'e.g., Don’t assume prior knowledge; avoid vendor-specific terms.'
    }
  ],
  template: ({ main, tasks, dos, donts, ctx, audience, style, tone }) => [
    'Use task/recipe chain of thought reasoning to break the goal into explicit steps, then produce the deliverable.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    main && `Goal: ${main}`,
    tasks && (
      'Tasks:\n' + String(tasks)
        .split(/\n+/)
        .map(s => s.trim())
        .filter(Boolean)
        .map((t, i) => `${i + 1}. ${t}`)
        .join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don’t:\n${donts}`,
    'First show the numbered plan, then execute it to produce the final output. Keep reasoning concise (procedural, verifiable).'
  ].filter(Boolean).join('\n')
},

{
  id:'tot_brainstorm',
  slug:'tree-of-thought-brainstorm',
  label:'Tree of Thought — Brainstorm & Evaluate',
  kind:'pattern',
  categories:['reasoning','planning'],
  tags:[
    'type:pattern','topic:reasoning','topic:branching','phase:explore','level:intermediate',
    'use:brainstorm','use:compare-alternatives','use:decision'
  ],
  use_cases:[
    'generate multiple solution paths before deciding',
    'compare tradeoffs across ideas',
    'pick a best path with brief justification'
  ],
  definition:'Explore several reasoning branches (a small tree), score them against criteria, and choose a path.',
  help:'Describe the problem, list evaluation criteria (one per line), and add guardrails. The model will branch briefly and then decide.',
  boosters:[
    'Limit depth to 2–3 and 2–3 branches per node.',
    'Keep justifications to one sentence per branch (avoid long hidden reasoning).',
    'Summarize why the chosen path wins in ≤2 sentences.'
  ],
  fields:[
    { key:'problem',  label:'Problem / goal', type:'textarea',
      desc:'What needs solving or deciding?',
      ph:'e.g., Choose a pricing model for a new SaaS.' },
    { key:'criteria', label:'Evaluation criteria (one per line)', type:'textarea',
      desc:'How to judge branches.',
      ph:'Revenue predictability…\nAdoption friction…\nEase of experimentation…' },
    { key:'dos',      label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Provide scores 1–5; include a quick pro/con per branch.' },
    { key:'donts',    label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No long essays; ≤250 words total.' }
  ],
  template: ({ problem, criteria, dos, donts, ctx, audience, style, tone }) => [
    'Use Tree-of-Thought (branching brainstorm): propose alternatives, score them briefly, then choose one.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    problem && `Problem: ${problem}`,
    criteria && (
      'Evaluation criteria:\n' + String(criteria)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((c,i)=> `${i+1}. ${c}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output format:\n1) Branching brainstorm (depth 2–3; 2–3 branches per node). Use labels like 1, 1.1, 1.2.\n2) Brief scores per branch (1 sentence each).\n3) Chosen path with a 1–2 sentence rationale.\n4) Final recommendation or answer.'
  ].filter(Boolean).join('\n')
},

{
  id:'tot_decompose',
  slug:'tree-of-thought-decomposition',
  label:'Tree of Thought — Decomposition',
  kind:'pattern',
  categories:['reasoning','planning'],
  tags:[
    'type:pattern','topic:decomposition','topic:branching','phase:plan','level:intermediate',
    'use:breakdown','use:alternatives','use:execution-plan'
  ],
  use_cases:[
    'break a complex goal into a branching plan',
    'surface alternative sub-steps at key nodes',
    'pick a minimal viable path to execute next'
  ],
  definition:'Decompose a complex goal into a branching hierarchy of sub-tasks with alternatives and select a minimal path.',
  help:'Provide the complex goal and (optionally) focal areas and risks. The model will build a small tree and select a path.',
  boosters:[
    'Show a numbered hierarchy (1, 1.1, 1.1.1).',
    'Offer 2–3 alternative sub-steps at ambiguous nodes.',
    'End with a smallest-next-action checklist.'
  ],
  fields:[
    { key:'goal',     label:'Goal / complex task', type:'textarea',
      desc:'What should be decomposed?',
      ph:'e.g., Launch a developer portal in 6 weeks.' },
    { key:'facets',   label:'Focus areas (one per line, optional)', type:'textarea',
      desc:'Dimensions to branch on (e.g., people, process, tooling).',
      ph:'Docs…\nAuth…\nDX metrics…\nContent strategy…' },
    { key:'risks',    label:'Risks & assumptions (one per line, optional)', type:'textarea',
      desc:'Things that could change the plan.',
      ph:'Limited writer bandwidth…\nPending legal review…' },
    { key:'dos',      label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Identify dependencies; label critical path.' },
    { key:'donts',    label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'Keep to ≤400 words; avoid tool lock-in.' }
  ],
  template: ({ goal, facets, risks, dos, donts, ctx, audience, style, tone }) => [
    'Use Tree-of-Thought decomposition to create a branching plan, then select a minimal viable path.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    goal && `Goal: ${goal}`,
    facets && (
      'Focus areas:\n' + String(facets)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((f,i)=> `${i+1}. ${f}`).join('\n')
    ),
    risks && (
      'Risks & assumptions:\n' + String(risks)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((r,i)=> `${i+1}. ${r}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output format:\n1) Branching decomposition (numbered tree; show 2–3 alternatives where useful)\n2) Critical path (the minimal set of nodes)\n3) Dependencies & checkpoints\n4) Next actions (checklist)'
  ].filter(Boolean).join('\n')
},

{
  id:'triz',
  slug:'triz-inventive-problem-solving',
  label:'TRIZ (Theory of Inventive Problem Solving)',
  kind:'pattern',
  categories:['innovation','engineering','reasoning'],
  tags:[
    'type:pattern','topic:contradictions','topic:ideality','phase:invent','level:intermediate',
    'use:product-ideas','use:process-innovation','use:technical-problems'
  ],
  use_cases:[
    'resolve contradictions without trade-offs',
    'generate inventive principles to explore',
    'aim toward an Ideal Final Result (IFR)'
  ],
  definition:'A method that analyzes contradictions and patterns of invention to propose principle-driven solutions toward an ideal outcome.',
  help:'State the problem, list contradictions and available resources, and describe the Ideal Final Result (IFR).',
  boosters:[
    'Map each contradiction to candidate inventive principles.',
    'Offer at least 3 distinct concepts referencing principles.',
    'Briefly test each concept against constraints/resources.'
  ],
  fields:[
    { key:'problem',        label:'Problem statement', type:'textarea',
      desc:'What needs an inventive solution?',
      ph:'We need high throughput without increasing cost…' },
    { key:'contradictions', label:'Contradictions (one per line)', type:'textarea',
      desc:'Conflicts like speed vs quality.',
      ph:'Increase speed vs maintain accuracy…\nReduce cost vs keep reliability…' },
    { key:'resources',      label:'Available resources (one per line)', type:'textarea',
      desc:'Internal/external resources, fields, effects.',
      ph:'Idle CPU cycles…\nUser-generated data…\nCapacitors…' },
    { key:'ifr',            label:'Ideal Final Result (IFR)', type:'textarea',
      desc:'Describe the near-perfect outcome.',
      ph:'Zero defects at current cost and time…' },
    { key:'dos',            label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Reference named principles; give 3+ concepts.' },
    { key:'donts',          label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'Avoid vague “be more efficient”.' }
  ],
  template: ({ problem, contradictions, resources, ifr, dos, donts, ctx, audience, style, tone }) => [
    'Apply TRIZ: analyze contradictions, aim for the Ideal Final Result, propose principle-based concepts.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    problem && `Problem: ${problem}`,
    contradictions && (
      'Contradictions:\n' + String(contradictions)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((c,i)=> `${i+1}. ${c}`).join('\n')
    ),
    resources && (
      'Resources:\n' + String(resources)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((r,i)=> `${i+1}. ${r}`).join('\n')
    ),
    ifr && `Ideal Final Result (IFR): ${ifr}`,
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output:\n1) Map contradictions → candidate inventive principles\n2) 3–5 concepts referencing principles\n3) Quick feasibility/impact check'
  ].filter(Boolean).join('\n')
}

];

const searchEl = document.getElementById('fwSearch');
const allBtn   = document.getElementById('fwAll');

const norm = s => (s||'').toLowerCase();
function tokenize(s){ return norm(s).split(/[^a-z0-9]+/).filter(Boolean); }

function matchScore(fw, query){
  const q = (query||'').trim();
  if(!q) return 0;

  const qTokens = tokenize(q);
  if(!qTokens.length) return 0;

  const hayPieces = [
    fw.label, fw.slug, fw.definition, fw.help,
    ...(fw.categories||[]), ...(fw.tags||[]),
    ...(fw.use_cases||[]), ...(fw.boosters||[]),
    ...((fw.fields||[]).flatMap(f=>[f.label, f.desc, f.ph]))
  ].filter(Boolean);

  const hay = hayPieces.join(' ').toLowerCase();
  const hayTokens = tokenize(hay);

  let score = 0;
  qTokens.forEach(t=>{
    // strong boost for label prefix match
    if (norm(fw.label).startsWith(t)) score += 8;
    // general token presence in tags/use_cases/desc/etc.
    if (hayTokens.includes(t)) score += 3;
  });
  return score;
}


// UI bootstrap
const sel = $('#frameworkSel');
// --- Multi-tab state (with migration from single state) ---
let state = window.state || {};
state.common = state.common || {};


// --- URL param: pick framework by ?slug=... (supports slug or id, case-insensitive)
(() => {
  const params = new URLSearchParams(window.location.search);
  const q = (params.get('slug') || '').trim().toLowerCase();
  if (!q) return;

  // Match by slug or id
  const pick = FRAMEWORKS.find(f =>
    (f.slug && f.slug.toLowerCase() === q) ||
    (f.id   && f.id.toLowerCase()   === q)
  );
  if (!pick) return;

  // If tabs not yet migrated, seed the pre-migration id so the first tab uses it.
  state.id = pick.id;

  // If tabs already exist (edge case), align the active tab now too.
  if (Array.isArray(state.tabs) && state.tabs.length) {
    const i = Number.isInteger(state.active) ? state.active : 0;
    state.tabs[i] = { ...(state.tabs[i] || {}), id: pick.id };
  }
})();


// If already migrated, keep it. Otherwise wrap the old single-state into a tab.
if (!Array.isArray(state.tabs) || !state.tabs.length){
  const initialId = (typeof state.id === 'string') ? state.id : (FRAMEWORKS[0]?.id || null);
  state.tabs = [{
    id: initialId,
    fields: state.fields || {},
    extra: (state.extra && state.extra[initialId]) ?? undefined
  }];
  state.active = 0;
  // clean up legacy keys (optional)
  delete state.id; delete state.fields;
}; // use let so we can set the id after we build options

function buildFrameworkOptions(filterText=''){
  const base = FRAMEWORKS.slice()
    .sort((a,b)=> a.label.localeCompare(b.label,'en',{sensitivity:'base'}));

  const total = base.length;
  let list = base;

  const q = (filterText||'').trim();
  if (q){
    list = base
      .map(f=>({f, s: matchScore(f, q)}))
      .filter(x=> x.s > 0)
      .sort((a,b)=> b.s - a.s || a.f.label.localeCompare(b.f.label,'en',{sensitivity:'base'}))
      .map(x=> x.f);
    if (!list.length) list = base; // graceful fallback
  }

  // Rebuild <select> to reflect the filtered ordering
  sel.innerHTML = '';
  list.forEach(f=>{
    const o = document.createElement('option');
    o.value = f.id;
    o.textContent = f.label;
    sel.appendChild(o);
  });

  // Update the little "Showing N/M" hint
  const fwHint = document.getElementById('fwHint');
  if (fwHint){
    if (q){
      // If we fell back to base because there were 0 hits, treat it as "all"
      const isFallback = !base.some(b => (norm(b.label).includes(norm(q))));
      const count = isFallback ? total : list.length;
      fwHint.textContent = `Showing ${count}/${total} — Hit Enter`;
      fwHint.hidden = false;
    } else {
      fwHint.textContent = '';
      fwHint.hidden = true;
    }
  }

  // Preserve current tab's selection if it's in the filtered list; otherwise
  // at least show the *first* filtered option in the dropdown so users see the filter working.
  const t = activeTab();
  const keep = t.id && list.find(x=>x.id===t.id);
  if (keep){
    sel.value = t.id;
  } else {
    sel.selectedIndex = 0;  // visually show the top match
  }
}



// build options now (call again later if you ever modify FRAMEWORKS at runtime)
buildFrameworkOptions();

renderTabs();
buildFrameworkOptions(''); // ensure suggestions render
renderFields(); emit();


    function fieldInput(el, on){ el.addEventListener('input', on); el.addEventListener('change', on); }
    
    
    /* ==== Inline Counters (Stage 1) ==== */
function approxTokens(str){ return Math.ceil((str || '').length / 4); } // fast heuristic
function estimateTokens(str){
  try{
    if (typeof window.customTokenCounter === 'function') {
      const n = Number(window.customTokenCounter(String(str)));
      if (Number.isFinite(n) && n > 0) return Math.ceil(n);
    }
  }catch(e){ /* ignore */ }
  return approxTokens(str);
}

/* ==== Prompt totals: gather, compute, render ==== */
function gatherPreviewText(){
  // If you render a deck of cards, concatenate all visible outputs.
  const deck = document.getElementById('outDeck');
  if (deck && !deck.hidden){
    return Array.from(deck.querySelectorAll('.outBody'))
      .map(n => (n.textContent || '').trim())
      .filter(Boolean)
      .join('\n\n---\n\n');
  }
  // Fallback to the single current preview (the big one)
  const out = document.getElementById('out');
  return (out?.textContent || '').trim();
}

function updatePromptTotal(){
  const el = document.getElementById('promptTotal');
  if (!el) return;
  const text = gatherPreviewText();
  if (!text){ el.textContent = ''; return; }
  const chars = text.length;
  const toks  = estimateTokens(text);
  el.textContent = `${toks} tokens · ${chars} characters`;
}


/* ==== Context Coach (single, for current preview) ==== */
/* Token bands tuned for full prompt length (current preview only) */
const PROMPT_COACH_BANDS = [
  { /* Too little */          max:  79,  state:'low',     label:'Type more'    },
  { /* Not enough */          min:  80,  max: 150, state:'low',     label:'Not enough'   },
  { /* Almost there */        min: 151,  max: 250, state:'near',    label:'Almost there' },
  { /* Looking good */        min: 251,  max: 400, state:'good',    label:'Looking good' },
  { /* Great! */              min: 401,  max: 600, state:'good',    label:'Great!'       },
  { /* Perfect! */            min: 601,  max: 800, state:'perfect', label:'Perfect!'     },
  { /* Too much (long wall) */min: 1001,          state:'high',    label:'Too much'     }
];

function coachForPrompt(tokens){
  for (const r of PROMPT_COACH_BANDS){
    const okMin = (r.min == null) || (tokens >= r.min);
    const okMax = (r.max == null) || (tokens <= r.max);
    if (okMin && okMax) return { state: r.state, label: r.label };
  }
  return { state: 'good', label: 'Looking good' };
}

/* Create/update the coach node inside #out based on current preview tokens */
function updateOutCoach(){
  const out = document.getElementById('out');
  if (!out) return;

  // Create once
  let coach = out.querySelector('.outCoach');
  if (!coach){
    coach = document.createElement('div');
    coach.className = 'outCoach';
    coach.setAttribute('role','status');
    coach.setAttribute('aria-live','polite');
    const pill = document.createElement('span');
    pill.className = 'pill';
    coach._pill = pill;
    coach.appendChild(pill);
    out.appendChild(coach);
  }

  const text = (out.textContent || '').trim();
  if (!text){
    coach.hidden = true;
    out.classList.remove('hasCoach');
    return;
  }

  const tokens = estimateTokens(text); // uses your existing heuristic/precise counter
  const { state, label } = coachForPrompt(tokens);
  coach.dataset.state = state;
  coach._pill.textContent = label;
  coach.hidden = false;
  out.classList.add('hasCoach');
}


/* ==== Master totals: across ALL templates ==== */
function gatherMasterText(){
  const deck = document.getElementById('outDeck');
  if (deck){
    const bodies = deck.querySelectorAll('.outBody');
    if (bodies && bodies.length){
      return Array.from(bodies)
        .map(n => (n.textContent || '').trim())
        .filter(Boolean)
        .join('\n\n---\n\n')
        .trim();
    }
  }
  // Fallback to the single current preview (#out) if no deck/cards
  const out = document.getElementById('out');
  return (out?.textContent || '').trim();
}

function updateMasterPromptTotal(){
  const el = document.getElementById('masterPromptTotal');
  if (!el) return;
  const text = gatherMasterText();
  if (!text){ el.textContent = ''; return; }
  const chars = text.length;
  const toks  = estimateTokens(text); // uses your existing heuristic/precise token estimator
  el.textContent = `${toks} tokens · ${chars} characters`;
}

/* ==== Current preview counter (top-right inside #out) ==== */
function updateOutPreviewCounter(){
  const out = document.getElementById('out');
  if (!out) return;

  let node = out.querySelector('.outCounter');
  if (!node){
    node = document.createElement('div');
    node.className = 'outCounter';
    node.setAttribute('aria-hidden', 'true');
    out.appendChild(node);
  }

  const text = (out.textContent || '').trim();
  if (!text){
    node.textContent = '';
    node.hidden = true;
    out.classList.remove('hasCounter');
    return;
  }

  const chars = text.length;
  const toks  = estimateTokens(text);
  node.textContent = `${toks}t · ${chars}c`;
  node.hidden = false;
  out.classList.add('hasCounter');
}

/* === Counter refresh scheduler (debounced to next frame) === */
function refreshPromptCountersSoon(){
  if (refreshPromptCountersSoon._pending) return;
  refreshPromptCountersSoon._pending = true;
  requestAnimationFrame(()=>{
    refreshPromptCountersSoon._pending = false;
    // Keep the original per-current-prompt updater:
    updatePromptTotal && updatePromptTotal();
    // ADD the new master updater (do not replace the old call):
    updateMasterPromptTotal && updateMasterPromptTotal();
    // Keep the tiny current-preview corner counter:
    updateOutPreviewCounter && updateOutPreviewCounter();
      updateOutCoach && updateOutCoach();     
  });
}

function formatCounts(chars, tokens){ return `${tokens}t · ${chars}c`; }

function setupCounter(inputEl){
  // Only for text & textarea
  const tag = inputEl.tagName.toLowerCase();
  if (!(tag === 'input' || tag === 'textarea')) return;

  // Wrap input in a positioned holder (if not already)
  if (!inputEl.parentElement || !inputEl.parentElement.classList.contains('fieldHolder')){
    const holder = document.createElement('div');
    holder.className = 'fieldHolder';
    inputEl.parentElement.insertBefore(holder, inputEl);
    holder.appendChild(inputEl);
  }
  // Create the counter once
  if (!inputEl._counterNode){
    const n = document.createElement('span');
    n.className = 'counter';
    n.setAttribute('aria-hidden', 'true');
    inputEl._counterNode = n;
    inputEl.parentElement.appendChild(n);
    inputEl.classList.add('hasCounter');
  }

  const update = ()=>{
    const val = inputEl.value || '';
    const chars = val.length;
    const tokens = estimateTokens(val);
    inputEl._counterNode.textContent = (chars > 0) ? formatCounts(chars, tokens) : '';
    inputEl._counterNode.hidden = chars === 0;
  };

  // Initial + live updates
  update();
  inputEl.addEventListener('input', update);
  inputEl.addEventListener('change', update);
}


function enrichFromGlossary(fw){
  const hit = (window.GLOSSARY || []).find(x => x.slug === fw.slug);
  if (!hit) return fw; // no change if not found
  return {
    ...fw,
    label: hit.term || fw.label,             // prefer glossary term as label
    status: hit.status || fw.status,
    tags: Array.from(new Set([...(fw.tags||[]), ...(hit.tags||[])])),
    categories: Array.from(new Set([...(fw.categories||[]), ...(hit.categories||[])])),
    sources: hit.sources || fw.sources
  };
}

if (searchEl){
  // Live filter as you type
  searchEl.addEventListener('input', ()=>{
    buildFrameworkOptions(searchEl.value);
  });

  // Keyboard niceties on the search box
  searchEl.addEventListener('keydown', (e)=>{
    // Ctrl/Cmd+K handled globally elsewhere — keep it
    if (e.key === 'Enter'){
      // Rebuild once more to be 100% in-sync with what's visible
      buildFrameworkOptions(searchEl.value);
      const first = sel.options[0];
      if (first){
        const t = activeTab();
        sel.value = first.value;   // mirror visually
        t.id = first.value;        // commit selection
        t.fields = {};
        renderFields(); emitAll(); nudgeFieldsSwap();
      }
    } else if (e.key === 'ArrowDown'){
      // Move focus into the result list so arrow keys can pick an item
      e.preventDefault();
      sel.focus();
    } else if (e.key === 'Escape'){
      // Clear filter and show all
      searchEl.value = '';
      buildFrameworkOptions('');
      const hint = document.getElementById('fwHint'); if (hint){ hint.hidden = true; hint.textContent = ''; }
      sel.focus();
    }
  });

  // Global: Ctrl/Cmd+K focuses the search bar
  document.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if ((k === 'k') && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      searchEl.focus();
      searchEl.select();
    }
  });
}


if (allBtn){
  allBtn.addEventListener('click', ()=>{
    searchEl.value = '';
    buildFrameworkOptions('');
    sel.focus(); // user can open the native dropdown
  });
}

function activeTab(){ return state.tabs[state.active]; }

function tabLabel(t){
  const fw = FRAMEWORKS.find(f=>f.id===t.id);
  return fw ? fw.label : 'Untitled';
}

function addTab(copyCurrent=true){
  // Always start new tabs blank on the placeholder template
  const none = FRAMEWORKS.find(f => f.id === 'none') || FRAMEWORKS[0];
  const next = { id: none?.id || null, fields:{}, extra: undefined };

  state.tabs.push(next);
  state.active = state.tabs.length - 1;

  renderTabs();
  buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
  renderFields();
  emitAll();
}


function closeTab(idx){
  if (state.tabs.length <= 1) return; // keep at least one
  state.tabs.splice(idx, 1);
  if (state.active >= state.tabs.length) state.active = state.tabs.length - 1;
  renderTabs(); buildFrameworkOptions(document.getElementById('fwSearch')?.value||'');
  renderFields(); emitAll();
}

function clearOrCloseTab(idx){
  // If there is more than one tab, behave like close.
  if (state.tabs.length > 1){
    closeTab(idx);
    return;
  }

  // Single tab: reset this tab to the default "— Select a template —"
  const none = FRAMEWORKS.find(f => f.id === 'none') || FRAMEWORKS[0];
  state.tabs[0] = { id: none?.id || null, fields: {}, extra: undefined };
  state.active = 0;

  // Re-render UI
  renderTabs();
  buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
  renderFields();
  emitAll();
}


function switchTab(idx){
  if (idx<0 || idx>=state.tabs.length) return;
  state.active = idx;
  renderTabs(); buildFrameworkOptions(document.getElementById('fwSearch')?.value||'');
  renderFields(); emitAll(); nudgeFieldsSwap();
}

function renderTabs(){
  const bar = document.getElementById('tabbar');
  if (!bar) return;
  bar.innerHTML = '';
  const many = state.tabs.length > 1;
  bar.hidden = !many;
  if (!many) return;

  state.tabs.forEach((t, i)=>{
    const b = document.createElement('div');
    b.className = 'tab' + (i===state.active?' active':'');
    b.title = 'Switch to this template';
    b.addEventListener('click', (e)=>{
      // ignore clicks on the close button itself
      if (e.target.closest('.x')) return;
      switchTab(i);
    });

    const title = document.createElement('span');
    title.textContent = tabLabel(t);
    b.appendChild(title);

    const x = document.createElement('button');
    x.className = 'x'; x.type='button'; x.textContent = 'x';
    x.title = 'Remove this template';
    x.addEventListener('click', (e)=>{ e.stopPropagation(); closeTab(i); });
    b.appendChild(x);

    bar.appendChild(b);
  });
}

      function nudgeFieldsSwap(){
  const f = document.getElementById('fields');
  if (!f) return;
  f.classList.remove('fields-swap');
  // reflow to restart animation
  void f.offsetWidth;
  f.classList.add('fields-swap');
}
      

function makePromptForTab(t){
  const fw = FRAMEWORKS.find(f=>f.id===t.id);
  if (!fw) return '';
  const meta = enrichFromGlossary ? enrichFromGlossary(fw) : fw; // safe if enrichment not present
  const ctx = ctxString ? ctxString() : '';
  const merged = {
    ctx,
    audience: document.getElementById('audience')?.value || '',
    style:    document.getElementById('style')?.value || '',
    tone:     document.getElementById('tone')?.value || '',
    ...(t.fields || {})
  };
  const body = fw.template(merged);
  // If the user hasn't typed anything, fall back to the framework's boosters
const boosterFallback = Array.isArray(fw.boosters) ? fw.boosters.join(' ') : '';
const rawExtra = (t.extra ?? '').trim();
const extra = rawExtra.length ? rawExtra : boosterFallback;
const extraText = extra ? `Additional instructions: ${extra}` : '';
  const header = meta.definition ? `Using ${meta.label}: ${meta.definition}` : `Using ${meta.label}.`;
  return [header, body, extraText].filter(Boolean).join('\n').replace(/\n{3,}/g,'\n\n').trim();
}

function emitAll(){
  // keep legacy preview in #out (active tab)
  const out = document.getElementById('out');
  if (out){
    const txt = makePromptForTab(activeTab() || {});
    out.textContent = txt || '';
    
 refreshPromptCountersSoon(); // keep counters in sync with any preview update

  }

  // render all cards
  const deck = document.getElementById('outDeck');
  if (!deck) return;
  deck.innerHTML = '';
  state.tabs.forEach((t, i)=>{
    const card = document.createElement('div');
    card.className = 'outCard';

    const head = document.createElement('div');
    head.className = 'outHead';
    const title = document.createElement('div');
    title.className = 'title';
    title.textContent = tabLabel(t);
    head.appendChild(title);

    const actions = document.createElement('div');
    actions.className = 'actions';

  // Clear from the card (resets when only one tab; closes when multiple)
const x = document.createElement('button');
x.className = 'x'; 
x.type = 'button'; 
x.textContent = 'Clear';
x.title = (state.tabs.length > 1) ? 'Remove this template' : 'Clear this template';
x.addEventListener('click', ()=> clearOrCloseTab(i));
actions.appendChild(x);


    head.appendChild(actions);
    card.appendChild(head);

    const body = document.createElement('div');
    body.className = 'outBody';
    body.textContent = makePromptForTab(t);
    card.appendChild(body);

    deck.appendChild(card);
  });
}


    function renderFields(){
      const t = activeTab();
const fw = FRAMEWORKS.find(f=>f.id===t.id);

// Tab context chip
{
  const ctx = document.createElement('div');
  ctx.id = 'tabContext';
  const idx = (Number.isInteger(state.active) ? state.active : 0) + 1;
  ctx.textContent = `Editing: Tab ${idx} • ` + (fw ? fw.label : 'No template');
  fieldsWrap.appendChild(ctx);
}


      help.textContent = fw.help;
      fieldsWrap.innerHTML='';
fw.fields.forEach(f=>{
  const wrap = document.createElement('div');
  wrap.className = 'field';

  // Label
  const lab = document.createElement('label');
  lab.textContent = f.label;
  lab.htmlFor = `${f.id || f.key}`;
  wrap.appendChild(lab);

  // Special case: dynamic tasks list (repeatable textareas)
  if (f.type === 'dynamic_tasks'){
    const list = document.createElement('div');
    list.className = 'tasksList';

    // Helper to read/write the field into state as a single newline-joined string
    const getValues = () =>
      Array.from(list.querySelectorAll('textarea'))
        .map(ta => ta.value.trim());

    const sync = ()=>{
      const tvals = getValues().filter(Boolean).join('\n');
      (t.fields || (t.fields = {}))[f.key] = tvals;
      emit();
    };

    const addTask = (value='')=>{
      const idx = list.querySelectorAll('textarea').length + 1;

      const item = document.createElement('div');
      item.style.marginTop = idx === 1 ? '0' : '10px';

      const small = document.createElement('div');
      small.className = 'tinyLabel';
      small.textContent = `Task ${idx}`;
      item.appendChild(small);

      const ta = document.createElement('textarea');
      ta.placeholder = f.ph ? `${f.ph}` : `Describe task ${idx}…`;
      ta.value = value;
      item.appendChild(ta);

      // Live updates + inline counter on each task field
      fieldInput(ta, sync);
      setupCounter(ta);

      list.appendChild(item);
      addBtn.parentElement.appendChild(addBtn); // keep button under the newest
      ta.focus();
    };

    // Seed from any saved value (newline-separated), else start with one empty
    const seed = (t.fields && t.fields[f.key]) ? String(t.fields[f.key]) : '';
    const parts = seed ? seed.split(/\n+/).map(s=>s.trim()).filter(Boolean) : [''];
    parts.forEach(v => addTask(v));
    // Ensure state is synced even if initial values came from seed
    sync();

    // Add Task button
    const addBtn = document.createElement('button');
    addBtn.type = 'button';
    addBtn.className = 'btn sm';
    addBtn.textContent = '+ Add task';
    addBtn.style.marginTop = '8px';
    addBtn.addEventListener('click', ()=> addTask(''));

    wrap.appendChild(list);
    wrap.appendChild(addBtn);

    // Optional helper text
    if (f.desc){
      const d = document.createElement('div');
      d.className = 'desc';
      d.textContent = f.desc;
      wrap.appendChild(d);
    }

    fieldsWrap.appendChild(wrap);
    return; // important: skip the default single-input branch
  }

  // DEFAULT single input/textarea branch
  const holder = document.createElement('div');
  holder.className = 'fieldHolder';
let input;
if (f.type === 'textarea'){
  input = document.createElement('textarea');
} else {
  input = document.createElement('input');
  input.type = 'text';
}

input.placeholder = f.ph || '';
input.id = f.key;
input.value = (t.fields && t.fields[f.key]) || '';

/* -- Special case: persona typeahead -- */
if (f.type === 'typeahead' && f.key === 'persona_name'){
  holder.classList.add('taWrap');
  const list = document.createElement('div');
  list.className = 'taList';
  list.hidden = true;
  holder.appendChild(input);
  holder.appendChild(list);

  let activeIndex = -1;
  function renderSuggestions(q){
    const hits = personaFilter(q, 30);
    list.innerHTML = '';
    activeIndex = -1;
    if (!hits.length){ list.hidden = true; return; }
    hits.forEach((p, idx)=>{
      const item = document.createElement('div');
      item.className = 'taItem';
      item.innerHTML = `<span class="name">${p.name}</span>
                        <span class="sub">${p.profession||''}${p.tags?.length?` • ${p.tags.join(', ')}`:''}</span>`;
item.addEventListener('click', (e)=>{
  // Keep UI and state in sync BEFORE re-render to beat any pending input events
  input.value = p.name || '';
  (t.fields || (t.fields = {})).persona_name = input.value;

  applyPersonaToTab(t, p);
  t.fields.end = (t.fields.end || '');

  // Hide suggestions and re-render fields
  list.hidden = true;
  renderFields(); 
  emit();

  // Optional: jump cursor to End goal next
  const endInput = document.querySelector('#end');
  if (endInput) endInput.focus();
});

      list.appendChild(item);
    });
    list.hidden = false;
  }

  input.addEventListener('input', ()=>{
    (t.fields || (t.fields = {}))[f.key] = input.value;
    if (input.value.trim().length === 0){ list.hidden = true; emit(); return; }
    renderSuggestions(input.value);
    emit();
  });

  input.addEventListener('keydown', (e)=>{
    const items = Array.from(list.children);
    if (list.hidden || !items.length) return;

    if (e.key === 'ArrowDown'){ e.preventDefault(); activeIndex = Math.min(items.length-1, activeIndex+1); }
    if (e.key === 'ArrowUp'){   e.preventDefault(); activeIndex = Math.max(0, activeIndex-1); }
    if (e.key === 'Escape'){ list.hidden = true; return; }

if (e.key === 'Enter' && activeIndex >= 0){
  e.preventDefault();
  items[activeIndex].dispatchEvent(new Event('click', {bubbles:true}));
  return;
}

    items.forEach((n,i)=> n.classList.toggle('active', i===activeIndex));
  });

  // Hide on blur (delay so clicks register)
  input.addEventListener('blur', ()=> setTimeout(()=> list.hidden = true, 120));
} else {
  // Normal field (text/textarea)
  holder.appendChild(input);
}

// Save + preview updates (works for both normal and typeahead)
wrap.appendChild(holder);
fieldInput(input, ()=>{
  (t.fields || (t.fields = {}))[f.key] = input.value;
  emit(); // will call emitAll() + totals
});


  // Inline counter (Stage 1)
  setupCounter(input);

  // Optional helper text (unchanged)
  if (f.desc){
    const d = document.createElement('div');
    d.className = 'desc';
    d.textContent = f.desc;
    wrap.appendChild(d);
  }

  fieldsWrap.appendChild(wrap);
});

      
      

// --- Additional instructions box (prefilled from per-framework boosters) ---
{
  const wrap = document.createElement('div');
  wrap.className = 'field';

  const label = document.createElement('label');
  label.textContent = 'Additional instructions';
  label.setAttribute('for', 'extra');

  const holder = document.createElement('div');
  holder.className = 'fieldHolder';

  const ta = document.createElement('textarea');
  ta.id = 'extra';
  ta.rows = 3;

  // Deterministic behavior: use placeholder for boosters; user text wins if present
  const def = defaultBooster(t.id);
  const cur = (t.extra || '').trim();
  if (cur) ta.value = cur;
  if (!cur && def) ta.placeholder = def;

  holder.appendChild(ta);
  wrap.appendChild(label);
  wrap.appendChild(holder);

  // Save + preview updates
  fieldInput(ta, ()=>{
    t.extra = ta.value.trim();
    emit();
  });

  // Inline counter (Stage 1)
  setupCounter(ta);

  fieldsWrap.appendChild(wrap);
}
// --- end Additional instructions box ---




// meta box (enriched from glossary when available)
chips.innerHTML = '';
const meta = enrichFromGlossary(fw);

// Build a boxed section so everything stacks nicely
const box = document.createElement('div');
box.className = 'metaBox';
chips.appendChild(box);

// Row 1: Open in Glossary (its own line)
if (meta?.slug){
  const row = document.createElement('div');
  row.className = 'metaRow';
  const a = document.createElement('a');
  a.className = 'chip metaLink';
  a.href = `../glossary/index.html#${meta.slug}`;
  a.textContent = 'Open in Glossary';
  a.title = meta.label;
  row.appendChild(a);
  box.appendChild(row);
}

// Optional status (still small, under its own row)
if (meta?.status){
  const row = document.createElement('div');
  row.className = 'metaRow';
  const st = document.createElement('span');
  st.className = 'chip';
  st.textContent = `Status: ${meta.status}`;
  row.appendChild(st);
  box.appendChild(row);
}

// Helper to group tags by key
function groupTags(list){
  const groups = {};
  (list || []).forEach(t=>{
    const [k, v] = String(t).split(':');
    if (!k || v === undefined) return;
    (groups[k] ||= []).push(v);
  });
  return groups;
}

// Row 2: CATEGORIES (title line + its own pill row)
if (meta?.categories?.length){
  const title = document.createElement('div');
  title.className = 'metaSectionTitle';
  title.textContent = 'Categories';
  box.appendChild(title);

  const row = document.createElement('div');
  row.className = 'metaPills';
  meta.categories.forEach(cat=>{
    const s = document.createElement('span');
    s.className = 'chip';
    s.textContent = cat;
    row.appendChild(s);
  });
  box.appendChild(row);
}

// Row 3: TAGS grouped by key (type/topic/phase/level/…)
const tagGroups = groupTags(meta?.tags);
const keys = Object.keys(tagGroups);
if (keys.length){
  const title = document.createElement('div');
  title.className = 'metaSectionTitle';
  title.textContent = 'Tags';
  box.appendChild(title);

  keys.sort().forEach(key=>{
    const row = document.createElement('div');
    row.className = 'metaPills';

    const k = document.createElement('span');
    k.className = 'tinyLabel';
    k.textContent = key;
    row.appendChild(k);

    tagGroups[key].forEach(val=>{
      const s = document.createElement('span');
      s.className = 'chip';
      s.textContent = val;
      row.appendChild(s);
    });

    box.appendChild(row);
  });
}


    }

    function ctxString(){
      const u = $('#usecase').value.trim();
      const a = $('#audience').value.trim();
      const s = $('#style').value.trim();
      const t = $('#tone').value.trim();
      const bits=[];
      if(u) bits.push(`Use‑case: ${u}`);
      if(a) bits.push(`Audience: ${a}`);
      if(s) bits.push(`Style: ${s}`);
      if(t) bits.push(`Tone: ${t}`);
      return bits.join(' | ');
    }

function emit(){
  emitAll();
  updatePromptTotal();
  updateOutPreviewCounter();
}

   sel.addEventListener('change', ()=>{
  const t = activeTab();
  t.id = sel.value;
  t.fields = {};      // reset fields when switching template
  if (!t.extra || !t.extra.trim()) delete t.extra; // NEW: allow booster prefill for new template
   renderTabs(); renderFields(); emitAll(); nudgeFieldsSwap();
});

// New: one-click commit of the top search hit when a filter is active.
// This avoids the awkward "pick something else, then come back" dance.
sel.addEventListener('mousedown', () => {
  const q = (document.getElementById('fwSearch')?.value || '').trim();
  if (!q) return; // only intervene when filtering
  const first = sel.options[0];
  if (!first) return;
  const t = activeTab();
  if (t.id !== first.value) {
    // Mirror UI and commit selection
    sel.value = first.value;
    t.id = first.value;
    t.fields = {};
    if (!t.extra || !t.extra.trim()) delete t.extra; // allow booster prefill on new template
    renderTabs(); renderFields(); emitAll(); nudgeFieldsSwap();
  }
});


    ['usecase','audience','style','tone'].forEach(id=>{
      const el = document.getElementById(id); fieldInput(el, emit);
    });
    
    // Persist common fields + visual filled state
const COMMON_IDS = ['usecase','audience','style','tone'];
function toggleFilled(el){ el.classList.toggle('filled', !!el.value.trim()); }
COMMON_IDS.forEach(id=>{
  const el = document.getElementById(id);
  const saved = localStorage.getItem('fw_'+id);
  if (saved !== null) el.value = saved;
  toggleFilled(el);
  el.addEventListener('input', ()=>{
    localStorage.setItem('fw_'+id, el.value);
    toggleFilled(el);
    emit();
  });
});

function getAllGeneratedText(){
  const deck = document.getElementById('outDeck');
  if (deck && deck.children.length){
    const titles = deck.querySelectorAll('.outCard .title');
    const bodies  = deck.querySelectorAll('.outCard .outBody');
    const parts = [];
    titles.forEach((t,i)=>{
      const head = (t.textContent || '').trim();
      const body = (bodies[i]?.textContent || '').trim();
      parts.push(`### ${head}\n${body}`);
    });
    return parts.join('\n\n').trim();
  }
  // fallback to single preview
  const out = document.getElementById('out');
  return (out?.textContent || '').trim();
}


    // Actions
$('#copyBtn').addEventListener('click', async ()=>{
  // If deck is visible, gather all card bodies; else copy the single preview
  const deck = document.getElementById('outDeck');
  const text = deck && !deck.hidden
    ? Array.from(deck.querySelectorAll('.outBody'))
        .map(n => n.textContent.trim())
        .filter(Boolean)
        .join('\n\n---\n\n')
    : (document.getElementById('out')?.textContent || '');
  try { await navigator.clipboard.writeText(text); }
  catch(e){ console.warn('Copy failed', e); }
  const dlg = document.getElementById('msg'); dlg?.showModal();
});



   $('#openBtn').addEventListener('click', async ()=>{
  const txt = getAllGeneratedText();
  const dlg = $('#msg');
  // 1) Copy to clipboard (primary guarantee)
  let copied = false;
  try { await navigator.clipboard.writeText(txt); copied = true; }
  catch(e){ console.warn('Clipboard write failed:', e); }
  try {
    const url = 'https://chat.openai.com/?q=' + encodeURIComponent(txt);
    window.open(url, '_blank', 'noopener,noreferrer');
  } catch(e){ console.warn('Open failed', e); }
  // message text is updated just below in your existing code





      // 2) Attempt to open ChatGPT with a prefilled query param (best-effort)
      function buildChatURL(prompt){
        const base = localStorage.getItem('chatgpt_target') || 'https://chatgpt.com/';
        try{
          const u = new URL(base);
          // Try multiple param names — ChatGPT may ignore them, but harmless.
          u.searchParams.set('q', prompt);
          u.searchParams.set('prompt', prompt);
          u.searchParams.set('input', prompt);
          return u.toString();
        }catch(err){
          console.warn('Bad chat target URL; falling back.', err);
          return 'https://chatgpt.com/';
        }
      }
      const url = buildChatURL(txt);
      window.open(url, '_blank', 'noopener');

      // 3) User feedback
      const msg = copied
        ? 'Prompt copied to clipboard. A ChatGPT tab opened. If the prompt did not auto-appear, paste with Cmd/Ctrl+V.'
        : 'Opened ChatGPT. Could not auto-copy the prompt (browser denied). Please select the text in the preview and copy it manually.';
      const msgEl = document.getElementById('msgText');
      if(msgEl) msgEl.textContent = msg; else console.info(msg);
      dlg.showModal();
    });
    
    // Add template (single, guarded wiring)
(function wireAddTemplate(){
  if (window.__addTemplateWired) return;
  window.__addTemplateWired = true;
  const btn = document.getElementById('addPromptBtn');
  if (!btn) return;
  btn.addEventListener('click', (e)=>{
    e.preventDefault();
    if (typeof addTab === 'function') addTab(true);
  });
})();


    // Theme
    const themeBtn = $('#theme');
    themeBtn.addEventListener('click', ()=>{
      const light = document.documentElement.getAttribute('data-theme')==='light';
      document.documentElement.setAttribute('data-theme', light?'' : 'light');
      themeBtn.setAttribute('aria-pressed', light? 'false':'true');
      themeBtn.querySelector('span:last-child').textContent = light? 'Light':'Dark';
    });
    
    // --- Dialog: make it closable via button and backdrop ---
const dlg = document.getElementById('msg');
const dlgClose = document.getElementById('dlgClose');

// Close when clicking the "Close" button
if (dlgClose) dlgClose.addEventListener('click', () => dlg.close());

// Close when clicking the backdrop (outside the dialog content)
dlg.addEventListener('click', (e) => {
  // If the click target is the <dialog> itself, it's the backdrop
  if (e.target === dlg) dlg.close();
});

// Optional: ensure Esc always closes (most browsers do this by default)
dlg.addEventListener('cancel', () => {
  // no-op; letting the default behavior close the dialog
});

// --- Draggable vertical resizer for the left panel ---
(function(){
  const resizer = document.getElementById('resizer');
  const root = document.documentElement;
  const MIN = 280, MAX = 900;

  // restore saved width if present
  const saved = parseInt(localStorage.getItem('fw_leftW') || '', 10);
  if (!isNaN(saved)) root.style.setProperty('--leftW', saved + 'px');

  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

  let dragging = false;

  function onMove(clientX){
    const wrapRect = document.querySelector('.wrap').getBoundingClientRect();
    const x = clientX - wrapRect.left;           // position inside the grid
    const newW = clamp(x, MIN, MAX);             // left column width
    root.style.setProperty('--leftW', newW + 'px');
    localStorage.setItem('fw_leftW', String(newW));
  }

  resizer.addEventListener('mousedown', (e)=>{
    dragging = true; e.preventDefault();
    document.body.style.userSelect = 'none';
  });
  window.addEventListener('mousemove', (e)=>{ if(dragging) onMove(e.clientX); });
  window.addEventListener('mouseup', ()=>{
    if(dragging){ dragging=false; document.body.style.userSelect=''; }
  });

  // Touch support
  resizer.addEventListener('touchstart', (e)=>{
    dragging = true; document.body.style.userSelect='none';
  }, {passive:true});
  window.addEventListener('touchmove', (e)=>{
    if(!dragging) return;
    const t = e.touches[0]; if(t) onMove(t.clientX);
  }, {passive:true});
  window.addEventListener('touchend', ()=>{
    if(dragging){ dragging=false; document.body.style.userSelect=''; }
  });

  // Keyboard resizing for accessibility
  resizer.addEventListener('keydown', (e)=>{
    const step = (e.shiftKey ? 40 : 20);
    const cur = parseInt(getComputedStyle(root).getPropertyValue('--leftW') || '360', 10);
    if (e.key === 'ArrowLeft'){ const w = clamp(cur - step, MIN, MAX); root.style.setProperty('--leftW', w + 'px'); localStorage.setItem('fw_leftW', String(w)); }
    if (e.key === 'ArrowRight'){ const w = clamp(cur + step, MIN, MAX); root.style.setProperty('--leftW', w + 'px'); localStorage.setItem('fw_leftW', String(w)); }
  });
})();

    // init
    renderFields(); emit();
  })();
  </script>
</body>
</html>
