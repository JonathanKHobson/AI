<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prompt Template Builder (beta)</title>
  <style>
:root{
  --bg:#0b0f14; --panel:#121821; --card:#0f151d; --muted:#9db0c3; --text:#e7eff7;
  --accent:#4ea1ff; --chip:#1b2533; --border:#1b2838; --radius:14px; --gap:14px;
  --green:#2ecc71; --yellow:#f1c40f; --red:#e74c3c; --purple:#a78bfa;
  /* new */
  --border-strong:#2a3a4f; /* darker/lighter than --border for better separation in dark */
}
:root[data-theme="light"]{
  --bg:#f7fafc; --panel:#ffffff; --card:#ffffff; --muted:#5a6b7b; --text:#121621;
  --accent:#2563eb; --chip:#f1f5f9; --border:#d8e0ea;
  /* new: slightly stronger than light border for clear separation */
  --border-strong:#b9c6d6;
}

.modal::backdrop{ background: rgba(0,0,0,.4); }
.modal-body{ width:min(880px, 96vw); padding:16px; background:var(--bg); color:var(--text);
  border:1px solid var(--border); border-radius:12px; }
.modal-header{ display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; }
.modal-section .field{ margin:12px 0; }
.modal-footer{ display:flex; gap:8px; justify-content:flex-end; margin-top:8px; }
.modal .icon.close{ font-size:20px; line-height:1; }
#actionPreview{ width:100%; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
.scope-row{ display:flex; gap:24px; align-items:center; flex-wrap:wrap; }
.radio{ display:flex; gap:8px; align-items:center; }
.radio input{ transform: translateY(1px); }
.hint{ opacity:.7; font-weight:400; }
.note{ margin:6px 0 0; opacity:.75; font-size:.9em; }

.toast{
  position: fixed;
  right: 16px;
  bottom: 16px;
  max-width: 60ch;
  padding: 10px 12px;
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--chip);
  color: var(--text);
  box-shadow: 0 6px 20px rgba(0,0,0,.18);
  z-index: 9999;
  font-size: 13px;
}

.metaRow {
  display: flex;
  gap: 0.5rem;
}

.toast[hidden]{ display:none; }


    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans",sans-serif}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}

    header{
      display:flex;align-items:center;gap:12px;padding:12px 16px;position:sticky;top:0;z-index:10;
      background:linear-gradient(180deg,var(--panel),rgba(0,0,0,0));border-bottom:1px solid var(--border);
      backdrop-filter: blur(8px);
    }
    header .spacer{flex:1}
    .btn{cursor:pointer;border:1px solid var(--border);background:var(--chip);color:var(--text);padding:8px 12px;border-radius:10px}
    .btn.primary{background:var(--accent);color:#061422;border:none}
    /* default (dark theme): keep dark text on light accent */
.btn.primary{ color:#061422; }

/* Subheader that matches our h3 section look */
.subhead{
  margin: 0 0 6px;
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
  padding-left: 12px;       /* aligns with the tabs' left pad */
}


/* light theme: white text on darker accent for AA contrast */
:root[data-theme="light"] .btn.primary{ color:#ffffff; }

    .btn.sm{padding:6px 10px;font-size:14px;border-radius:8px}
    
    /* Danger button + helper text for save/reset */
.btn.danger{ background:var(--red); color:#fff; border:none }

/* Universal affordances */
.btn:hover{ transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,.18); }
.btn:active{ transform: translateY(0); box-shadow:none; }
.btn:focus-visible{ outline:none; box-shadow:0 0 0 2px rgba(78,161,255,.45); }

/* Make chips and tabs feel interactive */
.chip:hover, .tab:hover{ box-shadow:0 0 0 2px rgba(78,161,255,.20); }


.saveHelp{ margin-top:6px; }

   .toggle{
  display:inline-flex;align-items:center;gap:8px;
  border:1px solid var(--border);background:var(--chip);
  padding:6px 10px;border-radius:999px;
  color: var(--text); /* force readable text in both themes */
}
.toggle:hover, .toggle:focus-visible{
  box-shadow: 0 0 0 2px rgba(78,161,255,.25);
  outline: none;
}

    .dot{width:16px;height:16px;border-radius:50%;background:linear-gradient(180deg,#fdd835,#fbc02d);box-shadow:inset 0 -3px 6px rgba(0,0,0,.25)}
    :root[data-theme="light"] .dot{background:linear-gradient(180deg,#121621,#394554)}

    .wrap{
  display:grid;
  grid-template-columns: var(--leftW, 360px) 6px 1fr; /* left | resizer | right */
  gap:16px;
  padding:16px;
}

/* Add breathing room to the right of the resizer only */
/* Extra breathing room between resizer and the right panel */
.wrap > #resizer + .panel{
  margin-left: 12px;     /* shifts panel away from the handle */
  padding-left: 12px;    /* shifts content away from the panel edge */
}



    .panel{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius)}
    .panel h2{margin:0;padding:12px 14px;border-bottom:1px solid var(--border);font-size:18px}
    .panel section{padding:14px}

    label{display:block;margin:10px 0 6px;color:var(--muted);font-size:16px; font-weight:600;}
    
.resizer{
  width:6px;
  cursor: col-resize;
  background: transparent;
  position: relative;
}
.resizer::after{
  content:'';
  position:absolute; inset:0;
  background: linear-gradient(to bottom, transparent 0, transparent 20%, var(--border) 20%, var(--border) 80%, transparent 80%, transparent 100%);
  opacity:.6;
}
.resizer:hover::after{ opacity:1; }

/* Clearer grab handle inside the 6px resizer */
.resizer::before{
  content:'';
  position:absolute;
  top:12px; bottom:12px;
  left:50%; transform:translateX(-50%);
  width:2px; border-radius:2px;
  background: rgba(255,255,255,.30);        /* dark mode default */
}
:root[data-theme="light"] .resizer::before{
  background: rgba(0,0,0,.28);              /* light mode default */
}
.resizer:hover::before,
.resizer:focus-visible::before{
  background: var(--accent);
  box-shadow: 0 0 0 2px rgba(78,161,255,.25);
}

.finder{ margin-bottom:8px; }
.finder input{ width:100%; }


.finder{ position:relative; margin-bottom:8px; }
.finder input{ width:100%; padding-right:64px; }
.finder .btn.tiny{
  position:absolute; right:6px; top:50%; transform:translateY(-50%);
  padding:4px 8px; font-size:12px; border-radius:999px;
}

/* Hint: shows "Showing N/M" when filtered */
.finder .hint{
  position:absolute;
  right:56px;              /* sits just to the left of the All button */
  top:50%; transform:translateY(-50%);
  font-size:12px;
  color:var(--muted);
  opacity:.9;
  pointer-events:none;     /* don't steal clicks from the input */
}

.ta-menu {
  position: absolute; z-index: 50; margin-top: 4px; max-height: 240px; overflow:auto;
  border: 1px solid var(--border-color, #ddd); border-radius: 8px; background: var(--bg, #fff);
  box-shadow: 0 6px 24px rgba(0,0,0,.08); min-width: 260px;
}
.ta-menu .ta-item { padding: 8px 10px; cursor: pointer; }
.ta-menu .ta-item:hover, .ta-menu .ta-item.ta-active { background: rgba(0,0,0,.06); }




/* Not Using */
.useChips{ display:flex; flex-wrap:wrap; gap:8px; margin:6px 0 8px; }
.useChips .chip{ cursor:pointer; user-select:none; }
.useChips .chip.active{ outline:2px solid var(--accent); }

.suggestions{ display:flex; flex-wrap:wrap; gap:6px; margin:6px 0 12px; }
.suggestions .suggest{ cursor:pointer; padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:var(--chip); font-size:12px; }


/* Nice vertical rhythm between fields */
.field + .field{ margin-top:12px; }


/* Inline counters inside inputs/textareas */
.fieldHolder{ position:relative; }
.counter{
  position:absolute; right:10px; bottom:8px;
  font-size:11px; color:var(--muted); opacity:0.85;
  pointer-events:none; user-select:none;
}
.hasCounter{ padding-right:76px !important; }   /* prevent overlap with typing */
textarea.hasCounter{ padding-right:84px !important; } /* a tad more room for multi-line */


    input[type="text"], textarea, select{
      width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);
      background:var(--card);color:var(--text);outline:none;
    }
    
    input.filled, textarea.filled{
  box-shadow: 0 0 0 2px var(--accent) inset;
  background: rgba(78,161,255,.08);
}
:root[data-theme="light"] input.filled,
:root[data-theme="light"] textarea.filled{
  background: rgba(37,99,235,.06);
}

    textarea{min-height:100px;resize:vertical}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  
    .help{
  color:var(--muted);
  font-size:12px;          /* smaller than label (13px) */
  line-height:1.35;
  margin-top:6px;            /* space from input */
  opacity:0.9;               /* lighter than labels */
}



.desc{
  color:var(--muted);
  font-size:13px;       /* smaller than label */
  line-height:1.35;
  margin-top:6px;
  opacity:0.8;            /* a bit stronger than .help so it reads clearly */
}

/* Meta block under the Glossary button */
.metaSection{
  margin-top:10px;
  font-size:12px;
  color:var(--muted);
  font-weight:700;
  text-transform:uppercase;
  letter-spacing:.04em;
}

.metaGroup{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:8px;
  margin-top:6px;
}

.tinyLabel{
  font-size:11px;
  color:var(--muted);
  opacity:.85;
  padding:2px 8px;
  border:1px solid var(--border);
  border-radius:999px;
  background:var(--chip);
}

/* Dedicated meta box */
#metaChips{
  display:block !important;                 /* stop flex from .chips */
}
.metaBox{
  margin-top:12px;
  padding:12px;
  border:1px solid var(--border);
  border-radius: var(--radius);
  background: var(--card);
}
.metaRow{ margin-top:8px; }
.metaSectionTitle{
  margin-top:10px;
  font-size:12px;
  color:var(--muted);
  font-weight:700;
  text-transform:uppercase;
  letter-spacing:.04em;
}
.metaPills{
  display:flex; flex-wrap:wrap; gap:8px; margin-top:6px;
}
.metaLink{
  display:inline-flex; margin-bottom:4px;
}
.tinyLabel{
  font-size:11px; color:var(--muted); opacity:.85;
  padding:2px 8px; border:1px solid var(--border); border-radius:999px; background:var(--chip);
}

/* Tabs */
.tabs{ display:flex; gap:6px; margin:6px 0 10px; flex-wrap:wrap; padding-left:12px; }

.tab{
  display:inline-flex; align-items:center; gap:8px;
  padding:6px 10px; border:1px solid var(--border); border-radius:999px;
  background:var(--chip); cursor:pointer; font-size:12px;
}
.tab.active{ outline:2px solid var(--accent); }
.tab .x{
  border:none; background:transparent; cursor:pointer; font-size:14px; line-height:1;
  color:var(--muted);
}
.tab .x:hover{ color:var(--text); }

.tab .x{ cursor: pointer; }
.tab .x:disabled{ cursor: not-allowed; opacity:.6; }

/* Output deck */
#outDeck{ display:flex; flex-direction:column; gap:12px; margin-top:12px; }
.outCard{
  border:1px solid var(--border); border-radius:var(--radius); background:var(--card);
  padding:10px 12px;
}
.outHead{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  margin-bottom:8px; font-size:13px; color:var(--muted);
  padding-right:10px; /* NEW: gives breathing room so Clear isn't flush right */
}

.outHead .title{ font-weight:600; color:var(--text); }
.outHead .actions{
  display:flex; gap:8px;
  margin-right:2px; /* NEW: tiny inset for safety on narrow widths */
}


.outBody{ white-space:pre-wrap; font-family:inherit; font-size:13px; line-height:1.45; }
.outActions{ margin-top:10px; }

/* Subtle flash to signal the panel changed */
.fields-swap {
  animation: fieldsSwapFlash 280ms ease-out;
}
@keyframes fieldsSwapFlash {
  0%   { box-shadow: 0 0 0 2px var(--accent) inset; background: rgba(78,161,255,.06); }
  100% { box-shadow: none; background: transparent; }
}

/* A small context chip above the fields */
#tabContext {
  margin-bottom: 8px;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 999px;
  background: var(--chip);
  font-size: 12px;
  color: var(--muted);
}

    .chips{display:flex;flex-wrap:wrap;gap:8px}
   .chip{
  background:var(--chip);
  border:1px solid var(--border);
  border-radius:999px;
  padding:6px 10px;
  font-size:12px;
  line-height:1;
  color:var(--text);           /* ← fixes black-on-black in dark mode */
  cursor:pointer;              /* nicer affordance */
  transition:background .15s ease,border-color .15s ease,box-shadow .15s ease,color .15s ease;
}

/* Extra guards for common dark-theme toggles */
[data-theme="dark"] .chip{ color:var(--text); }
.theme-dark .chip{ color:var(--text); }
.dark .chip{ color:var(--text); }

/* Subtle hover/focus to aid discoverability without hurting contrast */
.chip:hover{ border-color:var(--accent); }
.chip:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }

/* Space chips away from the search bar */
#datasetChips{ margin:8px 0 12px; }  /* top 8px, bottom 12px */


.chip[aria-pressed="true"]{
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(78,161,255,.2) inset;
  color: var(--text);
}

.chip[aria-pressed="false"]{ opacity:.92; }   /* still fully readable */
.chip[aria-pressed="true"]{ opacity:1; font-weight:600; }

/* Bias multi-select chips */
.chipsInput{ display:flex; flex-wrap:wrap; gap:6px; align-items:center; padding:6px; border:1px solid var(--border); border-radius:10px; background:var(--card); min-height:36px; }
.chipsInput input{ flex:1; min-width:140px; border:none; outline:none; background:transparent; padding:6px 8px; font-size:14px; }
.chipsInput .chip{ display:inline-flex; align-items:center; gap:6px; }
.chipsInput .chip .x{ margin-left:4px; border:none; background:transparent; cursor:pointer; font-size:14px; line-height:1; padding:0 4px; color:var(--muted); }
.chipsInput .dot{ width:8px; height:8px; border-radius:999px; display:inline-block; }
.dot.bias{ background:#d97706; }       /* amber */
.dot.technique{ background:#059669; }  /* green */
.dot.dilemma{ background:#7c3aed; }    /* purple */
.dot.custom{ background:#6b7280; }     /* gray */



    pre{margin:0;padding:14px;background:var(--card);border-top:1px solid var(--border);border-radius:0 0 var(--radius) var(--radius);overflow:auto;white-space:pre-wrap}

    .pill{padding:4px 8px;border-radius:999px;border:1px solid var(--border);font-size:12px}
    .pill[data-val="framework"]{color:var(--green)}
    .pill[data-val="pattern"]{color:var(--yellow)}
    
    .pill[data-val="tasks"]{color:var(--accent)}

    
   /* Additional instructions box spacing */
#extra{
  min-height: 72px;
  resize: vertical;
}
 
   /* --- Prompt totals under title --- */
.prompt-total{
  margin: -6px 0 8px 0;
  font-size:12px;
  color: var(--muted);
  opacity: 0.9;
}

/* Master total under the "Generated prompt" header */
.prompt-total--master{
  margin-top: 8px;
  padding-top: 6px;
  border-top: 1px solid var(--border);
}


/* --- Current preview inline counter (top-right of the big preview) --- */
/* We attach this inside the #out element */
#out{ position: relative; } /* harmless if already positioned elsewhere */
#out .outCounter{
  position:absolute;
  top:8px; right:8px;
  font-size:12px; color:var(--muted); opacity:0.9;
  pointer-events:none; user-select:none;
  background: transparent; /* stays invisible atop your preview */
}


/* ==== Context Coach (single, for current preview) ==== */
/* Sits inside #out, just below the top-right small counter */
#out .outCoach{
  position:absolute;
  right:8px; 
  top:30px; /* directly below .outCounter at top:8px */
  font-size:12px; 
  color:var(--muted); 
  opacity:0.95;
  pointer-events:none; 
  user-select:none;
}
#out .outCoach[hidden]{ display:none; }

/* Chip look with AA-safe colored left border */
#out .outCoach .pill{
  display:inline-flex; align-items:center;
  padding:2px 10px; border-radius:999px;
  background:var(--chip); border:1px solid var(--border);
  font-weight:700;
  /* color stays readable; accent via left border only */
}

/* State colors */
#out .outCoach[data-state="low"]     .pill{ border-left:4px solid var(--yellow); }
#out .outCoach[data-state="near"]    .pill{ border-left:4px solid var(--accent); }
#out .outCoach[data-state="good"]    .pill{ border-left:4px solid var(--green); }
#out .outCoach[data-state="perfect"] .pill{ border-left:4px solid var(--purple); }
#out .outCoach[data-state="high"]    .pill{ border-left:4px solid var(--red); }

/* Make room at the top of the preview when coach is visible */
#out.hasCoach{
  padding-top:52px;
  /* NEW: reserve horizontal space for the coach pill */
  padding-right: var(--coachPad, 160px) !important;
}

#out.hasCounter{
  padding-top:28px;
  /* NEW: reserve horizontal space for the corner counter */
  padding-right: var(--counterPad, 72px);
}
   
    /* Independent scroll for the left panel */
#configPanel{
  position: sticky;
  top: 60px; /* sits under the sticky header */
  max-height: calc(100vh - 60px - 16px); /* header + grid padding */
  overflow: auto; /* vertical & horizontal if needed */
}


/* Area labels to distinguish preview vs deck */
.areaLabel{
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 8px; margin:8px 0 6px;
  border:1px solid var(--border);
  background:var(--chip);
  border-radius:999px; font-size:12px; color:var(--muted);
}
.areaLabel .dot{ width:6px; height:6px; border-radius:999px; background:var(--accent); }

/* Stronger section separation (dark-friendly) */
#out{
  border:1px solid var(--border-strong);
  background:linear-gradient(180deg, rgba(78,161,255,.05), transparent 45%);
  border-radius: var(--radius);
}
.outCard{
  border-color: var(--border-strong);
}

/* Tabs close button: compact circular */
.tab .x{
  color: var(--text);
  background: var(--chip);
  border: 1px solid var(--border-strong);
  border-radius: 999px;
  width: 22px; height: 22px; line-height:1;
  display:inline-flex; align-items:center; justify-content:center;
}

.tab .x:hover{ box-shadow: 0 0 0 2px rgba(78,161,255,.25); }
.tab .x:focus-visible{ outline:none; box-shadow:0 0 0 2px rgba(78,161,255,.45); }

/* Deck Clear/Delete: danger pill */
.outHead .x{
  background: var(--red);
  color: #fff;
  border: none;
  border-radius: 999px;
  padding: 4px 10px; line-height:1;
  display:inline-flex; align-items:center; justify-content:center;
  width: auto; height: auto;       /* kill forced 22x22 circle */
  min-width: 0;
}
.outHead .x:hover{ filter: brightness(1.05); box-shadow:0 0 0 2px rgba(78,161,255,.20); }
.outHead .x:focus-visible{ outline:none; box-shadow:0 0 0 2px rgba(78,161,255,.45); }

/* Defensive: in light theme, never fall back to chip styles */
:root[data-theme="light"] .outHead .x{
  background: var(--red);
  color: #fff;
}

/* Card "Clear/Delete" pill — let the text breathe */
.outHead .actions .x{
  min-width: auto;
  height: auto;
  padding: 2px 10px;
  border-radius: 999px;
  line-height: 1.2;
  background: var(--chip);
  border: 1px solid var(--border);
  cursor: pointer;                 /* 👈 make it a hand */
}
.outHead .actions .x:disabled{
  cursor: not-allowed; opacity: .6;
}

.outHead .actions .x:hover{
  filter: brightness(1.05);
  box-shadow: 0 0 0 2px rgba(78,161,255,.20);
}
.outHead .actions .x:focus-visible{
  outline: none;
  box-shadow: 0 0 0 2px rgba(78,161,255,.45);
}
/* Explicitly pin in light theme too (avoid accidental white-on-white) */
:root[data-theme="light"] .outHead .actions .x{
  background: var(--red);
  color: #fff;
}


/* === Typeahead (persona picker) === */
.taWrap{ position:relative; }
.taList{
  position:absolute; left:0; right:0; top:100%;
  margin-top:6px; z-index:50;
  background:var(--card); border:1px solid var(--border); border-radius:10px;
  max-height:220px; overflow:auto;
  box-shadow: 0 6px 18px rgba(0,0,0,.25);
}
.taList[hidden]{ display:none; }
.taItem{
  padding:8px 10px; cursor:pointer; border-bottom:1px solid var(--border);
  font-size:13px; display:flex; flex-direction:column; gap:2px;
}
.taItem:last-child{ border-bottom:none; }
.taItem .name{ color:var(--text); font-weight:600; }
.taItem .sub{ color:var(--muted); font-size:12px; }
.taItem.active{ outline:2px solid var(--accent); outline-offset:-2px; }

.panel select{
  width:100%;
  padding:8px 36px 8px 10px;      /* room for chevron */
  border:1px solid var(--border);
  border-radius:10px;
  background:var(--card);
  color:var(--text);
  outline:none;
  appearance:none;                /* show our chevron */
  background-image:
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><path d='M4 6l4 4 4-4' fill='none' stroke='%2399AABB' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/></svg>");
  background-repeat:no-repeat;
  background-position:right 10px center;
  cursor:pointer;
}

/* Dropdown helper cluster */
.pickerHelp { margin-top: 6px; }

/* First line: concise “how the list works” caption */
#fwListHelp.desc{
  margin: 0 0 6px;           /* space below this caption */
  font-size: 12px;
  line-height: 1.35;
  opacity: .9;
}

/* Second line: template definition/use-cases, visually separated */
#fwHelp.help{
  margin-top: 10px;
  padding-top: 10px;
  border-top: 2px dashed var(--border);
  line-height: 1.4;
}

/* No divider when there’s nothing to say */
#fwHelp.help:empty{
  margin-top: 0;
  padding-top: 0;
  border-top: none;
}


/* Make "Open in Glossary" look linky and stand out */
.metaLink {
  background: transparent;
  border: none;
  padding: 0;
  color: var(--accent);
  text-decoration: underline;
  cursor: pointer;
}
/* Non-clickable meta chips shouldn't look clickable */
.metaPills .chip { cursor: default; }


/* More breathing room between chips and search */
#datasetChips { margin: 6px 0 10px; }

/* Chips: readable in dark mode when not selected */
#datasetChips .chip {
  background: var(--chip);
  color: var(--text);
  border: 1px solid var(--border);
}
#datasetChips .chip[aria-pressed="true"] {
  background: var(--accent);
  color: #061422;                 /* dark text on accent */
}
:root[data-theme="light"] #datasetChips .chip[aria-pressed="true"]{
  color: #fff;                    /* light theme: white text on accent */
}

:root[data-theme="light"] .btn.danger{ background: var(--red); color:#fff; }
:root[data-theme="dark"]  .btn.danger{ background: var(--red); color:#fff; }


    @media (max-width: 960px){
      .wrap{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <header>
    <a class="btn sm" href="../glossary/index.html" target="_blank" rel="noopener">← Back to Full Glossary</a>
    <a class="btn sm" href="./templates-glossary.html" target="_blank" rel="noopener">Open Template Glossary</a>

    <strong>Prompt Framework Builder</strong>
    <span class="pill" data-val="framework" title="Thinking Structures & Patterns">thinking structures + patterns</span>
    <span class="spacer"></span>
<button id="copyBtn" class="btn sm">Copy Prompt</button>
<button id="openBtn" class="btn primary sm">💬 Ask ChatGPT</button>
    <button id="theme" class="toggle" aria-pressed="false" title="Toggle theme"><span class="dot"></span><span>Light</span></button>
  </header>

  <div class="wrap">
  <div class="panel" id="configPanel">
      <h2>Configure</h2>
      
<!-- Hidden until >1 template -->
<h3 id="tabbarLabel" class="subhead" hidden>Active templates</h3>
<div id="tabbar" class="tabs" hidden></div>

      
      <section>
        <label for="frameworkSel">Templates</label>
        
        <div id="datasetChips" class="chips" role="toolbar" aria-label="Template sets">
  <button class="chip" id="chipPatterns" aria-pressed="true"  type="button" title="Frameworks & patterns">Patterns</button>
<button class="chip" id="chipTasks"    aria-pressed="false" type="button" title="Task-specific templates (preview)">Tasks</button>

</div>
        
<div id="finderBar" class="finder">
  <input id="fwSearch" type="text" placeholder="Find a template by name, tag, or use case… (Ctrl/Cmd+K)">
  <!-- NEW: rich typeahead suggestions list (same style as persona typeahead) -->
  <div id="fwSuggest" class="taList" role="listbox" hidden></div>
  <span id="fwHint" class="hint" aria-live="polite" hidden></span>
  <button id="fwAll" type="button" class="btn tiny" title="Show full list">All</button>
</div>
<div id="finderHelp" class="desc" style="margin:6px 0 8px">
  Type to filter the <b>dropdown list below</b>.
</div>




<select id="frameworkSel" aria-label="Search results: templates list"></select>
<div class="pickerHelp">
  <div id="fwListHelp" class="desc">
    This dropdown shows matching templates. Click to open it, then pick one.
  </div>
  <div id="fwHelp" class="help" aria-live="polite"></div>
</div>


      </section>

      <section>
      
      <!-- Hidden until >1 template -->
      
      <div class="help"><br>Fill in the template below. Only fill what helps. Empty fields are omitted in the prompt.</div>

      
<div id="tabbar" class="tabs" hidden></div>


        <h3 style="margin:0 0 6px;font-size:14px">Common context (optional)</h3>
        <div class="row">
          <div>
            <label for="usecase">Use‑case / scenario</label>
            <input id="usecase" type="text" placeholder="e.g., Launch email for a new service" />
          </div>
          <div>
<label for="audience">Audience</label>
<div id="audienceChipsWrap" class="chipsInput">
  <div id="audienceChips" class="chips"></div>
  <input id="audience" type="text"
         placeholder="e.g., Busy SMB owners"
         autocomplete="off" data-typeahead="persona" />
</div>
<div id="audienceSuggestions" class="ta-menu" hidden></div>

          </div>
        </div>
        <div class="row">
          <div>
            <label for="style">Style</label>
            <input id="style" type="text" placeholder="e.g., Practical, plain language" />
          </div>
          <div>
            <label for="tone">Tone</label>
            <input id="tone" type="text" placeholder="e.g., Friendly, confident" />
          </div>
        </div>
        
                <div class="row">
          <div style="grid-column:1/-1">
          <div id="biasCtx" class="field">
            <label for="biasInput">Bias awareness &amp; mitigation</label>
            <div id="biasChipsWrap" class="chipsInput">
              <div id="biasChips" class="chips"></div>
              <input id="biasInput" type="text" placeholder="Type to add biases, tactics, or dilemmas…" autocomplete="off" />
            </div>
            <div id="biasSuggestions" class="ta-menu" hidden></div>
            <div class="help">Add biases to avoid, mitigation tactics to apply, or ethical dilemmas to consider. We’ll adapt the prompt accordingly.</div>
          </div>
          </div>
        </div>
        
      </section>

      <section>
        <h3 style="margin:0 0 6px;font-size:14px">Template fields</h3>
        <div id="fields"></div>
        <div class="help"><br> Only fill what helps. Empty fields are omitted in the prompt.</div>
        
        <!-- Secondary quick actions: mirrors header actions -->
<div class="actionsRow actionsRow--secondary" style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 14px">
<button id="copyBtn2" class="btn sm" title="Copy active tab">Copy Prompt</button>
<button id="openBtn2" class="btn primary sm" title="Open active tab in ChatGPT">💬 Ask ChatGPT</button>
<button id="worksheetBtn2" class="btn sm" title="Open a printable worksheet for the active template">Print Worksheet</button>
    <button id="clearBtn2" class="btn sm danger" title="Clear just this prompt">Clear</button>
</div>

      </section>

      <section>
        <div class="chips" id="metaChips"></div>
      </section>
    </div>
<div id="resizer" class="resizer" role="separator" aria-orientation="vertical" aria-valuemin="280" aria-valuemax="900" tabindex="0"></div>
    <div class="panel">
      <h2>Generated prompt</h2>
      <div id="masterPromptTotal" class="prompt-total prompt-total--master" aria-live="polite"></div>

<div id="previewLabel" class="areaLabel"><span class="dot"></span><span>Preview • Active tab</span></div>
<pre id="out"></pre>

<div class="outActions" style="margin-top:8px">
  <button id="addPromptBtn" class="btn primary" title="Add another template to this session">+ Add template</button>
  <button id="copyAllBtnFooter" class="btn sm" data-action="copy-all">Copy Prompt</button>
<button id="openAllBtnFooter" class="btn primary sm" data-action="open-all">💬 Ask ChatGPT</button>
</div>

<div id="deckLabel" class="areaLabel" hidden><span class="dot"></span><span>Output deck • All templates</span></div>



<div id="outDeck" class="out-deck" hidden></div>

<!-- New: add-template button under the preview/deck -->



    </div>

    
  </div>

  <dialog id="msg"><form method="dialog" style="margin:0">
    <section id="msgText" style="padding:16px">
    
    Prompt copied to clipboard. A new tab opened; if it didn’t prefill, paste with Cmd/Ctrl+V.
    
    </section>
    
    
    <footer style="display:flex;justify-content:flex-end;gap:8px;padding:12px;border-top:1px solid var(--border)">
    
    <button class="btn" type="button" id="dlgClose">Close</button>

  </form></dialog>
  
  
<dialog id="actionModal" class="modal">
  <form method="dialog" class="modal-body" id="actionForm" aria-labelledby="actionTitle">
    <header class="modal-header">
      <h3 id="actionTitle">Copy Prompt</h3>
      <button type="button" class="icon close" aria-label="Close" id="actionClose">×</button>
    </header>

    <section class="modal-section">
      <div class="field">
        <label>Which content?</label>
        <div class="scope-row" role="radiogroup" aria-label="Which content">
          <label class="radio">
            <input type="radio" name="scope" value="prompt" id="scopePrompt" checked>
            <span>Current prompt <small class="hint">(the active template)</small></span>
          </label>
          <label class="radio">
            <input type="radio" name="scope" value="all" id="scopeAll">
            <span>All prompts <small class="hint">(everything in your list)</small></span>
          </label>
        </div>
      </div>

      <div class="field">
        <label for="actionPreview">Preview (you can edit before confirming)</label>
        <textarea id="actionPreview" rows="14" spellcheck="false"></textarea>
      </div>

      <p id="actionNote" class="note" hidden></p>
    </section>

    <footer class="modal-footer">
      <button type="submit" class="btn primary" id="actionConfirm">Copy</button>
      <button type="button" class="btn" id="actionCancel">Cancel</button>
    </footer>
  </form>
</dialog>

<div id="toast" class="toast" aria-live="polite" hidden></div>

  
  <script src="./templates.data.js"></script>
  <script src="./glossary.data.js"></script>
  
    <script>
  // Frameworks DB (window.FRAMEWORKS) — safe to load even if absent
  (function tryLoadFrameworks(){
    const s = document.createElement('script');
    s.src = './templates.data.js';
    s.onerror = ()=>console.info('Template data not found at ./template.data.js.');
    document.head.appendChild(s);
  })();
</script>

  <!-- Load the glossary if available. Adjust the path to match your repo layout. -->
  <script>
    // If this file lives at /AI/tools/framework-template-builder.html,
    // the glossary may be at /AI/glossary/glossary.data.js. We try to load it dynamically.
    (function tryLoadGlossary(){
      const s = document.createElement('script');
      s.src = './glossary.data.js';
      s.onerror = ()=>console.info('Glossary not found at ./glossary/glossary.data.js — continuing without it.');
      document.head.appendChild(s);
    })();
  </script>
  
  <script>
  // Personas DB (window.PERSONAS) — safe to load even if absent
  (function tryLoadPersonas(){
    const s = document.createElement('script');
    s.src = './persona.data.js';
    s.onerror = ()=>console.info('Persona data not found at ./persona.data.js — typeahead will still allow free text.');
    document.head.appendChild(s);
  })();
</script>

<script>
// Biases DB (window.BIASES) — safe to load even if absent
(function tryLoadBiases(){
  function inject(path, final=false){
    const s = document.createElement('script');
    s.src = path;
    s.onload = ()=>{
      try{
        // Rebuild index if our helpers exist
        if (typeof buildBiasIndex === 'function') {
          window.__BIAS_IDX = null;
          buildBiasIndex();
        }
        // Let listeners (chips/typeahead) re-render suggestions
        document.dispatchEvent(new Event('biases-loaded'));
      }catch(e){}
    };
    s.onerror = ()=>{
      console.info('Bias data not found at', path);
      // Light fallbacks for common naming/paths
      if (!final) {
        const next = (path === './bias.data.js')
          ? './biases.data.js'
          : (path === './biases.data.js')
            ? './biased.data.js'
            : null;
        if (next) { inject(next); return; }
      }
    };
    document.head.appendChild(s);
  }
  inject('./bias.data.js');
})();
</script>



<script>
// S4 — Lazy loader for tasks dataset (window.TASK_TEMPLATES)
function ensureTasksLoaded(onready){
  if (Array.isArray(window.TASK_TEMPLATES)) { onready && onready(); return; }
  const s = document.createElement('script');
  s.src = './templates.tasks.data.js';
  s.onload  = ()=> onready && onready();
  s.onerror = ()=> { console.info('Tasks dataset not found at ./templates.tasks.data.js'); onready && onready(); };
  document.head.appendChild(s);
}
</script>

  <script>
  (function(){
    const $ = s=>document.querySelector(s);
    // Use the new Action Modal for copy/open flows
window.__USE_ACTION_MODAL__ = true;

(function ensureThemeToggle(){
  const btn = document.getElementById('theme');
  if (!btn) return;
  btn.addEventListener('click', ()=>{
    const root = document.documentElement;
    const cur  = root.getAttribute('data-theme') || 'dark';
    const next = (cur === 'light') ? 'dark' : 'light';
    root.setAttribute('data-theme', next);
    btn.setAttribute('aria-pressed', next === 'light' ? 'true' : 'false');
    const label = btn.querySelector('span:last-child');
    if (label) label.textContent = next === 'light' ? 'Dark' : 'Light';
    try{
      const ui = JSON.parse(localStorage.getItem('pb.v1.ui') || '{}');
      ui.theme = next;
      localStorage.setItem('pb.v1.ui', JSON.stringify(ui));
    }catch(_){}
    // Let your existing "saveUI after click" hook run too (it already exists).
  });
})();
    
    
    // --- Persistence (localStorage) ------------------------------
const LS_KEYS = {
  state: 'pb.v1.state',
  ui:    'pb.v1.ui'
};

// Clear all saved app data and reload
function resetSavedSession(){
  try{
    localStorage.removeItem(LS_KEYS.state);
    localStorage.removeItem(LS_KEYS.ui);
  }catch(e){ console.warn('Reset failed:', e); }
  location.reload();
}


function _safeParse(s){ try{ return JSON.parse(s); }catch(e){ return null; } }

function loadSavedState(){
  const raw = localStorage.getItem(LS_KEYS.state);
  return raw ? _safeParse(raw) : null;
}

let _saveTimer = null;
function saveNow(){
  try{
    // 'state' is our live app state (tabs, fields, active, etc.)
    localStorage.setItem(LS_KEYS.state, JSON.stringify(state));
  }catch(e){
    console.warn('localStorage save failed:', e);
  }finally{
    _saveTimer = null;
  }
}
function scheduleSave(){
  if (_saveTimer) clearTimeout(_saveTimer);
  _saveTimer = setTimeout(saveNow, 300); // debounce a bit
}

// UI (theme + left panel width)
function applySavedUI(){
  const ui = _safeParse(localStorage.getItem(LS_KEYS.ui)) || {};
  if (ui.leftW){
    document.documentElement.style.setProperty('--leftW', ui.leftW);
  }
  if (ui.theme){
    document.documentElement.setAttribute('data-theme', ui.theme);
    const tbtn = document.getElementById('theme');
    if (tbtn){
      const isLight = ui.theme === 'light';
      tbtn.setAttribute('aria-pressed', isLight ? 'true' : 'false');
      // optional label swap if your button shows "Light"/"Dark"
      const label = tbtn.querySelector('span:last-child');
      if (label) label.textContent = isLight ? 'Dark' : 'Light';
    }
  }
}

function saveUI(){
  try{
    const wrap = document.querySelector('.wrap');
    const cols = wrap ? getComputedStyle(wrap).gridTemplateColumns : '';
    const leftW = cols ? cols.split(' ')[0] : getComputedStyle(document.documentElement).getPropertyValue('--leftW') || '360px';
    const theme = document.documentElement.getAttribute('data-theme') || 'dark';
    localStorage.setItem(LS_KEYS.ui, JSON.stringify({ leftW, theme, ts: Date.now() }));
  }catch(e){
    console.warn('localStorage UI save failed:', e);
  }
}

// Apply UI prefs ASAP (before building the UI)
applySavedUI();

// Global safety nets: save on input/changes and when leaving
document.addEventListener('input',  scheduleSave, { capture:true });
document.addEventListener('change', scheduleSave, { capture:true });
document.addEventListener('visibilitychange', ()=>{ if (document.hidden) saveNow(); });
window.addEventListener('beforeunload', saveNow);

// Save UI when theme toggles or the resizer stops
window.addEventListener('load', ()=>{
  const themeBtn = document.getElementById('theme');
  if (themeBtn){
    themeBtn.addEventListener('click', ()=> setTimeout(saveUI, 0)); // after your existing toggle code runs
  }
  const resizer = document.getElementById('resizer');
  if (resizer){
    // Pointer up = resizing done; also catch keyboard nudges on the resizer
    resizer.addEventListener('pointerup', saveUI);
    resizer.addEventListener('keyup',     saveUI);
  }
});
    
    /* ===== Persona helpers ===== */
function personaIndex(){
  // Returns an array; empty if the data hasn't loaded yet.
  return Array.isArray(window.PERSONAS) ? window.PERSONAS : [];
}

function personaFilter(query, max=20){
  const q = (query||'').trim().toLowerCase();
  if (!q) return [];
  const toks = q.split(/\s+/).filter(Boolean);
  const src = personaIndex();

  // Score by token coverage + prefix boost on name/id
  const scored = src.map(p=>{
    const hay = (p.meta?.search_text || `${p.name||''} ${p.profession||''} ${(p.tags||[]).join(' ')}`).toLowerCase();
    let s = 0;
    for (const t of toks){
      if (hay.includes(t)) s += 2;
      if (String(p.name||'').toLowerCase().startsWith(t)) s += 4;
      if (String(p.id||'').toLowerCase().startsWith(t)) s += 3;
    }
    return {p, s};
  }).filter(x=>x.s>0)
    .sort((a,b)=> b.s - a.s || String(a.p.name).localeCompare(String(b.p.name)));

  return scored.slice(0,max).map(x=>x.p);
}

function personaText(p){
  const asList = v => Array.isArray(v) ? v : String(v||'').split(/[\n,]+/).map(s=>s.trim()).filter(Boolean);
  const bullets = arr => asList(arr).map(x=>'• ' + x).join('\n');
  const csv     = arr => asList(arr).join(', ');
  return [
    p.name && `Name: ${p.name}`,
    p.profession && `Profession: ${p.profession}`,
    p.summary && `Summary: ${p.summary}`,
    p.description && `Description: ${p.description}`,
    (p.core_tasks && asList(p.core_tasks).length) && `Core tasks:\n${bullets(p.core_tasks)}`,
    (p.skills && asList(p.skills).length) && `Skills: ${csv(p.skills)}`,
    (p.vocabulary && asList(p.vocabulary).length) && `Vocabulary: ${csv(p.vocabulary)}`,
    (p.goals && asList(p.goals).length) && `Goals:\n${bullets(p.goals)}`,
    (p.pain_points && asList(p.pain_points).length) && `Pain points:\n${bullets(p.pain_points)}`,
    (p.tools && asList(p.tools).length) && `Tools: ${csv(p.tools)}`
  ].filter(Boolean).join('\n');
}


function applyPersonaToTab(tab, persona){
  if (!tab || !persona) return;
  // Do NOT touch 'end' (user-supplied goal)
  tab.fields = {
    ...(tab.fields||{}),
    persona_name: persona.name || '',
    profession:   persona.profession || '',
    summary:      persona.summary || '',
    description:  persona.description || '',
    core_tasks:   (persona.core_tasks||[]).join('\n'),
    skills:       (persona.skills||[]).join(', '),
    vocabulary:   (persona.vocabulary||[]).join(', '),
    goals:        (persona.goals||[]).join('\n'),
    pain_points:  (persona.pain_points||[]).join('\n'),
    tools:        (persona.tools||[]).join(', ')
  };
}


// --- Persona string helpers (global) ---
// Build a compact inline string (defaults to Name/Profession/Summary with labels)
function personaInlineFlexible(p, opts = {}){
  const include = Array.isArray(opts.include) && opts.include.length
    ? opts.include : ['name','profession','summary'];
  const labels = opts.labels !== false;
  const sep = typeof opts.sep === 'string' ? opts.sep : ' · ';
  const labelMap = {
    name: labels ? 'Name: ' : '',
    profession: labels ? 'Profession: ' : '',
    role: labels ? 'Role: ' : '',
    title: labels ? 'Title: ' : '',
    summary: labels ? 'Summary: ' : '',
    bio: labels ? 'Bio: ' : '',
    expertise: labels ? 'Expertise: ' : ''
  };
  return include
    .map(k => ((p?.[k] ?? '').toString().trim() ? labelMap[k] + p[k] : ''))
    .filter(Boolean)
    .join(sep);
}

// Lightweight “just the name”
function personaInline(p){ return p?.name || ''; }

// Template fill utility (e.g., "Hello {name}")
function personaFillTemplate(tpl, p){
  return String(tpl||'').replace(/\{(\w+)\}/g, (_,k)=> (p?.[k] ?? ''));
}


// --- Persona datasource (expects window.PERSONAS or similar) ---
function getAllPersonas(){
  const raw = (window.PERSONAS || window.personas || window.PERSONA_LIBRARY || []);
  return Array.isArray(raw) ? raw : [];
}

function personaKeyFields(p){
  return [
    p.name || p.label || p.persona_name || '',
    p.profession || '',
    p.summary || '',
    (p.tags||[]).join(' '),
    (p.skills||''),
    (p.vocabulary||''),
    (p.goals||''),
    (p.pain_points||'')
  ].join(' ').toLowerCase();
}

// Tiny in-memory index
let __PERSONA_IDX = null;
function buildPersonaIndex(){
  const list = getAllPersonas();
  __PERSONA_IDX = list.map((p,i)=>({
    i, name: String(p.name || p.label || 'Unknown').trim(),
    hay: personaKeyFields(p), p
  }));
  return __PERSONA_IDX;
}
function searchPersonas(q){
  if (!__PERSONA_IDX) buildPersonaIndex();
  const toks = String(q||'').toLowerCase().split(/[^a-z0-9]+/).filter(Boolean);
  if (!toks.length) return __PERSONA_IDX.slice(0,8);
  return __PERSONA_IDX
    .map(r=>{
      let s = 0; for (const t of toks){ if (r.hay.includes(t)) s++; }
      return { ...r, s };
    })
    .filter(r => r.s > 0)
    .sort((a,b)=> b.s - a.s || a.name.localeCompare(b.name))
    .slice(0,8);
}

// Render a compact block for prompts (NOT the Audience field)
function formatPersonaForPrompt(p){
  const list = s => String(s||'').split(/[\n,]+/).map(x=>x.trim()).filter(Boolean);
  const bullets = (arr, label) => arr.length ? `${label}:\n` + arr.map(x=>`- ${x}`).join('\n') : '';
  return [
    `Audience profile — ${p.name || p.label || 'Selected Persona'}`,
    p.summary && `Summary: ${p.summary}`,
    bullets(list(p.core_tasks),'Core tasks'),
    bullets(list(p.skills),'Skills'),
    bullets(list(p.goals),'Goals'),
    bullets(list(p.pain_points),'Pain points'),
    bullets(list(p.vocabulary),'Vocabulary'),
    bullets(list(p.tools),'Tools')
  ].filter(Boolean).join('\n');
}

// Attach lightweight typeahead to the Audience input
function attachPersonaTypeahead(inputEl, menuEl, getActiveTab, onChange){
  function close(){ menuEl.hidden = true; menuEl.innerHTML = ''; active = -1; }
  let items = [], active = -1;

  inputEl.addEventListener('input', ()=>{
    const q = inputEl.value.trim();
    items = searchPersonas(q);
    if (!items.length){ close(); return; }
menuEl.innerHTML = items.map((r,idx)=>{
  const sum = (r.p && (r.p.summary || r.p.definition || '') || '').toString().trim();
  return `<div class="ta-item${idx===0?' ta-active':''}" data-idx="${idx}">
    <div class="name"><strong>${r.name}</strong></div>
    ${sum ? `<div class="sub">${sum}</div>` : ''}
  </div>`;
}).join('');
    active = 0;
    // position the menu under input
    const rect = inputEl.getBoundingClientRect();
    menuEl.style.minWidth = rect.width + 'px';
    menuEl.hidden = false;
  });

  inputEl.addEventListener('keydown', (e)=>{
    if (menuEl.hidden) return;
    if (e.key === 'ArrowDown'){ e.preventDefault(); active = Math.min(active+1, items.length-1); highlight(); }
    else if (e.key === 'ArrowUp'){ e.preventDefault(); active = Math.max(active-1, 0); highlight(); }
    else if (e.key === 'Enter' || e.key === ','){ e.preventDefault(); pick(active); }
    else if (e.key === 'Escape'){ close(); }
  });

  menuEl.addEventListener('mousedown', (e)=>{
    const el = e.target.closest('.ta-item'); if (!el) return;
    pick(parseInt(el.dataset.idx,10)||0);
  });

  function highlight(){
    [...menuEl.querySelectorAll('.ta-item')].forEach((n,i)=> n.classList.toggle('ta-active', i===active));
  }
function pick(i){
  const r = items[i]; if (!r) return;
  close();

  // Persist to the active tab (as before)
  const tab = getActiveTab && getActiveTab();
  let names = [];
  if (tab){
    tab.common = tab.common || {};
    const arr = Array.isArray(tab.common.audience_personas) ? tab.common.audience_personas : [];

    // De-dupe by id or name
    const exists = arr.some(p =>
      String(p.id||p.name).toLowerCase() === String(r.p.id||r.p.name).toLowerCase()
    );
    if (!exists) arr.push(r.p);

    tab.common.audience_personas = arr;
    tab.common.audience_persona  = arr[0]; // back-compat single
    names = arr.map(p => p.name).filter(Boolean);

    // What the user sees in the field (just the names, comma-sep)
    tab.common.audience = names.join(', ');
    if (onChange) onChange(tab);
  }

  // Replace the partial token with the normalized CSV
  inputEl.value = names.length ? names.join(', ') : (r.name || '');
  inputEl.classList.toggle('filled', !!inputEl.value);
  inputEl.focus();
}



  // Click-away to close
  document.addEventListener('click', (ev)=>{
    if (ev.target!==inputEl && !menuEl.contains(ev.target)) close();
  });
}

/* ===== Bias helpers ===== */
// Minimal, persona-parallel utilities. Won’t touch existing persona flows.

function biasIndex(){
  // Prefer window.* but gracefully accept a top-level BIASES const
  if (Array.isArray(window.BIASES))        return window.BIASES;
  if (Array.isArray(window.biases))        return window.biases;
  if (Array.isArray(window.BIAS_LIBRARY))  return window.BIAS_LIBRARY;
  if (Array.isArray(window.BIAS))          return window.BIAS;
  try { if (typeof BIASES !== 'undefined' && Array.isArray(BIASES)) return BIASES; } catch (e){}
  return [];
}


function _biasAsList(v){ return Array.isArray(v) ? v : String(v||'').split(/[\n,]+/).map(s=>s.trim()).filter(Boolean); }
function _biasBullets(arr){ return _biasAsList(arr).map(x=>'• '+x).join('\n'); }
function _biasCSV(arr){ return _biasAsList(arr).join(', '); }

function biasKeyFields(b){
  return [
    b.name || b.label || b.bias_name || '',
    b.kind || '',
    b.category || '',
    b.summary || b.definition || b.description || '',
    (b.tags||[]).join(' '),
    (b.contexts||''),
    (b.mitigations||''),
    (b.examples||'')
  ].join(' ').toLowerCase();
}

let __BIAS_IDX = null;
function buildBiasIndex(){
  const list = biasIndex();
  __BIAS_IDX = list.map((b,i)=>({
    i,
    name: String(b.name || b.label || 'Unknown bias').trim(),
    hay: biasKeyFields(b),
    b
  }));
  return __BIAS_IDX;
}

function searchBiases(q, max=30){
  // Build on first use; if we built too early (empty) but data is now present, rebuild.
  if (!__BIAS_IDX || (__BIAS_IDX.length === 0 && Array.isArray(biasIndex()) && biasIndex().length > 0)) {
    buildBiasIndex();
  }
  const toks = String(q||'').toLowerCase().split(/[^a-z0-9]+/).filter(Boolean);
  if (!toks.length) return (__BIAS_IDX || []).slice(0, Math.min(max, (__BIAS_IDX||[]).length)).map(r=>r.b);
  return (__BIAS_IDX || [])
    .map(r=>{
      let s=0; for (const t of toks){ if (r.hay.includes(t)) s++; if (r.name.toLowerCase().startsWith(t)) s+=2; }
      return { ...r, s };
    })
    .filter(r=> r.s>0)
    .sort((a,b)=> b.s - a.s || a.name.localeCompare(b.name))
    .slice(0, max)
    .map(r=> r.b);
}

// --- Bias lookup & kind helpers (used by chips + directive composer) ---
function getBiasById(id){
  if (!__BIAS_IDX || !__BIAS_IDX.length) buildBiasIndex && buildBiasIndex();
  const needle = String(id || '').toLowerCase();
  const hit = (__BIAS_IDX || []).find(r =>
    String(r.b.id || '').toLowerCase() === needle ||
    String(r.b.name || '').toLowerCase() === needle
  );
  return hit ? hit.b : null;
}
function biasKindOf(b){
  const k = String(b?.kind || '').toLowerCase();
  const c = Array.isArray(b?.category) ? b.category.join(' ').toLowerCase()
                                       : String(b?.category || '').toLowerCase();
  if (/mitigation|technique/.test(k) || /mitigation/.test(c)) return 'technique';
  if (/dilemma|ethical/.test(k)     || /dilemma|ethical/.test(c)) return 'dilemma';
  return 'bias';
}

// --- Autofill helpers (personas/bias/etc.) -------------------------------

function tryAutofillValue(field, sug) {
  // Only for typeahead fields with an autofill directive
  if (!field || !field.autofill) return null;

  // "bias->inline", "persona->inline", etc.
  const [domain, mode] = String(field.autofill).split('->');
  const dataset = field.dataset || field.source || field.autocomplete || ''; // robustness
  const key = sug && (sug.value || sug.id || sug.slug || sug.label);

  if (!key) return null;

  if (domain === 'persona' && mode === 'inline') {
    // Reuse your existing persona inline if present
    return personaInlineLookup(key);
  }

  if (domain === 'bias' && mode === 'inline') {
    return biasInlineLookup(key, dataset);
  }

  // Fallback: not recognized
  return null;
}

// Persona inline lookup (uses your existing store if available)
function personaInlineLookup(key) {
  const lib = (window.DATASETS && (window.DATASETS.persona || window.DATASETS.personas)) || [];
  const p = findByAnyKey(lib, key);
  if (!p) return key;
  // Example inline: "Name — profession; summary"
  const parts = [
    p.name,
    p.profession ? `— ${p.profession}` : null,
    p.summary ? `; ${p.summary}` : null
  ].filter(Boolean);
  return parts.join(' ').replace(/\s+/g,' ').trim();
}

// Bias inline lookup
function biasInlineLookup(key, datasetName) {
  // Prefer the bias dataset explicitly, then any global registry
  const lib =
    (window.DATASETS && window.DATASETS[datasetName || 'bias']) ||
    (window.LIB && (window.LIB.bias || window.LIB.biases)) ||
    (window.DATASETS && (window.DATASETS.bias || window.DATASETS.biases)) ||
    [];

  const b = findByAnyKey(lib, key);
  if (!b) return key;

  // Compose a SINGLE LINE summary similar in spirit to persona->inline
  // Tweak fields as your bias.data.js provides (kind/type/summary/aliases etc.)
  const kind = b.kind || b.type || (b.tags && b.tags.find(t=>/^kind:|^type:/.test(t))) || '';
  const kindInline = kind ? (String(kind).replace(/^.*?:/,'').trim()) : '';

  // Prefer a short summary; otherwise use first sentence of description/notes
  const summary =
    b.summary ||
    (b.description && String(b.description).split(/[.?!]\s/)[0]) ||
    (b.notes && String(b.notes).split(/\n/)[0]) ||
    '';

  const parts = [
    b.name,
    kindInline ? `— ${kindInline}` : null,
    summary ? `; ${summary}` : null
  ].filter(Boolean);

  return parts.join(' ').replace(/\s+/g,' ').trim();
}

// small utility: find object by various keys
function findByAnyKey(list, key) {
  const k = String(key).toLowerCase();
  return list.find(x =>
    (x.id && String(x.id).toLowerCase() === k) ||
    (x.slug && String(x.slug).toLowerCase() === k) ||
    (x.name && String(x.name).toLowerCase() === k) ||
    (x.label && String(x.label).toLowerCase() === k)
  );
}


// Mirror personaFilter signature
function biasFilter(query, max=20){
  const q = (query||'').trim();
  if (!q) return [];
  return searchBiases(q, max);
}

// Rich text block, inline string, and templated fill
function biasText(b){
  return [
    b.name && `Name: ${b.name}`,
    b.kind && `Kind: ${b.kind}`,
    b.category && `Category: ${b.category}`,
    b.summary && `Summary: ${b.summary}`,
    b.definition && `Definition: ${b.definition}`,
    (b.contexts && _biasAsList(b.contexts).length) && `Contexts:\n${_biasBullets(b.contexts)}`,
    (b.mitigations && _biasAsList(b.mitigations).length) && `Mitigations:\n${_biasBullets(b.mitigations)}`,
    (b.examples && _biasAsList(b.examples).length) && `Examples:\n${_biasBullets(b.examples)}`,
    (b.tags && _biasAsList(b.tags).length) && `Tags: ${_biasCSV(b.tags)}`
  ].filter(Boolean).join('\n');
}

function biasInlineFlexible(b, opts = {}){
  const include = Array.isArray(opts.include) && opts.include.length
    ? opts.include : ['name','category','summary'];
  const labels = opts.labels !== false;
  const sep = typeof opts.sep === 'string' ? opts.sep : ' · ';
  const labelMap = {
    name: labels ? 'Name: ' : '',
    kind: labels ? 'Kind: ' : '',
    category: labels ? 'Category: ' : '',
    summary: labels ? 'Summary: ' : ''
  };
  return include
    .map(k => ((b?.[k] ?? '').toString().trim() ? labelMap[k] + b[k] : ''))
    .filter(Boolean)
    .join(sep);
}

function biasFillTemplate(tpl, b){
  return String(tpl||'').replace(/\{(\w+)\}/g, (_,k)=> (b?.[k] ?? ''));
}

// Optional “spread into tab fields” (mirrors applyPersonaToTab)
function applyBiasToTab(tab, bias){
  if (!tab || !bias) return;
  tab.fields = {
    ...(tab.fields||{}),
    bias_name:        bias.name || '',
    bias_kind:        bias.kind || '',
    bias_category:    bias.category || '',
    bias_summary:     bias.summary || '',
    bias_definition:  bias.definition || '',
    bias_contexts:    _biasAsList(bias.contexts).join('\n'),
    bias_mitigations: _biasAsList(bias.mitigations).join('\n'),
    bias_examples:    _biasAsList(bias.examples).join('\n'),
    bias_tags:        _biasAsList(bias.tags).join(', ')
  };
}

/* ===== Bias directive composer ===== */
function composeBiasDirectives(ids){
  const list = Array.isArray(ids) ? ids : [];
  if (!list.length) return { combined:'', awareness:'', mitigations:'', ethics:'' };

  const asObj = id => getBiasById(id) || (String(id).startsWith('custom:') ? { id, name: String(id).slice(7), kind:'custom', summary:'' } : null);
  const items = list.map(asObj).filter(Boolean);

  const buckets = { awareness:[], mitigations:[], ethics:[] };
  for (const b of items){
    const kind = biasKindOf(b);
    if (kind === 'technique') buckets.mitigations.push(b);
    else if (kind === 'dilemma') buckets.ethics.push(b);
    else buckets.awareness.push(b);
  }

  const bullet = (n,s) => s ? `• ${n}: ${String(s).trim()}` : `• ${n}`;

  const aw = buckets.awareness.length
    ? ['Awareness', ...buckets.awareness.map(b => bullet(b.name, b.summary || b.definition || 'Avoid reinforcing; balance sources; ask a neutral clarifying question if risk is detected.'))].join('\n')
    : '';

  const mi = buckets.mitigations.length
    ? ['Mitigations', ...buckets.mitigations.map(b => bullet('Apply ' + b.name, b.summary || b.definition || 'Apply this tactic as appropriate.'))].join('\n')
    : '';

  const et = buckets.ethics.length
    ? ['Ethical considerations', ...buckets.ethics.map(b => bullet(b.name, b.summary || b.definition || 'Surface trade-offs and seek constraints before deciding.'))].join('\n')
    : '';

  const combined = [aw, mi, et].filter(Boolean).join('\n\n');
  return { combined: combined ? 'Bias directives —\n' + combined : '', awareness:aw, mitigations:mi, ethics:et };
}


    
    // --- helper: default booster for a framework id
function defaultBooster(id){
  const fw = FIND(id);
  if (!fw) return '';
  const arr = Array.isArray(fw.boosters) ? fw.boosters : [];
  return arr.join(' ').trim();
}

    const out = $('#out');
    const fieldsWrap = $('#fields');
    const help = $('#fwHelp');
    const chips = $('#metaChips');
    


// Use external dataset loaded by templates.data.js.
// Prefer TEMPLATES, fall back to FRAMEWORKS for older files.
const FRAMEWORKS = (window.TEMPLATES || window.FRAMEWORKS || []);

// S4 — dataset accessors
const PATTERNS = FRAMEWORKS;
function TASKS(){ return Array.isArray(window.TASK_TEMPLATES) ? window.TASK_TEMPLATES : []; }

// Ensure the "— Select a template —" option exists at index 0
function withNone(list){
  return list.some(f=>f && f.id === 'none')
    ? list
    : [{ id:'none', label:'— Template Picker —' }, ...list];
}

// Cross-dataset lookup by id (works for Patterns or Tasks, independent of current chip)
function FIND(id){
  if (!id) return null;
  return (
    (PICKER().find(f => f.id === id)) ||       // prefer what's visible
    (PATTERNS || []).find(f => f.id === id) || // then legacy/patterns
    TASKS().find(f => f.id === id) ||          // then tasks (lazy loaded)
    null
  );
}


// S3 — dataset helpers (no behavior change yet)
// Keep existing S2 helpers if you already added them; these only fill gaps.
window.currentDataset = window.currentDataset || (()=>{
  try { return localStorage.getItem('fw_dataset') || 'patterns'; }
  catch(e){ return 'patterns'; }
});

window.setDataset = window.setDataset || ((ds)=>{
  try { localStorage.setItem('fw_dataset', ds); } catch(e){}
  // Note: S2 may also update chip visuals + pill; that’s fine to live elsewhere.
});

// For now, PICKER() = FRAMEWORKS (no behavior change).
// In S4 we’ll redefine this to return TASKS or PATTERNS based on currentDataset().
// S4 — PICKER now reflects currentDataset()
const PICKER = function(){
  const ds = (typeof currentDataset === 'function') ? currentDataset() : 'patterns';
  return ds === 'tasks' ? withNone(TASKS()) : withNone(PATTERNS);
};




const searchEl = document.getElementById('fwSearch');
const allBtn   = document.getElementById('fwAll');
const sug      = document.getElementById('fwSuggest'); // NEW


// === Framework/Pattern/Task typeahead (rich suggestions under the search box) ===
let fwTaActive = -1;

function fwSubtext(f){
  const uc = (f.use_cases || []).filter(Boolean).slice(0,2).join(' • ');
  if (uc) return uc;
  const t = String(f.definition || f.help || '').trim().replace(/\s+/g,' ');
  return t.length > 140 ? t.slice(0,140) + '…' : t;
}

function rankFrameworks(q){
  const list = (typeof PICKER === 'function') ? PICKER() : [];
  return list
    .map(f => ({ f, s: matchScore(f, q) }))
    .filter(x => x.s > 0)
    .sort((a,b)=> b.s - a.s || a.f.label.localeCompare(b.f.label,'en',{sensitivity:'base'}))
    .map(x=>x.f);
}

function hideFwSuggestions(){
  if (!sug) return;
  sug.hidden = true;
  sug.innerHTML = '';
  fwTaActive = -1;
}

function commitFwPick(id){
  const sel = document.getElementById('frameworkSel');
  if (!sel) return;
  sel.value = id;
  if (typeof switchFramework === 'function') switchFramework(id);
  if (typeof updatePickerPreview === 'function') updatePickerPreview();
  hideFwSuggestions();
}

function renderFwSuggestions(q){
  if (!sug) return;
  const query = (q||'').trim();
  if (!query){ hideFwSuggestions(); return; }

  const doRender = ()=>{
    const ranked = rankFrameworks(query).slice(0,12);
    if (!ranked.length){ hideFwSuggestions(); return; }
    sug.innerHTML = ranked.map(f => `
      <div class="taItem" role="option" data-id="${f.id}">
        <span class="name">${f.label}</span>
        <span class="sub">${fwSubtext(f)}</span>
      </div>
    `).join('');
    fwTaActive = -1;
    sug.hidden = false;
  };

  const ds = (typeof currentDataset === 'function') ? currentDataset() : 'patterns';
  if (ds === 'tasks' && typeof ensureTasksLoaded === 'function') ensureTasksLoaded(doRender);
  else doRender();
}

// Mouse pick
sug?.addEventListener('mousedown', (e)=>{
  const it = e.target.closest('.taItem'); if (!it) return;
  commitFwPick(it.dataset.id);
});

// Close on outside click/blur (delay so clicks register)
document.addEventListener('click', (e)=>{
  if (!sug || sug.hidden) return;
  const inFinder = e.target.closest('#finderBar');
  if (!inFinder) hideFwSuggestions();
});
searchEl?.addEventListener('blur', ()=> setTimeout(hideFwSuggestions, 120));


// S2 — cosmetic dataset chips (no data swap yet)
const chipPatterns = document.getElementById('chipPatterns');
const chipTasks    = document.getElementById('chipTasks');
const modePill     = document.querySelector('span.pill');

// Helpers: persist + reflect pressed state
function currentDataset(){
  return localStorage.getItem('fw_dataset') || 'patterns';
}

// Update the header pill to match dataset mode
function updatePill(ds){
  if (!modePill) return;
  if (ds === 'tasks'){
    // Title & text for Tasks mode
    modePill.dataset.val = 'tasks';                 // safe new value; see optional CSS below
    modePill.title       = 'Specific Tasks';
    modePill.textContent = 'specific tasks';
  } else {
    // Title & text for Patterns/Thinking Structures mode
    modePill.dataset.val = 'framework';             // keep existing styling compatibility
    modePill.title       = 'Thinking Structures & Patterns';
    modePill.textContent = 'thinking structures + patterns';
  }
}

function setDataset(ds){
  localStorage.setItem('fw_dataset', ds);
  chipPatterns?.setAttribute('aria-pressed', String(ds === 'patterns'));
  chipTasks?.setAttribute('aria-pressed',    String(ds === 'tasks'));
  updatePill(ds); // ← NEW: keep the pill in sync
}

// Initialize pressed visuals + pill from storage (defaults to "patterns")
setDataset(currentDataset());

// Clicks flip visuals + persist choice (still purely cosmetic)
// S4 — actually switch the dataset used by the picker/search
chipPatterns?.addEventListener('click', ()=>{
  setDataset('patterns');
  buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
  // optional: re-render fields if your UI depends on active list
  // renderFields(); emit();
});

chipTasks?.addEventListener('click', ()=>{
  ensureTasksLoaded(()=>{
    setDataset('tasks');
    buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
    // optional: re-render fields if your UI depends on active list
    // renderFields(); emit();
  });
});



const norm = s => (s||'').toLowerCase();
function tokenize(s){ return norm(s).split(/[^a-z0-9]+/).filter(Boolean); }

function matchScore(fw, query){
  const q = (query||'').trim();
  if(!q) return 0;

  const qTokens = tokenize(q);
  if(!qTokens.length) return 0;

  const hayPieces = [
    fw.label, fw.slug, fw.definition, fw.help,
    ...(fw.categories||[]), ...(fw.tags||[]),
    ...(fw.use_cases||[]), ...(fw.boosters||[]),
    ...((fw.fields||[]).flatMap(f=>[f.label, f.desc, f.ph]))
  ].filter(Boolean);

  const hay = hayPieces.join(' ').toLowerCase();
  const hayTokens = tokenize(hay);
  const labelTokens = tokenize(fw.label || '');
  const slug = (fw.slug||'').toLowerCase();

  let score = 0;
  qTokens.forEach(t=>{
    // Strong: label token startsWith (e.g., "deci" → "Decision")
    if (labelTokens.some(tok => tok.startsWith(t))) score += 7;

    // Strong: whole label startsWith the token (old behavior)
    if ((fw.label||'').toLowerCase().startsWith(t)) score += 8;

    // Medium: slug starts with token
    if (slug.startsWith(t)) score += 5;

    // Medium: exact token present in any hay token
    if (hayTokens.includes(t)) score += 3;

    // Light: substring appears anywhere (lets "motiva" hit “motivation” in desc/tags)
    if (hay.includes(t)) score += 1;
  });

  return score;
}



// UI bootstrap
const sel = $('#frameworkSel');

// Live helper preview for the picker (uses def > help > first use_case)
function updatePickerPreview() {
  const el = document.getElementById('fwHelp');
  if (!el) return;
  const fw = typeof FIND === 'function' ? FIND(sel.value) : null;
  if (!fw) { el.textContent = ''; return; }

  const useCase = Array.isArray(fw.use_cases) && fw.use_cases.length ? `Use-case: ${fw.use_cases[0]}` : '';
  const text = (fw.definition || fw.help || useCase || '').toString().trim();
  el.textContent = text;
}

// Update the helper when the selection moves (keyboard or click)
sel.addEventListener('input',  updatePickerPreview);  // fires while the list is open in many browsers
sel.addEventListener('change', updatePickerPreview);  // always fires on commit


// Persist what users typed per-framework within the same tab.
function switchFramework(newId){
  const t = activeTab();
  if (!t) return;

  const oldId = t.id;
  // Save current draft under old framework id
  t._drafts = t._drafts || {};
  t._drafts[oldId] = {
    fields: { ...(t.fields || {}) },
    extra:  t.extra
  };

  // Switch to the new framework id
  t.id = newId;

  // Restore prior draft if available, otherwise start fresh
  const prior = t._drafts[newId];
  if (prior){
    t.fields = { ...(prior.fields || {}) };
    t.extra  = prior.extra;
  } else {
    t.fields = {};
    if (!t.extra || !String(t.extra).trim()) delete t.extra; // allow boosters to prefill
  }

  renderTabs(); renderFields(); emitAll(); nudgeFieldsSwap(); scheduleSave();
}


// --- Multi-tab state (with migration from single state) ---
let state = loadSavedState() || window.state || {};
window.state = state; // expose for action modal + other modules
state.common = state.common || {};



// --- URL param: pick framework by ?slug=... (supports slug or id, case-insensitive)
(()=>{
  const params = new URLSearchParams(window.location.search);
  const q = (params.get('slug') || '').trim().toLowerCase();
  if (!q) return;

  const applyPick = ()=>{
    const list = typeof PICKER === 'function' ? PICKER() : (window.TEMPLATES || window.FRAMEWORKS || []);
    const pick = list.find(f =>
      (f.slug && f.slug.toLowerCase() === q) ||
      (f.id   && f.id.toLowerCase()   === q)
    ) || (typeof FIND === 'function' ? FIND(q) : null);
    if (!pick) return;

    state.id = pick.id;
    if (Array.isArray(state.tabs) && state.tabs.length) {
      const i = Number.isInteger(state.active) ? state.active : 0;
      state.tabs[i] = { ...(state.tabs[i] || {}), id: pick.id };
    }
  };

  const ds = (typeof currentDataset === 'function') ? currentDataset() : 'patterns';
  if (ds === 'tasks' && typeof ensureTasksLoaded === 'function') {
    ensureTasksLoaded(applyPick);
  } else {
    applyPick();
  }
})();



// If already migrated, keep it. Otherwise wrap the old single-state into a tab.
if (!Array.isArray(state.tabs) || !state.tabs.length){
  // Prefer the Template Picker (id:'none') when seeding a fresh session.
const initialId = (typeof state.id === 'string')
  ? state.id
  : ((FRAMEWORKS.find(f => f && f.id === 'none')?.id) || (FRAMEWORKS[0]?.id) || null);
state.tabs = [{
  id: initialId,
  fields: state.fields || {},
  extra: (state.extra && state.extra[initialId]) ?? undefined,
  // NEW: per-tab common context (migrates from old global if present)
  common: {
    ctx:       (state.common?.usecase ?? state.common?.ctx) ?? '',
    audience:  state.common?.audience ?? '',
    style:     state.common?.style ?? '',
    tone:      state.common?.tone ?? ''
  }
}];
// Optional cleanup of legacy globals
delete state.common;
delete state.fields;

  state.active = 0;
  // clean up legacy keys (optional)
  delete state.id; delete state.fields;
}; // use let so we can set the id after we build options

function buildFrameworkOptions(filterText=''){
  const base = PICKER().slice()
    .sort((a,b)=> a.label.localeCompare(b.label,'en',{sensitivity:'base'}));

  const total = base.length;
  let list = base;
  let usedFallback = false;

  const q = (filterText||'').trim();
  if (q){
    list = base
      .map(f=>({f, s: matchScore(f, q)}))
      .filter(x=> x.s > 0)
      .sort((a,b)=> b.s - a.s || a.f.label.localeCompare(b.f.label,'en',{sensitivity:'base'}))
      .map(x=> x.f);
    if (!list.length) {
  list = base;           // graceful fallback
  usedFallback = true;   // <-- we really fell back
}

  }

  // Rebuild <select> to reflect the filtered ordering
  sel.innerHTML = '';
  list.forEach(f => {
    const o = document.createElement('option');
    o.value = f.id;
    o.textContent = f.label;

    // Tooltip fallback (works in many browsers when hovering the closed select or list entries)
    o.title = (f.definition || f.help || (Array.isArray(f.use_cases) && f.use_cases[0]) || '').toString();

    sel.appendChild(o);
  });


  // Update the little "Showing N/M" hint
  const fwHint = document.getElementById('fwHint');
  if (fwHint){
    if (q){
      // If we fell back to base because there were 0 hits, treat it as "all"
const count = usedFallback ? total : list.length;
fwHint.textContent = `Showing ${count}/${total} — Hit Enter`;

      fwHint.hidden = false;
    } else {
      fwHint.textContent = '';
      fwHint.hidden = true;
    }
  }

  // Preserve current tab's selection if it's in the filtered list; otherwise
  // at least show the *first* filtered option in the dropdown so users see the filter working.
  const t = activeTab();
  const keep = t.id && list.find(x=>x.id===t.id);
  if (keep){
    sel.value = t.id;
  } else {
  sel.selectedIndex = 0;               // visually show the top match
  if (t && list.length) {              // NEW: commit the default into state
    t.id = list[0].id;
  }
}
    // Keep helper preview in sync with whatever is visually selected
  if (typeof updatePickerPreview === 'function') updatePickerPreview();

}



// Boot: render only after the active dataset is ready (handles lazy Tasks)
(function boot(){
  const doInit = ()=>{
    buildFrameworkOptions('');
    renderTabs();
    renderFields();
    if (typeof syncCommonInputs === 'function') syncCommonInputs();
    emit();
  };
  const ds = (typeof currentDataset === 'function') ? currentDataset() : 'patterns';
  if (ds === 'tasks' && typeof ensureTasksLoaded === 'function'){
    ensureTasksLoaded(doInit);  // waits for templates.tasks.data.js to populate window.TASK_TEMPLATES
  } else {
    doInit();
  }
})();



    function fieldInput(el, on){ el.addEventListener('input', on); el.addEventListener('change', on); }
    
    
    /* ==== Inline Counters (Stage 1) ==== */
function approxTokens(str){ return Math.ceil((str || '').length / 4); } // fast heuristic
function estimateTokens(str){
  try{
    if (typeof window.customTokenCounter === 'function') {
      const n = Number(window.customTokenCounter(String(str)));
      if (Number.isFinite(n) && n > 0) return Math.ceil(n);
    }
  }catch(e){ /* ignore */ }
  return approxTokens(str);
}

/* ==== Prompt totals: gather, compute, render ==== */
function gatherPreviewText(){
  // If you render a deck of cards, concatenate all visible outputs.
  const deck = document.getElementById('outDeck');
  if (deck && !deck.hidden){
    return Array.from(deck.querySelectorAll('.outBody'))
      .map(n => (n.textContent || '').trim())
      .filter(Boolean)
      .join('\n\n---\n\n');
  }
  // Fallback to the single current preview (the big one)
  const out = document.getElementById('out');
  return (out?.textContent || '').trim();
}

function updatePromptTotal(){
  const el = document.getElementById('promptTotal');
  if (!el) return;
  const text = gatherPreviewText();
  if (!text){ el.textContent = ''; return; }
  const chars = text.length;
  const toks  = estimateTokens(text);
  el.textContent = `${toks} tokens · ${chars} characters`;
}


/* ==== Context Coach (single, for current preview) ==== */
/* Token bands tuned for full prompt length (current preview only) */
const PROMPT_COACH_BANDS = [
  { /* Too little */          max:  79,  state:'low',     label:'Type more'    },
  { /* Not enough */          min:  80,  max: 150, state:'low',     label:'Not enough'   },
  { /* Almost there */        min: 151,  max: 250, state:'near',    label:'Almost there' },
  { /* Looking good */        min: 251,  max: 400, state:'good',    label:'Looking good' },
  { /* Great! */              min: 401,  max: 600, state:'good',    label:'Great!'       },
  { /* Perfect! */            min: 601,  max: 800, state:'perfect', label:'Perfect!'     },
  { /* Too much (long wall) */min: 1001,          state:'high',    label:'Too much'     }
];

function coachForPrompt(tokens){
  for (const r of PROMPT_COACH_BANDS){
    const okMin = (r.min == null) || (tokens >= r.min);
    const okMax = (r.max == null) || (tokens <= r.max);
    if (okMin && okMax) return { state: r.state, label: r.label };
  }
  return { state: 'good', label: 'Looking good' };
}

/* Create/update the coach node inside #out based on current preview tokens */
function updateOutCoach(){
  const out = document.getElementById('out');
  if (!out) return;

  // Create once
  let coach = out.querySelector('.outCoach');
  if (!coach){
    coach = document.createElement('div');
    coach.className = 'outCoach';
    coach.setAttribute('role','status');
    coach.setAttribute('aria-live','polite');
    const pill = document.createElement('span');
    pill.className = 'pill';
    coach._pill = pill;
    coach.appendChild(pill);
    out.appendChild(coach);
  }

  const text = (out.textContent || '').trim();
  if (!text){
    coach.hidden = true;
    out.classList.remove('hasCoach');
    return;
  }

  const tokens = estimateTokens(text); // uses your existing heuristic/precise counter
  const { state, label } = coachForPrompt(tokens);
  coach.dataset.state = state;
  coach._pill.textContent = label;
  coach.hidden = false;
  out.classList.add('hasCoach');
}


/* ==== Master totals: across ALL templates ==== */
function gatherMasterText(){
  const deck = document.getElementById('outDeck');
  if (deck){
    const bodies = deck.querySelectorAll('.outBody');
    if (bodies && bodies.length){
      return Array.from(bodies)
        .map(n => (n.textContent || '').trim())
        .filter(Boolean)
        .join('\n\n---\n\n')
        .trim();
    }
  }
  // Fallback to the single current preview (#out) if no deck/cards
  const out = document.getElementById('out');
  return (out?.textContent || '').trim();
}

function updateMasterPromptTotal(){
  const el = document.getElementById('masterPromptTotal');
  if (!el) return;
  const text = gatherMasterText();
  if (!text){ el.textContent = ''; return; }
  const chars = text.length;
  const toks  = estimateTokens(text); // uses your existing heuristic/precise token estimator
  el.textContent = `Total: ${toks} tokens · ${chars} characters`;
}

/* ==== Current preview counter (top-right inside #out) ==== */
function updateOutPreviewCounter(){
  const out = document.getElementById('out');
  if (!out) return;

  let node = out.querySelector('.outCounter');
  if (!node){
    node = document.createElement('div');
    node.className = 'outCounter';
    node.setAttribute('aria-hidden', 'true');
    out.appendChild(node);
  }

  const text = (out.textContent || '').trim();
  if (!text){
    node.textContent = '';
    node.hidden = true;
    out.classList.remove('hasCounter');
    return;
  }

  const chars = text.length;
  const toks  = estimateTokens(text);
  node.textContent = `${toks}t · ${chars}c`;
  node.hidden = false;
  out.classList.add('hasCounter');
}

/* === Counter refresh scheduler (debounced to next frame) === */
function refreshPromptCountersSoon(){
  if (refreshPromptCountersSoon._pending) return;
  refreshPromptCountersSoon._pending = true;
  requestAnimationFrame(()=>{
    refreshPromptCountersSoon._pending = false;
    // Keep the original per-current-prompt updater:
    updatePromptTotal && updatePromptTotal();
    // ADD the new master updater (do not replace the old call):
    updateMasterPromptTotal && updateMasterPromptTotal();
    // Keep the tiny current-preview corner counter:
    updateOutPreviewCounter && updateOutPreviewCounter();
      updateOutCoach && updateOutCoach();     
  });
}

function formatCounts(chars, tokens){ return `${tokens}t · ${chars}c`; }

function setupCounter(inputEl){
  // Only for text & textarea
  const tag = inputEl.tagName.toLowerCase();
  if (!(tag === 'input' || tag === 'textarea')) return;

  // Wrap input in a positioned holder (if not already)
  if (!inputEl.parentElement || !inputEl.parentElement.classList.contains('fieldHolder')){
    const holder = document.createElement('div');
    holder.className = 'fieldHolder';
    inputEl.parentElement.insertBefore(holder, inputEl);
    holder.appendChild(inputEl);
  }
  // Create the counter once
  if (!inputEl._counterNode){
    const n = document.createElement('span');
    n.className = 'counter';
    n.setAttribute('aria-hidden', 'true');
    inputEl._counterNode = n;
    inputEl.parentElement.appendChild(n);
    inputEl.classList.add('hasCounter');
  }

  const update = ()=>{
    const val = inputEl.value || '';
    const chars = val.length;
    const tokens = estimateTokens(val);
    inputEl._counterNode.textContent = (chars > 0) ? formatCounts(chars, tokens) : '';
    inputEl._counterNode.hidden = chars === 0;
  };

  // Initial + live updates
  update();
  inputEl.addEventListener('input', update);
  inputEl.addEventListener('change', update);
}


function enrichFromGlossary(fw){
  const hit = (window.GLOSSARY || []).find(x => x.slug === fw.slug);
  if (!hit) return fw; // no change if not found
  return {
    ...fw,
    label: hit.term || fw.label,             // prefer glossary term as label
    status: hit.status || fw.status,
    tags: Array.from(new Set([...(fw.tags||[]), ...(hit.tags||[])])),
    categories: Array.from(new Set([...(fw.categories||[]), ...(hit.categories||[])])),
    sources: hit.sources || fw.sources
  };
}

if (searchEl){
// Live filter + rich suggestions
searchEl.addEventListener('input', ()=>{
  const q = searchEl.value;
  buildFrameworkOptions(q);
  renderFwSuggestions(q);
});


// Keyboard niceties on the search box (now aware of suggestions)
searchEl.addEventListener('keydown', (e)=>{
  const sel = document.getElementById('frameworkSel');
  const items = Array.from(sug?.children || []);

  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') return; // handled globally

  if ((e.key === 'ArrowDown' || e.key === 'ArrowUp') && items.length){
    e.preventDefault();
    if (e.key === 'ArrowDown') fwTaActive = Math.min(items.length - 1, fwTaActive + 1);
    if (e.key === 'ArrowUp')   fwTaActive = Math.max(0, fwTaActive - 1);
    items.forEach((n,i)=> n.classList.toggle('active', i===fwTaActive));
    return;
  }

  if (e.key === 'Enter'){
    if (items.length && fwTaActive >= 0){
      e.preventDefault();
      const active = items[fwTaActive];
      if (active) commitFwPick(active.dataset.id);
      return;
    }
    // Fallback: commit the first filtered option as before
    buildFrameworkOptions(searchEl.value);
    const first = sel?.options?.[0];
    if (first){
      e.preventDefault();
      commitFwPick(first.value);
    }
    return;
  }

  if (e.key === 'Escape'){
    e.preventDefault();
    hideFwSuggestions();
    searchEl.value = '';
    buildFrameworkOptions('');
    const hint = document.getElementById('fwHint'); 
    if (hint){ hint.hidden = true; hint.textContent = ''; }
    sel?.focus();
    return;
  }

  // If suggestions aren’t open, ArrowDown still drops into the native select
  if (e.key === 'ArrowDown' && !items.length){
    e.preventDefault();
    sel?.focus();
  }
});


  // Global: Ctrl/Cmd+K focuses the search bar
  document.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if ((k === 'k') && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      searchEl.focus();
      searchEl.select();
    }
  });
}


if (allBtn){
allBtn.addEventListener('click', ()=>{
  searchEl.value = '';
  hideFwSuggestions(); // NEW
  buildFrameworkOptions('');
  sel.focus();
});

}

function activeTab(){ return state.tabs[state.active]; }

function tabLabel(t){
  const fw = FIND(t.id);
  return fw ? fw.label : 'Untitled';
}


function addTab(copyCurrent = false){
  const none = FRAMEWORKS.find(f => f.id === 'none') || FRAMEWORKS[0];
  const cur  = state.tabs?.[state.active];

  // Clone when explicitly duplicating; otherwise start truly blank
  const next = (copyCurrent && cur) ? {
    id:     cur.id,
    fields: { ...(cur.fields || {}) },
    extra:  cur.extra,
    common: { ...(cur.common || {}) }
  } : {
    id:     (none?.id || null),
    fields: {},
    extra:  undefined,
    common: { ctx:'', audience:'', style:'', tone:'' }   // NEW: per-tab
  };

  state.tabs.push(next);
  state.active = state.tabs.length - 1;

  renderTabs();
  buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
  renderFields();
  syncCommonInputs();          // NEW: hydrate the Common Context UI for this tab
  emitAll();
  scheduleSave();
}

function syncCommonInputs(){
  const t = activeTab() || {};
  const c = t.common || {};
  const map = { usecase:'ctx', audience:'audience', style:'style', tone:'tone' };

  Object.entries(map).forEach(([id, key])=>{
    const el = document.getElementById(id);
    if (!el) return;

    const newVal = c[key] || '';
    const changed = el.value !== newVal;

    // 1) Apply the new value
    el.value = newVal;

    // 2) Keep the visual “filled” state in sync
    el.classList.toggle('filled', !!newVal);

    // 3) Nudge counters/listeners so the UI reflects the switch immediately
    if (changed){
      el.dispatchEvent(new Event('input',  { bubbles:true }));
      el.dispatchEvent(new Event('change', { bubbles:true }));
    }
  });
}




function closeTab(idx){
  if (state.tabs.length <= 1) return; // keep at least one
  state.tabs.splice(idx, 1);
  if (state.active >= state.tabs.length) state.active = state.tabs.length - 1;
  renderTabs(); buildFrameworkOptions(document.getElementById('fwSearch')?.value||'');
  renderFields(); emitAll();
}

function clearOrCloseTab(idx){
  // If there is more than one tab, behave like close.
  if (state.tabs.length > 1){
    closeTab(idx);
    return;
  }

  // Single tab: reset this tab to the default "— Select a template —"
  
state.tabs[0] = {
  id: 'none',
  fields: {},
  extra: undefined,
  // keep common context if present
  common: { ...(state.tabs[0]?.common || { ctx:'', audience:'', style:'', tone:'' }) }
};

  state.active = 0;

  // Re-render UI
  renderTabs();
  buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
  renderFields();
  emitAll();
}


function switchTab(idx){
  if (idx<0 || idx>=state.tabs.length) return;
  state.active = idx;
  renderTabs(); buildFrameworkOptions(document.getElementById('fwSearch')?.value||'');
  renderFields(); syncCommonInputs(); emitAll(); nudgeFieldsSwap();
  // notify auxiliary controls
  document.dispatchEvent(new Event('tab-switched'));
}


function renderTabs(){
const bar = document.getElementById('tabbar');
if (!bar) return;
bar.innerHTML = '';
const many = state.tabs.length > 1;
bar.hidden = !many;
const lab = document.getElementById('tabbarLabel');
if (lab) lab.hidden = !many;
if (!many) return;



  state.tabs.forEach((t, i)=>{
    const b = document.createElement('div');
    b.className = 'tab' + (i===state.active?' active':'');
    b.title = 'Switch to this template';
    b.addEventListener('click', (e)=>{
      // ignore clicks on the close button itself
      if (e.target.closest('.x')) return;
      switchTab(i);
    });

    const title = document.createElement('span');
    title.textContent = tabLabel(t);
    b.appendChild(title);

const x = document.createElement('button');
x.className = 'x'; x.type='button';
x.textContent = '×';
x.title = 'Remove this template';

    x.addEventListener('click', (e)=>{ e.stopPropagation(); closeTab(i); });
    b.appendChild(x);

    bar.appendChild(b);
  });
}

      function nudgeFieldsSwap(){
  const f = document.getElementById('fields');
  if (!f) return;
  f.classList.remove('fields-swap');
  // reflow to restart animation
  void f.offsetWidth;
  f.classList.add('fields-swap');
}
      

function makePromptForTab(t){
const fw = FIND(t.id);
const hasRealFields = fw && Array.isArray(fw.fields) && fw.fields.length > 0;
if (!fw || (fw.id === 'none' && !hasRealFields)) return '';

  const meta = enrichFromGlossary ? enrichFromGlossary(fw) : fw; // safe if enrichment not present
const c = (t.common || {});
let ctxPlus = ctxStringFromTab(t);

// Multi-select aware: include all selected persona blocks; fallback to legacy single
const persons = Array.isArray(c.audience_personas) && c.audience_personas.length
  ? c.audience_personas
  : (c.audience_persona ? [c.audience_persona] : []);

if (persons.length){
  const blocks = persons
    .map(p => formatPersonaForPrompt(p))
    .filter(Boolean)
    .join('\n\n');
  ctxPlus = [ctxPlus, blocks].filter(Boolean).join('\n\n');
}


const merged = {
  ctx: ctxPlus,
  ...(t.fields || {})
};

// === Bias directives (from Common Context) ===
let biasSection = '';
{
  const ids = (t.common && Array.isArray(t.common.bias_ids)) ? t.common.bias_ids : [];
  const blocks = composeBiasDirectives(ids);
  merged.bias_awareness_block   = blocks.awareness || '';
  merged.bias_mitigations_block = blocks.mitigations || '';
  merged.ethics_block           = blocks.ethics || '';
  merged.bias_directives        = blocks.combined || '';
}

// Build body AFTER merged is enriched
const body = fw.template(merged);


// Persona profile fallback — if the template does NOT render ctx,
// we still inject a neat persona section right after the header.
let personaSection = '';
if (c.audience_persona) {
  const block = formatPersonaForPrompt(c.audience_persona);
  if (block && !body.includes('Audience profile —')) {
    personaSection = block;
  }
}

// If the user hasn't typed anything, fall back to the framework's boosters
const boosterFallback = Array.isArray(fw.boosters) ? fw.boosters.join(' ') : '';
const rawExtra = (t.extra ?? '').trim();
const extra = rawExtra.length ? rawExtra : boosterFallback;
const extraText = extra ? `Additional instructions: ${extra}` : '';

const header = meta.definition ? `Using ${meta.label}: ${meta.definition}` : `Using ${meta.label}.`;

// If the template didn’t render a bias block, append a compact one at the end.
const biasAuto = merged.bias_directives || '';
const biasTail = (biasAuto && !String(body).includes('Bias directives') && !String(extraText).includes('Bias directives'))
  ? biasAuto : '';

// Assemble: Header → (optional persona section) → Body → Extra → (optional bias tail)
return [header, personaSection, body, extraText, biasTail]
  .filter(Boolean)
  .join('\n')
  .replace(/\n{3,}/g,'\n\n')
  .trim();


}

window.makePromptForTab = makePromptForTab;


function emitAll(){
  // keep legacy preview in #out (active tab)
  const out = document.getElementById('out');
  if (out){
    const txt = makePromptForTab(activeTab() || {});
    out.textContent = txt || '';
    
 refreshPromptCountersSoon(); // keep counters in sync with any preview update

  }

  // render all cards
  const deck = document.getElementById('outDeck');
  if (!deck) return;
  deck.innerHTML = '';
  state.tabs.forEach((t, i)=>{
    const card = document.createElement('div');
    card.className = 'outCard';

    const head = document.createElement('div');
    head.className = 'outHead';
    const title = document.createElement('div');
    title.className = 'title';
    title.textContent = tabLabel(t);
    head.appendChild(title);

    const actions = document.createElement('div');
    actions.className = 'actions';

  // Clear from the card (resets when only one tab; closes when multiple)
const x = document.createElement('button');
x.className = 'x'; 
x.type = 'button'; 
x.textContent = (state.tabs.length > 1) ? 'Delete' : 'Clear';
x.title = (state.tabs.length > 1) ? 'Remove this template' : 'Clear this template';
x.addEventListener('click', ()=>{
  const isDelete = state.tabs.length > 1;
  const msg = isDelete
    ? 'Remove this template from your deck?'
    : 'Clear this prompt (reset to “— Select a template —”)?';
  if (!confirm(msg)) return;
  clearOrCloseTab(i);
});
actions.appendChild(x);


    head.appendChild(actions);
    card.appendChild(head);

    const body = document.createElement('div');
    body.className = 'outBody';
    body.textContent = makePromptForTab(t);
    card.appendChild(body);

    deck.appendChild(card);
  });
}


    function renderFields(){
      const t = activeTab();
const fw = FIND(t?.id);
fieldsWrap.innerHTML = '';
const hasRealFields = fw && Array.isArray(fw.fields) && fw.fields.length > 0;
if (!fw || (fw.id === 'none' && !hasRealFields)){
  help.textContent = 'Pick a template above to get started.';



  // Show a little context chip even when empty
  const ctx = document.createElement('div');
  ctx.id = 'tabContext';
  const idx = (Number.isInteger(state.active) ? state.active : 0) + 1;
  ctx.textContent = `Editing: Tab ${idx} • No template`;
  fieldsWrap.appendChild(ctx);
  return;
}
help.textContent = fw.help || '';

      
// Tab context chip
{
  const ctx = document.createElement('div');
  ctx.id = 'tabContext';
  const idx = (Number.isInteger(state.active) ? state.active : 0) + 1;
  ctx.textContent = `Editing: Tab ${idx} • ` + (fw ? fw.label : 'No template');
  fieldsWrap.appendChild(ctx);
}
      
fw.fields.forEach(f=>{
  const wrap = document.createElement('div');
  wrap.className = 'field';

  // Label
  const lab = document.createElement('label');
  lab.textContent = f.label;
  lab.htmlFor = `${f.id || f.key}`;
  wrap.appendChild(lab);

  // Special case: dynamic tasks list (repeatable textareas)
  if (f.type === 'dynamic_tasks'){
    const list = document.createElement('div');
    list.className = 'tasksList';

    // Helper to read/write the field into state as a single newline-joined string
    const getValues = () =>
      Array.from(list.querySelectorAll('textarea'))
        .map(ta => ta.value.trim());

    const sync = ()=>{
      const tvals = getValues().filter(Boolean).join('\n');
      (t.fields || (t.fields = {}))[f.key] = tvals;
      emit();
    };

    const addTask = (value='')=>{
      const idx = list.querySelectorAll('textarea').length + 1;

      const item = document.createElement('div');
      item.style.marginTop = idx === 1 ? '0' : '10px';

      const small = document.createElement('div');
      small.className = 'tinyLabel';
      small.textContent = `Task ${idx}`;
      item.appendChild(small);

      const ta = document.createElement('textarea');
      ta.placeholder = f.ph ? `${f.ph}` : `Describe task ${idx}…`;
      ta.value = value;
      item.appendChild(ta);

      // Live updates + inline counter on each task field
      fieldInput(ta, sync);
      setupCounter(ta);

      list.appendChild(item);
      addBtn.parentElement.appendChild(addBtn); // keep button under the newest
      ta.focus();
    };
    
    function activeTab(){ return state.tabs[state.active]; }



    // Seed from any saved value (newline-separated), else start with one empty
    const seed = (t.fields && t.fields[f.key]) ? String(t.fields[f.key]) : '';
    const parts = seed
  ? (itType === 'typeahead_textarea'
      ? seed.split(/\n\s*---\s*\n/)
      : seed.split(/\n+/)
    ).map(s=>s.trim()).filter(Boolean)
  : [''];

    parts.forEach(v => addTask(v));
    // Ensure state is synced even if initial values came from seed
    sync();

    // Add Task button
    const addBtn = document.createElement('button');
    addBtn.type = 'button';
    addBtn.className = 'btn sm';
    addBtn.textContent = '+ Add task';
    addBtn.style.marginTop = '8px';
    addBtn.addEventListener('click', ()=> addTask(''));

    wrap.appendChild(list);
    wrap.appendChild(addBtn);

    // Optional helper text
    if (f.desc){
      const d = document.createElement('div');
      d.className = 'desc';
      d.textContent = f.desc;
      wrap.appendChild(d);
    }

    fieldsWrap.appendChild(wrap);
    return; // important: skip the default single-input branch
  }
  
  // --- Universal repeater (multi-row inputs; supports typeahead) ---
if (f.type === 'repeater'){
  const list   = document.createElement('div');
  list.className = 'repWrap';

  const max    = Number.isFinite(f.max) ? f.max : 10;             // cap (optional)
  const itType = f.itemType || 'text';                            // 'text' | 'textarea' | 'typeahead' | 'typeahead_textarea'

  // Read/Write helpers (store as newline-joined string for compatibility with templates that .split(/\n+/))
  const readValues = () =>
    Array.from(list.querySelectorAll('[data-item] textarea, [data-item] input'))
      .map(el => (el.value || '').trim())
      .filter(Boolean);

  const sync = ()=>{
    // Preserve multi-line rows: use a block joiner for textarea rows
const joiner = (itType === 'typeahead_textarea') ? '\n\n---\n\n' : '\n';
(t.fields || (t.fields = {}))[f.key] = readValues().join(joiner);

    emit();
  };

  const addBtn = document.createElement('button');
  addBtn.type = 'button';
  addBtn.className = 'btn sm';
  addBtn.textContent = `+ Add ${f.unit || 'row'}`;

  function addItem(value=''){
    const count = list.querySelectorAll('[data-item]').length;
    if (count >= max) return;

    const item = document.createElement('div');
    item.className = 'repItem';
    item.setAttribute('data-item', '');
    item.style.marginTop = count === 0 ? '0' : '10px';

    const holder = document.createElement('div');
    holder.className = 'fieldHolder';

    // input kind
    let input;
    if (itType === 'textarea' || itType === 'typeahead_textarea'){
      input = document.createElement('textarea');
    } else {
      input = document.createElement('input');
      input.type = 'text';
    }
    input.placeholder = f.ph || '';
    input.value = value;

    // delete button
    const del = document.createElement('button');
    del.type = 'button';
    del.className = 'btn sm danger';
    del.textContent = '– Remove';
    del.style.marginTop = '6px';
del.addEventListener('click', ()=>{
  if (!confirm('Remove this field value?')) return;
  item.remove();
  sync();
});


    holder.appendChild(input);
    item.appendChild(holder);
    item.appendChild(del);

    // Inline counter
    setupCounter(input);

    // Wire saving
    fieldInput(input, sync);

    // Persona-backed typeahead per row (reuses same behavior as single-field typeahead)
// Source-backed typeahead per row (persona or bias)
if (itType === 'typeahead' || itType === 'typeahead_textarea'){
  const source = (f.dataset || f.source || f.autocomplete || 'persona'); // 'persona' | 'bias'
  holder.classList.add('taWrap');

  const listEl = document.createElement('div');
  listEl.className = 'taList';
  listEl.hidden = true;
  holder.appendChild(listEl);

  let activeIndex = -1;

  function renderSuggestions(q){
    const hits = (source === 'bias') ? biasFilter(q, 30) : personaFilter(q, 30);
    listEl.innerHTML = '';
    activeIndex = -1;
    if (!hits.length){ listEl.hidden = true; return; }

    hits.forEach((obj)=>{
      const it = document.createElement('div');
      it.className = 'taItem';

      // Render line 2 differently per source
      const sub = (source === 'bias')
        ? `${obj.category || obj.kind || ''}${(obj.tags && obj.tags.length) ? (' • ' + obj.tags.join(', ')) : ''}`
        : `${obj.profession || ''}${(obj.tags && obj.tags.length) ? (' • ' + obj.tags.join(', ')) : ''}`;

      it.innerHTML = `
        <span class="name">${obj.name}</span>
        <span class="sub">${sub}</span>
      `.trim();

      it.addEventListener('click', ()=>{
if (source === 'bias'){
  // Mirror single-field modes for biases
  const wantsTextarea = (f.autofill === 'bias->textarea') || (itType === 'typeahead_textarea');
  const modeInline    = (f.autofill === 'bias->inline');
  const modeTemplate  = (f.autofill === 'bias->template');

  if (wantsTextarea){
    input.value = biasText(obj);
  } else if (modeTemplate){
    input.value = biasFillTemplate(f.bias_template, obj);
  } else if (modeInline){
    input.value = biasInlineFlexible(obj, {
      labels:  f?.inline_labels !== false,
      sep:     f?.separator || ' · ',
      include: Array.isArray(f?.include) ? f.include : undefined
    });
  } else {
    input.value = obj.name || '';
  }
} else {
  // keep persona behavior identical to before
  const txt = (typeof personaStringFor === 'function')
    ? personaStringFor({ ...f, type: itType }, obj)
    : (itType === 'typeahead_textarea'
        ? (typeof personaText === 'function' ? personaText(obj) : (obj.summary || obj.name || ''))
        : (f?.autofill === 'persona->inline'
            ? (typeof personaInlineFlexible === 'function'
                ? personaInlineFlexible(obj, {
                    labels: f?.inline_labels !== false,
                    sep:    f?.separator || ' · ',
                    include: Array.isArray(f?.include) ? f.include : undefined
                  })
                : (obj.name || ''))
            : (obj.name || '')));
  input.value = txt;
}


        listEl.hidden = true;
        sync();
      });

      listEl.appendChild(it);
    });

    listEl.hidden = false;
  }

  input.addEventListener('input', ()=>{
    if (input.value.trim().length === 0){ listEl.hidden = true; sync(); return; }
    renderSuggestions(input.value);
    sync();
  });

  input.addEventListener('keydown', (e)=>{
    const items = Array.from(listEl.children);
    if (listEl.hidden || !items.length) return;
    if (e.key === 'ArrowDown'){ e.preventDefault(); activeIndex = Math.min(items.length-1, activeIndex+1); }
    if (e.key === 'ArrowUp'){   e.preventDefault(); activeIndex = Math.max(0, activeIndex-1); }
    if (e.key === 'Escape'){ listEl.hidden = true; return; }
    if (e.key === 'Enter' && activeIndex >= 0){
      e.preventDefault();
      items[activeIndex].dispatchEvent(new Event('click', {bubbles:true}));
      return;
    }
    items.forEach((n,i)=> n.classList.toggle('active', i===activeIndex));
  });

  input.addEventListener('blur', ()=> setTimeout(()=> listEl.hidden = true, 120));
}


    list.appendChild(item);
    // Keep add button at the bottom
    addBtn.parentElement && addBtn.parentElement.appendChild(addBtn);
    input.focus();
  }

  // Seed from saved newline list or start with one blank
  const seed = (t.fields && t.fields[f.key]) ? String(t.fields[f.key]) : '';
const parts = seed
  ? (itType === 'typeahead_textarea'
      ? seed.split(/\n\s*---\s*\n/)
      : seed.split(/\n+/)
    ).map(s=>s.trim()).filter(Boolean)
  : [''];

  parts.forEach(v => addItem(v));
  sync();

  // Add button wiring
  addBtn.addEventListener('click', ()=> addItem(''));

  // Attach to the field wrapper
  wrap.appendChild(list);
  wrap.appendChild(addBtn);

  // Optional helper text
  if (f.desc){
    const d = document.createElement('div');
    d.className = 'desc';
    d.textContent = f.desc;
    wrap.appendChild(d);
  }

  fieldsWrap.appendChild(wrap);
  return; // important: skip the default branch
}

  
    // SELECT (dropdown) branch
  if (f.type === 'select'){
    const holder = document.createElement('div');
    holder.className = 'fieldHolder';

    const sel = document.createElement('select');
    sel.id = f.key;

    // Accept either [{value,label}, ...] or ["value", ...]
    (f.options || []).forEach(opt => {
      const o = document.createElement('option');
      if (typeof opt === 'string'){
        o.value = opt; o.textContent = opt;
      } else {
        o.value = opt.value;
        o.textContent = opt.label || opt.value;
      }
      sel.appendChild(o);
    });

    // Initialize & wire state
    const current = (t.fields && t.fields[f.key]) || sel.options[0]?.value || '';
    sel.value = current;
    (t.fields || (t.fields = {}))[f.key] = sel.value;

    sel.addEventListener('change', ()=>{
      (t.fields || (t.fields = {}))[f.key] = sel.value;
      emit();
    });

    holder.appendChild(sel);
    wrap.appendChild(holder);

    // Optional helper text
    if (f.desc){
      const d = document.createElement('div');
      d.className = 'desc';
      d.textContent = f.desc;
      wrap.appendChild(d);
    }

    fieldsWrap.appendChild(wrap);
    return; // skip default branch
  }


  // DEFAULT single input/textarea branch
  const holder = document.createElement('div');
  holder.className = 'fieldHolder';
let input;
if (f.type === 'textarea' || f.type === 'typeahead_textarea'){
  input = document.createElement('textarea');
} else {
  input = document.createElement('input');
  input.type = 'text';
}


input.placeholder = f.ph || '';
input.id = f.key;
input.value = (t.fields && t.fields[f.key]) || '';

/* -- Typeahead (persona- or bias-backed) -- */
if (f.type === 'typeahead' || f.type === 'typeahead_textarea'){

  const source = (f.dataset || f.source || f.autocomplete || 'persona'); // 'persona' | 'bias'
  holder.classList.add('taWrap');

  const list = document.createElement('div');
  list.className = 'taList';
  list.hidden = true;

  holder.appendChild(input);
  holder.appendChild(list);

  let activeIndex = -1;

  function renderSuggestions(q){
    const hits = (source === 'bias') ? biasFilter(q, 30) : personaFilter(q, 30);
    list.innerHTML = '';
    activeIndex = -1;
    if (!hits.length){ list.hidden = true; return; }

    hits.forEach((obj, idx)=>{
      const item = document.createElement('div');
      item.className = 'taItem';

      const sub = (source === 'bias')
        ? `${obj.category || obj.kind || ''}${(obj.tags && obj.tags.length) ? (' • ' + obj.tags.join(', ')) : ''}`
        : `${obj.profession || ''}${(obj.tags && obj.tags.length) ? (' • ' + obj.tags.join(', ')) : ''}`;

      item.innerHTML = `
        <span class="name">${obj.name}</span>
        <span class="sub">${sub}</span>
      `.trim();

      item.addEventListener('click', ()=>{
        (t.fields || (t.fields = {}));

        if (source === 'bias'){
          // Spread into mapped fields when requested
          if (f.autofill === 'bias->spread' || f.key === 'bias_name'){
            applyBiasToTab(t, obj);
            list.hidden = true;
            renderFields();
            emit();
            return;
          }

          // Fill strategies
          const wantsTextarea = (f.autofill === 'bias->textarea') || (f.type === 'typeahead_textarea');
          const modeInline    = (f.autofill === 'bias->inline');
          const modeTemplate  = (f.autofill === 'bias->template');

          if (wantsTextarea){
            const txt = biasText(obj);
            input.value = txt;
            t.fields[f.key] = txt;
          } else if (modeTemplate){
            const txt = biasFillTemplate(f.bias_template, obj);
            input.value = txt;
            t.fields[f.key] = txt;
          } else if (modeInline){
            const txt = biasInlineFlexible(obj, {
              labels: f?.inline_labels !== false,
              sep:    f?.separator || ' · ',
              include: Array.isArray(f?.include) ? f.include : undefined
            });
            input.value = txt;
            t.fields[f.key] = txt;
          } else {
            input.value = obj.name || '';
            t.fields[f.key] = input.value;
          }

          list.hidden = true;
          emit();
          return;
        }

        // === persona (existing behavior preserved) ===
        const isPersona = (f.key === 'persona_name');
        const wantsPersonaTextarea = (f.autofill === 'persona->textarea') || (f.type === 'typeahead_textarea');

        if (isPersona){
          applyPersonaToTab(t, obj);
          t.fields.end = (t.fields.end || '');
          list.hidden = true;
          renderFields();
          emit();
          const endInput = document.querySelector('#end'); if (endInput) endInput.focus();
          return;
        }

        if (wantsPersonaTextarea){
          const txt = personaText(obj);
          input.value = txt;
          t.fields[f.key] = txt;
        } else if (f.autofill === 'persona->template'){
          const txt = personaFillTemplate(f.persona_template, obj);
          input.value = txt;
          t.fields[f.key] = txt;
        } else if (f.autofill === 'persona->inline'){
          const txt = personaInlineFlexible(obj, {
            labels: f?.inline_labels !== false,
            sep:    f?.separator || ' · ',
            include: Array.isArray(f?.include) ? f.include : undefined
          });
          input.value = txt;
          t.fields[f.key] = txt;
        } else {
          input.value = obj.name || '';
          t.fields[f.key] = input.value;
        }

        list.hidden = true;
        emit();
      });

      list.appendChild(item);
    });

    list.hidden = false;
  }

  input.addEventListener('input', ()=>{
    (t.fields || (t.fields = {}))[f.key] = input.value;
    if (input.value.trim().length === 0){ list.hidden = true; emit(); return; }
    renderSuggestions(input.value);
    emit();
  });

  input.addEventListener('keydown', (e)=>{
    const items = Array.from(list.children);
    if (list.hidden || !items.length) return;

    if (e.key === 'ArrowDown'){ e.preventDefault(); activeIndex = Math.min(items.length-1, activeIndex+1); }
    if (e.key === 'ArrowUp'){   e.preventDefault(); activeIndex = Math.max(0, activeIndex-1); }
    if (e.key === 'Escape'){ list.hidden = true; return; }

    if (e.key === 'Enter' && activeIndex >= 0){
      e.preventDefault();
      items[activeIndex].dispatchEvent(new Event('click', {bubbles:true}));
      return;
    }

    items.forEach((n,i)=> n.classList.toggle('active', i===activeIndex));
  });

  // Hide on blur (delay so clicks register)
  input.addEventListener('blur', ()=> setTimeout(()=> list.hidden = true, 120));

} else {
  // Normal field (text/textarea)
  holder.appendChild(input);
}


// Save + preview updates (works for both normal and typeahead)
wrap.appendChild(holder);
fieldInput(input, ()=>{
  (t.fields || (t.fields = {}))[f.key] = input.value;
  emit(); // will call emitAll() + totals
});

function personaInline(p){
  const parts = [];
  if (p.name) parts.push(`Name: ${p.name}`);
  if (p.profession) parts.push(`Profession: ${p.profession}`);
  if (p.summary) parts.push(`Summary: ${p.summary}`);
  return parts.join(' ');
}

// Fill arbitrary "{name}" "{profession}" "{summary}" etc.
function personaFillTemplate(tpl, p){
  return String(tpl||'').replace(/\{(\w+)\}/g, (_,k)=> (p?.[k] ?? ''));
}

// Build a clean one-liner with options
function personaInlineFlexible(p, opts = {}){
  const include = Array.isArray(opts.include) && opts.include.length
    ? opts.include
    : ['name','profession','summary']; // default order

  const labels = (opts.labels !== false); // default: show "Name:", etc.
  const sep    = (typeof opts.sep === 'string') ? opts.sep : ' · ';

  const labelMap = {
    name:       labels ? 'Name: '       : '',
    profession: labels ? 'Profession: ' : '',
    role:       labels ? 'Role: '       : '',
    title:      labels ? 'Title: '      : '',
    summary:    labels ? 'Summary: '    : '',
    bio:        labels ? 'Bio: '        : '',
    expertise:  labels ? 'Expertise: '  : ''
  };

  const parts = include.map(k => {
    const v = (p?.[k] ?? '').toString().trim();
    return v ? (labelMap[k] + v) : '';
  }).filter(Boolean);

  return parts.join(sep);
}

// Single router for all persona insertions
function personaStringFor(field, p){
  // mode: 'name' | 'inline' | 'textarea' | 'template'
  let mode = 'name';
  if (typeof field?.autofill === 'string' && field.autofill.startsWith('persona->')) {
    mode = field.autofill.split('persona->')[1];
  } else if (field?.type === 'typeahead_textarea') {
    mode = 'textarea';
  }

  if (mode === 'textarea') return (typeof personaText === 'function') ? personaText(p) : (p?.summary || '');
  if (mode === 'template') return personaFillTemplate(field?.persona_template, p);

  if (mode === 'inline') {
    return personaInlineFlexible(p, {
      labels: field?.inline_labels !== false,             // default true
      sep:    field?.separator || ' · ',                  // default " · "
      include: Array.isArray(field?.include) ? field.include : undefined
    });
  }

  // 'name' default
  return p?.name || '';
}




  // Inline counter (Stage 1)
  setupCounter(input);

  // Optional helper text (unchanged)
  if (f.desc){
    const d = document.createElement('div');
    d.className = 'desc';
    d.textContent = f.desc;
    wrap.appendChild(d);
  }

  fieldsWrap.appendChild(wrap);
});

      
      

// --- Additional instructions box (prefilled from per-framework boosters) ---
{
  const wrap = document.createElement('div');
  wrap.className = 'field';

  const label = document.createElement('label');
  label.textContent = 'Additional instructions';
  label.setAttribute('for', 'extra');

  const holder = document.createElement('div');
  holder.className = 'fieldHolder';

  const ta = document.createElement('textarea');
  ta.id = 'extra';
  ta.rows = 3;

  // Deterministic behavior: use placeholder for boosters; user text wins if present
  const def = defaultBooster(t.id);
  const cur = (t.extra || '').trim();
  if (cur) ta.value = cur;
  if (!cur && def) ta.placeholder = def;

  holder.appendChild(ta);
  wrap.appendChild(label);
  wrap.appendChild(holder);

  // Save + preview updates
  fieldInput(ta, ()=>{
    t.extra = ta.value.trim();
    emit();
  });

  // Inline counter (Stage 1)
  setupCounter(ta);

  fieldsWrap.appendChild(wrap);
}
// --- end Additional instructions box ---




// meta box (enriched from glossary when available)
chips.innerHTML = '';
const meta = enrichFromGlossary(fw);

// Build a boxed section so everything stacks nicely
const box = document.createElement('div');
box.className = 'metaBox';
chips.appendChild(box);

// Row 0: Save & Reset session controls (above Glossary)
{
  const row = document.createElement('div');
  row.className = 'metaRow';

  const controls = document.createElement('div');
  controls.className = 'metaGroup';

  // Save button
  const saveBtn = document.createElement('button');
  saveBtn.type = 'button';
  saveBtn.className = 'btn sm';
  saveBtn.id = 'saveSessionBtn';
  saveBtn.textContent = 'Save session';

  // Reset button (red, with confirm)
  const resetBtn = document.createElement('button');
  resetBtn.type = 'button';
  resetBtn.className = 'btn sm danger';
  resetBtn.id = 'resetSessionBtn';
  resetBtn.textContent = 'Reset (wipe all)';

  controls.appendChild(saveBtn);
  controls.appendChild(resetBtn);
  row.appendChild(controls);
  box.appendChild(row);

  // Helper text (plain-language)
  const saveHelp = document.createElement('div');
  saveHelp.className = 'help saveHelp';
  saveHelp.textContent = 'Saves to your browser only. Clearing site data/cookies, switching browsers, or using private mode will remove it.';
  box.appendChild(saveHelp);

  // Wire up behavior
  const doImmediateSave = () => {
    if (typeof window.saveNow === 'function') return window.saveNow();
    if (typeof window.scheduleSave === 'function') return window.scheduleSave();
    // Fallback: write state directly (keeps working even if you didn’t add saveNow yet)
    try{ localStorage.setItem((LS_KEYS && LS_KEYS.state) || 'pb.v1.state', JSON.stringify(state)); }catch(e){}
  };

  saveBtn.addEventListener('click', ()=>{
    const original = saveBtn.textContent;
    saveBtn.disabled = true;
    saveBtn.textContent = 'Saving…';

    try { doImmediateSave(); } finally {
      // lightweight “it saved” feedback
      setTimeout(()=>{
        saveBtn.textContent = 'Saved ✓';
        setTimeout(()=>{
          saveBtn.disabled = false;
          saveBtn.textContent = original;
        }, 900);
      }, 400);
    }
  });

  resetBtn.addEventListener('click', ()=>{
    const msg =
      'This will clear all tabs, fields, and saved preferences for Prompt Builder in this browser.\n\nStart fresh?';
    if (!confirm(msg)) return;

    if (typeof window.resetSavedSession === 'function'){
      window.resetSavedSession();
      return;
    }
    // Fallback reset if helper isn’t present for any reason
    try{
      localStorage.removeItem((LS_KEYS && LS_KEYS.state) || 'pb.v1.state');
      localStorage.removeItem((LS_KEYS && LS_KEYS.ui)    || 'pb.v1.ui');
    }catch(e){}
    location.reload();
  });
}


// Row 1: Open in Glossary (two links: Full + Template)
if (meta?.slug){
  const row = document.createElement('div');
  row.className = 'metaRow';
  row.style.gap = '0.5rem'; // adds spacing between glossary chips

  // Full Glossary (existing behavior, just relabeled)
  const fullA = document.createElement('a');
  fullA.className = 'chip metaLink';
  fullA.href = `../glossary/index.html#${meta.slug}`;
  fullA.textContent = 'Open in Full Glossary';
  fullA.title = meta.label;
  row.appendChild(fullA);

  // Template Glossary (new, deep-links by slug as well)
  const tplA = document.createElement('a');
  tplA.className = 'chip metaLink';
  tplA.href = `./Templates-Glossary.html#${meta.slug}`;
  tplA.textContent = 'Open in Template Glossary';
  tplA.title = meta.label;
  row.appendChild(tplA);

  box.appendChild(row);
}


// Optional status (still small, under its own row)
if (meta?.status){
  const row = document.createElement('div');
  row.className = 'metaRow';
  row.style.gap = '0.5rem'; // adds spacing between glossary chips
  const st = document.createElement('span');
  st.className = 'chip';
  st.textContent = `Status: ${meta.status}`;
  row.appendChild(st);
  box.appendChild(row);
}

// Helper to group tags by key
function groupTags(list){
  const groups = {};
  (list || []).forEach(t=>{
    const [k, v] = String(t).split(':');
    if (!k || v === undefined) return;
    (groups[k] ||= []).push(v);
  });
  return groups;
}

// Row 2: CATEGORIES (title line + its own pill row)
if (meta?.categories?.length){
  const title = document.createElement('div');
  title.className = 'metaSectionTitle';
  title.textContent = 'Categories';
  box.appendChild(title);

  const row = document.createElement('div');
  row.className = 'metaPills';
  meta.categories.forEach(cat=>{
    const s = document.createElement('span');
    s.className = 'chip';
    s.textContent = cat;
    row.appendChild(s);
  });
  box.appendChild(row);
}

// Row 3: TAGS grouped by key (type/topic/phase/level/…)
const tagGroups = groupTags(meta?.tags);
const keys = Object.keys(tagGroups);
if (keys.length){
  const title = document.createElement('div');
  title.className = 'metaSectionTitle';
  title.textContent = 'Tags';
  box.appendChild(title);

  keys.sort().forEach(key=>{
    const row = document.createElement('div');
    row.className = 'metaPills';

    const k = document.createElement('span');
    k.className = 'tinyLabel';
    k.textContent = key;
    row.appendChild(k);

    tagGroups[key].forEach(val=>{
      const s = document.createElement('span');
      s.className = 'chip';
      s.textContent = val;
      row.appendChild(s);
    });

    box.appendChild(row);
  });
}


    }

function ctxStringFromTab(t){
  const c = (t && t.common) || {};
  const u = (c.ctx||'').trim();
  const a = (c.audience||'').trim();
  const s = (c.style||'').trim();
  const tn = (c.tone||'').trim();
  const bits=[];
  if(u) bits.push(`Use-case: ${u}`);
  if(a) bits.push(`Audience: ${a}`);
  if(s) bits.push(`Style: ${s}`);
  if(tn) bits.push(`Tone: ${tn}`);
  return bits.join(' | ');
}

function emit(){
  emitAll();
  updatePromptTotal();
  updateOutPreviewCounter();
}

sel.addEventListener('change', () => {
  switchFramework(sel.value);
  if (typeof updatePickerPreview === 'function') updatePickerPreview();
});


// New: one-click commit of the top search hit when a filter is active.
// This avoids the awkward "pick something else, then come back" dance.
sel.addEventListener('mousedown', () => {
  const q = (document.getElementById('fwSearch')?.value || '').trim();
  if (!q) return; // only intervene when filtering
  const first = sel.options[0];
  if (!first) return;
  const t = activeTab();
  if (t.id !== first.value) {
    // Mirror UI and commit selection
sel.value = first.value;
switchFramework(first.value);

  }
});


['usecase','audience','style','tone'].forEach(id=>{
  const el = document.getElementById(id);
  if (!el) return;
  const key = (id === 'usecase') ? 'ctx' : id;

  const on = () => {
    const t = activeTab();
    if (!t) return;
    t.common = t.common || { ctx:'', audience:'', style:'', tone:'' };
    t.common[key] = el.value || '';

    // Only clear persona if the Audience text diverges from the bound persona's name.
   if (id === 'audience') {
  const current = (el.value || '').trim();
  if (!current) {
    // Only clear bindings if the field is actually blank
    t.common.audience_persona  = null;
    t.common.audience_personas = [];
  }
  // Otherwise keep whatever was selected via the typeahead
}


    el.classList.toggle('filled', !!el.value);
    emitAll();
  };

  el.addEventListener('input', on);
  el.addEventListener('change', on);
});


// (removed) Audience single-input typeahead — superseded by chips multi-select

// === Audience multi-select (chips + persona typeahead) ===
(function(){
  const input = document.getElementById('audience');               // same id as before
  const wrap  = document.getElementById('audienceChipsWrap');
  const chips = document.getElementById('audienceChips');
  const menu  = document.getElementById('audienceSuggestions');
  if (!input || !chips || !menu) return;

  let items = [];      // current search hits from personas
  let active = -1;     // highlighted index in menu
  let picks  = [];     // [{ id, name, p }], where p = full persona object

  function close(){ menu.hidden = true; menu.innerHTML=''; active=-1; }

  function renderChips(){
    chips.innerHTML = '';
    for (const it of picks){
      const el = document.createElement('span');
      el.className = 'chip';
      el.setAttribute('data-id', it.id);
      el.innerHTML = `<span class="nm">${it.name}</span><button class="x" title="Remove">×</button>`;
      el.querySelector('.x').addEventListener('click', ()=>{ removePick(it.id); });
      chips.appendChild(el);
    }
  }

  function syncCommon(){
    const t = (typeof activeTab === 'function') ? activeTab() : null;
    if (!t) return;
    t.common = t.common || {};
    // authoritative: full persona objects
    t.common.audience_personas = picks.map(p=>p.p);
    // legacy back-compat: first selection
    t.common.audience_persona  = picks[0]?.p || null;
    // inline context chip (CSV of names)
    t.common.audience          = picks.map(p=>p.name).join(', ');
    if (typeof emitAll === 'function') emitAll();
    if (typeof scheduleSave === 'function') scheduleSave();
    // mirror filled state on the input
    input.classList.toggle('filled', !!t.common.audience);
  }

  function hasId(id){ return picks.some(p=>String(p.id).toLowerCase() === String(id).toLowerCase()); }
  function addPick(res){
    const p = res?.p || null;
    if (!p) return;
    const id   = String(p.id || p.name || '').trim() || Math.random().toString(36).slice(2);
    const name = String(p.name || p.label || p.persona_name || id).trim();
    if (hasId(id)) return;
    picks.push({ id, name, p });
    input.value = '';  // clear token after add
    renderChips(); syncCommon(); close(); input.focus();
  }
  function removePick(id){
    picks = picks.filter(p=>p.id !== id);
    renderChips(); syncCommon();
  }

  function highlight(){
    [...menu.querySelectorAll('.ta-item')].forEach((n,i)=> n.classList.toggle('ta-active', i===active));
  }

  function renderMenu(q){
    items = (typeof searchPersonas === 'function') ? searchPersonas(q) : [];
    if (!items.length){ close(); return; }
    menu.innerHTML = items.map((r,idx)=>{
      const sum = (r.p && (r.p.summary || r.p.definition || '') || '').toString().trim();
      return `<div class="ta-item${idx===0?' ta-active':''}" data-idx="${idx}">
        <div class="name"><strong>${r.name}</strong></div>
        ${sum ? `<div class="sub">${sum}</div>` : ''}
      </div>`;
    }).join('');
    active = 0;
    const rect = input.getBoundingClientRect();
    menu.style.minWidth = rect.width + 'px';
    menu.hidden = false;
  }

  input.addEventListener('input', ()=>{
    const q = input.value.trim();
    if (!q){ close(); return; }
    renderMenu(q);
  });

  input.addEventListener('keydown', (e)=>{
    // Backspace to pop last chip when menu is closed and input is empty
    if (menu.hidden){
      if (e.key === 'Backspace' && !input.value && picks.length){
        e.preventDefault(); removePick(picks[picks.length-1].id); return;
      }
      // not navigating a menu
      return;
    }
    if (e.key === 'ArrowDown'){ e.preventDefault(); active = Math.min(active+1, items.length-1); highlight(); }
    else if (e.key === 'ArrowUp'){ e.preventDefault(); active = Math.max(active-1, 0);           highlight(); }
    else if (e.key === 'Enter' || e.key === ','){ e.preventDefault(); addPick(items[Math.max(0,active)]); }
    else if (e.key === 'Escape'){ e.preventDefault(); close(); }
  });

  menu.addEventListener('mousedown', (e)=>{
    const el = e.target.closest('.ta-item'); if (!el) return;
    const idx = parseInt(el.dataset.idx,10) || 0;
    addPick(items[idx]);
  });

  document.addEventListener('click', (ev)=>{
    if (ev.target!==input && !menu.contains(ev.target)) close();
  });

  // Rehydrate chips on tab switch
  function refreshFromTab(){
    const t = (typeof activeTab === 'function') ? activeTab() : null;
    const arr = Array.isArray(t?.common?.audience_personas) ? t.common.audience_personas : [];
    if (arr.length){
      picks = arr.map(p=>({ id: String(p.id || p.name || '').trim() || Math.random().toString(36).slice(2),
                            name: String(p.name || p.label || p.persona_name || 'Persona'),
                            p }));
    } else {
      picks = []; // no fallback to arbitrary CSV; we want dataset-backed personas
    }
    renderChips(); syncCommon();
  }
  refreshFromTab();
  document.addEventListener('tab-switched', refreshFromTab);
})();

function showToast(msg, ms=1600){
  const el = document.getElementById('toast');
  if (!el) return;
  el.textContent = msg;
  el.hidden = false;
  clearTimeout(showToast._t);
  showToast._t = setTimeout(()=>{ el.hidden = true; }, ms);
}



// === Bias multi-select (chips + typeahead) ===
(function(){
  const input = document.getElementById('biasInput');
  const wrap  = document.getElementById('biasChipsWrap');
  const chips = document.getElementById('biasChips');
  const menu  = document.getElementById('biasSuggestions');
  if (!input || !chips || !menu) return;

  let items = [];       // current search hits
  let active = -1;      // index in items
  let picks  = [];      // array of {id,name,kind}

  function kindDot(k){ return ['bias','technique','dilemma','custom'].includes(k) ? k : 'bias'; }
  function close(){ menu.hidden = true; menu.innerHTML=''; active=-1; }

  function syncCommon(){
    const t = (typeof activeTab === 'function') ? activeTab() : null;
    if (!t) return;
    t.common = t.common || {};
    t.common.bias_names = picks.map(p=>p.name).join(', ');
    t.common.bias_ids   = picks.map(p=>p.id);
    if (typeof emitAll === 'function') emitAll();
    if (typeof scheduleSave === 'function') scheduleSave();
  }

  function hasId(id){ return picks.some(p=>p.id === id); }
  function renderChips(){
    chips.innerHTML = '';
    for (const p of picks){
      const el = document.createElement('span');
      el.className = 'chip';
      el.setAttribute('data-id', p.id);
      el.innerHTML = `<span class="dot ${kindDot(p.kind)}" title="${p.kind}"></span><span class="nm">${p.name}</span><button class="x" title="Remove">×</button>`;
      el.querySelector('.x').addEventListener('click', ()=>{ removePick(p.id); });
      chips.appendChild(el);
    }
  }
  function addPick(obj){
    const id = String(obj.id || obj.name || '').trim() || ('custom:' + Math.random().toString(36).slice(2));
    const kind = (obj.kind ? String(obj.kind).toLowerCase() : 'bias');
    const name = String(obj.name || obj.label || obj.id || '').trim() || 'Custom item';
    if (hasId(id)) return;
    picks.push({id, name, kind});
    renderChips(); syncCommon();
  }
  function removePick(id){
    picks = picks.filter(p=>p.id !== id);
    renderChips(); syncCommon();
  }

  function renderMenu(q){
    items = biasFilter(q, 30) || [];
    if ((!items || !items.length) && q.trim().length){
      items = [{ id:'custom:'+q.trim(), name:q.trim(), kind:'custom', summary:'' }];
    }
    if (!items.length){ close(); return; }
    menu.innerHTML = items.map((b,i)=>{
      const sub = (b.category || b.kind || '');
      const dot = kindDot(b.kind);
const sum = (b.summary || b.definition || '').toString().trim();
return `<div class="ta-item${i===0?' ta-active':''}" data-idx="${i}">
  <div class="name"><span class="dot ${dot}"></span> <strong>${b.name}</strong></div>
  ${sum ? `<div class="sub">${sum}</div>` : ''}
</div>`;

    }).join('');
    active = 0;
    const rect = input.getBoundingClientRect();
    menu.style.minWidth = rect.width + 'px';
    menu.hidden = false;
  }
  function pick(i){
    const b = items[i]; if (!b) return;
    addPick(b);
    input.value = '';
    close();
    input.focus();
  }

  input.addEventListener('input', ()=>{
    const q = input.value.trim();
    if (!q){ close(); return; }
    renderMenu(q);
  });
  input.addEventListener('keydown', (e)=>{
    if (menu.hidden){
      if (e.key === 'Backspace' && !input.value && picks.length){
        removePick(picks[picks.length-1].id);
        e.preventDefault();
      }
      return;
    }
    const els = Array.from(menu.children);
    if (e.key === 'ArrowDown'){ e.preventDefault(); active = Math.min(active+1, els.length-1); }
    else if (e.key === 'ArrowUp'){ e.preventDefault(); active = Math.max(active-1, 0); }
    else if (e.key === 'Enter' || e.key === ','){ e.preventDefault(); pick(active>=0?active:0); }
    else if (e.key === 'Escape'){ e.preventDefault(); close(); return; }
    els.forEach((n,i)=> n.classList.toggle('ta-active', i===active));
  });
  menu.addEventListener('mousedown', (e)=>{
    const el = e.target.closest('.ta-item'); if (!el) return;
    pick(parseInt(el.dataset.idx,10)||0);
  });
  document.addEventListener('click', (ev)=>{
    if (ev.target!==input && !menu.contains(ev.target)) close();
  });

  // Refresh when tabs switch
  function refreshFromTab(){
    const t = (typeof activeTab === 'function') ? activeTab() : null;
    picks = Array.isArray(t?.common?.bias_ids)
      ? (t.common.bias_ids.map(id=>{
          const obj = getBiasById(id) || (String(id).startsWith('custom:') ? {id, name:String(id).slice(7), kind:'custom'} : null);
          return obj ? { id: obj.id || id, name: obj.name || String(id), kind: biasKindOf(obj) } : null;
        }).filter(Boolean))
      : [];
    renderChips();
    if (t){ t.common.bias_names = picks.map(p=>p.name).join(', '); if (typeof emitAll==='function') emitAll(); }
  }

  // on load
  refreshFromTab();
  
  // When the dataset finishes loading late, rebuild menu/chips immediately
document.addEventListener('biases-loaded', ()=>{
  try {
    if (typeof buildBiasIndex === 'function') { window.__BIAS_IDX = null; buildBiasIndex(); }
    refreshFromTab();
    const q = input.value.trim();
    if (q) { // if the user is already typing, show fresh suggestions
      // Re-open menu with current query
      (function renderMenuImmediate(){ 
        // reuse the existing renderMenu
        if (typeof renderMenu === 'function') renderMenu(q);
      })();
    }
  } catch(e){}
});


  // listen for our custom event (slice 5 adds it)
  document.addEventListener('tab-switched', refreshFromTab);
})();



    
    // Persist common fields + visual filled state
const COMMON_IDS = ['usecase','audience','style','tone'];
function toggleFilled(el){ el.classList.toggle('filled', !!el.value.trim()); }
COMMON_IDS.forEach(id=>{
  const el = document.getElementById(id);
  const saved = localStorage.getItem('fw_'+id);
  if (saved !== null) el.value = saved;
  toggleFilled(el);
  el.addEventListener('input', ()=>{
    localStorage.setItem('fw_'+id, el.value);
    toggleFilled(el);
    emit();
  });
});

function getAllGeneratedText(){
  const deck = document.getElementById('outDeck');
  if (deck && deck.children.length){
    const titles = deck.querySelectorAll('.outCard .title');
    const bodies  = deck.querySelectorAll('.outCard .outBody');
    const parts = [];
    titles.forEach((t,i)=>{
      const head = (t.textContent || '').trim();
      const body = (bodies[i]?.textContent || '').trim();
      parts.push(`### ${head}\n${body}`);
    });
    return parts.join('\n\n').trim();
  }
  // fallback to single preview
  const out = document.getElementById('out');
  return (out?.textContent || '').trim();
}

 function buildFrameworkDigest() {
    const all = Array.isArray(window.TEMPLATES) ? window.TEMPLATES
      : (Array.isArray(window.FRAMEWORKS) ? window.FRAMEWORKS
      : (Array.isArray(FRAMEWORKS) ? FRAMEWORKS : []));
    const base = (all||[]).filter(f => f && f.id && f.id !== 'none');

    // Deduplicate by slug → label
    const seen = new Set();
    const list = [];
    for (const f of base) {
      const key = String(f.slug || f.label || f.id).trim().toLowerCase();
      if (seen.has(key)) continue;
      seen.add(key);
      list.push(f);
    }

    // Sort alphabetically by label
    list.sort((a,b)=> String(a.label).localeCompare(String(b.label)));

    // Clean + pick up to 2 tags (prefix-stripped)
    function pickTags(f){
      const raw = (f.tags||[]).map(t => {
        const s = String(t||'');
        const idx = s.indexOf(':');
        return idx >= 0 ? s.slice(idx+1) : s;
      }).filter(Boolean);

      const uniq = [];
      for (const t of raw) { if (!uniq.includes(t)) uniq.push(t); }

      // lightweight preference: topic/use near front
      uniq.sort((a,b)=>{
        const prio = (x) => (/^(creativity|analysis|writing|marketing|planning|prioritization|decision|evaluation)$/i.test(x) ? 0 : 1);
        return prio(a) - prio(b) || a.localeCompare(b);
      });

      return uniq.slice(0,2);
    }

    const lines = list.map(f => {
      const t = pickTags(f);
      return t.length ? `- ${f.label} (${t.join(', ')})` : `- ${f.label}`;
    }).join('\n');

    return 'Framework digest (for the assistant; do not invent new ones):\n' + lines;
  } 
  
// Actions
$('#copyBtn').addEventListener('click', async (e)=>{ if (window.__USE_ACTION_MODAL__) return;
  const deck = document.getElementById('outDeck');
  let text = '';

  if (deck && !deck.hidden) {
    // === Copy All Mode ===
    const nodes = Array.from(deck.querySelectorAll('.outBody'));
    const pieces = [];

    for (let i = 0; i < nodes.length; i++) {
      let tabText = nodes[i].textContent.trim();

      // Match node to tab (assuming window.TABS holds your tab objects in order)
      const tab = (state && state.tabs) ? state.tabs[i] : null;
      if (tab && tab.id === 'none') {
        tabText = tabText + '\n\n' + buildFrameworkDigest();
      }

      if (tabText) pieces.push(tabText);
    }

    text = pieces.join('\n\n---\n\n');
  } else {
    // === Copy Single Mode ===
    text = (document.getElementById('out')?.textContent || '');
    const active = (typeof activeTab === 'function' ? activeTab() : (state && state.tabs ? state.tabs[state.active] : null));
    if (active && active.id === 'none') {
      text = text + '\n\n' + buildFrameworkDigest();
    }
  }

  try { await navigator.clipboard.writeText(text); }
  catch(e){ console.warn('Copy failed', e); }

  const dlg = document.getElementById('msg'); 
  dlg?.showModal();
});



   $('#openBtn').addEventListener('click', async (e)=>{ if (window.__USE_ACTION_MODAL__) return;
  const txt = getAllGeneratedText();
  const dlg = $('#msg');
  // 1) Copy to clipboard (primary guarantee)
  let copied = false;
  try { await navigator.clipboard.writeText(txt); copied = true; }
  catch(e){ console.warn('Clipboard write failed:', e); }
  try {
    const url = 'https://chat.openai.com/?q=' + encodeURIComponent(txt);
    window.open(url, '_blank', 'noopener,noreferrer');
  } catch(e){ console.warn('Open failed', e); }
  // message text is updated just below in your existing code





      // 2) Attempt to open ChatGPT with a prefilled query param (best-effort)
      function buildChatURL(prompt){
        const base = localStorage.getItem('chatgpt_target') || 'https://chatgpt.com/';
        try{
          const u = new URL(base);
          // Try multiple param names — ChatGPT may ignore them, but harmless.
          u.searchParams.set('q', prompt);
          u.searchParams.set('prompt', prompt);
          u.searchParams.set('input', prompt);
          return u.toString();
        }catch(err){
          console.warn('Bad chat target URL; falling back.', err);
          return 'https://chatgpt.com/';
        }
      }
      const url = buildChatURL(txt);
      window.open(url, '_blank', 'noopener');

      // 3) User feedback
      const msg = copied
        ? 'Prompt copied to clipboard. A ChatGPT tab opened. If the prompt did not auto-appear, paste with Cmd/Ctrl+V.'
        : 'Opened ChatGPT. Could not auto-copy the prompt (browser denied). Please select the text in the preview and copy it manually.';
      const msgEl = document.getElementById('msgText');
      if(msgEl) msgEl.textContent = msg; else console.info(msg);
      dlg.showModal();
    });
    
    // Add template (single, guarded wiring)
(function wireAddTemplate(){
  if (window.__addTemplateWired) return;
  window.__addTemplateWired = true;
  const btn = document.getElementById('addPromptBtn');
  if (!btn) return;
btn.addEventListener('click', (e)=>{
  e.preventDefault();
  if (typeof addTab === 'function') addTab(false);
});

})();



    
    // --- Dialog: make it closable via button and backdrop ---
const dlg = document.getElementById('msg');
const dlgClose = document.getElementById('dlgClose');

// Close when clicking the "Close" button
if (dlgClose) dlgClose.addEventListener('click', () => dlg.close());

// Close when clicking the backdrop (outside the dialog content)
dlg.addEventListener('click', (e) => {
  // If the click target is the <dialog> itself, it's the backdrop
  if (e.target === dlg) dlg.close();
});

// Optional: ensure Esc always closes (most browsers do this by default)
dlg.addEventListener('cancel', () => {
  // no-op; letting the default behavior close the dialog
});

// --- Draggable vertical resizer for the left panel ---
(function(){
  const resizer = document.getElementById('resizer');
  const root = document.documentElement;
  const MIN = 280, MAX = 900;

  // restore saved width if present
  const saved = parseInt(localStorage.getItem('fw_leftW') || '', 10);
  if (!isNaN(saved)) root.style.setProperty('--leftW', saved + 'px');

  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

  let dragging = false;

  function onMove(clientX){
    const wrapRect = document.querySelector('.wrap').getBoundingClientRect();
    const x = clientX - wrapRect.left;           // position inside the grid
    const newW = clamp(x, MIN, MAX);             // left column width
    root.style.setProperty('--leftW', newW + 'px');
    localStorage.setItem('fw_leftW', String(newW));
  }

  resizer.addEventListener('mousedown', (e)=>{
    dragging = true; e.preventDefault();
    document.body.style.userSelect = 'none';
  });
  window.addEventListener('mousemove', (e)=>{ if(dragging) onMove(e.clientX); });
  window.addEventListener('mouseup', ()=>{
    if(dragging){ dragging=false; document.body.style.userSelect=''; }
  });

  // Touch support
  resizer.addEventListener('touchstart', (e)=>{
    dragging = true; document.body.style.userSelect='none';
  }, {passive:true});
  window.addEventListener('touchmove', (e)=>{
    if(!dragging) return;
    const t = e.touches[0]; if(t) onMove(t.clientX);
  }, {passive:true});
  window.addEventListener('touchend', ()=>{
    if(dragging){ dragging=false; document.body.style.userSelect=''; }
  });

  // Keyboard resizing for accessibility
  resizer.addEventListener('keydown', (e)=>{
    const step = (e.shiftKey ? 40 : 20);
    const cur = parseInt(getComputedStyle(root).getPropertyValue('--leftW') || '360', 10);
    if (e.key === 'ArrowLeft'){ const w = clamp(cur - step, MIN, MAX); root.style.setProperty('--leftW', w + 'px'); localStorage.setItem('fw_leftW', String(w)); }
    if (e.key === 'ArrowRight'){ const w = clamp(cur + step, MIN, MAX); root.style.setProperty('--leftW', w + 'px'); localStorage.setItem('fw_leftW', String(w)); }
  });
})();

// init happens in boot() below (deferred if Tasks dataset is active)


// Mirror header actions in the secondary action row (no code duplication)
(function wireSecondaryActions(){ if (window.__USE_ACTION_MODAL__) return;
  const copy2  = document.getElementById('copyBtn2');
  const open2  = document.getElementById('openBtn2');
  const clear2 = document.getElementById('clearBtn2');
  
  
  
  
  

  function activePromptText(){
    try{
      const t = (typeof activeTab === 'function') ? activeTab() : null;
      if (!t) return '';
      let text = (typeof makePromptForTab === 'function') ? makePromptForTab(t) : '';
      if (t.id === 'none' && typeof buildFrameworkDigest === 'function'){
        const dig = buildFrameworkDigest();
        if (dig) text = [text, dig].filter(Boolean).join('\n\n');
      }
      return String(text || '').trim();
    }catch(e){
      console.warn('activePromptText failed:', e);
      return '';
    }
  }

  // Helper: reset a tab to the picker (never deletes)
  function resetTabToPicker(idx){
    try{
      const prevCommon = (state.tabs?.[idx]?.common) || { ctx:'', audience:'', style:'', tone:'' };
      state.tabs[idx] = { id:'none', fields:{}, extra: undefined, common: { ...prevCommon } };
      state.active = idx;
      renderTabs();
      buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
      renderFields();
      emitAll();
      if (typeof scheduleSave === 'function') scheduleSave();
    }catch(e){
      console.warn('resetTabToPicker failed:', e);
    }
  }

  copy2 && copy2.addEventListener('click', async ()=>{
    const text = activePromptText();
    try { await navigator.clipboard.writeText(text); } catch(e){ console.warn('Copy failed', e); }
    const dlg = document.getElementById('msg'); const msg = document.getElementById('msgText');
    if (msg) msg.textContent = 'Prompt copied to clipboard.';
    dlg && dlg.showModal && dlg.showModal();
  });

  open2 && open2.addEventListener('click', async ()=>{
    const text = activePromptText();
    let copied = false;
    try { await navigator.clipboard.writeText(text); copied = true; } catch(e){}
    const base = localStorage.getItem('chatgpt_target') || 'https://chatgpt.com/';
    let url = base;
    try { const u = new URL(base); u.searchParams.set('q', text); u.searchParams.set('prompt', text); u.searchParams.set('input', text); url = u.toString(); } catch(e){}
    try { window.open(url, '_blank', 'noopener,noreferrer'); } catch(e){}
    const dlg = document.getElementById('msg'); const msg = document.getElementById('msgText');
    if (msg) msg.textContent = copied
      ? 'Prompt copied. A ChatGPT tab opened. If it didn’t prefill, paste with Cmd/Ctrl+V.'
      : 'Opened ChatGPT. Could not auto-copy; please paste your prompt manually.';
    dlg && dlg.showModal && dlg.showModal();
  });

  clear2 && clear2.addEventListener('click', ()=>{
    const idx = Number.isInteger(state.active) ? state.active : 0;
    const fw  = typeof FIND === 'function' ? FIND(state.tabs?.[idx]?.id) : null;
    const label = fw?.label || 'this prompt';
    const msg = `Clear ${label}? This will reset just the active prompt to “— Select a template —”.`;
    if (!confirm(msg)) return;
    resetTabToPicker(idx);
  });
})();

// === Core button re-bind (safe even if called multiple times) ===
(function wireCoreButtons(){ if (window.__USE_ACTION_MODAL__) return;
  const $ = s => document.querySelector(s);

  // Header buttons (original)
  const copyHeader = $('#copyBtn');
  const openHeader = $('#openBtn');
  const addHeader  = $('#addPromptBtn');
  const themeBtn   = $('#theme');

  // Footer mirrors we just renamed
  const copyFooter = $('#copyAllBtnFooter');
  const openFooter = $('#openAllBtnFooter');

  // Reuse existing app handlers if present; otherwise fall back gracefully
  const doCopyAll = (window.copyAllPrompts || window.copyDeck || window.copyAll || function(){
    // Fallback: copy whatever is visible (deck or single preview)
    const deck = document.getElementById('outDeck');
    const solo = document.getElementById('out');
    let text = '';
    if (deck && !deck.hidden) {
      text = Array.from(deck.querySelectorAll('.outCard .outBody, .outCard pre'))
        .map(n => n.textContent || '')
        .filter(Boolean)
        .join('\n\n');
    } else if (solo) {
      text = solo.textContent || '';
    }
    text = text.trim();
    if (!text) return;
    navigator.clipboard.writeText(text).then(()=> showMsg('Prompt copied to clipboard.'));
  });

  const doOpenAll = (window.openAllInChatGPT || window.openDeck || function(){
    // Fallback: open current preview in ChatGPT
    const solo = document.getElementById('out');
    const text = (solo ? solo.textContent : '').trim();
    if (!text) return;
    const url = 'https://chat.openai.com/?q=' + encodeURIComponent(text.slice(0, 7000));
    window.open(url, '_blank', 'noopener');
    showMsg('Opened ChatGPT. If it didn’t prefill, paste with Cmd/Ctrl+V.');
  });

  const doAddTemplate = (window.addTemplate || window.addPrompt || function(){
    // Fallback: focus the template picker
    document.getElementById('frameworkSel')?.focus();
  });

  function showMsg(s){
    const dlg = document.getElementById('msg');
    const txt = document.getElementById('msgText');
    if (dlg && txt){ txt.textContent = s; dlg.showModal(); }
  }
  function bind(btn, fn){
    if (btn && fn) btn.addEventListener('click', e=>{ e.preventDefault(); fn(); });
  }

  // Bind header
  bind(copyHeader, doCopyAll);
  bind(openHeader, doOpenAll);
  bind(addHeader,  doAddTemplate);

  // Bind footer mirrors
  bind(copyFooter, doCopyAll);
  bind(openFooter, doOpenAll);

  // Theme toggle — keep label + aria in sync, persist to localStorage
  if (themeBtn){
    themeBtn.addEventListener('click', ()=>{
      const root = document.documentElement;
      const cur  = root.getAttribute('data-theme') || 'dark';
      const next = cur === 'light' ? 'dark' : 'light';
      root.setAttribute('data-theme', next);
      themeBtn.setAttribute('aria-pressed', next === 'light' ? 'true' : 'false');
      const label = themeBtn.querySelector('span:last-child');
      if (label) label.textContent = next === 'light' ? 'Dark' : 'Light';
      try{
        const ui = JSON.parse(localStorage.getItem('pb.v1.ui') || '{}');
        ui.theme = next;
        localStorage.setItem('pb.v1.ui', JSON.stringify(ui));
      }catch(e){}
    });
  }
})();

// Global: build a ChatGPT URL with best-effort prefill
// Build a ChatGPT URL; prefer ?prompt= only. Also return a length hint.
function buildChatURL(prompt){
  const base = (localStorage.getItem('chatgpt_target') || 'https://chatgpt.com/').trim();
  const txt  = String(prompt || '');
  let url = 'https://chatgpt.com/';
  try {
    const u = new URL(base);
    // Only set ?prompt=. Do NOT also set q/input (those can bloat and cause 431).
    u.search = ''; // clear any previous search
    u.searchParams.set('prompt', txt);
    url = u.toString();
  } catch(_) {
    url = 'https://chatgpt.com/?prompt=' + encodeURIComponent(txt);
  }
  // Conservative headroom: warn if the URL exceeds ~7.8k chars (varies by browser/server).
  const TOO_LONG = url.length > 7800;
  return { url, tooLong: TOO_LONG, base: (new URL((() => {
    try { return base; } catch(_) { return 'https://chatgpt.com/'; }
  })())).origin + '/' };
}
window.buildChatURL = buildChatURL;




// ===== Action Modal v2 — unified, conflict-safe =====
(function(){
  const dlg = document.getElementById('actionModal');
  if (!dlg) return;

  const $ = (sel)=> document.querySelector(sel);
  const title   = $('#actionTitle');
  const closeX  = $('#actionClose');
  const cancelB = $('#actionCancel');
  const confirm = $('#actionConfirm');
  const form    = $('#actionForm');
  const ta      = $('#actionPreview');
  const note    = $('#actionNote');
  const rPrompt = $('#scopePrompt');
  const rAll    = $('#scopeAll');

  // --- conflict shield ---
  // Use capture-phase listeners + stopImmediatePropagation to prevent old handlers from firing.
  function bindCapture(el, fn){
    if (!el) return;
    el.addEventListener('click', (ev)=>{
      ev.preventDefault();
      ev.stopPropagation();
      ev.stopImmediatePropagation();
      fn(ev);
    }, {capture:true});
    // also nuke inline onclicks if any
    el.onclick = null;
  }

  // --- text builders ---
  function getActiveTab(){
    const s = window.state || {};
    const i = Number.isInteger(s.active) ? s.active : 0;
    return (s.tabs && s.tabs[i]) ? s.tabs[i] : null;
  }
  function promptLabel(t, idx){
    const meta = (window.FRAMEWORKS_BY_ID && t?.id) ? window.FRAMEWORKS_BY_ID[t.id] : null;
    const name = meta?.label || t?.id || 'Prompt';
    return `## ${idx+1}. ${name}`;
  }
  function textForSingle(tOverride){
    try{
      const t = tOverride || getActiveTab();
      if (!t) return '';
      if (typeof window.makePromptForTab === 'function'){
        return window.makePromptForTab(t) || '';
      }
      return '';
    }catch(_){ return ''; }
  }
  function textForAll(){
    try{
      const tabs = (window.state && Array.isArray(window.state.tabs)) ? window.state.tabs : [];
      if (!tabs.length) return textForSingle();
      if (typeof window.makePromptForTab === 'function'){
        return tabs.map((t, idx)=>{
          const body = window.makePromptForTab(t) || '';
          return body ? `${promptLabel(t, idx)}\n${body}` : '';
        }).filter(Boolean).join('\n\n---\n\n');
      }
      return '';
    }catch(_){ return ''; }
  }
  function buildText(scope){
    return (scope === 'all') ? textForAll() : textForSingle();
  }

  function setScope(scope){
    rPrompt.checked = (scope === 'prompt');
    rAll.checked    = (scope === 'all');
    const txt = buildText(scope);
    ta.value = txt;
    // soft URL length hint for ChatGPT
const built = window.buildChatURL(txt);
note.hidden = !built.tooLong;
if (built.tooLong){
  note.textContent = 'This prompt is very long. We’ll copy it and open ChatGPT so you can paste (Ctrl/Cmd+V).';
}

  }

  // --- launcher ---
  let modalAction = 'copy'; // 'copy' | 'ask'
  function openModal(kind, defaultScope){
    modalAction = kind;
    title.textContent = (kind === 'ask') ? '💬 Ask ChatGPT' : 'Copy Prompt';
    confirm.textContent = (kind === 'ask') ? 'Open in ChatGPT' : 'Copy';
    setScope(defaultScope || 'prompt');
      ta.value = ta.value || buildText(rAll.checked ? 'all' : 'prompt'); // fallback if anything races
    if (typeof dlg.showModal === 'function') dlg.showModal();
    setTimeout(()=> ta.focus(), 30);
  }

  // radio changes
  rPrompt.addEventListener('change', ()=> setScope('prompt'));
  rAll   .addEventListener('change', ()=> setScope('all'));

  // close/cancel
  function closeModal(){ try{ dlg.close(); }catch(_){ dlg.open=false; } }
  closeX.addEventListener('click', closeModal);
  cancelB.addEventListener('click', closeModal);
  dlg.addEventListener('cancel', (e)=>{ e.preventDefault(); closeModal(); });

  // confirm
form.addEventListener('submit', async (e)=>{
  e.preventDefault();
  const txt = ta.value || '';
  if (!txt.trim()) return;

  if (modalAction === 'copy'){
    try { await navigator.clipboard.writeText(txt); } catch(_){}
    showToast('Copied to clipboard.');
    closeModal();
    return;
  }

  // Ask ChatGPT
  let built;
  try { built = window.buildChatURL(txt); } catch(_) { built = { url:'https://chatgpt.com/?prompt='+encodeURIComponent(txt), tooLong:false, base:'https://chatgpt.com/' }; }

  if (built.tooLong){
    // URL would be too long; fallback: copy then open a clean chat for paste.
    try { await navigator.clipboard.writeText(txt); } catch(_){}
    showToast('Text copied. ChatGPT opened — paste (Ctrl/Cmd+V).', 2600);
    window.open(built.base, '_blank', 'noopener,noreferrer');
    closeModal();
    return;
  }

  window.open(built.url, '_blank', 'noopener,noreferrer');
  closeModal();
});


  // --- wire triggers in CAPTURE (kills prior handlers) ---
  function wire(id, kind, defaultScope){
    const el = document.getElementById(id);
    bindCapture(el, ()=> openModal(kind, defaultScope));
  }
  // Header (defaults to All)
  wire('copyBtn', 'copy', 'all');
  wire('openBtn', 'ask',  'all');
  // Configure (defaults to Current)
  wire('copyBtn2', 'copy', 'prompt');
  wire('openBtn2', 'ask',  'prompt');
  // Footer duplicates if present (All)
  wire('copyAllBtnFooter', 'copy', 'all');
  wire('openAllBtnFooter', 'ask',  'all');

  // Inline chips (per-card) — give them class .js-inline-copy and data-idx (card index)
  document.addEventListener('click', function onChip(e){
    const btn = e.target.closest('.js-inline-copy');
    if (!btn) return;
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();

    const ix = Number(btn.getAttribute('data-idx'));
    const prev = window.state?.active;
    if (Number.isInteger(ix) && window.state?.tabs?.[ix]){
      window.state.active = ix;
      // Build once with that active index, then restore
      setScope('prompt');
      window.state.active = prev;
    } else {
      setScope('prompt');
    }
    openModal('copy', 'prompt');
  }, {capture:true}); // capture to preempt old handlers
})();


  })();
  </script>
  
  <script>
/* === Print Worksheet — full wiring (works with or without Action Modal) === */
(function wireWorksheetButton(){
  function getKind(){
    try { return (typeof currentDataset === 'function')
      ? currentDataset()
      : (localStorage.getItem('fw_dataset') || 'patterns'); }
    catch(_) { return 'patterns'; }
  }
  function getActive(){
    try {
      if (typeof activeTab === 'function') return activeTab();
      const s = window.state;
      if (s && Array.isArray(s.tabs)) return s.tabs[s.active];
    } catch(_) {}
    return null;
  }
  function collectFromTab(t){
    const bag = { common:{}, fields:{} };
    // Per-tab common in your app: { ctx, audience, style, tone }
    try {
      const c = t?.common || {};
      if (c.ctx)       bag.common.usecase  = c.ctx;
      if (c.audience)  bag.common.audience = c.audience;
      if (c.style)     bag.common.style    = c.style;
      if (c.tone)      bag.common.tone     = c.tone;
    } catch(_){}
    try { Object.assign(bag.fields, t?.fields || {}); } catch(_){}
    // Bias chips from UI (optional)
    try{
      const chips = Array.from(document.querySelectorAll('#biasChips .chip'))
        .map(c => (c.textContent||'').trim()).filter(Boolean);
      if (chips.length) bag.common.biases = chips;
    }catch(_){}
    return bag;
  }
  function openWorksheet(){
    const t = getActive();
    const id = t?.id || document.getElementById('frameworkSel')?.value || '';
    if (!id || id === 'none'){ alert('Pick a template first.'); return; }

    const kind = getKind(); // 'patterns' | 'tasks'
    const key  = `pb.v1.xfer.${kind}.${id}`;
    try { sessionStorage.setItem(key, JSON.stringify(collectFromTab(t))); } catch(_){}

    const url = new URL('./prompt-worksheet.html', location.href);
    url.searchParams.set('kind', kind);
    url.searchParams.set('id',   id);
    url.searchParams.set('xfer', key);
    window.open(url.toString(), '_blank', 'noopener');
  }

  // Event delegation so it works regardless of when the row is rendered
  document.addEventListener('click', function onClick(e){
    const btn = e.target.closest('#worksheetBtn2, #worksheetBtnHeader');
    if (!btn) return;
    e.preventDefault();
    e.stopPropagation();
    openWorksheet();
  }, { capture:true });
})();
</script>

  
</body>
</html>
