<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prompt Template Builder (beta)</title>
  <style>
:root{
  --bg:#0b0f14; --panel:#121821; --card:#0f151d; --muted:#9db0c3; --text:#e7eff7;
  --accent:#4ea1ff; --chip:#1b2533; --border:#1b2838; --radius:14px; --gap:14px;
  --green:#2ecc71; --yellow:#f1c40f; --red:#e74c3c; --purple:#a78bfa;
  /* new */
  --border-strong:#2a3a4f; /* darker/lighter than --border for better separation in dark */
}
:root[data-theme="light"]{
  --bg:#f7fafc; --panel:#ffffff; --card:#ffffff; --muted:#5a6b7b; --text:#121621;
  --accent:#2563eb; --chip:#f1f5f9; --border:#d8e0ea;
  /* new: slightly stronger than light border for clear separation */
  --border-strong:#b9c6d6;
}

    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans",sans-serif}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}

    header{
      display:flex;align-items:center;gap:12px;padding:12px 16px;position:sticky;top:0;z-index:10;
      background:linear-gradient(180deg,var(--panel),rgba(0,0,0,0));border-bottom:1px solid var(--border);
      backdrop-filter: blur(8px);
    }
    header .spacer{flex:1}
    .btn{cursor:pointer;border:1px solid var(--border);background:var(--chip);color:var(--text);padding:8px 12px;border-radius:10px}
    .btn.primary{background:var(--accent);color:#061422;border:none}
    /* default (dark theme): keep dark text on light accent */
.btn.primary{ color:#061422; }

/* light theme: white text on darker accent for AA contrast */
:root[data-theme="light"] .btn.primary{ color:#ffffff; }

    .btn.sm{padding:6px 10px;font-size:14px;border-radius:8px}
   .toggle{
  display:inline-flex;align-items:center;gap:8px;
  border:1px solid var(--border);background:var(--chip);
  padding:6px 10px;border-radius:999px;
  color: var(--text); /* force readable text in both themes */
}
.toggle:hover, .toggle:focus-visible{
  box-shadow: 0 0 0 2px rgba(78,161,255,.25);
  outline: none;
}

    .dot{width:16px;height:16px;border-radius:50%;background:linear-gradient(180deg,#fdd835,#fbc02d);box-shadow:inset 0 -3px 6px rgba(0,0,0,.25)}
    :root[data-theme="light"] .dot{background:linear-gradient(180deg,#121621,#394554)}

    .wrap{
  display:grid;
  grid-template-columns: var(--leftW, 360px) 6px 1fr; /* left | resizer | right */
  gap:16px;
  padding:16px;
}

    .panel{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius)}
    .panel h2{margin:0;padding:12px 14px;border-bottom:1px solid var(--border);font-size:18px}
    .panel section{padding:14px}

    label{display:block;margin:10px 0 6px;color:var(--muted);font-size:16px; font-weight:600;}
    
.resizer{
  width:6px;
  cursor: col-resize;
  background: transparent;
  position: relative;
}
.resizer::after{
  content:'';
  position:absolute; inset:0;
  background: linear-gradient(to bottom, transparent 0, transparent 20%, var(--border) 20%, var(--border) 80%, transparent 80%, transparent 100%);
  opacity:.6;
}
.resizer:hover::after{ opacity:1; }

/* Clearer grab handle inside the 6px resizer */
.resizer::before{
  content:'';
  position:absolute;
  top:12px; bottom:12px;
  left:50%; transform:translateX(-50%);
  width:2px; border-radius:2px;
  background: rgba(255,255,255,.30);        /* dark mode default */
}
:root[data-theme="light"] .resizer::before{
  background: rgba(0,0,0,.28);              /* light mode default */
}
.resizer:hover::before,
.resizer:focus-visible::before{
  background: var(--accent);
  box-shadow: 0 0 0 2px rgba(78,161,255,.25);
}

.finder{ margin-bottom:8px; }
.finder input{ width:100%; }


.finder{ position:relative; margin-bottom:8px; }
.finder input{ width:100%; padding-right:64px; }
.finder .btn.tiny{
  position:absolute; right:6px; top:50%; transform:translateY(-50%);
  padding:4px 8px; font-size:12px; border-radius:999px;
}

/* Hint: shows "Showing N/M" when filtered */
.finder .hint{
  position:absolute;
  right:56px;              /* sits just to the left of the All button */
  top:50%; transform:translateY(-50%);
  font-size:12px;
  color:var(--muted);
  opacity:.9;
  pointer-events:none;     /* don't steal clicks from the input */
}




/* Not Using */
.useChips{ display:flex; flex-wrap:wrap; gap:8px; margin:6px 0 8px; }
.useChips .chip{ cursor:pointer; user-select:none; }
.useChips .chip.active{ outline:2px solid var(--accent); }

.suggestions{ display:flex; flex-wrap:wrap; gap:6px; margin:6px 0 12px; }
.suggestions .suggest{ cursor:pointer; padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:var(--chip); font-size:12px; }


/* Nice vertical rhythm between fields */
.field + .field{ margin-top:12px; }


/* Inline counters inside inputs/textareas */
.fieldHolder{ position:relative; }
.counter{
  position:absolute; right:10px; bottom:8px;
  font-size:11px; color:var(--muted); opacity:0.85;
  pointer-events:none; user-select:none;
}
.hasCounter{ padding-right:76px !important; }   /* prevent overlap with typing */
textarea.hasCounter{ padding-right:84px !important; } /* a tad more room for multi-line */


    input[type="text"], textarea, select{
      width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);
      background:var(--card);color:var(--text);outline:none;
    }
    
    input.filled, textarea.filled{
  box-shadow: 0 0 0 2px var(--accent) inset;
  background: rgba(78,161,255,.08);
}
:root[data-theme="light"] input.filled,
:root[data-theme="light"] textarea.filled{
  background: rgba(37,99,235,.06);
}

    textarea{min-height:100px;resize:vertical}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  
    .help{
  color:var(--muted);
  font-size:12px;          /* smaller than label (13px) */
  line-height:1.35;
  margin-top:6px;            /* space from input */
  opacity:0.9;               /* lighter than labels */
}

.desc{
  color:var(--muted);
  font-size:13px;       /* smaller than label */
  line-height:1.35;
  margin-top:6px;
  opacity:0.8;            /* a bit stronger than .help so it reads clearly */
}

/* Meta block under the Glossary button */
.metaSection{
  margin-top:10px;
  font-size:12px;
  color:var(--muted);
  font-weight:700;
  text-transform:uppercase;
  letter-spacing:.04em;
}

.metaGroup{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:8px;
  margin-top:6px;
}

.tinyLabel{
  font-size:11px;
  color:var(--muted);
  opacity:.85;
  padding:2px 8px;
  border:1px solid var(--border);
  border-radius:999px;
  background:var(--chip);
}

/* Dedicated meta box */
#metaChips{
  display:block !important;                 /* stop flex from .chips */
}
.metaBox{
  margin-top:12px;
  padding:12px;
  border:1px solid var(--border);
  border-radius: var(--radius);
  background: var(--card);
}
.metaRow{ margin-top:8px; }
.metaSectionTitle{
  margin-top:10px;
  font-size:12px;
  color:var(--muted);
  font-weight:700;
  text-transform:uppercase;
  letter-spacing:.04em;
}
.metaPills{
  display:flex; flex-wrap:wrap; gap:8px; margin-top:6px;
}
.metaLink{
  display:inline-flex; margin-bottom:4px;
}
.tinyLabel{
  font-size:11px; color:var(--muted); opacity:.85;
  padding:2px 8px; border:1px solid var(--border); border-radius:999px; background:var(--chip);
}

/* Tabs */
.tabs{ display:flex; gap:6px; margin:6px 0 10px; flex-wrap:wrap; }
.tab{
  display:inline-flex; align-items:center; gap:8px;
  padding:6px 10px; border:1px solid var(--border); border-radius:999px;
  background:var(--chip); cursor:pointer; font-size:12px;
}
.tab.active{ outline:2px solid var(--accent); }
.tab .x{
  border:none; background:transparent; cursor:pointer; font-size:14px; line-height:1;
  color:var(--muted);
}
.tab .x:hover{ color:var(--text); }

/* Output deck */
#outDeck{ display:flex; flex-direction:column; gap:12px; margin-top:12px; }
.outCard{
  border:1px solid var(--border); border-radius:var(--radius); background:var(--card);
  padding:10px 12px;
}
.outHead{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  margin-bottom:8px; font-size:13px; color:var(--muted);
  padding-right:10px; /* NEW: gives breathing room so Clear isn't flush right */
}

.outHead .title{ font-weight:600; color:var(--text); }
.outHead .actions{
  display:flex; gap:8px;
  margin-right:2px; /* NEW: tiny inset for safety on narrow widths */
}

.outHead .x{
  border:1px solid var(--border); background:var(--chip); border-radius:8px;
  padding:2px 8px; cursor:pointer;
}
.outBody{ white-space:pre-wrap; font-family:inherit; font-size:13px; line-height:1.45; }
.outActions{ margin-top:10px; }

/* Subtle flash to signal the panel changed */
.fields-swap {
  animation: fieldsSwapFlash 280ms ease-out;
}
@keyframes fieldsSwapFlash {
  0%   { box-shadow: 0 0 0 2px var(--accent) inset; background: rgba(78,161,255,.06); }
  100% { box-shadow: none; background: transparent; }
}

/* A small context chip above the fields */
#tabContext {
  margin-bottom: 8px;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 999px;
  background: var(--chip);
  font-size: 12px;
  color: var(--muted);
}


    .chips{display:flex;flex-wrap:wrap;gap:8px}
    .chip{background:var(--chip);border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:12px}

    pre{margin:0;padding:14px;background:var(--card);border-top:1px solid var(--border);border-radius:0 0 var(--radius) var(--radius);overflow:auto;white-space:pre-wrap}

    .pill{padding:4px 8px;border-radius:999px;border:1px solid var(--border);font-size:12px}
    .pill[data-val="framework"]{color:var(--green)}
    .pill[data-val="pattern"]{color:var(--yellow)}
    
   /* Additional instructions box spacing */
#extra{
  min-height: 72px;
  resize: vertical;
}
 
   /* --- Prompt totals under title --- */
.prompt-total{
  margin: -6px 0 8px 0;
  font-size:12px;
  color: var(--muted);
  opacity: 0.9;
}

/* --- Current preview inline counter (top-right of the big preview) --- */
/* We attach this inside the #out element */
#out{ position: relative; } /* harmless if already positioned elsewhere */
#out .outCounter{
  position:absolute;
  top:8px; right:8px;
  font-size:12px; color:var(--muted); opacity:0.9;
  pointer-events:none; user-select:none;
  background: transparent; /* stays invisible atop your preview */
}


/* ==== Context Coach (single, for current preview) ==== */
/* Sits inside #out, just below the top-right small counter */
#out .outCoach{
  position:absolute;
  right:8px; 
  top:30px; /* directly below .outCounter at top:8px */
  font-size:12px; 
  color:var(--muted); 
  opacity:0.95;
  pointer-events:none; 
  user-select:none;
}
#out .outCoach[hidden]{ display:none; }

/* Chip look with AA-safe colored left border */
#out .outCoach .pill{
  display:inline-flex; align-items:center;
  padding:2px 10px; border-radius:999px;
  background:var(--chip); border:1px solid var(--border);
  font-weight:700;
  /* color stays readable; accent via left border only */
}

/* State colors */
#out .outCoach[data-state="low"]     .pill{ border-left:4px solid var(--yellow); }
#out .outCoach[data-state="near"]    .pill{ border-left:4px solid var(--accent); }
#out .outCoach[data-state="good"]    .pill{ border-left:4px solid var(--green); }
#out .outCoach[data-state="perfect"] .pill{ border-left:4px solid var(--purple); }
#out .outCoach[data-state="high"]    .pill{ border-left:4px solid var(--red); }

/* Make room at the top of the preview when coach is visible */
#out.hasCoach{
  padding-top:52px;
  /* NEW: reserve horizontal space for the coach pill */
  padding-right: var(--coachPad, 160px) !important;
}

#out.hasCounter{
  padding-top:28px;
  /* NEW: reserve horizontal space for the corner counter */
  padding-right: var(--counterPad, 72px);
}
   
    /* Independent scroll for the left panel */
#configPanel{
  position: sticky;
  top: 60px; /* sits under the sticky header */
  max-height: calc(100vh - 60px - 16px); /* header + grid padding */
  overflow: auto; /* vertical & horizontal if needed */
}


/* Area labels to distinguish preview vs deck */
.areaLabel{
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 8px; margin:8px 0 6px;
  border:1px solid var(--border);
  background:var(--chip);
  border-radius:999px; font-size:12px; color:var(--muted);
}
.areaLabel .dot{ width:6px; height:6px; border-radius:999px; background:var(--accent); }

/* Stronger section separation (dark-friendly) */
#out{
  border:1px solid var(--border-strong);
  background:linear-gradient(180deg, rgba(78,161,255,.05), transparent 45%);
  border-radius: var(--radius);
}
.outCard{
  border-color: var(--border-strong);
}

/* High-contrast remove buttons (tabs + deck) */
.tab .x,
.outHead .x{
  color: var(--text);
  background: var(--chip);
  border: 1px solid var(--border-strong);
  border-radius: 999px;
  padding: 4px 10px;               /* room for “Clear” */
    line-height: 1;
  width: 22px; height: 22px;
  display: inline-flex; align-items: center; justify-content: center;
}
.tab .x:hover, .outHead .x:hover{
  box-shadow: 0 0 0 2px rgba(78,161,255,.25);
}
.tab .x:focus-visible, .outHead .x:focus-visible{
  outline:none;
  box-shadow: 0 0 0 2px rgba(78,161,255,.45);
}

/* === Typeahead (persona picker) === */
.taWrap{ position:relative; }
.taList{
  position:absolute; left:0; right:0; top:100%;
  margin-top:6px; z-index:50;
  background:var(--card); border:1px solid var(--border); border-radius:10px;
  max-height:220px; overflow:auto;
  box-shadow: 0 6px 18px rgba(0,0,0,.25);
}
.taList[hidden]{ display:none; }
.taItem{
  padding:8px 10px; cursor:pointer; border-bottom:1px solid var(--border);
  font-size:13px; display:flex; flex-direction:column; gap:2px;
}
.taItem:last-child{ border-bottom:none; }
.taItem .name{ color:var(--text); font-weight:600; }
.taItem .sub{ color:var(--muted); font-size:12px; }
.taItem.active{ outline:2px solid var(--accent); outline-offset:-2px; }

.panel select{
  width:100%;
  padding:8px 10px;
  border:1px solid var(--border);
  border-radius:10px;
  background:var(--card);
  color:var(--text);
  outline:none;
}

    @media (max-width: 960px){
      .wrap{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <header>
    <a class="btn sm" href="../glossary/index.html">← Back to Glossary</a>
    <strong>Prompt Framework Builder</strong>
    <span class="pill" data-val="framework" title="Frameworks & Patterns">frameworks + patterns</span>
    <span class="spacer"></span>
    <button id="copyBtn" class="btn sm">Copy all prompts</button>
    <button id="openBtn" class="btn primary sm">Open in ChatGPT</button>
    <button id="theme" class="toggle" aria-pressed="false" title="Toggle theme"><span class="dot"></span><span>Light</span></button>
  </header>

  <div class="wrap">
  <div class="panel" id="configPanel">
      <h2>Configure</h2>
      
      <div id="tabbar" class="tabs" hidden></div>
      
      <section>
        <label for="frameworkSel">Templates</label>
        
<div id="finderBar" class="finder">
  <input id="fwSearch" type="text" placeholder="Find a template by name, tag, or use case… (Ctrl/Cmd+K)">
  <span id="fwHint" class="hint" aria-live="polite" hidden></span>
  <button id="fwAll" type="button" class="btn tiny" title="Show full list">All</button>
</div>



        <select id="frameworkSel"></select>
        <div id="fwHelp" class="help" aria-live="polite"></div>
      </section>

      <section>
      
      <!-- Hidden until >1 template -->
<div id="tabbar" class="tabs" hidden></div>
        <h3 style="margin:0 0 6px;font-size:14px">Common context (optional)</h3>
        <div class="row">
          <div>
            <label for="usecase">Use‑case / scenario</label>
            <input id="usecase" type="text" placeholder="e.g., Launch email for a new service" />
          </div>
          <div>
            <label for="audience">Audience</label>
            <input id="audience" type="text" placeholder="e.g., Busy SMB owners" />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="style">Style</label>
            <input id="style" type="text" placeholder="e.g., Practical, plain language" />
          </div>
          <div>
            <label for="tone">Tone</label>
            <input id="tone" type="text" placeholder="e.g., Friendly, confident" />
          </div>
        </div>
      </section>

      <section>
        <h3 style="margin:0 0 6px;font-size:14px">Template fields</h3>
        <div id="fields"></div>
        <div class="help"><br> Only fill what helps. Empty fields are omitted in the prompt.</div>
      </section>

      <section>
        <div class="chips" id="metaChips"></div>
      </section>
    </div>
<div id="resizer" class="resizer" role="separator" aria-orientation="vertical" aria-valuemin="280" aria-valuemax="900" tabindex="0"></div>
    <div class="panel">
      <h2>Generated prompt</h2>
      <div id="masterPromptTotal" class="prompt-total prompt-total--master" aria-live="polite"></div>

<div id="previewLabel" class="areaLabel"><span class="dot"></span><span>Preview • Active tab</span></div>
<pre id="out"></pre>

<div id="deckLabel" class="areaLabel" hidden><span class="dot"></span><span>Output deck • All templates</span></div>
<div id="outDeck" class="out-deck" hidden></div>

<!-- New: add-template button under the preview/deck -->
<div class="outActions" style="margin-top:8px">
  <button id="addPromptBtn" class="btn">+ Add template</button>
</div>

    </div>

    
  </div>

  <dialog id="msg"><form method="dialog" style="margin:0">
    <section id="msgText" style="padding:16px">
    
    Prompt copied to clipboard. A new tab opened; if it didn’t prefill, paste with Cmd/Ctrl+V.
    
    </section>
    
    
    <footer style="display:flex;justify-content:flex-end;gap:8px;padding:12px;border-top:1px solid var(--border)">
    
    <button class="btn" type="button" id="dlgClose">Close</button>

  </form></dialog>

  <!-- Load the glossary if available. Adjust the path to match your repo layout. -->
  <script>
    // If this file lives at /AI/tools/framework-template-builder.html,
    // the glossary may be at /AI/glossary/glossary.data.js. We try to load it dynamically.
    (function tryLoadGlossary(){
      const s = document.createElement('script');
      s.src = '../glossary/glossary.data.js';
      s.onerror = ()=>console.info('Glossary not found at ../glossary/glossary.data.js — continuing without it.');
      document.head.appendChild(s);
    })();
  </script>
  
  <script>
  // Personas DB (window.PERSONAS) — safe to load even if absent
  (function tryLoadPersonas(){
    const s = document.createElement('script');
    s.src = './persona.data.js';
    s.onerror = ()=>console.info('Persona data not found at ./persona.data.js — typeahead will still allow free text.');
    document.head.appendChild(s);
  })();
</script>


  <script>
  (function(){
    const $ = s=>document.querySelector(s);
    
    /* ===== Persona helpers ===== */
function personaIndex(){
  // Returns an array; empty if the data hasn't loaded yet.
  return Array.isArray(window.PERSONAS) ? window.PERSONAS : [];
}

function personaFilter(query, max=20){
  const q = (query||'').trim().toLowerCase();
  if (!q) return [];
  const toks = q.split(/\s+/).filter(Boolean);
  const src = personaIndex();

  // Score by token coverage + prefix boost on name/id
  const scored = src.map(p=>{
    const hay = (p.meta?.search_text || `${p.name||''} ${p.profession||''} ${(p.tags||[]).join(' ')}`).toLowerCase();
    let s = 0;
    for (const t of toks){
      if (hay.includes(t)) s += 2;
      if (String(p.name||'').toLowerCase().startsWith(t)) s += 4;
      if (String(p.id||'').toLowerCase().startsWith(t)) s += 3;
    }
    return {p, s};
  }).filter(x=>x.s>0)
    .sort((a,b)=> b.s - a.s || String(a.p.name).localeCompare(String(b.p.name)));

  return scored.slice(0,max).map(x=>x.p);
}

function applyPersonaToTab(tab, persona){
  if (!tab || !persona) return;
  // Do NOT touch 'end' (user-supplied goal)
  tab.fields = {
    ...(tab.fields||{}),
    persona_name: persona.name || '',
    profession:   persona.profession || '',
    summary:      persona.summary || '',
    description:  persona.description || '',
    core_tasks:   (persona.core_tasks||[]).join('\n'),
    skills:       (persona.skills||[]).join(', '),
    vocabulary:   (persona.vocabulary||[]).join(', '),
    goals:        (persona.goals||[]).join('\n'),
    pain_points:  (persona.pain_points||[]).join('\n'),
    tools:        (persona.tools||[]).join(', ')
  };
}

    
    
    // --- helper: default booster for a framework id
function defaultBooster(id){
  const fw = FRAMEWORKS.find(f => f.id === id);
  if (!fw) return '';
  const arr = Array.isArray(fw.boosters) ? fw.boosters : [];
  return arr.join(' ').trim();
}

    const out = $('#out');
    const fieldsWrap = $('#fields');
    const help = $('#fwHelp');
    const chips = $('#metaChips');
    



const FRAMEWORKS = [
  
    {
    id:'none',
    slug:'none',
    label:'— Select a template —',
    kind:'none',
    categories:['none'],
    tags:[
  'type:none'
],
use_cases: [
  'none'
],
boosters: [
  ""
],
    definition:'',
    help:'',
    fields:[
      {},
    
    ],
    template:({product,key_benefit,cta,constraints,ctx,audience,style,tone})=>[
      ``,
      ctx&&`Context: ${ctx}`,
      product&&`Offer: ${product}`,
      audience&&`Audience: ${audience}`,
      key_benefit&&`Key benefit/value: ${key_benefit}`,
      style&&`Style: ${style}`,
      tone&&`Tone: ${tone}`,
      constraints&&`Constraints: ${constraints}`,
      cta&&`End with this CTA: ${cta}`
    ].filter(Boolean).join('\n')
  },
  
    {
    id: 'abcde',
    slug: 'abcde-cbt-framework',
    label: 'ABCDE — Activating event · Belief · Consequence · Dispute · Effect',
    kind: 'framework',
    categories: ['psychology', 'self-reflection'],
    tags: [
      'type:framework','topic:cbt','topic:reframing','level:intermediate',
      'use:cognitive-bias','use:personal-coaching','use:thought-challenge'
    ],
    use_cases: [
      'reframe negative thoughts or assumptions',
      'self-coaching through emotional situations',
      'cognitive bias or stress analysis'
    ],
    boosters: [
      'Keep a calm, supportive tone when disputing the belief.',
      'Cite evidence or alternative viewpoints that challenge the negative belief.'
    ],
    definition: 'A cognitive restructuring tool to challenge a belief by examining an event, the belief, its consequence, disputing the belief, and envisioning a positive effect.',
    help: 'Describe the triggering event, your belief about it, and the outcome. The model will help dispute the belief and suggest a healthier outcome.',
    fields: [
      { key: 'event', label: 'Activating event', type: 'textarea',
        desc: 'What happened? The trigger or situation.',
        ph: 'e.g., My manager criticized my report in the team meeting.' },
      { key: 'belief', label: 'Belief or thought', type: 'textarea',
        desc: 'Your interpretation or assumption about the event.',
        ph: 'e.g., "I must be bad at my job."' },
      { key: 'consequence', label: 'Consequence (feelings/behavior)', type: 'textarea',
        desc: 'Emotions or actions that resulted from that belief.',
        ph: 'e.g., I felt anxious and avoided taking on new projects.' }
    ],
    template: ({ event, belief, consequence, ctx, audience, style, tone }) => [
      'Apply the ABCDE framework to reframe the situation.',
      ctx && `Context: ${ctx}`,
      audience && `Audience: ${audience}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      event && ('Activating event:\n' + event),
      belief && ('Belief:\n' + belief),
      consequence && ('Consequence:\n' + consequence),
      'Dispute: Identify evidence against the belief or an alternative perspective.',
      'Effect: Describe a healthier outcome or feeling once the belief is adjusted.'
    ].filter(Boolean).join('\n')
  },
  
  {
    id: 'addie',
    slug: 'addie-instructional-design',
    label: 'ADDIE — Analyze · Design · Develop · Implement · Evaluate',
    kind: 'framework',
    categories: ['education', 'planning'],
    tags: [
      'type:framework','topic:instructional-design','phase:plan','level:beginner',
      'use:course-development','use:lesson-planning','use:training-strategy'
    ],
    use_cases: [
      'plan and structure an educational course or program',
      'develop training materials systematically',
      'review and improve learning content'
    ],
    boosters: [
      'In Analyze, identify learner needs and constraints; in Evaluate, include metrics or feedback methods.',
      'Ensure each development step ties back to the learning objectives.'
    ],
    definition: 'An instructional design model outlining five phases for creating effective learning experiences.',
    help: 'Provide the training topic and audience. The model will walk through Analyze, Design, Develop, Implement, and Evaluate steps for a structured learning plan.',
    fields: [
      { key: 'topic', label: 'Training topic', type: 'text',
        desc: 'Subject matter or skill to be taught.',
        ph: 'e.g., Basics of Data Science' },
      { key: 'audience', label: 'Learner audience', type: 'text',
        desc: 'Who the learners are (age, role, prior knowledge).',
        ph: 'e.g., Junior marketing analysts with no coding background' },
      { key: 'objectives', label: 'Learning objectives (optional)', type: 'textarea',
        desc: 'Specific goals or outcomes for the learning (if already defined).',
        ph: 'e.g., Understand key Python libraries; build a simple regression model.' }
    ],
    template: ({ topic, audience, objectives, ctx, style, tone }) => [
      'Use the ADDIE model to design a learning experience.',
      ctx && `Context: ${ctx}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      topic && `Topic: ${topic}`,
      audience && `Audience: ${audience}`,
      objectives && ('Objectives:\n' + objectives),
      'Output:\n1) Analyze: needs & constraints\n2) Design: outline format & strategy\n3) Develop: materials & activities\n4) Implement: delivery plan\n5) Evaluate: assessment & feedback method'
    ].filter(Boolean).join('\n')
  },
  
  {
    id:'aida',
    slug:'aida-model',
    label:'AIDA — Attention · Interest · Desire · Action',
    kind:'framework',
    categories:['messaging frameworks','prompt development techniques'],
    tags:[
  'type:framework','topic:messaging','phase:apply','level:beginner',
  'use:ad-copy','use:landing-page','use:email-campaign','use:social-post'
],
use_cases: [
  'ad copy',
  'landing page messaging',
  'email campaign copy',
  'social post copy',
  'ad headlines & CTAs',
  'video script teaser',
  'push notification blurb'
],
boosters: [
  "Return 3 headline/CTA variants; rank them and state the top-1 reason in one short line."
],
    definition:'A classic four-stage persuasion model that moves an audience from attention to action.',
    help:'Classic marketing flow for persuasive outputs.',
    fields:[
      {key:'product',     label:'Product/offer',            type:'text',     desc:'What you are promoting.',           ph:'e.g., Email warmup tool'},
      {key:'key_benefit', label:'Key benefit',              type:'text',     desc:'Primary value to highlight.',      ph:'e.g., Better deliverability in 2 weeks'},
      {key:'cta',         label:'Primary call-to-action',   type:'text',     desc:'The action to take.',              ph:'e.g., Start free trial'},
      {key:'constraints', label:'Constraints',              type:'textarea', desc:'Rules/limits to follow.',          ph:'e.g., <=120 words; no jargon'}
    ],
    template:({product,key_benefit,cta,constraints,ctx,audience,style,tone})=>[
      `Use AIDA to craft a persuasive message.`,
      ctx&&`Context: ${ctx}`,
      product&&`Offer: ${product}`,
      audience&&`Audience: ${audience}`,
      key_benefit&&`Key benefit/value: ${key_benefit}`,
      style&&`Style: ${style}`,
      tone&&`Tone: ${tone}`,
      constraints&&`Constraints: ${constraints}`,
      cta&&`End with this CTA: ${cta}`
    ].filter(Boolean).join('\n')
  },
  
    {
  id:'argument-map',
  slug:'argument-mapping',
  label:'Argument Mapping — Claim · Premises · Objections · Rejoinders',
  kind:'framework',
  categories:['reasoning patterns'],
  tags:[
    'type:framework','topic:argumentation','phase:structure','level:beginner'
  ],
  use_cases:[
    'Debate prep','Design trade-offs','Policy briefs','Litigation memos'
  ],
  definition:'Lay out claims, supporting premises, objections, and rebuttals as a clear tree.',
  help:'Give a thesis, premises, likely objections, and evidence. You’ll get an ASCII map and a short strength assessment.',
  fields:[
    {key:'thesis',      label:'Thesis / main claim', type:'text',     ph:'e.g., We should adopt Option B.'},
    {key:'premises',    label:'Premises (one per line)', type:'textarea', ph:'e.g., Lower cost\\nHigher reliability\\nFaster to ship'},
    {key:'evidence',    label:'Key evidence',        type:'textarea', ph:'Studies, metrics, sources'},
    {key:'objections',  label:'Objections (one per line)',type:'textarea', ph:'e.g., Vendor risk\\nMigration cost'},
    {key:'rejoinders',  label:'Rejoinders (one per line)',type:'textarea', ph:'e.g., Multi-vendor strategy\\nStaged rollout'},
    {key:'standard',    label:'Standard of proof',   type:'text',     ph:'preponderance | clear & convincing | beyond reasonable doubt'}
  ],
  boosters:[
    'Return a 1–5 confidence score and the top missing premise or evidence that would improve it most.'
  ],
  template:({thesis,premises,evidence,objections,rejoinders,standard,ctx})=>[
    'Construct an argument map.',
    ctx && `Context: ${ctx}`,
    thesis && `Thesis: ${thesis}`,
    evidence && `Evidence: ${evidence}`,
    standard && `Standard of proof: ${standard}`,
    'Output:',
    'A) ASCII tree:',
    'Claim',
    '├─ Premises',
    premises && String(premises).split(/\\n+/).filter(Boolean).map((p,i)=>`│  ├─ P${i+1}: ${p}`).join('\\n'),
    '├─ Objections',
    objections && String(objections).split(/\\n+/).filter(Boolean).map((o,i)=>`│  ├─ O${i+1}: ${o}`).join('\\n'),
    '└─ Rejoinders',
    rejoinders && String(rejoinders).split(/\\n+/).filter(Boolean).map((r,i)=>`   ├─ R${i+1}: ${r}`).join('\\n'),
    'B) Assessment: note strongest premise, strongest objection, and net strength.',
    'C) Revision: refined thesis if warranted.'
  ].filter(Boolean).join('\n')
},

{
    id: 'bab',
    slug: 'before-after-bridge-formula',
    label: 'Before-After-Bridge (BAB) — Before state · After state · Bridge (solution)',
    kind: 'framework',
    categories: ['messaging frameworks', 'marketing'],
    tags: [
      'type:framework','topic:copywriting','phase:compose','level:beginner',
      'use:value-proposition','use:ad-copy','use:pitch'
    ],
    use_cases: [
      'highlight a product’s impact by contrasting life before vs. after its use',
      'craft persuasive marketing copy or landing page sections',
      'explain change by showing the transformation a solution provides'
    ],
    boosters: [
      'Make the "Before" scenario relatable and painful; make the "After" state clearly desirable.',
      'Present the solution (Bridge) as the unique link that makes the positive after-state possible.'
    ],
    definition: 'A persuasion formula that contrasts the audience’s world before and after a solution, then positions the solution as the bridge to get from before to after.',
    help: 'Describe the target audience’s current situation (Before) and the ideal future (After), and specify your solution. The model will craft a message that amplifies the pain of the before state, the appeal of the after state, and shows the solution as the bridge.',
    fields: [
      { key: 'before', label: 'Before — current pain point', type: 'textarea',
        desc: 'The problem state or situation the audience is facing now.',
        ph: 'e.g., Small business owners manually track invoices, causing errors and late payments.' },
      { key: 'after', label: 'After — desired outcome', type: 'textarea',
        desc: 'The improved state or benefit once the problem is solved.',
        ph: 'e.g., They have an automated system, so all invoices are tracked and paid on time with no effort.' },
      { key: 'product', label: 'Bridge — solution/offering', type: 'text',
        desc: 'The product or service that bridges the gap (your offering).',
        ph: 'e.g., PayEasy automated invoicing software' }
    ],
    template: ({ before, after, product, ctx, audience, style, tone }) => [
      'Use the Before-After-Bridge formula to craft a persuasive message.',
      ctx && `Context: ${ctx}`,
      audience && `Audience: ${audience}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      before && ('Before:\n' + before),
      after && ('After:\n' + after),
      product && (`Bridge (solution): ${product}`),
      'Output:\n1) Paint the “before” scenario (pain)\n2) Describe the “after” scenario (gain)\n3) Introduce the solution as the bridge between them'
    ].filter(Boolean).join('\n')
  },

{
  id:'bias_interrupters',
  slug:'bias-interrupters',
  label:'Bias Interrupters (process checks)',
  kind:'pattern',
  categories:['people','ethics','operations'],
  tags:[
    'type:pattern','topic:bias-interrupters','topic:rubrics','level:intermediate',
    'use:hiring','use:evaluation','use:promotion'
  ],
  use_cases:[
    'add measurable process tweaks to interrupt bias',
    'operationalize fair evaluation',
    'track change over time'
  ],
  definition:'System-level checks to interrupt bias in hiring, evaluation, and promotion using measurable tweaks.',
  help:'Choose a process step, name bias risks, add an interrupter strategy, pick a metric, and plan iteration.',
  boosters:[
    'Force a named owner per metric.',
    'Define success and a review cadence (e.g., quarterly).'
  ],
  fields:[
    { key:'process_step', label:'Process step', type:'text', ph:'Hiring / Evaluation / Promotion / Review' },
    { key:'bias_risk',    label:'Bias risk(s)', type:'textarea', ph:'Gut-feel; halo effect; similarity bias…' },
    { key:'strategy',     label:'Interrupter strategy', type:'textarea', ph:'Structured interviews; rubrics; anonymization…' },
    { key:'metric',       label:'Metric to track', type:'textarea', ph:'e.g., Score variance by rubric item; pass-through by group…' },
    { key:'iteration',    label:'Iteration plan', type:'textarea', ph:'What to refine next cycle and when.' }
  ],
  template: ({ process_step, bias_risk, strategy, metric, iteration, ctx, audience, style, tone }) => [
    'Design a bias-interrupter for a people process with clear metrics.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    process_step && `Process step: ${process_step}`,
    bias_risk && ('Bias risks:\n' + bias_risk),
    strategy && ('Interrupter strategy:\n' + strategy),
    metric && ('Metric(s) to track:\n' + metric),
    iteration && ('Iteration plan:\n' + iteration),
    'Output:\n1) Interrupter spec\n2) Owner + start date\n3) Metric w/ target\n4) Review cadence\n5) Risks & mitigations'
  ].filter(Boolean).join('\n')
},

{
  id:'bias_impact_assessment',
  slug:'bias-impact-assessment',
  label:'Bias Impact Assessment (AI/tech)',
  kind:'pattern',
  categories:['ai','ethics','risk'],
  tags:[
    'type:pattern','topic:impact-assessment','topic:transparency','level:advanced',
    'use:pre-launch','use:model-review','use:policy'
  ],
  use_cases:[
    'assess bias risks for systems before launch',
    'define mitigations and transparency steps',
    'plan follow-up monitoring'
  ],
  definition:'Pre-launch assessment modeled on impact reports to surface stakeholders, risks, mitigations, and monitoring.',
  help:'Name the system and purpose, list stakeholders, map bias risks, define mitigations & transparency, add monitoring.',
  boosters:[
    'Include an explainability note (e.g., model cards/datasheets).',
    'Propose a drift/impact monitoring threshold and response path.'
  ],
  fields:[
    { key:'system',       label:'System / algorithm / product name', type:'text', ph:'Name/version' },
    { key:'purpose',      label:'Intended purpose', type:'textarea', ph:'Primary task and success measures.' },
    { key:'stakeholders', label:'Stakeholders affected (one per line)', type:'textarea', ph:'Groups/roles.' },
    { key:'risks',        label:'Bias risks identified', type:'textarea', ph:'Inputs, labels, sampling, shift, proxy variables…' },
    { key:'mitigation',   label:'Mitigation steps', type:'textarea', ph:'Data/process/model changes; human-in-the-loop…' },
    { key:'transparency', label:'Transparency / explainability measures', type:'textarea', ph:'Docs, disclosures, appeal paths…' },
    { key:'monitoring',   label:'Follow-up monitoring plan', type:'textarea', ph:'Metrics, thresholds, cadence, owner.' }
  ],
  template: ({ system, purpose, stakeholders, risks, mitigation, transparency, monitoring, ctx, audience, style, tone }) => [
    'Create a Bias Impact Assessment for an AI/tech system.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    system && `System: ${system}`,
    purpose && ('Intended purpose:\n' + purpose),
    stakeholders && (
      'Stakeholders:\n' + String(stakeholders).split(/\n+/).map(s=>s.trim()).filter(Boolean).map((x,i)=>`${i+1}. ${x}`).join('\n')
    ),
    risks && ('Bias risks:\n' + risks),
    mitigation && ('Mitigation steps:\n' + mitigation),
    transparency && ('Transparency / explainability:\n' + transparency),
    monitoring && ('Monitoring plan:\n' + monitoring),
    'Output:\n1) System + purpose\n2) Stakeholders\n3) Risks\n4) Mitigations\n5) Transparency plan\n6) Monitoring plan (metric + threshold + owner)'
  ].filter(Boolean).join('\n')
},

{
  id:'blooms',
  slug:'blooms-taxonomy',
  label:'Bloom’s — Remember · Understand · Apply · Analyze · Evaluate · Create',
  kind:'framework',
  categories:['education','critical thinking frameworks'],
  tags:[
    'type:framework','topic:learning','phase:design','level:beginner',
    'use:learning-objectives','use:quiz-items','use:lesson-plans'
  ],
  use_cases:[
    'Write learning objectives','Create quiz/homework items','Plan lessons/projects'
  ],
  definition:'Generate objectives or questions aligned to a chosen Bloom level.',
  help:'Pick the level and topic; get measurable verbs and aligned tasks.',
  fields:[
    {key:'topic',    label:'Topic',     type:'text',     ph:'e.g., Binary search trees'},
    {key:'level',    label:'Bloom level',type:'text',    ph:'remember | understand | apply | analyze | evaluate | create'},
    {key:'n',        label:'# of items', type:'text',    ph:'e.g., 3'},
    {key:'constraints',label:'Constraints',type:'text',  ph:'e.g., measurable verbs; ≤120 words each'}
  ],
  boosters:[
    'Use measurable verbs; include success criteria; scaffold from easier to harder.'
  ],
  template:({topic,level,n,constraints,ctx,audience,style,tone})=>{
    const N = Number.parseInt(n||'3',10) || 3;
    return [
      'Create Bloom-aligned outputs.',
      ctx && `Context: ${ctx}`,
      topic && `Topic: ${topic}`,
      level && `Level: ${level}`,
      audience && `Audience: ${audience}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      constraints && `Constraints: ${constraints}`,
      `Output: ${N} ${level||'level'} learning ${level && level.match(/create|analy|evalu/i)?'tasks':'objectives/questions'} with:`,
      '- Measurable verb; prompt; expected answer traits; success criteria.'
    ].filter(Boolean).join('\n')
  }
},
  
  {
    id:'clear',
    slug:'clear-framework',
    label:'CLEAR — Challenge · Limitation · Effect · Action · Result',
    kind:'framework',
    categories:['analysis frameworks','prompt development techniques'],
    tags:[
  'type:framework','topic:analysis','phase:apply','level:beginner',
  'use:problem-framing','use:retrospective','use:decision-record'
],
use_cases: [
  'problem framing',
  'decision record',
  'risk assessment',
  'root-cause write-up',
  'retrospective summary',
  'proposal justification',
  'change request rationale'
],
boosters: [
  "End with a one-paragraph “Decision record” that links Action→Effect→Result explicitly."
],
    definition:'A problem-framing flow that surfaces constraints and outcomes.',
    help:'Problem-framing flow to surface constraints and outcomes.',
    fields:[
      {key:'challenge',  label:'Challenge',  type:'textarea', desc:'Problem context.',      ph:'e.g., Low onboarding completion'},
      {key:'limitation', label:'Limitation', type:'textarea', desc:'Constraints/risks.',    ph:'e.g., No in-app messaging yet'},
      {key:'effect',     label:'Effect',     type:'textarea', desc:'Observed impact.',      ph:'e.g., High drop-off at step 2'},
      {key:'action',     label:'Action',     type:'textarea', desc:'Intervention/plan.',    ph:'e.g., Add email nudge + tooltip'},
      {key:'result',     label:'Result',     type:'textarea', desc:'Outcome/measure.',      ph:'e.g., Onboarding completion +15%'}
    ],
    template:({challenge,limitation,effect,action,result,ctx})=>[
      ctx&&`Context: ${ctx}`,
      `Use the CLEAR framing to structure the answer.`,
      challenge&&`Challenge: ${challenge}`,
      limitation&&`Limitation: ${limitation}`,
      effect&&`Effect: ${effect}`,
      action&&`Action: ${action}`,
      result&&`Result: ${result}`
    ].filter(Boolean).join('\n')
  },
  
  {
  id:'clear_path',
  slug:'clear-path-forward-framework',
  label:'CLEAR Path Forward — Concise · Logical · Explicit · Adaptive · Reflective',
  kind:'framework',
  categories:['prompt development techniques','prompt literacy'],
  tags:[
    'type:framework','topic:prompting','phase:apply','level:beginner',
    'use:prompt-optimization','use:prompt-iteration','use:clarifying-questions','use:next-step'
  ],
  use_cases: [
    'prompt optimization','clarifying prompts','next-step planning',
    'teaching prompt literacy','debugging failed prompts'
  ],
  definition:'An AI prompt literacy framework that shapes a next best prompt via concise goals, logical steps, explicit constraints, adaptive context, and reflective checks.',
  help:'Use to tighten a messy prompt and identify the next concrete step.',
  fields:[
    {key:'concise',   label:'Concise (goal in one line)',       type:'text',     desc:'Single-sentence objective.',         ph:'e.g., Summarize the paper for a lay audience'},
    {key:'logical',   label:'Logical (steps/structure)',        type:'textarea', desc:'Outline reasoning or steps.',         ph:'e.g., Read → Extract key claims → Simplify → Check terms'},
    {key:'explicit',  label:'Explicit (rules/format/defs)',     type:'textarea', desc:'Constraints, definitions, formats.',  ph:'e.g., 120–150 words; define “overfitting”; Markdown'},
    {key:'adaptive',  label:'Adaptive (audience/context)',      type:'textarea', desc:'Who/where this applies; edge cases.', ph:'e.g., For non-technical policy analysts; US context'},
    {key:'reflective',label:'Reflective (checks/criteria)',     type:'textarea', desc:'Quality checks or acceptance tests.', ph:'e.g., No jargon; 2 factual references; no policy claims'}
  ],
  boosters:[
    'Propose an improved next prompt (≤3 lines) and one concrete next action.'
  ],
  template:({concise,logical,explicit,adaptive,reflective,ctx})=>[
    `Apply the CLEAR Path Forward framework to optimize the prompt and next action.`,
    ctx&&`Context: ${ctx}`,
    concise&&`Concise goal: ${concise}`,
    logical&&`Logical plan: ${logical}`,
    explicit&&`Explicit constraints/format: ${explicit}`,
    adaptive&&`Adaptive context: ${adaptive}`,
    reflective&&`Reflective checks: ${reflective}`
  ].filter(Boolean).join('\n')
},

{
  id:'clear_pm',
  slug:'clear-prompting-method',
  label:'CLEAR Prompting Method — Clarity · Length · Empathy · Actionability · Relevance',
  kind:'framework',
  categories:['prompt development techniques'],
  tags:[
    'type:framework','topic:prompting','phase:apply','level:beginner',
    'use:prompt-hygiene','use:length-control','use:audience-empathy','use:scope-management'
  ],
  use_cases: [
    'prompt hygiene','length control','audience fit',
    'scope management','instruction cleanup'
  ],
  definition:'A prompting checklist to improve clarity, respect length, empathize with the reader, ensure actionability, and maintain relevance.',
  help:'Use to “clean up” instructions before sending to a model.',
  fields:[
    {key:'clarity',       label:'Clarity (must-include info)', type:'textarea', desc:'Remove ambiguity; define terms.',      ph:'e.g., Define “qualified lead”; include timeframe'},
    {key:'length',        label:'Length (limit)',               type:'text',     desc:'Word/token/section limits.',          ph:'e.g., ≤150 words'},
    {key:'empathy',       label:'Empathy (audience needs)',     type:'textarea', desc:'Reader persona/concerns.',            ph:'e.g., Busy execs; prefer bullet points'},
    {key:'actionability', label:'Actionability (doable steps)', type:'textarea', desc:'What the model should do/produce.',   ph:'e.g., Provide 3 options + 1 pick with rationale'},
    {key:'relevance',     label:'Relevance (in/out of scope)',  type:'textarea', desc:'Focus and exclusions.',               ph:'e.g., Focus on onboarding; exclude pricing'}
  ],
  boosters:[
    'Return an edited, tightened prompt honoring the length; list any removed ambiguity in one line.'
  ],
  template:({clarity,length,empathy,actionability,relevance,ctx})=>[
    `Apply the CLEAR Prompting Method to refine the instructions.`,
    ctx&&`Context: ${ctx}`,
    clarity&&`Clarity requirements: ${clarity}`,
    length&&`Length limit: ${length}`,
    empathy&&`Audience empathy: ${empathy}`,
    actionability&&`Actionability: ${actionability}`,
    relevance&&`Relevance (scope): ${relevance}`
  ].filter(Boolean).join('\n')
},

{
  id:'cognitive_debiasing',
  slug:'cognitive-debiasing',
  label:'Cognitive Debiasing',
  kind:'pattern',
  categories:['ethics','bias','critical thinking'],
  tags:[
    'type:pattern','topic:debiasing','topic:consider-the-opposite','level:beginner',
    'use:analysis','use:strategy','use:review'
  ],
  use_cases:[
    'document a current assumption and actively seek disconfirming evidence',
    'run a quick pre-mortem on a plan',
    'decide next adjustment with rationale'
  ],
  definition:'A light-weight scaffold combining “consider the opposite,” disconfirming evidence, and pre-mortem moves.',
  help:'Name the bias risk, state the assumption, generate an opposite scenario, list disconfirming evidence, choose a next step.',
  boosters:[
    'Cite at least 2 credible, independent sources that challenge your assumption.',
    'Add a one-line pre-mortem: “If this failed in 6 weeks, it would be because…”'
  ],
  fields:[
    { key:'bias',        label:'Bias in question', type:'text', ph:'Anchoring / Confirmation / Availability / Other' },
    { key:'initial',     label:'My initial assumption', type:'textarea', ph:'Write it down plainly.' },
    { key:'opposite',    label:'Opposite scenario — What if the opposite is true?', type:'textarea', ph:'Spell the plausible opposite.' },
    { key:'disconfirm',  label:'Disconfirming evidence (≥2, one per line)', type:'textarea', ph:'Source, fact, or datapoint per line.' },
    { key:'premortem',   label:'Pre-mortem (optional) — If this failed, why?', type:'textarea', ph:'Top 1–3 failure reasons.' },
    { key:'decision',    label:'Next step decision — What will I adjust?', type:'textarea', ph:'Change of plan, metric, gate, or experiment.' }
  ],
  template: ({ bias, initial, opposite, disconfirm, premortem, decision, ctx, audience, style, tone }) => [
    'Apply a cognitive debiasing pass.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    bias && `Bias in question: ${bias}`,
    initial && ('Initial assumption:\n' + initial),
    opposite && ('Opposite scenario:\n' + opposite),
    disconfirm && (
      'Disconfirming evidence:\n' + String(disconfirm).split(/\n+/).map(s=>s.trim()).filter(Boolean).map((x,i)=>`${i+1}. ${x}`).join('\n')
    ),
    premortem && ('Pre-mortem:\n' + premortem),
    decision && ('Next step decision:\n' + decision),
    'Output:\n1) Assumption vs. opposite\n2) Disconfirming evidence (≥2)\n3) Decision & rationale\n4) Follow-up check in 2–4 weeks'
  ].filter(Boolean).join('\n')
},


{
    id:'comparative_analysis',
    slug:'comparative-analysis',
    label:'Comparative Analysis — rank • pros/cons • matrix',
    kind:'framework',
    categories:['analysis frameworks','decision support'],
    tags:[
      'type:framework','topic:comparison','topic:evaluation','phase:apply','level:intermediate'
    ],
    use_cases:[
      'choose between options','competitive analysis','tool selection','feature trade-offs'
    ],
    definition:'Compare multiple options using a selected comparison style (ranking, pros/cons, table, weighted matrix, etc.).',
    help:'Pick a comparison style, list the options (one per line), and optionally add criteria (weights with "name:weight").',
    boosters:[
      'End with a concise recommendation and next steps.',
      'Surface key trade-offs in one short line per option.',
      'If criteria are provided with weights, show the score math simply (no long reasoning).'
    ],
    fields:[
      { key:'topic',   label:'Topic / decision context', type:'text',
        ph:'e.g., Choose a JavaScript charting library for dashboards' },

      { key:'compare_style', label:'Comparison style', type:'select',
        desc:'The prompt adapts to your choice.',
        options:[
          { value:'pros-cons', label:'Pros & Cons' },
          { value:'for-against', label:'For & Against' },
          { value:'benefits-risks', label:'Benefits vs. Risks' },
          { value:'strengths-weaknesses', label:'Strengths & Weaknesses' },
          { value:'similarities-differences', label:'Similarities & Differences' },
          { value:'chart', label:'Chart' },
          { value:'venn', label:'Venn' },
          { value:'decision-tree', label:'Decision Tree' },
          { value:'heatmap', label:'Heat Map' },
          { value:'rank',      label:'Ranked List' },
          { value:'rating',    label:'Rating Scale' },
          { value:'weighted-matrix', label:'Weighted Criteria Matrix' },
          { value:'tiering',   label:'Tiering (S/A/B...)' },
          { value:'table',     label:'Side-by-Side Table' },
          { value:'point-by-point', label:'Point-by-Point' },
          { value:'block',     label:'Block Comparison' },
          { value:'benchmarking', label:'Benchmarking (vs gold standard)' },
          { value:'case-studies', label:'Case Studies' },
          { value:'analogies', label:'Analogies & Metaphors' },
          { value:'before-after', label:'Before vs After' },
          { value:'scenario',  label:'Scenario-Based' }
        ]
      },

      { key:'items',   label:'Options to compare (one per line)', type:'textarea',
        ph:'Option A\nOption B\nOption C' },

      { key:'criteria',label:'Criteria (one per line, optional weights)', type:'textarea',
        desc:'Optionally add weights like "cost:30", "ease of use:20". Unweighted criteria default to equal weight.',
        ph:'cost:30\necosystem:20\nperformance:25\nlearning curve:25' },

      { key:'scale_max',label:'Rating scale max (only for Rating Scale)', type:'text',
        ph:'10' },

      { key:'rules',  label:'Output rules / format preferences (optional)', type:'textarea',
        ph:'e.g., Markdown table; keep each pro/con ≤12 words; include tie-break rules.' }
    ],
    template:({topic,compare_style,items,criteria,scale_max='10',rules,ctx,audience,style,tone})=>{
      const list = String(items||'').split(/\n+/).map(s=>s.trim()).filter(Boolean);
      const critList = String(criteria||'').split(/\n+/).map(s=>s.trim()).filter(Boolean);
      const parsed = critList.map(c=>{
        const m = c.match(/^(.+?):\s*([0-9]+(?:\.[0-9]+)?)\s*$/i);
        return m ? {name:m[1].trim(), weight:parseFloat(m[2])} : {name:c, weight:null};
      });
      const hasWeights = parsed.some(c=>c.weight!==null);
      const simpleCriteria = parsed.map(c=>c.name).join(', ');
      const weightedLine = hasWeights
        ? parsed.map(c=>`${c.name} (${c.weight}%)`).join(', ')
        : simpleCriteria;

      const styleLine = (()=>{
        switch(compare_style){
          case 'for-against':
            return 'Lay out arguments "for" and "against" each option, then weigh balance of evidence.';
           case 'benefits-risks':
            return 'Lay out the benefits and risks for each option, then weigh and compare the benefits vs. the risks.';
          case 'strengths-weaknesses':
            return 'List strengths and weaknesses per option with one-line explanations.';
          case 'similarities-differences':
            return 'Make a two-column list: similarities on the left, differences on the right.';
          case 'rank':
            return 'Produce a ranked list (best → worst) with one-line justification per item.';
          case 'rating':
            return `Rate each item on a 1–${scale_max} scale for each criterion, show subtotals and a final average; break ties with a brief rationale.`;
          case 'weighted-matrix':
            return `Build a weighted criteria matrix. Criteria${hasWeights? ' (with weights)':''}: ${weightedLine}. Show per-criterion scores and a weighted total.`;
          case 'tiering':
            return 'Assign each item to tiers (S/A/B...) with one-line reason per assignment.';
          case 'table':
            return 'Create a side-by-side Markdown table: rows = criteria/features, columns = options. Keep cells concise.';
          case 'point-by-point':
            return 'Compare point-by-point across criteria: list each criterion and discuss how each option fares.';
          case 'block':
            return 'Write compact blocks: Option A summary, Option B summary, Option C summary; end with synthesis.';
          case 'benchmarking':
            return 'Benchmark each item against a named gold standard; call out gaps and advantages.';
          case 'case-studies':
            return 'Use short case snippets to illustrate differences; cite realistic scenarios.';
          case 'analogies':
            return 'Use clear analogies/metaphors to contrast items; keep analogies concrete.';
          case 'before-after':
            return 'Show before/after outcomes per option for the same scenario.';
          case 'scenario':
            return 'Test each option in the same hypothetical scenario; report outcomes and risks.';
          case 'chart':
            return 'Render comparison as a chart (bar, radar, scatter, etc.); include axis/legend labels.';
            case 'venn':
    return 'Draw a Venn diagram: overlapping area = shared traits, outer zones = unique traits.';
    case 'decision-tree':
    return 'Map a decision tree: branches show which option applies under which condition.';
    case 'heatmap':
    return 'Build a heatmap grid of items × criteria; color intensity signals performance.';
          default:
            return 'List pros & cons per option in bullet form, then synthesize trade-offs.';
        }
      })();

      const itemsBlock = list.length ? ('Options:\n' + list.map((t,i)=>`${i+1}. ${t}`).join('\n')) : '';
      const critBlock  = parsed.length ? (`Criteria:${hasWeights? ' (weights in %)':''}\n` + parsed.map(c=>`- ${c.name}${c.weight!==null?`: ${c.weight}%`:''}`).join('\n')) : '';

      return [
        'Perform a comparative analysis.',
        topic && `Topic/decision: ${topic}`,
        ctx && `Context: ${ctx}`,
        audience && `Audience: ${audience}`,
        style && `Style: ${style}`,
        tone && `Tone: ${tone}`,
        itemsBlock,
        critBlock,
        `Comparison mode: ${compare_style || 'pros-cons'}`,
        styleLine,
        rules && `Output rules: ${rules}`,
        'End with: (1) succinct recommendation, (2) key trade-offs in one line, (3) next steps or what could change the decision.'
      ].filter(Boolean).join('\n');
    }
  },
  
  {
  id:'constraint_flip',
  slug:'constraint-flip',
  label:'Constraint Flip (play with edges)',
  kind:'pattern',
  categories:['creativity','strategy'],
  tags:['type:pattern','topic:constraints','use:ideation','level:beginner'],
  use_cases:[
    'turn constraints into generators of ideas',
    'explore exaggerated and removed constraint states'
  ],
  definition:'Treat a constraint as a lever: exaggerate it to find new ideas; remove it to find alternatives.',
  help:'Name a real blocker; brainstorm both exaggerated and removed scenarios.',
  boosters:[
    'Write at least 3 ideas in each direction.',
    'Pick one idea to prototype this week.'
  ],
  fields:[
    { key:'limiting',   label:'What’s limiting me right now?', type:'textarea' },
    { key:'exaggerate', label:'If I exaggerated that constraint, what new idea emerges?', type:'textarea' },
    { key:'remove',     label:'If I removed it entirely, what could I try?', type:'textarea' }
  ],
  template: ({ limiting, exaggerate, remove, ctx, audience, style, tone }) => [
    'Flip the constraint to generate options.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    limiting && ('Constraint:\n' + limiting),
    exaggerate && ('Exaggerated constraint → ideas:\n' + exaggerate),
    remove && ('Removed constraint → ideas:\n' + remove),
    'Output:\n1) Constraint summary\n2) Ideas (exaggerate)\n3) Ideas (remove)\n4) One prototype to run'
  ].filter(Boolean).join('\n')
},
  
  {
    id:'costar',
    slug:'costar-framework',
    label:'COSTAR — Context · Objective · Style · Tone · Audience · Response',
    kind:'pattern',
    categories:['prompt development techniques','messaging frameworks'],
    tags:[
  'type:pattern','topic:prompting','phase:apply','level:beginner',
  'use:creative-brief','use:message-brief','use:content-brief'
],
use_cases: [
  'creative brief',
  'message brief',
  'content brief',
  'campaign brief',
  'UX copy brief',
  'press/news announcement brief'
],
boosters: [
  "Verify each COSTAR element is addressed; then output the final message under “Final response:”"
],
    definition:'A context-first messaging recipe encoding context, objective, style, tone, audience, and response format.',
    help:'Popular structure that bakes in style/tone and output format.',
    fields:[
      {key:'context',  label:'Context',  type:'textarea', desc:'Background, problem, scenario.',           ph:'e.g., Announcing a new feature to free users'},
      {key:'objective',label:'Objective',type:'text',     desc:'What the message must achieve.',           ph:'e.g., Drive upgrades to Pro'},
      {key:'style',    label:'Style (overrides common)', type:'text',  desc:'Writing style.',               ph:'e.g., Practical, plain language'},
      {key:'tone',     label:'Tone (overrides common)',  type:'text',  desc:'Emotional flavor.',            ph:'e.g., Friendly, confident'},
      {key:'audience', label:'Audience (overrides common)', type:'text', desc:'Who this is for.',           ph:'e.g., Busy SMB owners'},
      {key:'response', label:'Response format', type:'text', desc:'Desired output structure.',             ph:'e.g., Markdown outline with H2s'}
    ],
    template:({context,objective,style,tone,audience,response,ctx})=>[
      (ctx||context)&&`Context: ${ctx?ctx:context}`,
      objective&&`Objective: ${objective}`,
      (style)&&`Style: ${style}`,
      (tone)&&`Tone: ${tone}`,
      audience&&`Audience: ${audience}`,
      response&&`Response format: ${response}`,
      `Follow COSTAR. Ask clarifying Qs only if blocking.`
    ].filter(Boolean).join('\n')
  },
  
   {
    id: 'eisenhower_matrix',
    slug: 'eisenhower-priority-matrix',
    label: 'Eisenhower Matrix — Urgent/Important Prioritization',
    kind: 'framework',
    categories: ['productivity', 'prioritization'],
    tags: [
      'type:framework','topic:time-management','phase:plan','level:beginner',
      'use:task-prioritization','use:time-management','use:workflow'
    ],
    use_cases: [
      'categorize tasks by urgency and importance',
      'decide what to do now, schedule for later, delegate, or drop',
      'improve personal productivity or team task management'
    ],
    boosters: [
      'Include a brief justification for why each task falls into its category.',
      'If multiple tasks land in one category, rank them or suggest which to tackle first.'
    ],
    definition: 'A time-management framework that sorts tasks into four categories: Do (urgent & important), Schedule (important but not urgent), Delegate (urgent but not important), and Eliminate (neither).',
    help: 'List your tasks. Optionally provide context like deadlines or importance. The model will assign each task to one of four categories (Do now, Schedule, Delegate, Eliminate) using the Eisenhower urgency/importance matrix.',
    fields: [
      { key: 'tasks', label: 'Tasks (one per line)', type: 'textarea',
        desc: 'A list of tasks or to-dos to be prioritized.',
        ph: 'Task 1…\nTask 2…\nTask 3…' },
      { key: 'context', label: 'Context (optional)', type: 'textarea',
        desc: 'Deadlines, importance cues, or other info for the tasks (if any).',
        ph: 'e.g., Task 1 due tomorrow; Task 2 is optional cleanup; Task 3 critical for client meeting.' }
    ],
    template: ({ tasks, context, ctx, style, tone }) => [
      'Apply the Eisenhower Matrix to categorize the tasks by urgency and importance.',
      ctx && `Context: ${ctx}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      context && ('Additional context:\n' + context),
      tasks && (
        'Tasks:\n' + String(tasks).split(/\n+/).map(s => s.trim()).filter(Boolean).map((t,i) => `${i+1}. ${t}`).join('\n')
      ),
      'Return tasks grouped into 4 categories (with labels): Do (Urgent & Important), Schedule (Important but Not Urgent), Delegate (Urgent but Not Important), Eliminate (Neither).'
    ].filter(Boolean).join('\n')
  },
  
  {
    id: 'fab',
    slug: 'feature-advantage-benefit',
    label: 'FAB — Feature · Advantage · Benefit',
    kind: 'framework',
    categories: ['messaging frameworks', 'marketing'],
    tags: [
      'type:framework','topic:copywriting','phase:apply','level:beginner',
      'use:product-marketing','use:sales-copy','use:value-messaging'
    ],
    use_cases: [
      'turn product features into user-focused benefits for marketing copy',
      'train a model to articulate why a feature matters to customers',
      'create sales bullets or product descriptions emphasizing value'
    ],
    boosters: [
      'Translate technical features into plain advantages and user benefits.',
      'Ensure the benefit addresses a specific customer need or pain point.'
    ],
    definition: 'A classic product messaging formula that starts with a Feature of a product, explains the Advantage (what it does), and concludes with the Benefit (why it matters to the user).',
    help: 'Provide a key product feature. The model will respond with the feature, its advantage, and the benefit to the customer, helping make your messaging more customer-centric.',
    fields: [
      { key: 'feature', label: 'Product feature', type: 'text',
        desc: 'A specific feature or attribute of your product/offer.',
        ph: 'e.g., Real-time analytics dashboard' },
      { key: 'constraints', label: 'Constraints (optional)', type: 'text',
        desc: 'Any format or length constraints.',
        ph: 'e.g., 1 sentence per item; use bullet points.' }
    ],
    template: ({ feature, constraints, ctx, audience, style, tone }) => [
      'Use the FAB framework to highlight the feature, what it does, and why it matters.',
      ctx && `Context: ${ctx}`,
      audience && `Audience: ${audience}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      feature && `Feature: ${feature}`,
      'Advantage: <the model will explain what the feature does or how it\'s better>',
      'Benefit: <the model will explain why that advantage is valuable to the user>',
      constraints && `Constraints: ${constraints}`
    ].filter(Boolean).join('\n')
  },
  
    {
    id:'facts_primer',
    slug:'facts-expertise-primer',
    label:'Facts & Expertise Primer',
    kind:'framework',
    categories:['prompt development techniques','quality scaffolds'],
    tags:[
      'type:framework','topic:priming','topic:fact-checking','phase:setup','level:beginner'
    ],
    use_cases:[
      'prime a conversation with domain facts',
      'reduce hallucinations',
      'scope an expert role before a task'
    ],
    definition:'Prime the model with verified facts, role, and scope constraints before asking for an output.',
    help:'List facts one-per-line (or use the add-row control). The prompt will ground itself in those facts and mark unknowns.',
    boosters:[
      'Explicitly mark unknowns and ask up to 3 clarifying questions if needed.',
      'Prefer verifiable facts over speculation.',
      'Keep rationales to one short sentence unless asked to elaborate.'
    ],
    fields:[
      { key:'role',    label:'Role to embody (optional)', type:'text',
        ph:'e.g., Senior epidemiologist focused on respiratory viruses' },
      { key:'domain',  label:'Domain / scope', type:'text',
        ph:'e.g., US healthcare billing (2023–2025) • EU privacy law • K-12 math' },
      { key:'facts',   label:'Facts / known truths (one per line)', type:'textarea',
        desc:'One fact per line. Commas are OK; they will be split. Add short notes with ":" if useful.',
        ph:'e.g., HIPAA applies to covered entities\nGDPR requires lawful basis for processing' },
      { key:'pitfalls',label:'Known pitfalls / myths to avoid', type:'textarea',
        ph:'e.g., “Vitamin C cures colds” is a myth; do not claim it.' },
      { key:'task',    label:'Initial task or question', type:'textarea',
        ph:'e.g., Draft a one-page overview of consent requirements for telehealth.' },
      { key:'rigor',   label:'Rigor / citation expectations (optional)', type:'text',
        ph:'e.g., Cite authoritative sources; avoid fabricated citations.' }
    ],
    template:({role,domain,facts,pitfalls,task,rigor,ctx,audience,style,tone})=>{
      const factLines = String(facts||'')
        .split(/\n+|,/)
        .map(s=>s.trim())
        .filter(Boolean)
        .map((t,i)=>`${i+1}. ${t}`)
        .join('\n');

      return [
        'You are being primed with facts and scope before performing a task.',
        role   && `Adopt role: ${role}`,
        domain && `Domain/scope: ${domain}`,
        ctx    && `Context: ${ctx}`,
        audience && `Audience: ${audience}`,
        style  && `Style: ${style}`,
        tone   && `Tone: ${tone}`,
        factLines && `Facts (treat as ground truth):\n${factLines}`,
        pitfalls && `Avoid known pitfalls/myths:\n${pitfalls}`,
        rigor && `Rigor expectations: ${rigor}`,
        'Behavioral rules:',
        '- Prefer verifiable facts; do not invent sources.',
        '- If information is missing or ambiguous, explicitly list unknowns and ask up to 3 clarifying questions.',
        '- Keep rationales concise; do not reveal hidden chain-of-thought.',
        task && `Initial task:\n${task}`
      ].filter(Boolean).join('\n');
    }
  },
  
  {
    id: 'feynman',
    slug: 'feynman-technique',
    label: 'Feynman Technique — Explain Like I’m 5',
    kind: 'pattern',
    categories: ['education', 'learning'],
    tags: [
      'type:pattern','topic:simplification','topic:teaching','level:beginner',
      'use:explanation','use:knowledge-check','use:debug-understanding'
    ],
    use_cases: [
      'simplify complex concepts for a broader audience',
      'identify gaps in understanding by attempting a simple explanation',
      'learn or teach a new topic by breaking it down'
    ],
    boosters: [
      'Use analogies a child would understand to explain difficult concepts.',
      'Identify any technical terms in the explanation and immediately clarify them in simpler words.'
    ],
    definition: 'A learning strategy where you try to explain a concept in simple terms (as if to a child), revealing gaps in understanding to address.',
    help: 'Provide a topic or concept. The model will give a simple explanation (ELI5 style) and clarify any parts that might still be confusing, following the Feynman Technique.',
    fields: [
      { key: 'concept', label: 'Concept or topic', type: 'textarea',
        desc: 'The subject you want explained simply.',
        ph: 'e.g., Quantum entanglement' }
    ],
    template: ({ concept, ctx, style, tone }) => [
      'Explain the concept as if teaching a 5-year-old, then clarify any tricky parts.',
      ctx && `Context: ${ctx}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      concept && `Concept: ${concept}`,
      'Output:\n1) Simple Explanation\n2) Clarifications for any complex terms or ideas'
    ].filter(Boolean).join('\n')
  },
  
  {
  id:'few_shot',
  slug:'few-shot-examples',
  label:'Examples / Few-Shot Prompting',
  kind:'pattern',
  categories:['prompt development techniques','prompt literacy'],
  tags:[
    'type:pattern','topic:examples','topic:few-shot','phase:apply','level:beginner',
    'use:format-guidance','use:style-transfer','use:output-shaping'
  ],
  use_cases:[
    'show ideal output format with 1+ shots',
    'demonstrate style/voice to imitate',
    'constrain outputs to examples'
  ],
  definition:'Guide the model by supplying one or more example outputs (“shots”) to anchor format and tone.',
  help:'Add a main brief/goal, then list examples (one per line). The model mirrors structure/style from the shots.',
  boosters:[
    'Begin with a short description of the desired format before listing examples.',
    'Number the examples and refer back to them explicitly.',
    'Prefer short, high-signal examples over long rambles.'
  ],
  fields:[
    { key:'main',     label:'Main brief / goal',     type:'textarea',
      desc:'What you want, in plain language.',
      ph:'e.g., Generate a product description in the style below.' },
    { key:'examples', label:'Examples / shots (one per line)', type:'textarea',
      desc:'Provide one example per line (short is fine).',
      ph:'Example 1…\nExample 2…\nExample 3…' },
    { key:'dos',      label:"Do's (must do)",        type:'textarea',
      desc:'Positive constraints the output must follow.',
      ph:'Use the given headings; keep under 200 words; cite the example number used.' },
    { key:'donts',    label:"Don'ts / constraints",  type:'textarea',
      desc:'Things to avoid or hard limits.',
      ph:"Don't invent facts; avoid slang; no emojis." }
  ],
  template: ({ main, examples, dos, donts, ctx, audience, style, tone }) => [
    'Use few-shot prompting. Mirror the structure/style demonstrated by the examples.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    main && `Goal: ${main}`,
    examples && (
      'Examples:\n' + String(examples)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((ex,i)=> `${i+1}. ${ex}`)
        .join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don't:\n${donts}`,
    'First restate the intended format in one line, then produce the output consistent with the examples.'
  ].filter(Boolean).join('\n')
},

{
  id:'facione-core',
  slug:'facione-core-skills',
  label:'Facione — Interpret · Analyze · Evaluate · Infer · Explain · Self-regulate',
  kind:'framework',
  categories:['critical thinking frameworks'],
  tags:[
    'type:framework','topic:critical-thinking','phase:analyze','level:intermediate'
  ],
  use_cases:[
    'Evidence appraisal','Research summaries','Root cause analysis','Design/ethics reviews'
  ],
  definition:'Operationalize the six core skills of critical thinking on a target claim/problem.',
  help:'Run the six-skill loop briefly and finish with a self-check.',
  fields:[
    {key:'topic',         label:'Topic/claim/problem', type:'text',     ph:'e.g., “Feature X reduces churn by 10%.”'},
    {key:'evidence',      label:'Evidence for',        type:'textarea', ph:'Key supporting evidence'},
    {key:'counter',       label:'Evidence against',    type:'textarea', ph:'Counterevidence / disconfirming data'},
    {key:'alt_hypotheses',label:'Alternative hypotheses',type:'textarea', ph:'Other explanations/causes'},
    {key:'explain_aud',   label:'Explanation audience',type:'text',     ph:'e.g., exec team, students, customers'},
    {key:'selfreg_checks',label:'Self-regulation checks',type:'text',   ph:'e.g., seek disconfirming data; avoid anchoring'}
  ],
  boosters:[
    'Finish with a 2-line “Because-Therefore” justification and 1 actionable next test.'
  ],
  template:({topic,evidence,counter,alt_hypotheses,explain_aud,selfreg_checks,ctx})=>[
    'Use Facione’s six skills on the target.',
    ctx && `Context: ${ctx}`,
    topic && `Target: ${topic}`,
    'Output:',
    '1) Interpretation (what the information means).',
    evidence && `2) Analysis (structures/relations in the evidence): ${evidence}`,
    counter && `3) Evaluation (credibility and strength of pro vs con): ${counter}`,
    alt_hypotheses && `4) Inference (best-supported conclusion + uncertainty; consider alternatives): ${alt_hypotheses}`,
    explain_aud && `5) Explanation (concise, audience-appropriate): audience=${explain_aud}`,
    selfreg_checks && `6) Self-regulation (bias/quality checks applied): ${selfreg_checks}`
  ].filter(Boolean).join('\n')
},

{
    id: 'first_principles',
    slug: 'first-principles-analysis',
    label: 'First Principles — Question assumptions & reason from basics',
    kind: 'framework',
    categories: ['reasoning', 'innovation'],
    tags: [
      'type:framework','topic:problem-solving','topic:assumptions','level:intermediate',
      'use:strategy','use:research','use:inventive-thinking'
    ],
    use_cases: [
      'solve complex problems by breaking them down to fundamental truths',
      'challenge default assumptions to find innovative solutions',
      'analyze feasibility by building up from basic principles'
    ],
    boosters: [
      'Explicitly list core facts or principles that are undeniably true in this context.',
      'For each assumption, ask “Why must this be true?” and explore what happens if it’s not.'
    ],
    definition: 'A problem-solving approach that strips a problem down to fundamental truths and builds solutions from the ground up, rather than relying on assumptions or analogies.',
    help: 'State the problem and any assumptions. The model will break the problem into basics, challenge assumptions, and propose a solution derived from first principles thinking.',
    fields: [
      { key: 'problem', label: 'Problem or question', type: 'textarea',
        desc: 'The issue to solve or question to answer, as specifically stated as possible.',
        ph: 'e.g., How can we create a low-cost, sustainable water filter for remote areas?' },
      { key: 'assumptions', label: 'Assumptions (optional, one per line)', type: 'textarea',
        desc: 'Any existing assumptions or constraints you have in mind.',
        ph: 'Water must be boiled to purify...\nWe can only use local materials...' }
    ],
    template: ({ problem, assumptions, ctx, style, tone }) => [
      'Solve using first principles reasoning.',
      ctx && `Context: ${ctx}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      problem && `Problem: ${problem}`,
      assumptions && (
        'Assumptions:\n' + String(assumptions).split(/\n+/).map(s => s.trim()).filter(Boolean).map((a,i) => `${i+1}. ${a}`).join('\n')
      ),
      'Output:\n1) Fundamental truths (list core facts)\n2) Assumption challenges (what if each assumption is false?)\n3) Solution idea built from the fundamental truths'
    ].filter(Boolean).join('\n')
  },

{
  id:'goal_breakdown',
  slug:'goal-breakdown-decomposition',
  label:'Goal Breakdown (Prompt/Question Decomposition)',
  kind:'pattern',
  categories:['planning','prompt development techniques'],
  tags:[
    'type:pattern','topic:decomposition','topic:questions','phase:plan','level:beginner',
    'use:breakdown','use:micro-tasks','use:research-questions'
  ],
  use_cases:[
    'break a complex goal into micro-tasks',
    'turn a vague prompt into concrete sub-questions',
    'plan-first before execution'
  ],
  definition:'Break a complex goal/prompt into smaller, verifiable sub-tasks and sub-questions before doing the work.',
  help:'Enter a complex goal or prompt. The model will decompose it into a deep, numbered hierarchy and propose a minimal execution plan.',
  boosters:[
    'Show a numbered hierarchy (1, 1.1, 1.1.1…) before any deliverable.',
    'Flag assumptions and unknowns as explicit sub-questions.',
    'Suggest the smallest next action at the end.'
  ],
  fields:[
    { key:'main',  label:'Goal / complex task', type:'textarea',
      desc:'The overarching task or question to decompose.',
      ph:'e.g., Build a go-to-market plan for a B2B SaaS in 6 weeks.' },
    { key:'dos',   label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Use numbered hierarchy; identify dependencies.' },
    { key:'donts', label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No speculative claims; ≤500 words in plan.' }
  ],
  template: ({ main, dos, donts, ctx, audience, style, tone }) => [
    'Perform prompt/question decomposition for the goal into micro-tasks and sub-questions.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    main && `Goal/complex task: ${main}`,
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output format:\n1) Decomposition (numbered hierarchy)\n2) Minimal execution plan\n3) Assumptions & unknowns\n4) Next action'
  ].filter(Boolean).join('\n')
},

{
  id:'goal_composition',
  slug:'goal-composition',
  label:'Goal Composition (Prompt/Question Composition)',
  kind:'pattern',
  categories:['planning','prompt development techniques'],
  tags:[
    'type:pattern','topic:composition','topic:goals','phase:plan','level:beginner',
    'use:synthesis','use:roadmap','use:prioritization'
  ],
  use_cases:[
    'compose a broader goal from many sub-prompts/actions',
    'derive an objective and plan from granular tasks',
    'summarize scattered asks into one coherent brief'
  ],
  definition:'Synthesize a broader objective from a list of sub-prompts/actions, then propose a coherent plan.',
  help:'List sub-prompts/actions one per line. Optionally add an intended direction for the composed goal.',
  boosters:[
    'Cluster similar actions before composing.',
    'State explicit success criteria for the composed goal.',
    'End with one “north-star” metric.'
  ],
  fields:[
    { key:'direction', label:'Intended direction (optional)', type:'textarea',
      desc:'Theme or constraints to guide composition.',
      ph:'e.g., Emphasize ROI and low lift.' },
    { key:'actions',   label:'Sub-prompts / actions (one per line)', type:'textarea',
      desc:'Granular items to synthesize into a broader goal.',
      ph:'Draft FAQ page…\nInterview 5 users…\nDefine ICP…' },
    { key:'dos',       label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Quantify effort; produce a one-paragraph composed goal.' },
    { key:'donts',     label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No jargon; ≤300 words total.' }
  ],
  template: ({ direction, actions, dos, donts, ctx, audience, style, tone }) => [
    'Compose a broader goal from specific sub-prompts/actions, then produce a concise plan.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    direction && `Intended direction: ${direction}`,
    actions && (
      'Inputs (actions):\n' + String(actions)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((a,i)=> `${i+1}. ${a}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output:\n1) Composed goal (1 paragraph)\n2) 3–5 key objectives\n3) High-level plan by objective\n4) Single next action'
  ].filter(Boolean).join('\n')
},


{
  id:'goal_prompting',
  slug:'goal-prompting',
  label:'Goal Prompting',
  kind:'pattern',
  categories:['planning','prompt development techniques'],
  tags:[
    'type:pattern','topic:goals','phase:plan','level:beginner',
    'use:brainstorm','use:roadmap','use:prioritize'
  ],
  use_cases:[
    'state a primary goal and supporting goals',
    'ask the model to prioritize or plan',
    'structure outputs around explicit objectives'
  ],
  definition:'Center the request on a primary goal, with optional supporting goals listed separately.',
  help:'Write the main brief/goal, then list additional goals one per line, plus do/don’t guardrails.',
  boosters:[
    'Ask for a numbered plan tied to each goal.',
    'Request a brief risk or dependency note per goal.',
    'End with a next-action recommendation.'
  ],
  fields:[
    { key:'main',   label:'Primary goal (brief)', type:'textarea',
      desc:'One clear objective in your own words.',
      ph:'e.g., Launch a newsletter in 4 weeks.' },
    { key:'goals',  label:'Additional goals (one per line)', type:'textarea',
      desc:'List zero or more supporting goals.',
      ph:'Audience growth to 1k…\n≥40% open rate…\nMonetize by week 8…' },
    { key:'dos',    label:"Do's (must do)", type:'textarea',
      desc:'Positive constraints.',
      ph:'Quantify time/effort; provide a week-by-week outline.' },
    { key:'donts',  label:"Don'ts / constraints", type:'textarea',
      desc:'Limits or exclusions.',
      ph:"Don't exceed 700 words; avoid paid tools." }
  ],
  template: ({ main, goals, dos, donts, ctx, audience, style, tone }) => [
    'Focus on explicit objectives and produce a concise, actionable plan.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    main && `Primary goal: ${main}`,
    goals && (
      'Additional goals:\n' + String(goals)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((g,i)=> `${i+1}. ${g}`)
        .join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don't:\n${donts}`,
    'Provide a short plan tied to each goal, then a single next action.'
  ].filter(Boolean).join('\n')
},

  
  {
    id:'golden',
    slug:'golden-circle-framework',
    label:'Golden Circle — Why · How · What',
    kind:'framework',
    categories:['messaging frameworks','prompt development techniques'],
    tags:[
  'type:framework','topic:messaging','phase:overview','level:beginner',
  'use:brand-messaging','use:mission-vision','use:pitch-deck'
],
use_cases: [
  'brand messaging',
  'mission/vision alignment',
  'about page narrative',
  'investor pitch framing',
  'employer brand messaging',
  'product purpose statement'
],
boosters: [
  "Lead with “Why”; keep each section 2–3 sentences; end with a one-line “Because…” summary."
],
    definition:'A purpose-first communication model that moves from belief (why) to methods (how) to concrete offerings (what).',
    help:'Purpose-first messaging scaffold.',
    fields:[
      {key:'why', label:'Why (purpose/belief)',         type:'textarea', desc:'Belief/purpose.',     ph:'e.g., Everyone deserves privacy by default'},
      {key:'how', label:'How (principles/approach)',    type:'textarea', desc:'Methods/approach.',   ph:'e.g., Strong encryption; zero-knowledge design'},
      {key:'what',label:'What (products/services/actions)', type:'textarea', desc:'Offerings/actions.', ph:'e.g., Encrypted email; secure file share'}
    ],
    template:({why,how,what,ctx})=>[
      ctx&&`Context: ${ctx}`,
      `Craft a message using the Golden Circle.`,
      why&&`Why: ${why}`,
      how&&`How: ${how}`,
      what&&`What: ${what}`
    ].filter(Boolean).join('\n')
  },
  
  {
    id: 'grow',
    slug: 'grow-coaching-model',
    label: 'GROW — Goal · Reality · Options · Way Forward',
    kind: 'framework',
    categories: ['coaching', 'planning'],
    tags: [
      'type:framework','topic:goal-setting','topic:coaching','level:beginner',
      'use:personal-development','use:mentoring','use:problem-solving'
    ],
    use_cases: [
      'structure a coaching conversation or self-reflection',
      'set and plan personal or team goals with clear next steps',
      'evaluate options to overcome a challenge and commit to an action'
    ],
    boosters: [
      'Offer at least 3 distinct Options, even unconventional ones, before recommending a way forward.',
      'Encourage a specific, time-bound commitment in the Way Forward step (who, what, when).'
    ],
    definition: 'A coaching framework for goal-oriented conversations, progressing through defining a Goal, assessing the current Reality, brainstorming Options, and deciding the Way Forward (action plan).',
    help: 'Fill in the goal and current reality; the model will suggest options and a concrete plan. You can optionally provide any options you’ve considered or a tentative plan, and the model will build on it.',
    fields: [
      { key: 'goal', label: 'Goal', type: 'textarea',
        desc: 'The goal or outcome to achieve.',
        ph: 'e.g., Improve my public speaking confidence for work presentations.' },
      { key: 'reality', label: 'Reality (current situation)', type: 'textarea',
        desc: 'Current facts, obstacles, and context regarding the goal.',
        ph: 'e.g., I get very nervous, my last presentation had pacing issues and I avoided eye contact.' },
      { key: 'options', label: 'Options (optional, one per line)', type: 'textarea',
        desc: 'Any ideas or strategies already thought of to achieve the goal.',
        ph: 'Join a public speaking group...\nPractice with a friend...\nWatch online tutorials...' },
      { key: 'will', label: 'Way Forward (if decided, optional)', type: 'textarea',
        desc: 'A chosen action or commitment (if you already have one in mind).',
        ph: 'e.g., I will enroll in a Toastmasters club and practice weekly.' }
    ],
    template: ({ goal, reality, options, will, ctx, style, tone }) => [
      'Use the GROW model to structure the plan.',
      ctx && `Context: ${ctx}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      goal && `Goal: ${goal}`,
      reality && (`Reality:\n` + reality),
      options && (
        'Options:\n' + String(options).split(/\n+/).map(s => s.trim()).filter(Boolean).map((opt,i) => `${i+1}. ${opt}`).join('\n')
      ),
      will && (`Way Forward (given):\n` + will),
      'Output:\n1) Goal\n2) Reality factors\n3) Options analysis\n4) Way Forward (specific next steps)'
    ].filter(Boolean).join('\n')
  },
  
  {
    id: 'heros_journey',
    slug: 'heros-journey-narrative',
    label: 'Hero’s Journey — Departure · Initiation · Return',
    kind: 'framework',
    categories: ['storytelling frameworks', 'creative writing'],
    tags: [
      'type:framework','topic:storytelling','phase:compose','level:intermediate',
      'use:plot-outline','use:mythic-narrative','use:character-development'
    ],
    use_cases: [
      'generate a mythic or epic story outline following a hero’s journey structure',
      'develop a character’s transformative arc in creative writing',
      'brainstorm plot points for novels, games, or scenarios with a hero protagonist'
    ],
    boosters: [
      'Ensure the hero undergoes a meaningful transformation by the end of the journey.',
      'Include classic stages like Call to Adventure, Mentor/Helper, Trials, Crisis, Reward, and Return with the Elixir.'
    ],
    definition: 'A 12-stage narrative framework (Monomyth) where a hero leaves their ordinary world, faces trials and transformation, and returns home with newfound wisdom or power.',
    help: 'Provide details about the hero, their goal, and the world or antagonist. The model will outline a story following Hero’s Journey stages, covering departure, initiation, and return.',
    fields: [
      { key: 'hero', label: 'Hero / Protagonist', type: 'text',
        desc: 'Main character (name, role, traits).',
        ph: 'e.g., Aria, a cautious village girl with secret magic powers' },
      { key: 'quest', label: 'Quest / Goal', type: 'textarea',
        desc: 'The mission, challenge, or adventure the hero must undertake.',
        ph: 'e.g., Save her village from a spreading curse by finding the ancient healing stone.' },
      { key: 'nemesis', label: 'Antagonist or main challenge (optional)', type: 'text',
        desc: 'The villain or obstacle that opposes the hero.',
        ph: 'e.g., An evil sorcerer who thrives on the curse' },
      { key: 'setting', label: 'Setting (optional)', type: 'text',
        desc: 'The world or context where the story takes place.',
        ph: 'e.g., A medieval land where magic is feared and rare' }
    ],
    template: ({ hero, quest, nemesis, setting, ctx, style, tone }) => [
      'Craft a Hero’s Journey narrative outline.',
      ctx && `Context: ${ctx}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      hero && `Hero: ${hero}`,
      quest && `Goal/Quest: ${quest}`,
      nemesis && `Antagonist/Challenge: ${nemesis}`,
      setting && `Setting: ${setting}`,
      'Output:\n1) Departure (ordinary world, call to adventure, mentor, crossing threshold)\n2) Initiation (trials, allies, crisis, victory)\n3) Return (road back, transformation, return home with reward)'
    ].filter(Boolean).join('\n')
  },
  
  {
  id:'debiasing-checklist',
  slug:'heuristics-biases',
  label:'Heuristics & Biases — Debiasing Pre-flight',
  kind:'framework',
  categories:['critical thinking frameworks','quality checks'],
  tags:[
    'type:framework','topic:debiasing','phase:review','level:intermediate',
    'use:decisions','use:forecasts','use:research-summaries'
  ],
  use_cases:[
    'Review a draft answer/decision','Forecasting sanity check','Risk review'
  ],
  definition:'Run a short checklist to catch common cognitive biases and revise.',
  help:'Describe the decision/draft, stakes, time pressure, and known risks; get a bias scan and a revision.',
  fields:[
    {key:'decision',     label:'Decision/draft to check', type:'textarea', ph:'Paste the answer/decision you want to sanity-check'},
    {key:'stakes',       label:'Stakes/impact',           type:'text',     ph:'e.g., medium; reputational + cost'},
    {key:'time_pressure',label:'Time pressure',           type:'text',     ph:'e.g., high / moderate / low'},
    {key:'known_biases', label:'Known risks',             type:'text',     ph:'e.g., anchoring, confirmation, sunk cost'},
    {key:'tactics',      label:'Debiasing tactics',       type:'text',     ph:'base rates; outside view; premortem; reference class; “what would change my mind?”'}
  ],
  boosters:[
    'End with a one-line “If wrong, it’s because…” and a quick red-team question.'
  ],
  template:({decision,stakes,time_pressure,known_biases,tactics,ctx})=>[
    'Run a cognitive bias pre-flight check.',
    ctx && `Context: ${ctx}`,
    stakes && `Stakes: ${stakes}`,
    time_pressure && `Time pressure: ${time_pressure}`,
    known_biases && `Known risks: ${known_biases}`,
    tactics && `Preferred tactics: ${tactics}`,
    decision && `Draft under review:\n${decision}`,
    'Output:',
    '1) Bias scan (anchoring, availability, confirmation, sunk cost, overconfidence, base-rate neglect, scope insensitivity).',
    '2) Evidence/assumption spot-check; note priors/base rates.',
    '3) Revised answer/decision with explicit uncertainties.',
    '4) Premortem: top failure mode + mitigation.',
    '5) Decide: go / iterate / stop, with reason.'
  ].filter(Boolean).join('\n')
},
  
  {
  id:'hmw_statements',
  slug:'how-might-we-statements-hmw',
  label:'How Might We Statements (HMW)',
  kind:'pattern',
  categories:['design thinking','ideation'],
  tags:[
    'type:pattern','topic:problem-framing','topic:ideation','phase:explore','level:beginner',
    'use:brainstorm','use:problem-statement','use:workshop'
  ],
  use_cases:[
    'frame challenges as opportunities', 
    'product design', 'ux', 'problem solving',
    'generate multiple solution directions',
    'align teams around a crisp, positive prompt'
  ],
  definition:'A guiding question that reframes a need into an opportunity: “How might we [action] for [who] so that [outcome]?”',
  help:'Provide a concise need/challenge, who is affected, and the positive outcome you want.',
  boosters:[
    'Offer 3–5 phrasing variants that change the verb or scope.',
    'Keep each statement ≤20 words.',
    'Avoid embedded solutions—stay problem-oriented.'
  ],
  fields:[
    { key:'need',   label:'Need / challenge',        type:'textarea',
      desc:'What problem or opportunity are we framing?',
      ph:'Low onboarding completion for new users…' },
    { key:'action', label:'Action to explore',       type:'text',
      desc:'Open-ended action (no baked-in solution).',
      ph:'improve onboarding clarity' },
    { key:'who',    label:'Who is affected?',        type:'text',
      desc:'Audience or segment.',
      ph:'new SaaS signups' },
    { key:'outcome',label:'Positive outcome',        type:'text',
      desc:'Intended impact.',
      ph:'reach value in the first session' },
    { key:'dos',    label:"Do's (must do)",          type:'textarea',
      desc:'Positive guardrails.',
      ph:'Make variants; keep neutral tone.' },
    { key:'donts',  label:"Don\'ts / constraints",   type:'textarea',
      desc:'Limits to respect.',
      ph:'No solutioning; avoid jargon.' }
  ],
  template: ({ need, action, who, outcome, dos, donts, ctx, audience, style, tone }) => [
    'Create a clear, positive How-Might-We statement and a few concise variants.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    need && `Need/challenge: ${need}`,
    (action || who || outcome) && `HMW: How might we ${action||'[action]'} for ${who||'[who]'} so that ${outcome||'[outcome]'}?`,
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Provide 3–5 short variant phrasings with different verbs/scope.'
  ].filter(Boolean).join('\n')
},

{
  id:'implementation_intentions',
  slug:'if-then-planning',
  label:'Implementation Intentions (If–Then)',
  kind:'pattern',
  categories:['behavior','productivity'],
  tags:['type:pattern','topic:if-then','use:habit','level:beginner'],
  use_cases:[
    'bind a trigger to a specific action to reduce choice friction',
    'translate goals into cues'
  ],
  definition:'If [trigger/situation], then I will [specific action].',
  help:'Name a reliable trigger and a crisp then-action. Optional: add 1–2 backup plans.',
  boosters:[
    'Make the trigger observable and frequent.',
    'Write the action so “half-asleep you” could do it.'
  ],
  fields:[
    { key:'trigger', label:'If [trigger/situation]…', type:'textarea', ph:'e.g., When I open my laptop…' },
    { key:'action',  label:'…then I will [specific action]', type:'textarea', ph:'Open draft doc instead of email.' },
    { key:'backups', label:'Backup plans (optional, one per line)', type:'textarea' }
  ],
  template: ({ trigger, action, backups, ctx, audience, style, tone }) => [
    'Create an If–Then implementation intention.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    trigger && ('If ' + trigger),
    action && ('Then I will ' + action),
    backups && (
      'Backups:\n' + String(backups).split(/\n+/).map(s=>s.trim()).filter(Boolean).map((x,i)=>`${i+1}. ${x}`).join('\n')
    ),
    'Output:\n1) Trigger\n2) Specific action\n3) Backup(s)\n4) First check-in time'
  ].filter(Boolean).join('\n')
},

{
  id:'inclusive_design',
  slug:'inclusive-design-framework',
  label:'Inclusive Design (edge personas)',
  kind:'pattern',
  categories:['design','ethics','accessibility'],
  tags:[
    'type:pattern','topic:inclusive-design','topic:edge-cases','level:beginner',
    'use:product','use:content','use:service-design'
  ],
  use_cases:[
    'identify edge personas and barriers',
    'design adaptations that reduce exclusion',
    'articulate benefits to all users'
  ],
  definition:'Design for “edge cases” to reduce exclusion, following Microsoft’s Inclusive Design principles.',
  help:'Pick an edge persona, name the barrier, propose an adaptation, and explain the universal benefit.',
  boosters:[
    'Name concrete assistive tech or environmental constraints where relevant.',
    'Suggest a quick hallway/usability test to validate the adaptation.'
  ],
  fields:[
    { key:'edge_persona', label:'Persona at the edge — who might struggle most?', type:'textarea', ph:'e.g., Low-vision user; one-handed; low bandwidth…' },
    { key:'barrier',      label:'Barrier — what prevents full use?', type:'textarea', ph:'Perception, cognition, motor, language, network…' },
    { key:'adaptation',   label:'Adaptation — design change to reduce exclusion', type:'textarea', ph:'Concrete UI/content/process change.' },
    { key:'benefit',      label:'Benefit to all — how does this help beyond the edge user?', type:'textarea', ph:'Explicit generalization.' }
  ],
  template: ({ edge_persona, barrier, adaptation, benefit, ctx, audience, style, tone }) => [
    'Apply Inclusive Design to reduce exclusion.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    edge_persona && ('Edge persona:\n' + edge_persona),
    barrier && ('Barrier:\n' + barrier),
    adaptation && ('Adaptation:\n' + adaptation),
    benefit && ('Benefit to all:\n' + benefit),
    'Output:\n1) Edge case summary\n2) Barrier(s)\n3) Adaptation(s)\n4) Validation step\n5) Expected universal benefit'
  ].filter(Boolean).join('\n')
},
  
  {
  id:'kwy_vector',
  slug:'keywords-why-tasks-vector',
  label:'Keywords + Why + Tasks — Vector Priming',
  kind:'pattern',
  categories:['prompt development techniques','planning'],
  tags:[
    'type:pattern','topic:keywords','topic:why','topic:tasking','phase:plan','level:intermediate',
    'use:vector-priming','use:context-packing','use:negative-avoidance'
  ],
  use_cases:[
    'prime the model with topical vectors via keywords',
    'explain situational “why” for better alignment',
    'list actionable tasks and explicit negatives to avoid'
  ],
  definition:'Prime with keywords (vector hinting) and a clear “why,” list tasks, and name what to avoid.',
  help:'Fill the goal, why/context, comma-separated keywords, and tasks (one per line). Add avoid/constraints as needed.',
  boosters:[
    'Normalize keywords to canonical forms (singulars, lowercase) before using them.',
    'Tie each task to at least one keyword.',
    'Call out conflicts between “why” and constraints in one line.'
  ],
  fields:[
    { key:'goal',     label:'Goal / request', type:'textarea',
      desc:'The core ask in plain language.',
      ph:'e.g., Draft a press release for our seed round.' },
    { key:'why',      label:'Why / context', type:'textarea',
      desc:'Situation, constraints, or motivation that explains the request.',
      ph:'Positioning shift, investor expectations, embargo timing…' },
    { key:'keywords', label:'Keywords (comma-separated)', type:'text',
      desc:'Topical terms to prime the model’s “vector space.”',
      ph:'fintech, compliance, SOC2, runway, ARR, seed, product-market-fit' },
    { key:'tasks',    label:'Tasks (one per line)', type:'textarea',
      desc:'Concrete actions the model should take.',
      ph:'Draft headline…\nWrite summary paragraph…\nAdd 3 quotes…' },
    { key:'avoid',    label:'Avoid (comma-separated negatives)', type:'text',
      desc:'Phrases, angles, or topics to avoid.',
      ph:'hype, unverified metrics, jargon, inside jokes' },
    { key:'dos',      label:"Do's (must do)", type:'textarea',
      desc:'Positive constraints.',
      ph:'Cite sources; 150–250 words; AP style.' },
    { key:'donts',    label:"Don'ts / constraints", type:'textarea',
      desc:'Hard limits beyond “Avoid.”',
      ph:"Don't mention confidential partners; no sensitive data." }
  ],
  template: ({ goal, why, keywords, tasks, avoid, dos, donts, ctx, audience, style, tone }) => [
    'Use vector priming (keywords) plus explicit why/context and actionable tasks.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    goal && `Goal: ${goal}`,
    why && `Why/context: ${why}`,
    keywords && ('Keywords: ' + String(keywords).split(',').map(s=>s.trim()).filter(Boolean).join(', ')),
    tasks && (
      'Tasks:\n' + String(tasks)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((t,i)=> `${i+1}. ${t}`)
        .join('\n')
    ),
    avoid && ('Avoid: ' + String(avoid).split(',').map(s=>s.trim()).filter(Boolean).join(', ')),
    dos && `Do:\n${dos}`,
    donts && `Don't:\n${donts}`,
    'Execute the tasks, honoring keywords and avoid lists; if conflicts appear, state them briefly before proceeding.'
  ].filter(Boolean).join('\n')
},

{
  id:'least_to_most',
  slug:'least-to-most-ltm',
  label:'Least to Most (LtM)',
  kind:'pattern',
  categories:['reasoning','planning'],
  tags:[
    'type:pattern','topic:progressive-complexity','topic:reasoning','phase:solve','level:intermediate',
    'use:scaffolding','use:math','use:algorithms','use:teaching'
  ],
  use_cases:[
    'tackle problems by escalating from simple to complex',
    'derive a general method from trivial and small cases',
    'surface edge cases after building intuition'
  ],
  definition:'Solve by starting with the simplest instances, generalizing patterns, and stepping up complexity until the full problem is solved.',
  help:'Enter the problem, optionally outline a “complexity ladder” (one per line) from simplest to hardest, and add guardrails.',
  boosters:[
    'Keep each rung to one or two sentences.',
    'State the rule learned at each rung before moving up.',
    'End with a single, general solution and a quick edge-case check.'
  ],
  fields:[
    { key:'problem', label:'Problem / goal', type:'textarea',
      desc:'What should be solved or decided?',
      ph:'e.g., Explain and implement a function to validate parentheses.' },
    { key:'ladder',  label:'Complexity ladder (one per line, optional)', type:'textarea',
      desc:'From simplest to most complex cases.',
      ph:'Trivial case…\nSmall inputs…\nGeneral case…\nEdge cases…' },
    { key:'dos',     label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Show the rule discovered at each rung; keep total under 300 words.' },
    { key:'donts',   label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No lengthy proofs; avoid unexplained jumps.' }
  ],
  template: ({ problem, ladder, dos, donts, ctx, audience, style, tone }) => [
    'Use Least-to-Most reasoning: start with simple instances, extract a rule, scale up, then solve the full problem.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    problem && `Problem: ${problem}`,
    ladder && (
      'Complexity ladder:\n' + String(ladder)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((r,i)=> `${i+1}. ${r}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output format:\n1) Rungs (least→most) with the rule learned at each\n2) General solution\n3) Quick edge-case check'
  ].filter(Boolean).join('\n')
},

{
    id: 'monroe_sequence',
    slug: 'monroes-motivated-sequence',
    label: 'Monroe’s Motivated Sequence — Attention · Need · Satisfaction · Visualization · Action',
    kind: 'framework',
    categories: ['messaging frameworks', 'persuasion'],
    tags: [
      'type:framework','topic:persuasion','phase:compose','level:intermediate',
      'use:speechwriting','use:advocacy','use:public-speaking'
    ],
    use_cases: [
      'structure persuasive speeches or pitches for maximum impact',
      'guide the audience from feeling a need to taking an action',
      'formulate outreach messages (e.g., campaign appeals, motivational talks)'
    ],
    boosters: [
      'Open with a compelling hook (story or statistic) to grab Attention in the first step.',
      'In the Visualization step, paint a vivid picture of the future where the need is resolved (positive or negative outcomes).'
    ],
    definition: 'A five-step persuasive framework that grabs attention, establishes a need, presents a satisfying solution, helps the audience visualize the outcome, and ends with a call to action.',
    help: 'Provide the audience’s problem/need and your proposed solution. Optionally include an attention-grabber or desired call-to-action. The model will generate a structured persuasive message through all five steps of Monroe’s sequence.',
    fields: [
      { key: 'attention', label: 'Attention (hook, optional)', type: 'textarea',
        desc: 'An opening hook (question, anecdote, startling fact) to get attention.',
        ph: 'e.g., "Did you know nearly 40% of food gets thrown away while millions go hungry?"' },
      { key: 'audience_need', label: 'Need (audience problem)', type: 'textarea',
        desc: 'The problem or need affecting the audience that must be addressed.',
        ph: 'e.g., Working parents struggle to find time to cook healthy meals.' },
      { key: 'solution', label: 'Satisfaction (solution)', type: 'text',
        desc: 'Your solution or idea that will satisfy the need.',
        ph: 'e.g., A meal prep delivery service that provides ready-to-eat healthy dinners.' },
      { key: 'cta', label: 'Action (call-to-action, optional)', type: 'text',
        desc: 'The specific action you want the audience to take at the end.',
        ph: 'e.g., Sign up for a free week of our service today.' }
    ],
    template: ({ attention, audience_need, solution, cta, ctx, audience, style, tone }) => [
      'Use Monroe’s Motivated Sequence to structure a persuasive message.',
      ctx && `Context: ${ctx}`,
      audience && `Audience: ${audience}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      attention && ('Attention:\n' + attention),
      audience_need && ('Need:\n' + audience_need),
      solution && (`Satisfaction (Solution): ${solution}`),
      'Visualization: <the model will describe outcomes with the solution vs. without it>',
      cta && (`Action: ${cta}`),
      'Output:\n1) Attention\n2) Need\n3) Solution\n4) Visualization\n5) Action'
    ].filter(Boolean).join('\n')
  },

{
  id:'ooda_loop',
  slug:'ooda-loop',
  label:'OODA Loop (Observe–Orient–Decide–Act)',
  kind:'pattern',
  categories:['decision','strategy','ops'],
  tags:['type:pattern','topic:ooda','use:decision','level:beginner'],
  use_cases:[
    'cut through indecision with a tight OODA pass',
    'establish a clear next action under uncertainty'
  ],
  definition:'A rapid decision cadence: Observe → Orient → Decide → Act.',
  help:'Keep each stage concise; bias toward action with feedback.',
  boosters:[
    'Add a quick feedback note: how you’ll check results after acting.',
    'Limit Observe/Orient to facts relevant to the next step.'
  ],
  fields:[
    { key:'observe', label:'Observe — What’s the situation / facts?', type:'textarea', ph:'Crisp, decision-relevant facts only.' },
    { key:'orient',  label:'Orient — What matters most right now?', type:'textarea', ph:'Priorities, constraints, values.' },
    { key:'decide',  label:'Decide — What’s the next best step?', type:'textarea', ph:'One sentence.' },
    { key:'act',     label:'Act — What will I actually do now?', type:'textarea', ph:'Concrete action and owner.' }
  ],
  template: ({ observe, orient, decide, act, ctx, audience, style, tone }) => [
    'Run an OODA pass to unblock a decision.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    observe && ('Observe (facts):\n' + observe),
    orient && ('Orient (what matters):\n' + orient),
    decide && ('Decide (next best step):\n' + decide),
    act && ('Act (now):\n' + act),
    'Output:\n1) Key facts\n2) Priority frame\n3) Decision\n4) Immediate action + feedback check'
  ].filter(Boolean).join('\n')
},

{
    id: 'okr',
    slug: 'okr-goal-setting',
    label: 'OKR — Objective & Key Results',
    kind: 'framework',
    categories: ['strategy', 'planning'],
    tags: [
      'type:framework','topic:goals','topic:metrics','level:beginner',
      'use:strategic-planning','use:team-goals','use:performance-management'
    ],
    use_cases: [
      'define clear organizational or personal goals with measurable outcomes',
      'break down a vision into concrete targets',
      'evaluate progress by looking at quantifiable results tied to objectives'
    ],
    boosters: [
      'Make each Key Result specific, with a clear metric, target value, and timeframe.',
      'Ensure Key Results are outcomes (what is achieved), not tasks (what is done).'
    ],
    definition: 'A goal-setting framework pairing a qualitative Objective (what you want to achieve) with a set of quantitative Key Results (how you measure achievement).',
    help: 'Enter a high-level objective and optionally some initial key result ideas. The model will generate/refine a set of Key Results that make the objective specific and measurable.',
    fields: [
      { key: 'objective', label: 'Objective (qualitative goal)', type: 'textarea',
        desc: 'The significant goal to achieve (concise and inspirational).',
        ph: 'e.g., Become the market leader in customer satisfaction.' },
      { key: 'key_results', label: 'Key Results (optional, one per line)', type: 'textarea',
        desc: 'Draft key results (metrics/targets) if you have any, one per line.',
        ph: 'e.g., NPS score ≥ 60 by Q4\nRepeat purchase rate 30% higher by year-end' }
    ],
    template: ({ objective, key_results, ctx, audience, style, tone }) => [
      'Develop an OKR with a strong Objective and 2–5 measurable Key Results.',
      ctx && `Context: ${ctx}`,
      audience && `Audience: ${audience}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      objective && `Objective: ${objective}`,
      key_results && (
        'Given Key Result ideas:\n' + String(key_results).split(/\n+/).map(s => s.trim()).filter(Boolean).map((kr,i) => `${i+1}. ${kr}`).join('\n')
      ),
      'Output:\n1) Objective (qualitative)\n2) 2–5 Key Results (with metrics & targets)'
    ].filter(Boolean).join('\n')
  },


  {
    id:'par',
    slug:'par-method',
    label:'PAR — Problem · Action · Result',
    kind:'framework',
    categories:['storytelling frameworks','prompt development techniques'],
    tags:[
  'type:framework','topic:storytelling','phase:apply','level:beginner',
  'use:resume-bullet','use:case-study','use:status-update'
],
use_cases: [
  'resume bullet',
  'performance review note',
  'status update',
  'case study snapshot',
  'incident summary',
  'customer story outline'
],
boosters: [
  "Quantify results where possible (%, Δ, time); if no metrics given, propose proxy metrics."
],
    definition:'A compressed alternative to STAR that focuses on the core: problem, action, and result.',
    help:'Concise alternative to STAR.',
    fields:[
      {key:'problem', label:'Problem', type:'textarea', desc:'The obstacle or issue.', ph:'e.g., High churn after trial'},
      {key:'action',  label:'Action',  type:'textarea', desc:'What you did.',         ph:'e.g., Onboarding emails + in-app tips'},
      {key:'result',  label:'Result',  type:'textarea', desc:'Outcome/impact.',       ph:'e.g., Churn reduced from 14%→8%'}
    ],
    template:({problem,action,result,ctx})=>[
      ctx&&`Context: ${ctx}`,
      problem&&`Problem: ${problem}`,
      action&&`Action: ${action}`,
      result&&`Result: ${result}`,
      `Format the response as short bullets.`
    ].filter(Boolean).join('\n')
  },
  
  {
    id: 'pas',
    slug: 'pas-copywriting',
    label: 'PAS — Problem · Agitate · Solution',
    kind: 'framework',
    categories: ['messaging frameworks', 'marketing'],
    tags: [
      'type:framework','topic:copywriting','phase:compose','level:beginner',
      'use:ad-copy','use:email-copy','use:landing-page'
    ],
    use_cases: [
      'write persuasive copy by addressing the reader’s pain and offering relief',
      'structure marketing messages or support tickets by focusing on problem then solution',
      'craft introductions for pitches or blogs that hook with a problem and promise a solution'
    ],
    boosters: [
      'In the Agitate step, delve into emotional or practical consequences of the problem to make it feel urgent.',
      'Keep the Solution clear and directly tied to resolving the specific problem that was agitated.'
    ],
    definition: 'A copywriting formula that presents a Problem, amplifies it (Agitate), then provides a Solution to resolve the discomfort.',
    help: 'Provide the audience’s problem and your solution. The model will emphasize the pain of the problem (agitation) and then introduce the solution as the remedy.',
    fields: [
      { key: 'problem', label: 'Problem', type: 'textarea',
        desc: 'The core problem or pain point your audience faces.',
        ph: 'e.g., Project managers struggle to get timely updates from team members.' },
      { key: 'agitate', label: 'Agitate (pain details, optional)', type: 'textarea',
        desc: 'Details that exacerbate the problem or the feelings it causes.',
        ph: 'e.g., They spend hours chasing updates and feel constant stress as deadlines approach.' },
      { key: 'solution', label: 'Solution', type: 'text',
        desc: 'Your product or idea that solves the problem.',
        ph: 'e.g., SyncMaster auto-updates project status in real-time.' }
    ],
    template: ({ problem, agitate, solution, ctx, audience, style, tone }) => [
      'Use the PAS formula to write a persuasive message.',
      ctx && `Context: ${ctx}`,
      audience && `Audience: ${audience}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      problem && ('Problem:\n' + problem),
      agitate && ('Agitate:\n' + agitate),
      solution && (`Solution: ${solution}`),
      'Output:\n1) State the problem\n2) Agitate with vivid detail\n3) Present the solution and its relief'
    ].filter(Boolean).join('\n')
  },
  
  {
    id: 'pestle',
    slug: 'pestle-analysis',
    label: 'PESTLE — Political · Economic · Social · Technological · Legal · Environmental',
    kind: 'framework',
    categories: ['analysis frameworks', 'strategy'],
    tags: [
      'type:framework','topic:environment-scan','phase:overview','level:intermediate',
      'use:market-analysis','use:risk-analysis','use:strategic-planning'
    ],
    use_cases: [
      'analyze external factors affecting a business or project',
      'scan the macro-environment before launching an initiative',
      'identify opportunities and threats in the broader context'
    ],
    boosters: [
      'For each category, include at least one specific factor and its potential impact on the subject.',
      'Differentiate clearly between internal issues (not included here) and these external factors.'
    ],
    definition: 'A strategic analysis framework examining six external factors — Political, Economic, Social, Technological, Legal, and Environmental — that can impact an organization or initiative.',
    help: 'Specify the subject (project, company, strategy, etc.) and, if desired, any known factors under each PESTLE category. The model will produce an analysis touching on each category.',
    fields: [
      { key: 'subject', label: 'Subject of analysis', type: 'text',
        desc: 'The project, company, or scenario being analyzed.',
        ph: 'e.g., Expansion of ACME Corp into Asian markets' },
      { key: 'political', label: 'Political factors (optional, one per line)', type: 'textarea',
        desc: 'Government, policy, or regulatory factors to consider.',
        ph: 'Trade regulations...\nStability of local governments...' },
      { key: 'economic', label: 'Economic factors (optional, one per line)', type: 'textarea',
        desc: 'Market or financial conditions to consider.',
        ph: 'Currency exchange rate volatility...\nLocal labor cost trends...' },
      { key: 'social', label: 'Social factors (optional, one per line)', type: 'textarea',
        desc: 'Cultural, demographic, or consumer trends to consider.',
        ph: 'Population’s tech-savviness...\nShifts in consumer preferences...' },
      { key: 'technological', label: 'Technological factors (optional, one per line)', type: 'textarea',
        desc: 'Relevant technology trends or barriers.',
        ph: 'Internet infrastructure quality...\nAdoption of smartphones...' },
      { key: 'legal', label: 'Legal factors (optional, one per line)', type: 'textarea',
        desc: 'Laws, regulations, or legal risks to consider.',
        ph: 'Data protection laws...\nPatent or licensing issues...' },
      { key: 'environmental', label: 'Environmental factors (optional, one per line)', type: 'textarea',
        desc: 'Ecological or environmental considerations.',
        ph: 'Climate-related risks...\nLocal environmental regulations...' }
    ],
    template: ({ subject, political, economic, social, technological, legal, environmental, ctx }) => [
      `Conduct a PESTLE analysis${subject ? ` of ${subject}` : ''}.`,
      ctx && `Context: ${ctx}`,
      political && (
        'Political:\n' + String(political).split(/\n+/).map(s => s.trim()).filter(Boolean).map((x,i) => `${i+1}. ${x}`).join('\n')
      ),
      economic && (
        'Economic:\n' + String(economic).split(/\n+/).map(s => s.trim()).filter(Boolean).map((x,i) => `${i+1}. ${x}`).join('\n')
      ),
      social && (
        'Social:\n' + String(social).split(/\n+/).map(s => s.trim()).filter(Boolean).map((x,i) => `${i+1}. ${x}`).join('\n')
      ),
      technological && (
        'Technological:\n' + String(technological).split(/\n+/).map(s => s.trim()).filter(Boolean).map((x,i) => `${i+1}. ${x}`).join('\n')
      ),
      legal && (
        'Legal:\n' + String(legal).split(/\n+/).map(s => s.trim()).filter(Boolean).map((x,i) => `${i+1}. ${x}`).join('\n')
      ),
      environmental && (
        'Environmental:\n' + String(environmental).split(/\n+/).map(s => s.trim()).filter(Boolean).map((x,i) => `${i+1}. ${x}`).join('\n')
      ),
      'Output:\nProvide insights under each PESTLE category, noting key opportunities or threats in each.'
    ].filter(Boolean).join('\n')
  },
  
  {
  id:'paul-elder',
  slug:'paul-elder',
  label:'Paul–Elder — Elements of Thought + Standards',
  kind:'framework',
  categories:['critical thinking frameworks','prompt development techniques'],
  tags:[
    'type:framework','topic:critical-thinking','phase:analyze','level:intermediate',
    'use:argument-critique','use:decision-memo','use:policy-analysis'
  ],
  use_cases:[
    'Argument/brief critique','Decision memos','Policy/position analysis','Lesson planning checks'
  ],
  definition:'Structure reasoning via the Elements of Thought (purpose, question, info, concepts, assumptions, implications, point of view, inference) and judge it with Intellectual Standards (clarity, accuracy, precision, relevance, depth, breadth, logic, significance, fairness).',
  help:'Fill what you know for each element; pick standards to apply; get a structured critique and improvement.',
  fields:[
    {key:'purpose',       label:'Purpose',        type:'textarea', desc:'Goal/why this reasoning?', ph:'e.g., Decide if we should ship feature X this quarter'},
    {key:'key_question',  label:'Central question',type:'text',    desc:'Main question being answered', ph:'e.g., Should we ship feature X in Q4?'},
    {key:'information',   label:'Information',    type:'textarea', desc:'Key facts/data/sources',      ph:'e.g., user studies, cost estimates, incident data'},
    {key:'concepts',      label:'Concepts',       type:'textarea', desc:'Theories/principles/models',  ph:'e.g., opportunity cost, risk tolerance, SLA/SLO'},
    {key:'assumptions',   label:'Assumptions',    type:'textarea', desc:'What is taken for granted',   ph:'e.g., adoption rate, partner readiness'},
    {key:'pov',           label:'Point(s) of view',type:'textarea',desc:'Perspectives considered',     ph:'e.g., users, SRE, legal, finance'},
    {key:'inferences',    label:'Inferences',     type:'textarea', desc:'Conclusions drawn',           ph:'e.g., delaying reduces churn risk'},
    {key:'implications',  label:'Implications',   type:'textarea', desc:'Consequences of conclusions', ph:'e.g., revenue impact, reliability'},
    {key:'alternatives',  label:'Alternatives',   type:'textarea', desc:'Options/competing claims',    ph:'e.g., partial rollout, behind flag'},
    {key:'standards',     label:'Standards to apply', type:'text', desc:'Comma-sep list of standards', ph:'clarity, accuracy, precision, relevance, depth, breadth, logic, significance, fairness'}
  ],
  boosters:[
    'Give a 3-sentence synthesis and 2 sharper follow-up questions that would most improve the reasoning.'
  ],
  template:({purpose,key_question,information,concepts,assumptions,pov,inferences,implications,alternatives,standards,ctx,audience,style,tone})=>[
    'Apply the Paul–Elder framework to analyze reasoning.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    purpose && `Purpose: ${purpose}`,
    key_question && `Question: ${key_question}`,
    information && `Information: ${information}`,
    concepts && `Concepts: ${concepts}`,
    assumptions && `Assumptions: ${assumptions}`,
    pov && `Points of view: ${pov}`,
    inferences && `Inferences: ${inferences}`,
    implications && `Implications: ${implications}`,
    alternatives && `Alternatives: ${alternatives}`,
    standards && `Intellectual standards to apply: ${standards}`,
    'Output:',
    '1) Brief map of the eight elements (1–2 lines each).',
    '2) Critique using the listed standards (name the standard → note → fix).',
    '3) Revised conclusion with rationale.',
    '4) Evidence or info that would most change the answer.'
  ].filter(Boolean).join('\n')
},

  {
  id:'peas',
  slug:'peas-framework',
  label:'PEAS — Performance measure · Environment · Actuators · Sensors',
  kind:'framework',
  categories:['AI systems design','analysis frameworks'],
  tags:[
    'type:framework','topic:ai-systems','phase:design','level:intermediate',
    'use:agent-spec','use:task-modeling','use:benchmarking','use:requirements-doc'
  ],
  use_cases: [
    'agent specification','requirements doc','benchmark design',
    'task environment mapping','simulation setup'
  ],
  definition:'A canonical way to specify intelligent agents by defining success metrics, the environment, possible actions, and percepts.',
  help:'Use to design/evaluate agents or tools before building.',
  fields:[
    {key:'performance', label:'Performance measure', type:'textarea', desc:'Metrics, goals, constraints.',  ph:'e.g., Success@K, latency < 500ms, ≤2% hallucination rate'},
    {key:'environment', label:'Environment',        type:'textarea', desc:'World, resources, interfaces.', ph:'e.g., Web browser + internal docs + API with rate-limits'},
    {key:'actuators',   label:'Actuators',          type:'textarea', desc:'Actions the agent can take.',   ph:'e.g., Click, type, call API, write file'},
    {key:'sensors',     label:'Sensors',            type:'textarea', desc:'Observations/inputs.',          ph:'e.g., DOM snapshot, API responses, tool outputs'},
    {key:'assumptions', label:'Assumptions (opt.)', type:'textarea', desc:'Assumptions/risks/trust model.',ph:'e.g., Auth tokens valid; pages stable; tool outputs reliable'}
  ],
  boosters:[
    'Summarize as a PEAS tuple and include two evaluation scenarios with success/failure traces.'
  ],
  template:({performance,environment,actuators,sensors,assumptions,ctx})=>[
    `Define the agent using the PEAS framework.`,
    ctx&&`Context: ${ctx}`,
    performance&&`Performance measure: ${performance}`,
    environment&&`Environment: ${environment}`,
    actuators&&`Actuators: ${actuators}`,
    sensors&&`Sensors: ${sensors}`,
    assumptions&&`Assumptions/risks: ${assumptions}`
  ].filter(Boolean).join('\n')
},

{
  id:'persona',
  slug:'persona-actas',
  label:'Persona — ActAs / Simulate',
  kind:'pattern',
  categories:['prompt development techniques','persona prompting'],
  tags:[
    'type:pattern','topic:persona','phase:apply','level:beginner',
    'use:act-as','use:simulation','use:roleplay','use:agent-spec'
  ],
  boosters:[
    "Stay in-character. Prefer precise, domain-correct terminology. Cite trade-offs briefly before final answer."
  ],
  definition:'Simulate a specific persona (role) with domain skills, vocabulary, and constraints; then apply it to the user’s end goal.',
  help:'Type to search a persona. Picking one autofills the rest; or type your own persona free-form.',
  fields:[
    { key:'end',           label:'End goal / Task to Complete', type:'text',     ph:'e.g., Draft a 5-step onboarding plan' },

    // The special typeahead field (wired in renderFields)
    { key:'persona_name',  label:'Persona (who the AI will be)', type:'typeahead', ph:'e.g., UX designer, Data scientist, PM' },

    // Autofilled when a suggestion is chosen (editable)
    { key:'profession',    label:'Profession',   type:'text',     ph:'e.g., Designer' },
    { key:'summary',       label:'Summary',      type:'textarea', ph:'1–2 lines that define this persona' },
    { key:'description',   label:'Additional Description (optional)', type:'textarea', ph:'Longer narrative if available' },
    { key:'core_tasks',    label:'Core tasks (one per line)', type:'textarea', ph:'Plan tests\nWireframe flows\nSynthesize insights' },
    { key:'skills',        label:'Skills (comma or one per line)', type:'textarea', ph:'Wireframing, Prototyping, IA' },
    { key:'vocabulary',    label:'Vocabulary (comma or one per line)', type:'textarea', ph:'affordance, heuristic, persona' },
    { key:'goals',         label:'Goals (one per line)', type:'textarea', ph:'Improve task success\nReduce friction' },
    { key:'pain_points',   label:'Pain points (one per line)', type:'textarea', ph:'Stakeholder misalignment\nLegacy systems' },
    { key:'tools',         label:'Tools (comma or one per line)', type:'textarea', ph:'Figma, Lookback, Maze' }
  ],
  template:({ end, persona_name, profession, summary, description, core_tasks, skills, vocabulary, goals, pain_points, tools, ctx })=>{
    const asList = s => String(s||'').split(/[\n,]+/).map(v=>v.trim()).filter(Boolean);
    const asCSV  = s => asList(s).join(', ');
    const asBul  = s => asList(s).map(x=>'• ' + x).join('\n');

    return [
      ctx && `Context: ${ctx}`,
      (persona_name || profession) && `You are ${persona_name || 'the requested persona'}${profession ? `, a ${profession}` : ''}.`,
      summary && `Persona Summary: ${summary}`,
      description && `Persona Description: ${description}`,
      core_tasks && `You commonly do:\n${asBul(core_tasks)}`,
      skills && `Core skills: ${asCSV(skills)}`,
      vocabulary && `Vocabulary keywords: ${asCSV(vocabulary)}`,
      goals && `Common goals:\n${asBul(goals)}`,
      pain_points && `Common pain points:\n${asBul(pain_points)}`,
      tools && `Tools: ${asCSV(tools)}`,
      end && `\nUnderstanding your persona, complete this end goal objective: ${end}`
    ].filter(Boolean).join('\n');
  }
},

{
  id:'plan_solve',
  slug:'plan-and-solve-ps',
  label:'Plan and Solve (P&S)',
  kind:'pattern',
  categories:['reasoning','planning'],
  tags:[
    'type:pattern','topic:plan-first','topic:execution','topic:verification','phase:solve','level:intermediate',
    'use:math','use:coding','use:ops-procedures'
  ],
  use_cases:[
    'create a short plan before executing a solution',
    'separate planning from working to reduce errors',
    'verify results against explicit checks'
  ],
  definition:'Draft a minimal plan, execute it, and verify the result against stated checks.',
  help:'Enter the problem. Optionally provide a plan (one per line) and verification checks (one per line). The model will plan → solve → verify.',
  boosters:[
    'Keep the plan to 2–5 concise steps.',
    'Separate planning text from solution text.',
    'Verify against explicit checks; note any discrepancies.'
  ],
  fields:[
    { key:'problem', label:'Problem / question', type:'textarea',
      desc:'What needs to be solved?',
      ph:'e.g., Given an array, return indices of two numbers that add up to target.' },
    { key:'plan',    label:'Plan (one per line, optional)', type:'textarea',
      desc:'High-level steps before solving.',
      ph:'Understand inputs…\nOutline approach…\nExecute steps…\nValidate…' },
    { key:'checks',  label:'Verification checks (one per line, optional)', type:'textarea',
      desc:'Tests or criteria to validate the result.',
      ph:'Test with empty input…\nCheck off-by-one…\nTime complexity ≤ O(n log n)…' },
    { key:'dos',     label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'State assumptions; keep total under 300 words.' },
    { key:'donts',   label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No hidden reasoning; avoid unnecessary jargon.' }
  ],
  template: ({ problem, plan, checks, dos, donts, ctx, audience, style, tone }) => [
    'Use Plan-and-Solve: draft a minimal plan, execute it, then verify the result.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    problem && `Problem: ${problem}`,
    plan && (
      'Plan:\n' + String(plan)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((p,i)=> `${i+1}. ${p}`).join('\n')
    ),
    checks && (
      'Verification checks:\n' + String(checks)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((c,i)=> `${i+1}. ${c}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output format:\n1) Plan\n2) Solution/working\n3) Verification (reference the checks)'
  ].filter(Boolean).join('\n')
},

{
  id:'pomodoro',
  slug:'pomodoro-scaffold',
  label:'Pomodoro Scaffold',
  kind:'pattern',
  categories:['productivity','focus'],
  tags:['type:pattern','topic:pomodoro','use:focus','level:beginner'],
  use_cases:[
    'frame a single 25-minute focus sprint',
    'pair a micro-goal with a reward and next step'
  ],
  definition:'25-minute focused work block with short breaks.',
  help:'Pick one task and a tiny goal for this block; name your break reward; plan the next block.',
  boosters:[
    'Hide distractions: list top 3 and how you’ll block them.',
    'Write an “opening move” you’ll do in the first 60 seconds.'
  ],
  fields:[
    { key:'task',      label:'Task to tackle', type:'textarea' },
    { key:'micro',     label:'One 25-min micro-goal', type:'textarea' },
    { key:'reward',    label:'Break reward', type:'textarea' },
    { key:'next_step', label:'Next Pomodoro step', type:'textarea' }
  ],
  template: ({ task, micro, reward, next_step, ctx, audience, style, tone }) => [
    'Plan a Pomodoro to get moving.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    task && ('Task:\n' + task),
    micro && ('Micro-goal (25 min):\n' + micro),
    reward && ('Break reward:\n' + reward),
    next_step && ('Next Pomodoro step:\n' + next_step),
    'Output:\n1) Task + micro-goal\n2) First 60-sec move\n3) Reward\n4) Next block'
  ].filter(Boolean).join('\n')
},

{
  id:'premortem',
  slug:'pre-mortem-scaffold',
  label:'Pre-Mortem Scaffold',
  kind:'pattern',
  categories:['risk','planning','decision'],
  tags:['type:pattern','topic:premortem','use:planning','level:beginner'],
  use_cases:[
    'surface failure modes before committing',
    'turn risks into preventive steps and immediate actions'
  ],
  definition:'Imagine the project failed and ask why, so you can prevent it.',
  help:'Name the decision/project, list plausible failure causes, define prevention, then pick one immediate move.',
  boosters:[
    'Force at least 3 realistic failure causes.',
    'Assign owners and a check date for each preventive step.'
  ],
  fields:[
    { key:'decision',  label:'Decision / project at hand', type:'textarea', ph:'Name + scope.' },
    { key:'failed',    label:'Imagine it failed — what went wrong? (one per line)', type:'textarea', ph:'3–5 failure causes.' },
    { key:'prevent',   label:'Preventive step(s)', type:'textarea', ph:'Countermeasures mapped to causes.' },
    { key:'immediate', label:'Immediate action', type:'textarea', ph:'What starts today.' }
  ],
  template: ({ decision, failed, prevent, immediate, ctx, audience, style, tone }) => [
    'Run a pre-mortem to convert risks into action.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    decision && ('Decision / project:\n' + decision),
    failed && (
      'Failure causes (envisioned):\n' + String(failed).split(/\n+/).map(s=>s.trim()).filter(Boolean).map((x,i)=>`${i+1}. ${x}`).join('\n')
    ),
    prevent && ('Preventive steps:\n' + prevent),
    immediate && ('Immediate action:\n' + immediate),
    'Output:\n1) Top risks\n2) Mapped preventions\n3) Today’s move\n4) Owners + dates'
  ].filter(Boolean).join('\n')
},

  {
  id:'prompt_augmentation',
  slug:'prompt-augmentation-demonstration-learning',
  label:'Prompt Augmentation (Demonstration Learning)',
  kind:'pattern',
  categories:['prompt development techniques','prompt literacy'],
  tags:[
    'type:pattern','topic:examples','topic:demonstrations','phase:apply','level:intermediate',
    'use:format-guidance','use:style-transfer','use:pattern-learning'
  ],
  use_cases:[
    'teach the model a Q→A pattern by example',
    'lock in output format and tone via paired demonstrations',
    'evaluate consistency against provided answers'
  ],
  definition:'Provide multiple prompt→answer pairs so the model infers and follows the desired pattern.',
  help:'Enter your current brief (optional), then list prompts and answers line-by-line in parallel.',
  boosters:[
    'Keep pairs short and high-signal; avoid ambiguity.',
    'Use consistent structure across all answers.',
    'If counts mismatch, ignore extra lines.'
  ],
  fields:[
    { key:'main',     label:'Brief / request (optional)', type:'textarea',
      desc:'What you want now, guided by the examples.',
      ph:'e.g., Classify the following support ticket.' },
    { key:'prompts',  label:'Example prompts (one per line)', type:'textarea',
      desc:'Each line is a prompt/question.',
      ph:'Prompt A…\nPrompt B…\nPrompt C…' },
    { key:'answers',  label:'Example answers (one per line)', type:'textarea',
      desc:'Each line is the corresponding answer. Keep counts aligned with prompts.',
      ph:'Answer A…\nAnswer B…\nAnswer C…' },
    { key:'dos',      label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Follow the demonstrated headings exactly.' },
    { key:'donts',    label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No extra commentary; ≤150 words per answer.' }
  ],
  template: ({ main, prompts, answers, dos, donts, ctx, audience, style, tone }) => [
    'Use demonstration learning: infer the desired format and tone from the prompt→answer pairs, then apply consistently.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    main && `Brief: ${main}`,
    (prompts || answers) && (function(){
      const ps = String(prompts||'').split(/\n+/).map(s=>s.trim()).filter(Boolean);
      const as = String(answers||'').split(/\n+/).map(s=>s.trim()).filter(Boolean);
      const n = Math.min(ps.length, as.length);
      if (!n) return null;
      return 'Demonstrations:\n' + ps.slice(0,n).map((p,i)=>`${i+1}. Prompt: ${p}\n   Answer: ${as[i]}`).join('\n');
    })(),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'After the demonstrations, respond in the same pattern.'
  ].filter(Boolean).join('\n')
},

  
  {
  id:'raccca',
  slug:'raccca-framework',
  label:'RACCCA — Relevance · Accuracy · Completeness · Clarity · Coherence · Appropriateness',
  kind:'framework',
  categories:['evaluation frameworks','prompt development techniques'],
  tags:[
    'type:framework','topic:evaluation','phase:evaluate','level:beginner',
    'use:output-evaluation','use:rubric-scoring','use:quality-review','use:model-comparison'
  ],
  use_cases: [
    'quality review','rubric evaluation','model comparison',
    'content audit','risk screening'
  ],
  definition:'A rubric to evaluate generative outputs across six dimensions: relevance, accuracy, completeness, clarity, coherence, and appropriateness.',
  help:'Use to score or compare outputs and identify concrete fixes.',
  fields:[
    {key:'artifact',        label:'Artifact to evaluate', type:'textarea', desc:'Paste or describe the output.',      ph:'e.g., The draft blog intro…'},
    {key:'scale',           label:'Scale',                type:'text',     desc:'Scoring scale.',                    ph:'e.g., 1–5'},
    {key:'weights',         label:'Weights (opt.)',       type:'text',     desc:'Criterion weights.',                ph:'e.g., R:1,A:2,C:2,Cl:1,Co:1,Ap:1'},
    {key:'context',         label:'Context/requirements', type:'textarea', desc:'Intended use and constraints.',     ph:'e.g., Audience: Dev managers; tone: practical'},
    {key:'improvement_goal',label:'Improvement goal',     type:'textarea', desc:'Desired fix or target quality.',    ph:'e.g., Make it accurate and concise'}
  ],
  boosters:[
    'Return a table with RACCCA scores (on your scale) + 1-line justifications, a weighted overall score, and top-3 fixes. If suitable, include a revised draft.'
  ],
  template:({artifact,scale,weights,context,improvement_goal,ctx})=>[
    `Evaluate using the RACCCA framework.`,
    ctx&&`Context: ${ctx}`,
    artifact&&`Artifact: ${artifact}`,
    scale&&`Scale: ${scale}`,
    weights&&`Weights: ${weights}`,
    context&&`Requirements: ${context}`,
    improvement_goal&&`Improvement goal: ${improvement_goal}`
  ].filter(Boolean).join('\n')
},
  
  {
    id:'ratio',
    slug:'ratio-framework',
    label:'RATIO — Role · Audience · Task · Instructions · Output',
    kind:'pattern',
    categories:['prompt development techniques'],
   tags:[
  'type:pattern','topic:prompting','phase:apply','level:beginner',
  'use:prompt-spec','use:instructional-prompt','use:task-brief'
],
use_cases: [
  'prompt specification',
  'instructional prompt',
  'task brief',
  'agent/system prompt',
  'handoff brief',
  'template for graded output'
],
boosters: [
  "Validate format exactly (schema first, then fill); if schema can’t be met, output a minimal valid stub and list missing fields."
],
    definition:'An audience-centered prompt that captures role, target audience, the task, guiding instructions, and the required output shape.',
    help:'Audience-centered prompt with explicit output spec.',
    fields:[
      {key:'role',         label:'Role',         type:'text',     desc:'Who the model should emulate.', ph:'e.g., Product marketer'},
      {key:'audience',     label:'Audience',     type:'text',     desc:'Who this is for.',              ph:'e.g., New parents'},
      {key:'task',         label:'Task',         type:'textarea', desc:'What should be produced.',      ph:'e.g., Write a landing-page headline and 3 benefit bullets.'},
      {key:'instructions', label:'Instructions', type:'textarea', desc:'Constraints/steps to follow.',  ph:'e.g., Avoid jargon; use active voice; 120 words max.'},
      {key:'output',       label:'Output',       type:'text',     desc:'Exact deliverable shape.',      ph:'e.g., 1 headline + 3 bullets + CTA'}
    ],
    template:({role,audience,task,instructions,output,ctx})=>[
      role&&`You are ${role}.`,
      ctx&&`Context: ${ctx}`,
      audience&&`Target audience: ${audience}`,
      task&&`Task: ${task}`,
      instructions&&`Instructions: ${instructions}`,
      output&&`Output: ${output}`,
      `Use the RATIO pattern. Validate assumptions briefly before final output.`
    ].filter(Boolean).join('\n')
  },
  
  {
  id:'reflect_bias',
  slug:'reflect-bias-scaffold',
  label:'REFLECT (bias reflection)',
  kind:'pattern',
  categories:['ethics','bias','critical thinking'],
  tags:[
    'type:pattern','topic:bias','topic:reflection','level:beginner',
    'use:interviews','use:analysis','use:synthesis'
  ],
  use_cases:[
    'spot potential bias during interviews, analysis, or synthesis',
    'reframe a problem from multiple perspectives',
    'turn reflection into concrete next steps'
  ],
  definition:'A structured reflection scaffold to identify, check, and transform bias in your approach.',
  help:'Move through Recognize → Evaluate → Frame → Listen → Empathize → Check → Transform.',
  boosters:[
    'Keep tone neutral and specific; avoid moralizing.',
    'Return a bulleted summary + 3 concrete changes and 1 monitoring check.'
  ],
  fields:[
    { key:'recognize',  label:'Recognize — What bias might be at play?', type:'textarea', ph:'e.g., Confirmation bias; availability bias…' },
    { key:'evaluate',   label:'Evaluate — How does it influence my thinking?', type:'textarea', ph:'e.g., Overweighting a single user quote…' },
    { key:'frame',      label:'Frame — Restate the problem from a different perspective', type:'textarea', ph:'e.g., From a low-vision user; from operations…' },
    { key:'listen',     label:'Listen — Whose voices are missing?', type:'textarea', ph:'e.g., Non-English speakers; caregivers…' },
    { key:'empathize',  label:'Empathize — How would it feel in that missing perspective?', type:'textarea', ph:'Short, concrete description.' },
    { key:'check',      label:'Check — What assumption should I test?', type:'textarea', ph:'List 1–3 assumptions with test ideas.' },
    { key:'transform',  label:'Transform — How will I change my approach?', type:'textarea', ph:'e.g., Add recruitment quotas; change success metric…' }
  ],
  template: ({ recognize, evaluate, frame, listen, empathize, check, transform, ctx, audience, style, tone }) => [
    'Use the REFLECT scaffold to surface and mitigate bias.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    recognize && ('Recognize:\n' + recognize),
    evaluate && ('Evaluate:\n' + evaluate),
    frame && ('Frame (alt perspective):\n' + frame),
    listen && (
      'Listen (missing voices):\n' + String(listen).split(/\n+/).map(s=>s.trim()).filter(Boolean).map((x,i)=>`${i+1}. ${x}`).join('\n')
    ),
    empathize && ('Empathize (experience sketch):\n' + empathize),
    check && (
      'Check (assumptions + tests):\n' + String(check).split(/\n+/).map(s=>s.trim()).filter(Boolean).map((x,i)=>`${i+1}. ${x}`).join('\n')
    ),
    transform && ('Transform (changes to approach):\n' + transform),
    'Output:\n1) Key bias risks\n2) Reframed problem\n3) Missing voices to include\n4) 3 action changes + 1 monitoring check'
  ].filter(Boolean).join('\n')
},
  
  {
    id:'risen',
    slug:'risen-framework',
    label:'RISEN — Role · Instructions · Steps · End goal · Narrowing',
    kind:'pattern',
    categories:['prompt development techniques'],
    tags:[
  'type:pattern','topic:prompting','phase:plan','level:intermediate',
  'use:project-plan','use:workflow-design','use:research-plan'
],
use_cases: [
  'project plan',
  'research plan',
  'workflow design',
  'content production plan',
  'experiment plan',
  'learning plan'
],
boosters: [
  "State the 1–2 biggest tradeoffs; confirm the narrowed scope."
],
    definition:'A plan-then-focus scaffold: set role and instructions, outline steps, state the end goal, then narrow scope and priorities.',
    help:'Good for complex tasks with stepwise planning then focus.',
    fields:[
      {key:'role',        label:'Role',        type:'text',     desc:'Who the model should be.',          ph:'e.g., Program manager'},
      {key:'instructions',label:'Instructions',type:'textarea', desc:'Rules/constraints to honor.',       ph:'e.g., Prioritize clarity; reference internal style guide.'},
      {key:'steps',       label:'Steps',       type:'textarea', desc:'High-level plan or checklist.',     ph:'e.g., Research → Outline → Draft → Review → Finalize'},
      {key:'end_goal',    label:'End goal',    type:'text',     desc:'Definition of success.',            ph:'e.g., Publishable first draft by Friday EOD'},
      {key:'narrowing',   label:'Narrowing',   type:'textarea', desc:'Prioritization/scope cuts.',        ph:'e.g., Focus on onboarding, skip billing edge cases'}
    ],
    template:({role,instructions,steps,end_goal,narrowing,ctx})=>[
      role&&`You are ${role}.`,
      ctx&&`Context: ${ctx}`,
      instructions&&`Instructions: ${instructions}`,
      steps&&`Proposed steps: ${steps}`,
      end_goal&&`End goal: ${end_goal}`,
      narrowing&&`Focus/narrowing: ${narrowing}`,
      `Follow RISEN. Reflect on tradeoffs before final.`
    ].filter(Boolean).join('\n')
  },
  {
    id:'rodes',
    slug:'rodes-framework',
    label:'RODES — Role · Objective · Details · Examples · Sense check',
    kind:'pattern',
    categories:['prompt development techniques'],
    tags:[
  'type:pattern','topic:prompting','phase:apply','level:intermediate',
  'use:example-guided-writing','use:ux-microcopy','use:quality-check'
],
use_cases: [
  'example-guided rewriting',
  'UX microcopy',
  'tone/style adaptation',
  'product messaging variants',
  'quality check against criteria',
  'rubric-guided output'
],
boosters: [
  "Run the sense-check as a bullet list tied to the acceptance criteria, then deliver Final."
],
    definition:'Evidence-guided production: set role and objective, supply details and examples, then perform a brief sense-check before delivery.',
    help:'When you have exemplars and want a final self-check.',
    fields:[
      {key:'role',        label:'Role',        type:'text',     desc:'Who the model should be.',            ph:'e.g., UX writer'},
      {key:'objective',   label:'Objective',   type:'text',     desc:'Primary goal of the output.',         ph:'e.g., Improve sign-up microcopy'},
      {key:'details',     label:'Details',     type:'textarea', desc:'Key facts, constraints, resources.',  ph:'e.g., Product is mobile-only; support link must appear once.'},
      {key:'examples',    label:'Examples',    type:'textarea', desc:'Short exemplars to imitate.',         ph:'e.g., “Welcome aboard!” → concise, friendly tone'},
      {key:'sense_check', label:'Sense check', type:'textarea', desc:'Acceptance criteria/guardrails.',      ph:'e.g., At most 25 words; no slang; include link text'}
    ],
    template:({role,objective,details,examples,sense_check,ctx})=>[
      role&&`You are ${role}.`,
      ctx&&`Context: ${ctx}`,
      objective&&`Objective: ${objective}`,
      details&&`Details: ${details}`,
      examples&&`Examples: ${examples}`,
      sense_check&&`Sense-check before final: ${sense_check}`,
      `Apply RODES. Show brief reasoning if uncertain.`
    ].filter(Boolean).join('\n')
  },
  
  {
  id:'root_cause',
  slug:'root-cause-analysis',
  label:'Root Cause Analysis',
  kind:'pattern',
  categories:['quality','operations','reasoning'],
  tags:[
    'type:pattern','topic:5-whys','topic:causality','phase:diagnose','level:beginner',
    'use:incident-review','use:bug-analysis','use:process-improvement'
  ],
  use_cases:[
    'identify primary causes vs symptoms',
    'propose targeted countermeasures',
    'document verification steps'
  ],
  definition:'Identify the underlying cause of a problem (e.g., via 5 Whys), then propose countermeasures and checks.',
  help:'State the problem, list observed symptoms/evidence, and any guardrails.',
  boosters:[
    'Run at least 3–5 “Why?” steps until causes stop being actionable.',
    'Tie each countermeasure to a specific cause.',
    'Include verification and owner for each action.'
  ],
  fields:[
    { key:'problem',   label:'Problem statement', type:'textarea',
      desc:'What went wrong or what is undesired?',
      ph:'App crash rate spiked after v1.2…' },
    { key:'symptoms',  label:'Symptoms / evidence (one per line)', type:'textarea',
      desc:'Observed facts supporting the problem.',
      ph:'Crash logs show null ptr at …\nSpike at 10:42 UTC…' },
    { key:'dos',       label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Quantify impact; assign owners.' },
    { key:'donts',     label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No blame; ≤400 words.' }
  ],
  template: ({ problem, symptoms, dos, donts, ctx, audience, style, tone }) => [
    'Perform Root Cause Analysis using the 5 Whys and propose targeted countermeasures.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    problem && `Problem: ${problem}`,
    symptoms && (
      'Symptoms / evidence:\n' + String(symptoms)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((s,i)=> `${i+1}. ${s}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output:\n1) 5 Whys chain\n2) Root cause(s)\n3) Countermeasures (owner, due, verification)\n4) Residual risks'
  ].filter(Boolean).join('\n')
},

  
  {
    id:'rtf',
    slug:'rtf-framework',
    label:'RTF — Role · Task · Format',
    kind:'pattern',
    categories:['prompt development techniques'],
    tags:[
  'type:pattern','topic:prompting','phase:apply','level:beginner',
  'use:general-purpose','use:format-enforcement','use:starter-prompt'
],
use_cases: [
  'general-purpose prompting',
  'format enforcement',
  'role simulation',
  'structured data output',
  'template scaffold',
  'API-doc-style response',
  'quickstarter prompt'
],
boosters: [
  "Validate format exactly (schema first, then fill); if schema can’t be met, output a minimal valid stub and list missing fields."
],
    definition:'A general-purpose scaffold that specifies who the model is, what to do, and how to format the answer.',
    help:'General-purpose scaffold: define who the model is, what to do, and the response shape.',
    fields:[
      {key:'role',   label:'Role',   type:'text',     desc:'Who the model should act as.', ph:'e.g., Senior technical writer'},
      {key:'task',   label:'Task',   type:'textarea', desc:'Describe the work to be done.', ph:'e.g., Draft a user guide section explaining 2FA setup.'},
      {key:'format', label:'Format', type:'text',     desc:'The structure/shape of the output.', ph:'e.g., Markdown with H2s and code blocks'}
    ],
    template:({role,task,format,ctx})=>[
      role&&`You are ${role}.`,
      ctx&&`Context: ${ctx}`,
      task&&`Task: ${task}`,
      format&&`Respond in this format: ${format}`,
      `Follow the RTF pattern. Ask concise clarifying questions if needed.`
    ].filter(Boolean).join('\n')
  },
  
  {
  id:'scamper',
  slug:'scamper-framework',
  label:'SCAMPER (idea expansion)',
  kind:'pattern',
  categories:['creativity','ideation'],
  tags:['type:pattern','topic:scamper','use:ideas','level:beginner'],
  use_cases:[
    'systematically generate variants of an idea',
    'unstick creative exploration'
  ],
  definition:'Seven moves to push an idea: Substitute, Combine, Adapt, Modify, Put to other use, Eliminate, Reverse.',
  help:'Start with a current idea; write brief prompts for each SCAMPER move.',
  boosters:[
    'Demand at least 2 candidates per move (bullet them).',
    'End with one “crazy but testable” option.'
  ],
  fields:[
    { key:'current', label:'Current idea', type:'textarea', ph:'Describe the starting point.' },
    { key:'sub',     label:'Substitute — what element could you replace?', type:'textarea' },
    { key:'comb',    label:'Combine — what can be merged?', type:'textarea' },
    { key:'adapt',   label:'Adapt — what can be borrowed?', type:'textarea' },
    { key:'mod',     label:'Modify — exaggerated/minimized?', type:'textarea' },
    { key:'use',     label:'Put to other use — where else could it apply?', type:'textarea' },
    { key:'elim',    label:'Eliminate — what can you cut?', type:'textarea' },
    { key:'rev',     label:'Reverse — what if you flipped it?', type:'textarea' }
  ],
  template: ({ current, sub, comb, adapt, mod, use, elim, rev, ctx, audience, style, tone }) => [
    'Run SCAMPER to expand the idea space.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    current && ('Current idea:\n' + current),
    sub && ('Substitute:\n' + sub),
    comb && ('Combine:\n' + comb),
    adapt && ('Adapt:\n' + adapt),
    mod && ('Modify:\n' + mod),
    use && ('Put to other use:\n' + use),
    elim && ('Eliminate:\n' + elim),
    rev && ('Reverse:\n' + rev),
    'Output:\n1) 7 move list\n2) Top 3 candidates\n3) One testable “wild” option'
  ].filter(Boolean).join('\n')
},
  
   {
    id:'scenario_deliberative',
    slug:'scenario-based-deliberative',
    label:'Scenario-based Prompting — Deliberative reasoning',
    kind:'framework',
    categories:['prompt development techniques','reasoning'],
    tags:[
      'type:framework','topic:prompting','phase:compose','level:intermediate',
      'use:scenario','use:empathy','use:deliberation','use:edge-cases'
    ],
    use_cases:[
      'coaching & advice','policy-sensitive responses','support empathy','edge-case analysis'
    ],
    definition:'Grounds the model in a concrete situation and explicitly asks it to reason deliberately before answering.',
    help:'Set a vivid scenario and desired outcome. The framework slows the model down and separates thinking from the final recommendation.',
    fields:[
      {key:'role',        label:'Role (optional)',                    type:'text',     desc:'Perspective to adopt.',                         ph:'e.g., Emergency operations lead'},
      {key:'scenario',    label:'Scenario (specific, even extreme)',  type:'textarea', desc:'Describe actors, stakes, and context.',         ph:'e.g., ICU power outage during a heatwave; backups at 60 minutes…'},
      {key:'goal',        label:'Outcome goal',                       type:'text',     desc:'What success looks like.',                      ph:'e.g., Keep all patients safe until mains power returns'},
      {key:'constraints', label:'Constraints',                        type:'textarea', desc:'Non-negotiables, policies, risks.',             ph:'e.g., No transport; limited staff; HIPAA-safe comms only'},
      {key:'format',      label:'Response format (optional)',         type:'textarea', desc:'Headings/checklists to structure the output.',  ph:'e.g., 1) Immediate actions 2) Comms plan 3) Risks & mitigations'}
    ],
    boosters:[
      'Take a deep breath. Think step by step. First list assumptions and unknowns; then reason in numbered steps; then propose actions; end with a short checklist.',
      'Separate “Reasoning” from “Recommendation” using clear headings. Flag trade-offs and edge cases.'
    ],
    template:({role,scenario,goal,constraints,format,ctx})=>[
      'Engage in deliberate reasoning before answering.',
      ctx&&`Context: ${ctx}`,
      role&&`Role: ${role}`,
      scenario&&`Scenario: ${scenario}`,
      goal&&`Primary goal: ${goal}`,
      constraints&&`Constraints: ${constraints}`,
      'Deliberate: Take a deep breath; think step by step; state assumptions and unknowns; evaluate trade-offs.',
      format&&`Format: ${format}`,
      'Return:\n1) Reasoning\n2) Recommendation\n3) Checklist'
    ].filter(Boolean).join('\n')
  },
  
  {
  id:'six_hats',
  slug:'six-thinking-hats',
  label:'Six Thinking Hats',
  kind:'pattern',
  categories:['decision-making','ideation'],
  tags:[
    'type:pattern','topic:perspective-taking','topic:facilitation','phase:explore','level:beginner',
    'use:workshops','use:brainstorm','use:alignment'
  ],
  use_cases:[
    'explore multiple perspectives on a topic',
    'structure a discussion or solo reasoning',
    'surface risks, data, feelings, creativity, control'
  ],
  definition:'A role-play model (White, Red, Black, Yellow, Green, Blue) to examine a topic from six perspectives.',
  help:'Provide the topic and (optionally) the hat order (one per line).',
  boosters:[
    'Keep each hat’s notes to 2–3 bullets.',
    'End with a Blue hat summary decision.',
    'If no order is given, use White→Red→Black→Yellow→Green→Blue.'
  ],
  fields:[
    { key:'topic', label:'Topic / decision', type:'textarea',
      desc:'What are we evaluating or deciding?',
      ph:'Should we sunset Feature X?' },
    { key:'order', label:'Hat order (one per line, optional)', type:'textarea',
      desc:'Any subset/order of: White, Red, Black, Yellow, Green, Blue.',
      ph:'White\nRed\nBlack\nYellow\nGreen\nBlue' },
    { key:'dos',   label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'2–3 bullets per hat; be concrete.' },
    { key:'donts', label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No digressions; ≤350 words total.' }
  ],
  template: ({ topic, order, dos, donts, ctx, audience, style, tone }) => [
    'Use Six Thinking Hats to examine the topic from multiple perspectives, then conclude.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    topic && `Topic: ${topic}`,
    order && (
      'Hat order:\n' + String(order)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((h,i)=> `${i+1}. ${h}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output each hat with 2–3 bullets, then a Blue-hat summary decision.'
  ].filter(Boolean).join('\n')
},

{
    id: 'smart',
    slug: 'smart-goals',
    label: 'SMART Goals — Specific · Measurable · Achievable · Relevant · Time-bound',
    kind: 'framework',
    categories: ['planning', 'productivity'],
    tags: [
      'type:framework','topic:goal-setting','phase:plan','level:beginner',
      'use:personal-goals','use:project-planning','use:performance-goals'
    ],
    use_cases: [
      'refine vague goals into actionable statements',
      'ensure project objectives have clear success criteria and timelines',
      'evaluate if a goal is well-defined or needs adjustment'
    ],
    boosters: [
      'If any SMART element is missing (e.g., no timeframe), you will propose one to complete the goal definition.',
      'Present the output as 5 brief points (S, M, A, R, T) to clearly delineate each aspect.'
    ],
    definition: 'A goal-setting checklist ensuring an objective is Specific, Measurable, Achievable, Relevant, and Time-bound.',
    help: 'Enter a general goal. The model will break it down into the five SMART components, helping to make the goal clear and trackable.',
    fields: [
      { key: 'goal', label: 'General goal', type: 'textarea',
        desc: 'A short description of what you want to accomplish.',
        ph: 'e.g., Grow the mailing list for our newsletter.' },
      { key: 'specific', label: 'Specific (Optional)', type: 'textarea',
  desc: 'What exactly will be accomplished, by whom, and where it happens.',
  ph: 'e.g., Add a newsletter signup form to the site header and blog posts, and publish one monthly issue managed by the marketing team.' },
      { key: 'measurable', label: 'Measurable (Optional)', type: 'textarea',
  desc: 'How you will quantify success or track progress.',
  ph: 'e.g., Grow subscribers from 1,200 to 2,000 and reach a 5% signup rate on blog traffic.' },
{ key: 'achievable', label: 'Achievable (Optional)', type: 'textarea',
  desc: 'Why the target is realistic given resources, constraints, and past performance.',
  ph: 'e.g., Based on ~150 new subs per month from past campaigns, we can hit 2,000 by adding a lead magnet and two partner cross promotions.' },
{ key: 'relevant', label: 'Relevant (Optional)', type: 'textarea',
  desc: 'How this goal supports broader objectives or user needs.',
  ph: 'e.g., Email is our highest converting channel; a larger list supports the Q4 revenue OKR and product launch pipeline.' },
{ key: 'time_bound', label: 'Time-bound (Optional)', type: 'textarea',
  desc: 'The deadline and interim milestones or check-ins.',
  ph: 'e.g., Reach 2,000 subscribers by December 31, 2025; launch lead magnet by October 1 and review metrics every Monday.' }
    ],
template: ({ goal, ctx, audience, style, tone, specific, measurable, achievable, relevant, time_bound }) => [
  'Convert the goal into a SMART format.',
  ctx && `Context: ${ctx}`,
  audience && `Audience: ${audience}`,
  style && `Style: ${style}`,
  tone && `Tone: ${tone}`,
  goal && `Goal: ${goal}`,
  specific && ('Specific input:\n' + specific),
  measurable && ('Measurable input:\n' + measurable),
  achievable && ('Achievable input:\n' + achievable),
  relevant && ('Relevant input:\n' + relevant),
  time_bound && ('Time-bound input:\n' + time_bound),
  
    'Output each SMART element with details:',
  '- Specific: <what exactly will be done, by whom, and where>',
  '- Measurable: <how success will be quantified or tracked>',
  '- Achievable: <why it is realistic given resources and constraints>',
  '- Relevant: <how it supports broader objectives or user needs>',
  '- Time-bound: <deadline and interim checkpoints>',

  'Examples:',
  '- Specific eg: Add a newsletter signup form to the site header and blog posts, and publish one monthly issue managed by the marketing team.',
  '- Measurable eg: Grow subscribers from 1,200 to 2,000 and reach a 5% signup rate on blog traffic.',
  '- Achievable eg: Based on ~150 new subs per month from past campaigns, we can hit 2,000 by adding a lead magnet and two partner cross promotions.',
  '- Relevant eg: Email is our highest converting channel; a larger list supports the Q4 revenue OKR and product launch pipeline.',
  '- Time-bound eg: Reach 2,000 subscribers by December 31, 2025; launch lead magnet by October 1 and review metrics every Monday.',

  'Return:\n1) One sentence SMART goal\n2) KPI list with baselines and targets\n3) Milestone timeline with owners'
].filter(Boolean).join('\n')
  },

{
  id:'soar',
  slug:'soar-analysis',
  label:'SOAR Analysis',
  kind:'pattern',
  categories:['strategy','planning'],
  tags:[
    'type:pattern','topic:strategy','topic:positive-deviance','phase:plan','level:beginner',
    'use:offsites','use:visioning','use:roadmapping'
  ],
  use_cases:[
    'forward-looking strategic discussion',
    'align aspirations with measurable results',
    'find opportunity in strengths'
  ],
  definition:'Strengths, Opportunities, Aspirations, Results—an appreciative, forward-looking alternative to SWOT.',
  help:'Provide context (optional) and list SOAR elements (one per line each).',
  boosters:[
    'Tie each Aspiration to at least one Strength and Opportunity.',
    'Make Results measurable (metric, target, date).',
    'End with next steps.'
  ],
  fields:[
    { key:'context',       label:'Context (optional)', type:'textarea',
      desc:'Brief background or scope.',
      ph:'Q4 planning for self-serve growth…' },
    { key:'strengths',     label:'Strengths (one per line)', type:'textarea',
      desc:'What we already do well.',
      ph:'Fast release cadence…\nHighly engaged community…' },
    { key:'opportunities', label:'Opportunities (one per line)', type:'textarea',
      desc:'External possibilities to leverage.',
      ph:'Partnership with …\nUntapped EDU market…' },
    { key:'aspirations',   label:'Aspirations (one per line)', type:'textarea',
      desc:'Where we want to go.',
      ph:'Be the default for …\nNPS ≥ 50…' },
    { key:'results',       label:'Results (one per line)', type:'textarea',
      desc:'Measurable outcomes (metric & target).',
      ph:'ARR $5M by Q4; DAU 50k…' },
    { key:'dos',           label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Be specific and measurable.' },
    { key:'donts',         label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'Avoid vague aspirations.' }
  ],
  template: ({ context, strengths, opportunities, aspirations, results, dos, donts, ctx, audience, style, tone }) => [
    'Run a SOAR analysis (forward-looking strategy).',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    context && `Scope/context: ${context}`,
    strengths && (
      'Strengths:\n' + String(strengths)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    opportunities && (
      'Opportunities:\n' + String(opportunities)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    aspirations && (
      'Aspirations:\n' + String(aspirations)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    results && (
      'Results (measurable):\n' + String(results)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Close with 3 next steps linked to the SOAR items.'
  ].filter(Boolean).join('\n')
},

{
  id:'socratic',
  slug:'socratic-questioning',
  label:'Socratic Questioning',
  kind:'pattern',
  categories:['reasoning','critical thinking'],
  tags:[
    'type:pattern','topic:socratic','topic:assumptions','phase:explore','level:beginner',
    'use:analysis','use:teaching','use:debiasing'
  ],
  use_cases:[
    'interrogate claims and assumptions',
    'separate knowledge from belief',
    'surface implications and alternatives'
  ],
  definition:'A disciplined questioning method to clarify, probe assumptions, test evidence, explore viewpoints, and examine implications.',
  help:'Provide a claim/topic, plus any assumptions, evidence, or alternatives (one per line).',
  boosters:[
    'Keep questions sharp and answerable.',
    'Avoid leading or loaded wording.',
    'End with a synthesis and next inquiry.'
  ],
  fields:[
    { key:'claim',       label:'Claim / topic', type:'textarea',
      desc:'What are we questioning?',
      ph:'“We must pivot to enterprise immediately.”' },
    { key:'assumptions', label:'Assumptions (one per line, optional)', type:'textarea',
      desc:'Suspected premises.',
      ph:'SMB cannot pay…\nSales cycle is too long…' },
    { key:'evidence',    label:'Evidence (one per line, optional)', type:'textarea',
      desc:'Facts or data offered.',
      ph:'Churn 12%…\n2/5 enterprise pilots failed…' },
    { key:'alternatives',label:'Alternatives (one per line, optional)', type:'textarea',
      desc:'Other viewpoints/paths.',
      ph:'PLG focus…\nMid-market first…' },
    { key:'dos',         label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Neutral tone; concrete questions.' },
    { key:'donts',       label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'No ad hominem; ≤300 words.' }
  ],
  template: ({ claim, assumptions, evidence, alternatives, dos, donts, ctx, audience, style, tone }) => [
    'Apply Socratic questioning to probe the topic and synthesize a position.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    claim && `Topic: ${claim}`,
    assumptions && (
      'Assumptions:\n' + String(assumptions)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    evidence && (
      'Evidence:\n' + String(evidence)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    alternatives && (
      'Alternatives:\n' + String(alternatives)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((x,i)=> `${i+1}. ${x}`).join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output:\n1) Clarification questions\n2) Probe assumptions\n3) Test evidence\n4) Explore viewpoints\n5) Implications\n6) Synthesis & next inquiry'
  ].filter(Boolean).join('\n')
},

  
  {
    id:'star',
    slug:'star-technique',
    label:'STAR — Situation · Task · Action · Result',
    kind:'framework',
    categories:['storytelling frameworks','prompt development techniques'],
   tags:[
  'type:framework','topic:storytelling','phase:apply','level:beginner',
  'use:behavioral-interview','use:resume-bullet','use:case-study'
],
use_cases: [
  'behavioral interview answer',
  'resume bullet',
  'case study write-up',
  'performance self-review',
  'success story for stakeholders',
  'incident/postmortem story'
],
boosters: [
  "Quantify results where possible (%, Δ, time); if no metrics given, propose proxy metrics."
],
    definition:'A structured storytelling method for accomplishments and case studies.',
    help:'Great for case studies, resumes, performance stories.',
    fields:[
      {key:'situation', label:'Situation', type:'textarea', desc:'Context and constraints.', ph:'e.g., Missed quarterly target; low trial conversions'},
      {key:'task',      label:'Task',      type:'textarea', desc:'Goal or responsibility.',   ph:'e.g., Improve conversion rate by 20%'},
      {key:'action',    label:'Action',    type:'textarea', desc:'What you did.',            ph:'e.g., Ran pricing test; rewrote trial emails'},
      {key:'result',    label:'Result',    type:'textarea', desc:'Outcome/impact.',          ph:'e.g., +24% conversions; +18% MRR'}
    ],
    template:({situation,task,action,result,ctx,audience})=>[
      ctx&&`Context: ${ctx}`,
      audience&&`Target reader: ${audience}`,
      `Narrative using STAR:`,
      situation&&`• Situation: ${situation}`,
      task&&`• Task: ${task}`,
      action&&`• Action: ${action}`,
      result&&`• Result: ${result}`
    ].filter(Boolean).join('\n')
  },
  {
    id:'swot',
    slug:'swot-analysis',
    label:'SWOT — Strengths · Weaknesses · Opportunities · Threats',
    kind:'framework',
    categories:['analysis frameworks','prompt development techniques'],
    tags:[
  'type:framework','topic:analysis','phase:overview','level:beginner',
  'use:competitive-analysis','use:market-analysis','use:product-strategy'
],
use_cases: [
  'competitive analysis',
  'compare',
  'market scan',
  'product strategy snapshot',
  'business strategy review',
  'go-to-market assessment',
  'campaign planning snapshot'
],
boosters: [
  "Sort each list most-specific → least; avoid duplicates; flag any misclassified items (internal vs external)."
],
    definition:'A 2×2 strategic scan that separates internal factors (S/W) from external forces (O/T).',
    help:'Strategic scan of an idea, product, or org.',
    fields:[
      {key:'subject',      label:'Subject',            type:'text',     desc:'What we are analyzing.', ph:'e.g., New B2B email tool'},
      {key:'strengths',    label:'Known strengths',    type:'textarea', desc:'Optional seed inputs.',   ph:'e.g., Easy setup; strong analytics'},
      {key:'weaknesses',   label:'Known weaknesses',   type:'textarea', desc:'Optional seed inputs.',   ph:'e.g., Limited integrations'},
      {key:'opportunities',label:'Known opportunities',type:'textarea', desc:'Optional seed inputs.',   ph:'e.g., Growing SMB market'},
      {key:'threats',      label:'Known threats',      type:'textarea', desc:'Optional seed inputs.',   ph:'e.g., Mailbox policy changes'}
    ],
    template:({subject,strengths,weaknesses,opportunities,threats,ctx})=>[
      `Conduct a SWOT analysis${subject?` of ${subject}`:''}.`,
      ctx&&`Context: ${ctx}`,
      (strengths||weaknesses||opportunities||threats)?`Seed facts to consider:`:null,
      strengths&&`• Strengths (given): ${strengths}`,
      weaknesses&&`• Weaknesses (given): ${weaknesses}`,
      opportunities&&`• Opportunities (given): ${opportunities}`,
      threats&&`• Threats (given): ${threats}`,
      `Return as four labeled lists with 3–6 bullets each, most specific first.`
    ].filter(Boolean).join('\n')
  },

{
  id:'task_breakdown',
  slug:'task-recipe-cot',
  label:'Task Prompt Breakdown — Task/Recipe + Do/Don’t (CoT)',
  kind:'pattern',
  categories:['prompt development techniques','planning'],
  tags:[
    'type:pattern','topic:tasking','topic:reasoning','phase:plan','level:beginner',
    'use:project-steps','use:recipe','use:breakdown','use:delegation'
  ],
  use_cases: [
    'break a goal into concrete steps',
    'write a procedural recipe',
    'handoff a task with crisp Do/Don’t guardrails',
    'guide short “explain-your-steps” reasoning'
  ],
  definition:'Decompose a goal into explicit steps (tasks), with optional Do/Don’t constraints, then produce the deliverable.',
  help:'Provide a main brief, enumerate tasks (add as many as needed), then add Do/Don’t guardrails.',
  boosters:[
    'Show the step plan as a numbered list before the final deliverable.',
    'Keep reasoning concise and procedural (no hidden chain-of-thought).',
    'List assumptions in one line if any are required.'
  ],
  fields:[
    { key:'main',  label:'Main brief / goal', type:'textarea',
      desc:'High-level objective or problem statement.',
      ph:'e.g., Create a study plan for a 6-week data structures course.'
    },
    // You can switch this to "dynamic_tasks" after Step 2
    { key:'tasks', label:'Tasks (one per line)', type:'textarea',
      desc:'Enter one task/step per line.',
      ph:'Task 1…\nTask 2…\nTask 3…'
    },
    { key:'dos',   label:'Do’s (must do)', type:'textarea',
      desc:'Positive guardrails the output must follow.',
      ph:'e.g., Use simple language; include references; keep under 500 words.'
    },
    { key:'donts', label:'Don’ts / Constraints', type:'textarea',
      desc:'Negative guardrails or constraints.',
      ph:'e.g., Don’t assume prior knowledge; avoid vendor-specific terms.'
    }
  ],
  template: ({ main, tasks, dos, donts, ctx, audience, style, tone }) => [
    'Use task/recipe chain of thought reasoning to break the goal into explicit steps, then produce the deliverable.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    main && `Goal: ${main}`,
    tasks && (
      'Tasks:\n' + String(tasks)
        .split(/\n+/)
        .map(s => s.trim())
        .filter(Boolean)
        .map((t, i) => `${i + 1}. ${t}`)
        .join('\n')
    ),
    dos && `Do:\n${dos}`,
    donts && `Don’t:\n${donts}`,
    'First show the numbered plan, then execute it to produce the final output. Keep reasoning concise (procedural, verifiable).'
  ].filter(Boolean).join('\n')
},

{
  id:'tot_brainstorm',
  slug:'tree-of-thought-brainstorm',
  label:'Tree of Thought — Brainstorm & Evaluate',
  kind:'pattern',
  categories:['reasoning','planning'],
  tags:[
    'type:pattern','topic:reasoning','topic:branching','phase:explore','level:advanced',
    'use:brainstorm','use:compare-alternatives','use:decision'
  ],
  use_cases:[
    'generate multiple solution paths before deciding',
    'compare tradeoffs across ideas using a scoring rubric',
    'pick a best path with justification and a reflect pass'
  ],
  definition:'Explore three distinct reasoning branches (fast/minimal; thorough/future-proof; creative alternative), score them with a rubric, select/synthesize, deliver, then reflect.',
  help:'Describe the task, constraints, and what “good” looks like. Optionally paste custom evaluation criteria (one per line). Guardrails include arithmetic checks, terminology clarity, source-of-truth checks for time-varying info, and bias/inclusion calls.',
  boosters:[
    'Keep branches shallow (depth 2–3) to avoid overthinking.',
    'Use explicit labels: Branch A, A1, A2… Branch B… Branch C…',
    'Score on 1–5 with one-line justifications per criterion.',
    'Run a quick reflect pass: math/terms/bias/constraints.',
    'If the user supplied criteria, use them; otherwise use the default rubric included below.'
  ],
  fields:[
    { key:'problem',  label:'Task / problem', type:'textarea',
      desc:'What should be solved or decided?',
      ph:'e.g., Choose a pricing model for a new SaaS.' },
    { key:'constraints', label:'Constraints (time/tools/tone/privacy)', type:'textarea',
      desc:'Limits to respect; hard requirements.',
      ph:'e.g., Launch in 2 weeks; no paid ads; tone: friendly/expert.' },
    { key:'success', label:'Success criteria (what “good” looks like)', type:'textarea',
      desc:'How the output will be judged.',
      ph:'e.g., Clear pricing tiers, easy to A/B test, predictable revenue.' },
    { key:'criteria', label:'Evaluation criteria (optional, one per line)', type:'textarea',
      desc:'If empty, a default rubric will be used.',
      ph:'Plausibility…\nEvidence…\nConstraint fit…\nRisk profile…\nInclusivity…\nSimplicity…\nNovelty…' }
  ],
  template: ({ problem, constraints, success, criteria, ctx, audience, style, tone }) => {
    const rubricLines = String(criteria||'').split(/\n+/).map(s=>s.trim()).filter(Boolean);
    const rubric = rubricLines.length
      ? 'Evaluation criteria:\n' + rubricLines.map((c,i)=>`${i+1}. ${c}`).join('\n')
      : [
          'Default scoring rubric (1–5 each):',
          '1) Plausibility — internally coherent and realistic.',
          '2) Evidence — verifiable facts; cite when needed.',
          '3) Constraint fit — matches time, tools, and tone.',
          '4) Risk profile — failure modes, ambiguity, hidden costs.',
          '5) Inclusivity — avoid Western-centric defaults; note lenses.',
          '6) Simplicity — minimum moving parts.',
          '7) Novelty — useful creativity without hand-waving.'
        ].join('\n');

    return [
      'You are in Tree-of-Thought mode.',
      ctx && `Context: ${ctx}`,
      audience && `Audience: ${audience}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      problem && `Task: ${problem}`,
      constraints && `Constraints: ${constraints}`,
      success && `Success criteria: ${success}`,
      rubric,
      'Procedure:',
      '1) Generate 3 branches with different assumptions:',
      '   • Branch A: fast/minimal solution',
      '   • Branch B: thorough/future-proof solution',
      '   • Branch C: creative alternative',
      '   For each branch, list: assumptions, 3–5 steps, facts needed, risks, brief cost/benefit.',
      '2) Expand only the 2 most promising steps per branch to avoid overthinking.',
      '3) Score each branch on the rubric (1–5) with one-line justifications.',
      '4) Select the winning branch or synthesize a blend (2–4 lines on why).',
      '5) Produce the final deliverable.',
      '6) Reflect pass: check math (digit-by-digit if any), clarify terminology on first use, verify time-varying info against a source of truth, call out potential bias/assumptions, and list trade-offs in 3 bullets.',
      'Output format:',
      'Root',
      '├─ Branch A',
      '│  ├─ A1 …',
      '│  ├─ A2 …',
      '│  └─ …',
      '├─ Branch B',
      '│  ├─ B1 …',
      '│  ├─ B2 …',
      '│  └─ …',
      '└─ Branch C',
      '   ├─ C1 …',
      '   ├─ C2 …',
      '   └─ …',
      '→ Scores table → Selected path/synthesis → Final answer → Reflect pass.'
    ].filter(Boolean).join('\n');
  }
},


{
  id:'tot_decompose',
  slug:'tree-of-thought-decomposition',
  label:'Tree of Thought — Decomposition',
  kind:'pattern',
  categories:['reasoning','planning'],
  tags:[
    'type:pattern','topic:decomposition','topic:branching','phase:plan','level:advanced',
    'use:breakdown','use:alternatives','use:execution-plan'
  ],
  use_cases:[
    'break a complex goal into a branching plan with alternatives',
    'surface trade-offs at ambiguous nodes with scoring',
    'select a minimal viable critical path with checkpoints'
  ],
  definition:'Decompose a complex goal into a branching hierarchy with alternative sub-steps, score branch strategies, select a critical path, then reflect.',
  help:'Provide the goal, constraints, and any focus areas or risks. The model will build a numbered tree, compare strategies, choose a minimal viable path, and list next actions.',
  boosters:[
    'Show a numbered hierarchy (1, 1.1, 1.1.1).',
    'Offer 2–3 alternative sub-steps at ambiguous nodes.',
    'Label dependencies and the critical path.',
    'End with a smallest-next-action checklist and a reflect pass.'
  ],
  fields:[
    { key:'goal',  label:'Goal / complex task', type:'textarea',
      desc:'What should be decomposed?',
      ph:'e.g., Launch a developer portal in 6 weeks.' },
    { key:'constraints', label:'Constraints (time/tools/tone/privacy)', type:'textarea',
      desc:'Limits to respect; hard requirements.',
      ph:'e.g., 2 engineers, budget $5k, HIPAA data.' },
    { key:'success', label:'Success criteria (what “good” looks like)', type:'textarea',
      desc:'How the outcome will be judged.',
      ph:'e.g., Docs coverage ≥80%, SSO, <200ms P95.' },
    { key:'facets',   label:'Focus areas (one per line, optional)', type:'textarea',
      desc:'Dimensions to branch on (e.g., people, process, tooling).',
      ph:'Docs…\nAuth…\nDX metrics…\nContent strategy…' },
    { key:'risks',    label:'Known risks & assumptions (one per line, optional)', type:'textarea',
      desc:'Things that could change the plan.',
      ph:'Limited writer bandwidth…\nPending legal review…' },
    { key:'criteria', label:'Evaluation criteria (optional, one per line)', type:'textarea',
      desc:'If empty, a default rubric will be used.',
      ph:'Plausibility…\nEvidence…\nConstraint fit…\nRisk profile…\nInclusivity…\nSimplicity…\nNovelty…' }
  ],
  template: ({ goal, constraints, success, facets, risks, criteria, ctx, audience, style, tone }) => {
    const rubricLines = String(criteria||'').split(/\n+/).map(s=>s.trim()).filter(Boolean);
    const rubric = rubricLines.length
      ? 'Evaluation criteria:\n' + rubricLines.map((c,i)=>`${i+1}. ${c}`).join('\n')
      : [
          'Default scoring rubric (1–5 each):',
          '1) Plausibility — internally coherent and realistic.',
          '2) Evidence — verifiable facts; cite when needed.',
          '3) Constraint fit — matches time, tools, and tone.',
          '4) Risk profile — failure modes, ambiguity, hidden costs.',
          '5) Inclusivity — avoid Western-centric defaults; note lenses.',
          '6) Simplicity — minimum moving parts.',
          '7) Novelty — useful creativity without hand-waving.'
        ].join('\n');

    const facetsBlock = String(facets||'').split(/\n+/).map(s=>s.trim()).filter(Boolean);
    const risksBlock = String(risks||'').split(/\n+/).map(s=>s.trim()).filter(Boolean);

    return [
      'You are in Tree-of-Thought mode.',
      ctx && `Context: ${ctx}`,
      audience && `Audience: ${audience}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      goal && `Goal: ${goal}`,
      constraints && `Constraints: ${constraints}`,
      success && `Success criteria: ${success}`,
      facetsBlock.length && ('Focus areas:\n' + facetsBlock.map((f,i)=>`${i+1}. ${f}`).join('\n')),
      risksBlock.length && ('Known risks & assumptions:\n' + risksBlock.map((r,i)=>`${i+1}. ${r}`).join('\n')),
      rubric,
      'Procedure:',
      '1) Build a branching decomposition as a numbered tree (depth 2–3). Where a node is ambiguous, show 2–3 alternative sub-steps with brief pros/cons.',
      '2) Propose 3 branch strategies at the top level:',
      '   • Branch A: fast/minimal deliverable',
      '   • Branch B: thorough/future-proof deliverable',
      '   • Branch C: creative or non-obvious approach',
      '   For each, list assumptions, 3–5 major steps, key dependencies, and risks.',
      '3) Score the 3 branches on the rubric (1–5) with one-line justifications and a short cost/benefit.',
      '4) Select the critical path (minimal viable plan) and label it in the tree. Include dependencies and 2–4 checkpoints.',
      '5) Next actions: a checklist of 5–8 smallest steps to start in the next 1–2 days.',
      '6) Reflect pass: check math (digit-by-digit if any), clarify terminology on first use, verify time-varying info against a source of truth, call out potential bias/assumptions, and list any trade-offs in 3 bullets.',
      'Output format:',
      '1) Numbered tree (1, 1.1, 1.1.1) with alternatives annotated',
      '2) Branch A/B/C summaries',
      '3) Scores table',
      '4) Selected critical path with dependencies + checkpoints',
      '5) Next-actions checklist',
      '6) Reflect pass notes'
    ].filter(Boolean).join('\n');
  }
},

{
  id:'triangulation',
  slug:'triangulation-methods',
  label:'Triangulation Methods',
  kind:'pattern',
  categories:['research','ethics','bias'],
  tags:[
    'type:pattern','topic:triangulation','topic:validation','level:intermediate',
    'use:ux-research','use:analytics','use:mixed-methods'
  ],
  use_cases:[
    'reduce single-method bias by cross-checking findings',
    'document alignment/divergence across methods',
    'decide where to deepen research'
  ],
  definition:'Use multiple methods/sources to converge on more reliable findings and reduce researcher bias.',
  help:'Capture A/B (and optional C) methods + findings; then cross-check alignment and note dominance risks.',
  boosters:[
    'Label each method with its sampling limits.',
    'End with a “What we’ll do next” line for resolving divergences.'
  ],
  fields:[
    { key:'question',  label:'Question being investigated', type:'textarea', ph:'Research focus / decision at stake.' },
    { key:'method_a',  label:'Method A', type:'text', ph:'Survey / Interview / Analytics…' },
    { key:'findings_a',label:'Findings from A', type:'textarea', ph:'Bullets; one per line.' },
    { key:'method_b',  label:'Method B', type:'text', ph:'Different lens' },
    { key:'findings_b',label:'Findings from B', type:'textarea', ph:'Bullets; one per line.' },
    { key:'method_c',  label:'Method C (optional)', type:'text', ph:'Third lens' },
    { key:'findings_c',label:'Findings from C (optional)', type:'textarea', ph:'Bullets; one per line.' },
    { key:'cross',     label:'Cross-check — where do findings align/diverge?', type:'textarea', ph:'Note convergences and tensions.' },
    { key:'bias_risk', label:'Bias risk — which perspective dominates?', type:'textarea', ph:'Recruitment, sampling, analyst bias…' }
  ],
  template: ({ question, method_a, findings_a, method_b, findings_b, method_c, findings_c, cross, bias_risk, ctx, audience, style, tone }) => [
    'Run a triangulation summary to reduce single-method bias.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    question && ('Question:\n' + question),
    (method_a || findings_a) && [
      `Method A: ${method_a||''}`,
      findings_a && ('Findings A:\n' + String(findings_a).split(/\n+/).map(s=>s.trim()).filter(Boolean).map((x,i)=>`- ${x}`).join('\n'))
    ].filter(Boolean).join('\n'),
    (method_b || findings_b) && [
      `Method B: ${method_b||''}`,
      findings_b && ('Findings B:\n' + String(findings_b).split(/\n+/).map(s=>s.trim()).filter(Boolean).map((x,i)=>`- ${x}`).join('\n'))
    ].filter(Boolean).join('\n'),
    (method_c || findings_c) && [
      `Method C: ${method_c||''}`,
      findings_c && ('Findings C:\n' + String(findings_c).split(/\n+/).map(s=>s.trim()).filter(Boolean).map((x,i)=>`- ${x}`).join('\n'))
    ].filter(Boolean).join('\n'),
    cross && ('Cross-check:\n' + cross),
    bias_risk && ('Bias risk:\n' + bias_risk),
    'Output:\n1) Convergences\n2) Divergences\n3) Dominance risks\n4) Next research step'
  ].filter(Boolean).join('\n')
},

{
  id:'triz',
  slug:'triz-inventive-problem-solving',
  label:'TRIZ (Theory of Inventive Problem Solving)',
  kind:'pattern',
  categories:['innovation','engineering','reasoning'],
  tags:[
    'type:pattern','topic:contradictions','topic:ideality','phase:invent','level:intermediate',
    'use:product-ideas','use:process-innovation','use:technical-problems'
  ],
  use_cases:[
    'resolve contradictions without trade-offs',
    'generate inventive principles to explore',
    'aim toward an Ideal Final Result (IFR)'
  ],
  definition:'A method that analyzes contradictions and patterns of invention to propose principle-driven solutions toward an ideal outcome.',
  help:'State the problem, list contradictions and available resources, and describe the Ideal Final Result (IFR).',
  boosters:[
    'Map each contradiction to candidate inventive principles.',
    'Offer at least 3 distinct concepts referencing principles.',
    'Briefly test each concept against constraints/resources.'
  ],
  fields:[
    { key:'problem',        label:'Problem statement', type:'textarea',
      desc:'What needs an inventive solution?',
      ph:'We need high throughput without increasing cost…' },
    { key:'contradictions', label:'Contradictions (one per line)', type:'textarea',
      desc:'Conflicts like speed vs quality.',
      ph:'Increase speed vs maintain accuracy…\nReduce cost vs keep reliability…' },
    { key:'resources',      label:'Available resources (one per line)', type:'textarea',
      desc:'Internal/external resources, fields, effects.',
      ph:'Idle CPU cycles…\nUser-generated data…\nCapacitors…' },
    { key:'ifr',            label:'Ideal Final Result (IFR)', type:'textarea',
      desc:'Describe the near-perfect outcome.',
      ph:'Zero defects at current cost and time…' },
    { key:'dos',            label:"Do's (must do)", type:'textarea',
      desc:'Positive guardrails.',
      ph:'Reference named principles; give 3+ concepts.' },
    { key:'donts',          label:"Don\'ts / constraints", type:'textarea',
      desc:'Limits to respect.',
      ph:'Avoid vague “be more efficient”.' }
  ],
  template: ({ problem, contradictions, resources, ifr, dos, donts, ctx, audience, style, tone }) => [
    'Apply TRIZ: analyze contradictions, aim for the Ideal Final Result, propose principle-based concepts.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    problem && `Problem: ${problem}`,
    contradictions && (
      'Contradictions:\n' + String(contradictions)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((c,i)=> `${i+1}. ${c}`).join('\n')
    ),
    resources && (
      'Resources:\n' + String(resources)
        .split(/\n+/).map(s=>s.trim()).filter(Boolean)
        .map((r,i)=> `${i+1}. ${r}`).join('\n')
    ),
    ifr && `Ideal Final Result (IFR): ${ifr}`,
    dos && `Do:\n${dos}`,
    donts && `Don\'t:\n${donts}`,
    'Output:\n1) Map contradictions → candidate inventive principles\n2) 3–5 concepts referencing principles\n3) Quick feasibility/impact check'
  ].filter(Boolean).join('\n')
},

{
  id:'two_min_rule',
  slug:'two-minute-rule',
  label:'2-Minute Rule (David Allen)',
  kind:'pattern',
  categories:['productivity','behavior'],
  tags:['type:pattern','topic:two-minute','use:starter','level:beginner'],
  use_cases:[
    'reduce friction by doing a tiny version now',
    'convert avoidance into a first motion'
  ],
  definition:'If it takes ≤2 minutes, do it now. Otherwise, define a 2-minute starter.',
  help:'Name the task; answer Yes/No; either do it now or write a 2-minute starter step.',
  boosters:[
    'If “No,” schedule the starter step on your calendar.',
    'Write the starter so it’s purely mechanical.'
  ],
  fields:[
    { key:'task',           label:'Task — what am I avoiding?', type:'textarea' },
    { key:'two_min_possible',label:'Can I do a 2-minute version? (Yes/No)', type:'text', ph:'Yes / No' },
    { key:'starter',        label:'If No → 2-minute starter step', type:'textarea', ph:'Open doc and write title; create folder…' }
  ],
  template: ({ task, two_min_possible, starter, ctx, audience, style, tone }) => [
    'Apply the 2-Minute Rule to force a start.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    task && ('Task:\n' + task),
    typeof two_min_possible==='string' && two_min_possible && `Can do ≤2 min now? ${two_min_possible}`,
    (two_min_possible||'').toLowerCase().startsWith('y') ? 'Action: Do it now.' : (starter && ('Starter step:\n' + starter)),
    'Output:\n1) Task\n2) Immediate action or starter\n3) Timebox (≤2 min) + tiny reward'
  ].filter(Boolean).join('\n')
},

{
  id:'vars_delims',
  slug:'variables-and-delimiters',
  label:'Variables & Delimiters — Define once, reuse cleanly',
  kind:'framework',
  categories:['prompt development techniques','structuring'],
  tags:[
    'type:framework','topic:prompting','phase:compose','level:beginner',
    'use:variables','use:delimiters','use:glossary','use:spec'
  ],
  use_cases:[
    'long prompts with reusable terms','glossaries & specs','persona/role libraries','data field definitions'
  ],
  definition:'Declare variables once (names + definitions aligned by line). We auto-fence a VARIABLES block so the model resolves {NAME} unambiguously.',
  help:'In “Variables”, list names one per line (e.g., USER_ROLE). In “Definitions”, list matching definitions one per line (e.g., Senior data analyst…). Lines are zipped by index. Reference variables later as {USER_ROLE}.',
  fields:[
    { key:'variables',   label:'Variables (one per line)',      type:'textarea',
      desc:'Each line is a variable NAME. Uppercase is recommended (e.g., USER_ROLE).',
      ph:'USER_ROLE\nDATASET\nSUCCESS_CRITERIA' },

    { key:'definitions', label:'Definitions (one per line)',    type:'textarea',
      desc:'Each line defines the variable at the same line-number.',
      ph:'Senior data analyst reporting to the VP of Growth\nCSV with columns date, clicks, cost, conversions\nClear, testable outcomes within 30 days' },

    { key:'task',        label:'Primary task',                  type:'textarea',
      desc:'What you want done using the variables.',
      ph:'Write a 150–200 word onboarding email that references {USER_ROLE} and {SUCCESS_CRITERIA} and uses data from {DATASET}.' },

    { key:'constraints', label:'Constraints (optional)',        type:'textarea',
      desc:'Rules, limits, must-haves.',
      ph:'Plain language; cite {DATASET} column names exactly; avoid jargon.' },

    { key:'format',      label:'Response format (optional)',    type:'textarea',
      desc:'Headings/structure for output.',
      ph:'Markdown: Summary, Steps, Checklist' }
  ],
  boosters:[
    'Treat each {NAME} as canonical. If any mapping is missing, ask one concise clarifying question, then proceed.',
    'Keep variables verbatim (case-sensitive) when referencing, e.g., {USER_ROLE}.'
  ],
  template:({variables,definitions,task,constraints,format,ctx})=>{
    const toLines = s => (s||'').split('\n').map(x=>x.trim()).filter(x=>x.length>0);
    const names = toLines(variables);
    const defs  = toLines(definitions);

    const max = Math.max(names.length, defs.length);
    const pairs = [];
    for (let i=0;i<max;i++){
      const name = (names[i]||'').trim();
      const def  = (defs[i] || '(define)').trim();
      // skip fully empty lines
      if (!name && !def) continue;
      // provide a fallback name if definition appears without a name
      pairs.push([ name || `VAR_${i+1}`, def ]);
    }

    const mapped = pairs.map(([n,d])=>`${n} = ${d}`).join('\n');

    const issues = [];
    if (names.length !== defs.length){
      issues.push(`Note: ${names.length} variable(s) and ${defs.length} definition(s).`);
    }
    const bad = names.filter(n => n && !/^[A-Z][A-Z0-9_]*$/.test(n));
    if (bad.length){
      issues.push(`Suggestion: Normalize to UPPER_SNAKE_CASE → ${bad.join(', ')}`);
    }

    return [
      'Use the following variable definitions. Treat them as canonical.',
      '```VARIABLES',
      mapped,
      '```',
      ctx && `Context: ${ctx}`,
      task && `Task: ${task}`,
      constraints && `Constraints: ${constraints}`,
      issues.length ? `Validator: ${issues.join(' ')}` : null,
      'Rules: Always resolve placeholders like {NAME} from the VARIABLES block above. If any value is "(define)", ask one concise question, then proceed.',
      format && `Format: ${format}`
    ].filter(Boolean).join('\n');
  }
},

{
  id:'weighted_mini_matrix',
  slug:'weighted-mini-matrix',
  label:'Weighted Mini-Matrix (quick score)',
  kind:'pattern',
  categories:['decision','prioritization'],
  tags:['type:pattern','topic:matrix','use:prioritize','level:intermediate'],
  use_cases:[
    'compare up to 3 options against 2–3 criteria',
    'force a transparent, quick pick'
  ],
  definition:'Tiny decision matrix: options × criteria with 1–5 ratings; totals pick the frontrunner.',
  help:'Enter options (one per line) and criteria (one per line). In “Quick ratings,” add one line per option like “Option Name: 4, 3, 5” matching criteria order.',
  boosters:[
    'If a criterion matters more, duplicate it (acts as a simple weight).',
    'Break ties with a 5-minute spike test you’ll define at the end.'
  ],
  fields:[
    { key:'options',   label:'Options (≤3, one per line)', type:'textarea', ph:'Option A\nOption B\nOption C' },
    { key:'criteria',  label:'Criteria (2–3, one per line)', type:'textarea', ph:'Impact\nEffort\nRisk' },
    { key:'ratings',   label:'Quick ratings (1–5) — one line per option', type:'textarea', ph:'Option A: 5,2,4\nOption B: 4,3,5' }
  ],
  template: ({ options, criteria, ratings, ctx, audience, style, tone }) => {
    const opts = String(options||'').split(/\n+/).map(s=>s.trim()).filter(Boolean).slice(0,3);
    const crit = String(criteria||'').split(/\n+/).map(s=>s.trim()).filter(Boolean).slice(0,3);
    const rateLines = String(ratings||'').split(/\n+/).map(s=>s.trim()).filter(Boolean);
    const scoreMap = {};
    rateLines.forEach(line=>{
      const parts = line.split(':');
      const name = (parts[0]||'').trim();
      const nums = (parts[1]||'').split(/[, \t]+/).map(n=>parseFloat(n)).filter(n=>!isNaN(n)).slice(0,crit.length);
      if(name) scoreMap[name]=nums;
    });
    const totals = opts.map(name=>{
      const arr = (scoreMap[name]||[]);
      const total = arr.reduce((a,b)=>a+b,0);
      return { name, arr, total };
    });
    const best = totals.reduce((a,b)=> (b.total>(a?.total??-Infinity)?b:a), null);

    const header = [
      'Run a quick weighted mini-matrix.',
      ctx && `Context: ${ctx}`,
      audience && `Audience: ${audience}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      opts.length && ('Options:\n' + opts.map((o,i)=>`${i+1}. ${o}`).join('\n')),
      crit.length && ('Criteria (order = rating order):\n' + crit.map((c,i)=>`${i+1}. ${c}`).join('\n'))
    ].filter(Boolean).join('\n');

    const table = totals.length ? [
      'Ratings & totals:',
      ...totals.map(t => {
        const cells = t.arr.map((n,i)=>`${crit[i]??`C${i+1}`}=${n}`).join(', ');
        return `- ${t.name}: ${cells} | Total=${t.total||0}`;
      })
    ].join('\n') : '';

    const pick = best ? `Highest score → Next action: ${best.name}` : 'Highest score → Next action: (insufficient ratings)';

    return [header, table, pick, 'Output:\n1) Matrix summary\n2) Pick + one 5-min spike to validate'].filter(Boolean).join('\n');
  }
},

{
  id:'woop',
  slug:'woop-wish-outcome-obstacle-plan',
  label:'WOOP (Wish–Outcome–Obstacle–Plan)',
  kind:'pattern',
  categories:['behavior','motivation'],
  tags:['type:pattern','topic:woop','use:motivation','level:beginner'],
  use_cases:[
    'contrast desired outcome with the main obstacle',
    'bind an if–then plan to the obstacle'
  ],
  definition:'Wish → Outcome → Obstacle → Plan (if obstacle, then I will X).',
  help:'Write a short, specific wish; name the tangible best outcome; identify the likely obstacle; define the if–then plan.',
  boosters:[
    'Phrase the wish so it’s completable in ≤2 weeks.',
    'Make the obstacle internal (habit/thought) when possible.'
  ],
  fields:[
    { key:'wish',     label:'Wish — what do I want to complete?', type:'textarea' },
    { key:'outcome',  label:'Outcome — benefit if I succeed?', type:'textarea' },
    { key:'obstacle', label:'Obstacle — what usually gets in the way?', type:'textarea' },
    { key:'plan',     label:'Plan — if obstacle, then I will…', type:'textarea' }
  ],
  template: ({ wish, outcome, obstacle, plan, ctx, audience, style, tone }) => [
    'Use WOOP to turn motivation into a plan.',
    ctx && `Context: ${ctx}`,
    audience && `Audience: ${audience}`,
    style && `Style: ${style}`,
    tone && `Tone: ${tone}`,
    wish && ('Wish:\n' + wish),
    outcome && ('Outcome:\n' + outcome),
    obstacle && ('Obstacle:\n' + obstacle),
    plan && ('Plan (if obstacle, then I will…):\n' + plan),
    'Output:\n1) Wish\n2) Outcome\n3) Obstacle\n4) If–then plan\n5) First checkpoint'
  ].filter(Boolean).join('\n')
},

{
    id: 'fukatsu',
    slug: 'fukatsu-resurrection-prompt',
    label: 'Fukatsu Method · Instruction · Constraints · Input · Output',
    kind: 'framework',
    categories: ['prompt-engineering', 'structure'],
    tags: [
      'type:framework','origin:japan','topic:prompt-formatting','level:intermediate',
      'use:clear-spec','use:reduce-ambiguity','use:one-shot'
    ],
    use_cases: [
      'craft highly explicit prompts with clear sections',
      'reduce back-and-forth by frontloading constraints',
      'standardize team prompts for reproducibility'
    ],
    boosters: [
      'Keep sections explicitly labeled and ordered: Instruction, Constraints, Input, Output.',
      'Make Constraints concrete: tone, length, audience, citation rules, forbidden content.',
      'Define Output as a shape (headings, bullets, JSON schema) to guide formatting.'
    ],
    definition: 'A Japanese prompting format that separates the ask into four explicit sections (Instruction, Constraints, Input, Output) to minimize ambiguity and drive consistent results.',
    help: 'Fill in each section crisply. Treat Output like a contract for structure and scope.',
    fields: [
      { key: 'instruction', label: 'Instruction / Command', type: 'textarea', desc: 'What should the AI do or be?', ph: 'e.g., You are a technical editor. Improve clarity without changing meaning.' },
      { key: 'constraints', label: 'Constraints', type: 'textarea', desc: 'Rules, tone, length, style, do/don’t.', ph: 'e.g., 300 words max; friendly but precise; no marketing claims.' },
      { key: 'input', label: 'Input', type: 'textarea', desc: 'Source material or data.', ph: 'Paste text, bullets, transcript excerpt, etc.' },
      { key: 'output', label: 'Output Format', type: 'textarea', desc: 'Exact structure required.', ph: 'e.g., 1) Summary (3 bullets) 2) Edits (diff-style) 3) Next steps (2 items)' }
    ],
    template: ({ instruction, constraints, input, output, ctx, audience, style, tone }) => [
      'Follow this structured prompt.',
      ctx && `Context: ${ctx}`,
      audience && `Audience: ${audience}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      instruction && ('Instruction:\n' + instruction),
      constraints && ('Constraints:\n' + constraints),
      input && ('Input:\n' + input),
      output && ('Output:\n' + output)
    ].filter(Boolean).join('\n')
  },
  {
    id: 'hansei',
    slug: 'hansei-structured-reflection',
    label: 'Hansei · Structured Reflection and Continuous Learning',
    kind: 'framework',
    categories: ['learning', 'retrospective'],
    tags: [
      'type:framework','origin:japan','topic:continuous-improvement','level:beginner',
      'use:retro','use:postmortem','use:skill-building'
    ],
    use_cases: [
      'run a quick retrospective after tasks or releases',
      'identify concrete learning commitments',
      'build a culture of humble, ongoing improvement'
    ],
    boosters: [
      'Balance what went well with what can improve; avoid blame.',
      'Convert each insight into a specific next-step or experiment with an owner.',
      'Schedule a follow-up to check whether changes took root.'
    ],
    definition: 'A Japanese practice of candid self-reflection that turns missteps and successes into concrete learning and next actions.',
    help: 'Capture a situation, what worked, what did not, and the next experiments to try.',
    fields: [
      { key: 'situation', label: 'Situation', type: 'textarea', desc: 'What event or work are you reflecting on?', ph: 'e.g., Sprint 14 release' },
      { key: 'worked', label: 'What worked', type: 'textarea', desc: 'Strengths and wins.', ph: 'e.g., Early stakeholder demos reduced surprises.' },
      { key: 'improve', label: 'What to improve', type: 'textarea', desc: 'Gaps, mistakes, risks.', ph: 'e.g., Late QA handoff created bottlenecks.' },
      { key: 'experiments', label: 'Experiments / Next steps', type: 'textarea', desc: 'Concrete changes to try with owners and dates.', ph: 'e.g., Add QA pairing in week 1 (Owner: Sam, by 5/10).' }
    ],
    template: ({ situation, worked, improve, experiments, ctx, tone }) => [
      'Run a Hansei reflection.',
      ctx && `Context: ${ctx}`,
      tone && `Tone: ${tone}`,
      situation && ('Situation:\n' + situation),
      worked && ('What worked:\n' + worked),
      improve && ('What to improve:\n' + improve),
      experiments && ('Experiments / Next steps:\n' + experiments),
      'End with one sentence on how we will verify improvement.'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'ikigai',
    slug: 'ikigai-purpose-matrix',
    label: 'Ikigai · Love · Good at · World needs · Paid for',
    kind: 'framework',
    categories: ['self-strategy', 'career'],
    tags: [
      'type:framework','origin:japan','topic:purpose','level:beginner',
      'use:career-fit','use:project-alignment','use:value-mapping'
    ],
    use_cases: [
      'align projects with motivation and sustainability',
      'evaluate product ideas for meaning and viability',
      'craft personal development plans'
    ],
    boosters: [
      'Probe conflicts between quadrants and propose trade-offs.',
      'If one quadrant is weak, generate options to strengthen it.',
      'Offer a short narrative that ties all four quadrants together.'
    ],
    definition: 'A Japanese lens for purpose that considers what you love, what you are good at, what the world needs, and what can be paid for.',
    help: 'Fill each quadrant honestly; then connect them into one or two coherent directions.',
    fields: [
      { key: 'love', label: 'What you love', type: 'textarea', desc: 'Energizing activities or topics.', ph: 'e.g., Teaching, writing, data storytelling' },
      { key: 'good_at', label: 'What you are good at', type: 'textarea', desc: 'Strengths and skills.', ph: 'e.g., Interviewing, synthesis, prototyping' },
      { key: 'world_needs', label: 'What the world needs', type: 'textarea', desc: 'Problems worth solving.', ph: 'e.g., Ethical AI literacy for non-technical teams' },
      { key: 'paid_for', label: 'What you can be paid for', type: 'textarea', desc: 'Market demand and roles.', ph: 'e.g., UX research lead, AI educator' }
    ],
    template: ({ love, good_at, world_needs, paid_for, ctx, audience }) => [
      'Construct an Ikigai alignment.',
      ctx && `Context: ${ctx}`,
      audience && `Audience: ${audience}`,
      love && ('Love:\n' + love),
      good_at && ('Good at:\n' + good_at),
      world_needs && ('World needs:\n' + world_needs),
      paid_for && ('Paid for:\n' + paid_for),
      'Output:\n1) Overlaps (2–3)\n2) Two concrete directions (with first steps)\n3) Risks and how to test quickly'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'jugaad',
    slug: 'jugaad-frugal-innovation',
    label: 'Jugaad · Frugal, Flexible, Resourceful Innovation',
    kind: 'framework',
    categories: ['innovation', 'creativity'],
    tags: [
      'type:framework','origin:india','topic:constraint-driven','level:intermediate',
      'use:prototype-fast','use:workarounds','use:lean-solution'
    ],
    use_cases: [
      'find creative workarounds under tight constraints',
      'prototype “good enough” solutions rapidly',
      'adapt processes for low-resource environments'
    ],
    boosters: [
      'Start with constraint listing; treat each as a creative springboard.',
      'Prefer local, readily available resources first.',
      'Plan a quick test loop to validate usefulness before refinement.'
    ],
    definition: 'An Indian practice of improvisational problem-solving that embraces constraints to produce simple, effective, low-cost solutions.',
    help: 'Declare your objective, list constraints and available resources, then outline a scrappy path to value.',
    fields: [
      { key: 'objective', label: 'Objective', type: 'text', desc: 'Outcome you need to achieve.', ph: 'e.g., Collect field feedback without paid tools' },
      { key: 'constraints', label: 'Constraints', type: 'textarea', desc: 'Limits that shape the approach.', ph: 'e.g., No budget; offline; 1 week; non-technical users' },
      { key: 'resources', label: 'Available resources', type: 'textarea', desc: 'What you already have.', ph: 'e.g., WhatsApp, paper forms, one laptop' },
      { key: 'quick_test', label: 'Quick test', type: 'textarea', desc: 'How to validate fast.', ph: 'e.g., Pilot with 10 users in 48 hours' }
    ],
    template: ({ objective, constraints, resources, quick_test, ctx, tone }) => [
      'Apply a Jugaad plan.',
      ctx && `Context: ${ctx}`,
      tone && `Tone: ${tone}`,
      objective && `Objective: ${objective}`,
      constraints && ('Constraints:\n' + constraints),
      resources && ('Available resources:\n' + resources),
      quick_test && ('Quick test:\n' + quick_test),
      'Return:\n1) Scrappy plan (3–5 steps)\n2) Risk points & mitigations\n3) Upgrade path if the pilot succeeds'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'kishotenketsu',
    slug: 'kishotenketsu-four-act',
    label: 'Kishōtenketsu · Introduction · Development · Twist · Conclusion',
    kind: 'framework',
    categories: ['storytelling', 'structure'],
    tags: [
      'type:framework','origin:east-asia','topic:narrative','level:intermediate',
      'use:story-design','use:lesson-flow','use:surprise-without-conflict'
    ],
    use_cases: [
      'outline stories or lessons that pivot via contrast rather than conflict',
      'design explainer flows with a revealing twist',
      'prototype non-confrontational narratives'
    ],
    boosters: [
      'Make the Twist a perspective shift or unexpected connection, not a forced conflict.',
      'Ensure the Conclusion integrates the twist and recontextualizes the setup.',
      'Try alternates: visual twist, data twist, role twist.'
    ],
    definition: 'A four-part East Asian narrative structure that builds context, elaborates, introduces a twist, and then resolves without centering conflict.',
    help: 'Describe the topic, audience, and a twist seed. The model will outline all four acts.',
    fields: [
      { key: 'topic', label: 'Topic / Theme', type: 'text', desc: 'What is this about?', ph: 'e.g., Why bees matter' },
      { key: 'audience', label: 'Audience', type: 'text', desc: 'For whom is this story or lesson?', ph: 'e.g., Middle school science class' },
      { key: 'twist', label: 'Twist seed', type: 'textarea', desc: 'The contrast or reframe to reveal.', ph: 'e.g., Bees are livestock with passports in some countries' }
    ],
    template: ({ topic, audience, twist, ctx, style, tone }) => [
      'Use Kishōtenketsu to design a 4-act outline.',
      ctx && `Context: ${ctx}`,
      style && `Style: ${style}`,
      tone && `Tone: ${tone}`,
      topic && `Topic: ${topic}`,
      audience && `Audience: ${audience}`,
      twist && `Twist seed: ${twist}`,
      'Output:\n1) Introduction (set the ordinary)\n2) Development (deepen context)\n3) Twist (reveal contrast)\n4) Conclusion (integrate the twist)'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'lotus_blossom',
    slug: 'lotus-blossom-ideation',
    label: 'Lotus Blossom · 8-way Idea Expansion',
    kind: 'pattern',
    categories: ['creativity', 'ideation'],
    tags: [
      'type:pattern','origin:japan','topic:divergent-thinking','level:beginner',
      'use:brainstorm','use:subtopic-expansion','use:systematize-ideas'
    ],
    use_cases: [
      'systematically generate sub-ideas from a central theme',
      'expand a problem space to uncover hidden angles',
      'seed content pillars and sub-pillars'
    ],
    boosters: [
      'Force-fill all 8 petals to avoid early fixation.',
      'Turn each petal into a new center and repeat once for depth.',
      'Name clusters to reveal emergent themes.'
    ],
    definition: 'A Japanese ideation grid that places a core theme in the center, then expands to eight petals, each of which can blossom into further eight ideas.',
    help: 'Provide a central theme and optional seed petals. The model returns an 8× expansion with labels.',
    fields: [
      { key: 'theme', label: 'Central theme', type: 'text', desc: 'The core idea to blossom.', ph: 'e.g., Community onboarding' },
      { key: 'seed_petals', label: 'Seed petals (optional, 1 per line)', type: 'textarea', desc: 'Initial sub-ideas if you have them.', ph: 'e.g., Welcome ritual\nMentor matching\nMicro-tasks' }
    ],
    template: ({ theme, seed_petals, ctx }) => [
      `Run Lotus Blossom on${theme ? ` ${theme}` : ''}.`,
      ctx && `Context: ${ctx}`,
      seed_petals && ('Seed petals:\n' + seed_petals),
      'Output:\n- Petals (8 labeled sub-ideas)\n- For each petal: 8 expansions\n- 3 clusters with short labels'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'medicine_wheel',
    slug: 'medicine-wheel-holistic',
    label: 'Medicine Wheel · Physical · Mental · Emotional · Spiritual',
    kind: 'framework',
    categories: ['holistic-thinking', 'wellbeing'],
    tags: [
      'type:framework','origin:indigenous-north-america','topic:balance','level:beginner',
      'use:holistic-analysis','use:care-plans','use:ethical-check'
    ],
    use_cases: [
      'analyze a decision or plan through four human dimensions',
      'design interventions that balance practical and relational needs',
      'audit proposals for value alignment and community impact'
    ],
    boosters: [
      'Give at least one concrete observation per quadrant.',
      'Highlight imbalances and propose rebalancing steps.',
      'Name trade-offs explicitly where quadrants conflict.'
    ],
    definition: 'An Indigenous North American framework that examines situations through physical, mental, emotional, and spiritual lenses to seek balance.',
    help: 'State the problem and any existing considerations. The model will respond across the four quadrants.',
    fields: [
      { key: 'problem', label: 'Problem / Decision', type: 'textarea', desc: 'The situation to examine.', ph: 'e.g., Rolling out a new community policy' },
      { key: 'notes', label: 'Known considerations (optional)', type: 'textarea', desc: 'Any context you already have.', ph: 'e.g., Budget constraints; volunteer burnout' }
    ],
    template: ({ problem, notes, ctx }) => [
      'Apply the Medicine Wheel.',
      ctx && `Context: ${ctx}`,
      problem && `Problem: ${problem}`,
      notes && ('Notes:\n' + notes),
      'Output:\n- Physical (resources, logistics)\n- Mental (knowledge, clarity)\n- Emotional (relationships, feelings)\n- Spiritual/Values (ethics, meaning)\n- Imbalances and rebalancing steps'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'nemawashi',
    slug: 'nemawashi-consensus-building',
    label: 'Nemawashi · Quiet Pre-alignment for Consensus',
    kind: 'framework',
    categories: ['decision-making', 'stakeholders'],
    tags: [
      'type:framework','origin:japan','topic:consensus','level:intermediate',
      'use:change-management','use:proposal-socialization','use:political-risk-reduction'
    ],
    use_cases: [
      'socialize proposals in advance to reduce late-stage pushback',
      'identify concerns privately and adapt proposals before formal review',
      'accelerate official approvals by doing groundwork'
    ],
    boosters: [
      'Map stakeholders by influence and interest; plan 1:1s in logical order.',
      'Carry a one-page brief; ask for objections and co-author mitigations.',
      'Document pre-commitments and summarize shared edits before the meeting.'
    ],
    definition: 'A Japanese practice of building consensus informally by consulting stakeholders individually before formal decisions.',
    help: 'List the decision, stakeholders, and early risks. The model drafts a pre-alignment plan.',
    fields: [
      { key: 'decision', label: 'Decision / Proposal', type: 'textarea', desc: 'What you seek to approve.', ph: 'e.g., Switch analytics vendor this quarter' },
      { key: 'stakeholders', label: 'Stakeholders (one per line)', type: 'textarea', desc: 'People or groups to consult.', ph: 'e.g., Eng lead\nFinance partner\nSupport manager' },
      { key: 'risks', label: 'Known risks/concerns', type: 'textarea', desc: 'Anticipated objections.', ph: 'e.g., Cost, migration effort, data retention' }
    ],
    template: ({ decision, stakeholders, risks, ctx }) => [
      'Create a Nemawashi plan.',
      ctx && `Context: ${ctx}`,
      decision && ('Decision:\n' + decision),
      stakeholders && ('Stakeholders:\n' + stakeholders),
      risks && ('Known risks:\n' + risks),
      'Output:\n1) 1:1 sequence and objectives\n2) Objection log with mitigations\n3) Pre-commit summary for formal review'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'palaver',
    slug: 'palaver-talking-circle',
    label: 'Palaver Tree · Inclusive Talking Circle',
    kind: 'structure',
    categories: ['facilitation', 'conflict-resolution'],
    tags: [
      'type:structure','origin:africa','topic:consensus','level:beginner',
      'use:dialogue','use:community-decisions','use:roundtable'
    ],
    use_cases: [
      'facilitate inclusive dialogue with equal voice',
      'synthesize multi-perspective input into consensus',
      'resolve conflicts through patient discussion'
    ],
    boosters: [
      'Adopt turn-taking rules; timebox rounds, not people.',
      'Surface minority positions and ensure they are summarized accurately.',
      'Close with a consensus statement and action owners.'
    ],
    definition: 'An African community circle practice where issues are discussed openly until a shared understanding or consensus emerges.',
    help: 'Define the question and who is in the circle. The model proposes a round structure and synthesis method.',
    fields: [
      { key: 'question', label: 'Framing question', type: 'text', desc: 'What will the circle address?', ph: 'e.g., How should we prioritize next quarter’s projects?' },
      { key: 'participants', label: 'Participants (roles or names)', type: 'textarea', desc: 'Who gets a voice in the circle.', ph: 'e.g., Customer success, sales, eng, design, ops' },
      { key: 'protocol', label: 'Protocol notes (optional)', type: 'textarea', desc: 'Rules or rituals for speaking and listening.', ph: 'e.g., Talking stick; no interruptions; reflective listening' }
    ],
    template: ({ question, participants, protocol, ctx }) => [
      'Plan a Palaver-style talking circle.',
      ctx && `Context: ${ctx}`,
      question && `Question: ${question}`,
      participants && ('Participants:\n' + participants),
      protocol && ('Protocol:\n' + protocol),
      'Output:\n1) Round plan (opening to closing)\n2) Synthesis map of viewpoints\n3) Consensus statement and action list'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'sankofa',
    slug: 'sankofa-learn-from-past',
    label: 'Sankofa · Retrieve the Past to Guide the Future',
    kind: 'framework',
    categories: ['strategy', 'learning'],
    tags: [
      'type:framework','origin:ghana','topic:historical-insight','level:beginner',
      'use:pre-mortem','use:pattern-extraction','use:knowledge-transfer'
    ],
    use_cases: [
      'review precedents before launching a new initiative',
      'convert lessons learned into design constraints',
      'avoid repeat mistakes via explicit historical mapping'
    ],
    boosters: [
      'Pair each lesson with a design guardrail or decision rule.',
      'Balance caution with opportunity by listing positive precedents too.',
      'Close with 2 tests to verify we absorbed the lesson.'
    ],
    definition: 'An Akan concept that urges returning to the past to bring forward wisdom for present and future decisions.',
    help: 'Describe the future goal and any relevant history. The model will extract and apply lessons.',
    fields: [
      { key: 'goal', label: 'Future goal', type: 'text', desc: 'What you aim to achieve.', ph: 'e.g., Launch a community grants program' },
      { key: 'past_lessons', label: 'Past lessons (one per line)', type: 'textarea', desc: 'Experiences, case studies, or precedents.', ph: 'e.g., Low transparency eroded trust\nQuick feedback loops boosted adoption' }
    ],
    template: ({ goal, past_lessons, ctx }) => [
      'Apply Sankofa to guide the plan.',
      ctx && `Context: ${ctx}`,
      goal && `Goal: ${goal}`,
      past_lessons && ('Past lessons:\n' + past_lessons),
      'Output:\n1) Extracted principles\n2) Guardrails and decision rules\n3) Two validation checks in the first month'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'shoshin_koan',
    slug: 'shoshin-and-koan-inquiry',
    label: 'Shoshin + Koan · Beginner’s Mind and Paradox Inquiry',
    kind: 'pattern',
    categories: ['creativity', 'critical-thinking'],
    tags: [
      'type:pattern','origin:japan','topic:insight','level:advanced',
      'use:break-fixation','use:novel-angles','use:assumption-busting'
    ],
    use_cases: [
      'dislodge stale assumptions and reveal new frames',
      'generate creative prompts through paradox or metaphor',
      'teach a concept using simple, curiosity-first language'
    ],
    boosters: [
      'Rewrite the premise in child-friendly terms first.',
      'Pose one paradoxical question that cannot be answered by routine logic.',
      'End with a practical insight or small experiment inspired by the koan.'
    ],
    definition: 'A Zen approach that combines open beginner’s mind with a paradoxical prompt to interrupt habitual reasoning and surface fresh insight.',
    help: 'Provide the concept and any preconceptions to park. Optionally add a koan seed.',
    fields: [
      { key: 'concept', label: 'Concept', type: 'text', desc: 'Topic to explore.', ph: 'e.g., Productivity' },
      { key: 'preconceptions', label: 'Preconceptions (optional)', type: 'textarea', desc: 'Beliefs to set aside temporarily.', ph: 'e.g., Productivity means doing more tasks per hour' },
      { key: 'koan_seed', label: 'Koan seed (optional)', type: 'text', desc: 'A paradoxical question or image.', ph: 'e.g., What is the shape of a pause?' }
    ],
    template: ({ concept, preconceptions, koan_seed, ctx }) => [
      'Use Shoshin and a Koan to explore anew.',
      ctx && `Context: ${ctx}`,
      concept && `Concept: ${concept}`,
      preconceptions && ('Preconceptions to set aside:\n' + preconceptions),
      koan_seed && `Koan seed: ${koan_seed}`,
      'Output:\n1) ELI5 explanation\n2) Koan-style question\n3) Fresh insight and one small experiment'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'shu_ha_ri',
    slug: 'shu-ha-ri-mastery',
    label: 'Shu · Ha · Ri · Stages of Mastery',
    kind: 'framework',
    categories: ['learning', 'craft'],
    tags: [
      'type:framework','origin:japan','topic:skill-progression','level:beginner',
      'use:training-path','use:prompt-mastery','use:curriculum'
    ],
    use_cases: [
      'design a learning path from templates to innovation',
      'evaluate when to deviate from rules responsibly',
      'coach teams through levels of autonomy'
    ],
    boosters: [
      'Define “done” for each stage to prevent premature jumping.',
      'Document deviations at Ha and their rationale.',
      'At Ri, codify your style so others can learn from it.'
    ],
    definition: 'A Japanese model of learning: first follow the form (Shu), then adapt (Ha), then transcend and create your own approach (Ri).',
    help: 'Describe the skill and current stage. The model suggests focused practices and milestones.',
    fields: [
      { key: 'skill', label: 'Skill / Domain', type: 'text', desc: 'What are you mastering?', ph: 'e.g., Prompt engineering for chat models' },
      { key: 'stage', label: 'Current stage (Shu/Ha/Ri)', type: 'text', desc: 'Where are you now?', ph: 'e.g., Shu' },
      { key: 'shu_rules', label: 'Forms/rules (if Shu)', type: 'textarea', desc: 'Rules to follow exactly.', ph: 'e.g., Use role, task, constraints, examples' },
      { key: 'ha_variations', label: 'Variations (if Ha)', type: 'textarea', desc: 'Targeted experiments.', ph: 'e.g., Swap few-shot examples per audience' },
      { key: 'ri_signature', label: 'Signature (if Ri)', type: 'textarea', desc: 'Your style patterns.', ph: 'e.g., 3-pass critique loop + rubric' }
    ],
    template: ({ skill, stage, shu_rules, ha_variations, ri_signature, ctx }) => [
      'Plan by Shu–Ha–Ri.',
      ctx && `Context: ${ctx}`,
      skill && `Skill: ${skill}`,
      stage && `Stage: ${stage}`,
      shu_rules && ('Shu rules:\n' + shu_rules),
      ha_variations && ('Ha variations:\n' + ha_variations),
      ri_signature && ('Ri signature:\n' + ri_signature),
      'Output: milestones, exercises, and exit-criteria for the next stage.'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'shura',
    slug: 'shura-consultative-decision',
    label: 'Shura · Consultative Decision-Making',
    kind: 'framework',
    categories: ['governance', 'decision-making'],
    tags: [
      'type:framework','origin:islamic','topic:consultation','level:intermediate',
      'use:multi-stakeholder','use:consensus-seeking','use:deliberation'
    ],
    use_cases: [
      'structure multi-party decisions with inclusive input',
      'turn debate into constructive, principled dialogue',
      'document rationale for legitimacy and buy-in'
    ],
    boosters: [
      'Define decision criteria up front and share them.',
      'Invite dissenting views and capture them verbatim.',
      'End with a clear decision, owners, and a review date.'
    ],
    definition: 'An Islamic principle of inclusive consultation that gathers diverse perspectives to reach a legitimized decision.',
    help: 'State the decision and stakeholders. The model outputs a consultative plan and synthesis.',
    fields: [
      { key: 'decision', label: 'Decision to make', type: 'text', desc: 'The central choice.', ph: 'e.g., Choose a data retention policy' },
      { key: 'stakeholders', label: 'Stakeholders (one per line)', type: 'textarea', desc: 'Participants and impacted groups.', ph: 'e.g., Legal\nSecurity\nData science\nCustomer council' },
      { key: 'principles', label: 'Guiding principles', type: 'textarea', desc: 'Values or rules to honor.', ph: 'e.g., Privacy by default; proportionality; transparency' }
    ],
    template: ({ decision, stakeholders, principles, ctx }) => [
      'Run a Shura-style consultation.',
      ctx && `Context: ${ctx}`,
      decision && `Decision: ${decision}`,
      stakeholders && ('Stakeholders:\n' + stakeholders),
      principles && ('Principles:\n' + principles),
      'Output:\n1) Rounds of input (agenda)\n2) Synthesis with options and trade-offs\n3) Final decision, rationale, owners, review date'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'triz',
    slug: 'triz-inventive-problem-solving',
    label: 'TRIZ · Inventive Principles and Contradictions',
    kind: 'framework',
    categories: ['innovation', 'engineering'],
    tags: [
      'type:framework','origin:russia','topic:systematic-creativity','level:advanced',
      'use:resolve-conflicts','use:design-space','use:pattern-reuse'
    ],
    use_cases: [
      'resolve design contradictions systematically',
      'apply known inventive principles to new problems',
      'expand solution space beyond obvious variants'
    ],
    boosters: [
      'Phrase the core issue as a contradiction: improving X worsens Y.',
      'Try 3–5 different inventive principles before choosing.',
      'Translate each principle into 1–2 concrete solution sketches.'
    ],
    definition: 'A Russian-origin method that analyzes patterns of invention to resolve contradictions using reusable principles.',
    help: 'State the problem and the key contradiction. Optionally name principles to try.',
    fields: [
      { key: 'problem', label: 'Problem', type: 'textarea', desc: 'Core challenge to solve.', ph: 'e.g., Increase speed without reducing accuracy' },
      { key: 'contradiction', label: 'Contradiction', type: 'text', desc: 'X improves while Y worsens.', ph: 'e.g., Latency vs. model quality' },
      { key: 'principles', label: 'Principles to explore (optional)', type: 'textarea', desc: 'Inventive principles to test.', ph: 'e.g., Segmentation\nInversion\nUniversality' }
    ],
    template: ({ problem, contradiction, principles, ctx }) => [
      'Apply TRIZ to the problem.',
      ctx && `Context: ${ctx}`,
      problem && ('Problem:\n' + problem),
      contradiction && (`Contradiction: ${contradiction}`),
      principles && ('Principles to explore:\n' + principles),
      'Output:\n1) 3–5 candidate solutions (each mapped to a principle)\n2) Trade-offs and risks\n3) Pick one to prototype next'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'ubuntu',
    slug: 'ubuntu-collective-wisdom',
    label: 'Ubuntu · I Am Because We Are',
    kind: 'framework',
    categories: ['ethics', 'community'],
    tags: [
      'type:framework','origin:sub-saharan-africa','topic:interdependence','level:beginner',
      'use:ethical-lens','use:policy-design','use:stakeholder-empathy'
    ],
    use_cases: [
      'design solutions that enhance collective well-being',
      'evaluate impacts across communities and relationships',
      'resolve conflicts by restoring trust and connection'
    ],
    boosters: [
      'Map who benefits, who bears cost, and how reciprocity is maintained.',
      'Prefer options that strengthen relationships long term.',
      'Include a restoration plan if harms occurred.'
    ],
    definition: 'A Sub-Saharan philosophy centering human interdependence and communal flourishing as criteria for good action.',
    help: 'Describe the situation and affected groups. The model weighs options through an Ubuntu lens.',
    fields: [
      { key: 'situation', label: 'Situation', type: 'textarea', desc: 'What decision or design is under review?', ph: 'e.g., Moderation policy change' },
      { key: 'groups', label: 'Affected groups (one per line)', type: 'textarea', desc: 'Communities or stakeholders.', ph: 'e.g., Creators\nNew users\nModerators\nAdvertisers' },
      { key: 'harms', label: 'Potential harms or past harms', type: 'textarea', desc: 'Risks, inequities, trust issues.', ph: 'e.g., Disproportionate takedowns for certain dialects' }
    ],
    template: ({ situation, groups, harms, ctx }) => [
      'Evaluate with Ubuntu.',
      ctx && `Context: ${ctx}`,
      situation && ('Situation:\n' + situation),
      groups && ('Affected groups:\n' + groups),
      harms && ('Harms:\n' + harms),
      'Output:\n1) Options that maximize collective benefit\n2) Trade-offs and mitigations\n3) Restoration or reciprocity steps'
    ].filter(Boolean).join('\n')
  },
  {
    id: 'yin_yang',
    slug: 'yin-yang-complementarity',
    label: 'Yin · Yang · Dynamic Complementarity',
    kind: 'framework',
    categories: ['systems-thinking', 'paradox'],
    tags: [
      'type:framework','origin:china','topic:both-and','level:advanced',
      'use:balance-tradeoffs','use:paradox-design','use:context-shifts'
    ],
    use_cases: [
      'frame trade-offs as complementary rather than binary',
      'design strategies that harmonize opposing forces',
      'analyze how shifts in one pole affect the other'
    ],
    boosters: [
      'Name the two poles and the shared purpose that links them.',
      'List actions that strengthen one pole without starving the other.',
      'Identify rhythms or cycles where emphasis should shift over time.'
    ],
    definition: 'A Chinese lens for holding apparent opposites in a dynamic, interdependent balance to achieve harmony in changing contexts.',
    help: 'Define the polarity (two tensions) and the shared aim. The model proposes harmonizing moves.',
    fields: [
      { key: 'polarity_a', label: 'Pole A', type: 'text', desc: 'First side of the tension.', ph: 'e.g., Speed' },
      { key: 'polarity_b', label: 'Pole B', type: 'text', desc: 'Second side of the tension.', ph: 'e.g., Thoroughness' },
      { key: 'shared_aim', label: 'Shared aim', type: 'text', desc: 'Why both matter.', ph: 'e.g., Deliver quality quickly and reliably' }
    ],
    template: ({ polarity_a, polarity_b, shared_aim, ctx }) => [
      'Use Yin–Yang complementarity.',
      ctx && `Context: ${ctx}`,
      polarity_a && `Pole A: ${polarity_a}`,
      polarity_b && `Pole B: ${polarity_b}`,
      shared_aim && `Shared aim: ${shared_aim}`,
      'Output:\n1) Harmonic strategies (serve both poles)\n2) Cycle or cadence of emphasis\n3) Watchouts when one pole dominates'
    ].filter(Boolean).join('\n')
  }

];

const searchEl = document.getElementById('fwSearch');
const allBtn   = document.getElementById('fwAll');

const norm = s => (s||'').toLowerCase();
function tokenize(s){ return norm(s).split(/[^a-z0-9]+/).filter(Boolean); }

function matchScore(fw, query){
  const q = (query||'').trim();
  if(!q) return 0;

  const qTokens = tokenize(q);
  if(!qTokens.length) return 0;

  const hayPieces = [
    fw.label, fw.slug, fw.definition, fw.help,
    ...(fw.categories||[]), ...(fw.tags||[]),
    ...(fw.use_cases||[]), ...(fw.boosters||[]),
    ...((fw.fields||[]).flatMap(f=>[f.label, f.desc, f.ph]))
  ].filter(Boolean);

  const hay = hayPieces.join(' ').toLowerCase();
  const hayTokens = tokenize(hay);

  let score = 0;
  qTokens.forEach(t=>{
    // strong boost for label prefix match
    if (norm(fw.label).startsWith(t)) score += 8;
    // general token presence in tags/use_cases/desc/etc.
    if (hayTokens.includes(t)) score += 3;
  });
  return score;
}


// UI bootstrap
const sel = $('#frameworkSel');
// --- Multi-tab state (with migration from single state) ---
let state = window.state || {};
state.common = state.common || {};


// --- URL param: pick framework by ?slug=... (supports slug or id, case-insensitive)
(() => {
  const params = new URLSearchParams(window.location.search);
  const q = (params.get('slug') || '').trim().toLowerCase();
  if (!q) return;

  // Match by slug or id
  const pick = FRAMEWORKS.find(f =>
    (f.slug && f.slug.toLowerCase() === q) ||
    (f.id   && f.id.toLowerCase()   === q)
  );
  if (!pick) return;

  // If tabs not yet migrated, seed the pre-migration id so the first tab uses it.
  state.id = pick.id;

  // If tabs already exist (edge case), align the active tab now too.
  if (Array.isArray(state.tabs) && state.tabs.length) {
    const i = Number.isInteger(state.active) ? state.active : 0;
    state.tabs[i] = { ...(state.tabs[i] || {}), id: pick.id };
  }
})();


// If already migrated, keep it. Otherwise wrap the old single-state into a tab.
if (!Array.isArray(state.tabs) || !state.tabs.length){
  const initialId = (typeof state.id === 'string') ? state.id : (FRAMEWORKS[0]?.id || null);
  state.tabs = [{
    id: initialId,
    fields: state.fields || {},
    extra: (state.extra && state.extra[initialId]) ?? undefined
  }];
  state.active = 0;
  // clean up legacy keys (optional)
  delete state.id; delete state.fields;
}; // use let so we can set the id after we build options

function buildFrameworkOptions(filterText=''){
  const base = FRAMEWORKS.slice()
    .sort((a,b)=> a.label.localeCompare(b.label,'en',{sensitivity:'base'}));

  const total = base.length;
  let list = base;

  const q = (filterText||'').trim();
  if (q){
    list = base
      .map(f=>({f, s: matchScore(f, q)}))
      .filter(x=> x.s > 0)
      .sort((a,b)=> b.s - a.s || a.f.label.localeCompare(b.f.label,'en',{sensitivity:'base'}))
      .map(x=> x.f);
    if (!list.length) list = base; // graceful fallback
  }

  // Rebuild <select> to reflect the filtered ordering
  sel.innerHTML = '';
  list.forEach(f=>{
    const o = document.createElement('option');
    o.value = f.id;
    o.textContent = f.label;
    sel.appendChild(o);
  });

  // Update the little "Showing N/M" hint
  const fwHint = document.getElementById('fwHint');
  if (fwHint){
    if (q){
      // If we fell back to base because there were 0 hits, treat it as "all"
      const isFallback = !base.some(b => (norm(b.label).includes(norm(q))));
      const count = isFallback ? total : list.length;
      fwHint.textContent = `Showing ${count}/${total} — Hit Enter`;
      fwHint.hidden = false;
    } else {
      fwHint.textContent = '';
      fwHint.hidden = true;
    }
  }

  // Preserve current tab's selection if it's in the filtered list; otherwise
  // at least show the *first* filtered option in the dropdown so users see the filter working.
  const t = activeTab();
  const keep = t.id && list.find(x=>x.id===t.id);
  if (keep){
    sel.value = t.id;
  } else {
    sel.selectedIndex = 0;  // visually show the top match
  }
}



// build options now (call again later if you ever modify FRAMEWORKS at runtime)
buildFrameworkOptions();

renderTabs();
buildFrameworkOptions(''); // ensure suggestions render
renderFields(); emit();


    function fieldInput(el, on){ el.addEventListener('input', on); el.addEventListener('change', on); }
    
    
    /* ==== Inline Counters (Stage 1) ==== */
function approxTokens(str){ return Math.ceil((str || '').length / 4); } // fast heuristic
function estimateTokens(str){
  try{
    if (typeof window.customTokenCounter === 'function') {
      const n = Number(window.customTokenCounter(String(str)));
      if (Number.isFinite(n) && n > 0) return Math.ceil(n);
    }
  }catch(e){ /* ignore */ }
  return approxTokens(str);
}

/* ==== Prompt totals: gather, compute, render ==== */
function gatherPreviewText(){
  // If you render a deck of cards, concatenate all visible outputs.
  const deck = document.getElementById('outDeck');
  if (deck && !deck.hidden){
    return Array.from(deck.querySelectorAll('.outBody'))
      .map(n => (n.textContent || '').trim())
      .filter(Boolean)
      .join('\n\n---\n\n');
  }
  // Fallback to the single current preview (the big one)
  const out = document.getElementById('out');
  return (out?.textContent || '').trim();
}

function updatePromptTotal(){
  const el = document.getElementById('promptTotal');
  if (!el) return;
  const text = gatherPreviewText();
  if (!text){ el.textContent = ''; return; }
  const chars = text.length;
  const toks  = estimateTokens(text);
  el.textContent = `${toks} tokens · ${chars} characters`;
}


/* ==== Context Coach (single, for current preview) ==== */
/* Token bands tuned for full prompt length (current preview only) */
const PROMPT_COACH_BANDS = [
  { /* Too little */          max:  79,  state:'low',     label:'Type more'    },
  { /* Not enough */          min:  80,  max: 150, state:'low',     label:'Not enough'   },
  { /* Almost there */        min: 151,  max: 250, state:'near',    label:'Almost there' },
  { /* Looking good */        min: 251,  max: 400, state:'good',    label:'Looking good' },
  { /* Great! */              min: 401,  max: 600, state:'good',    label:'Great!'       },
  { /* Perfect! */            min: 601,  max: 800, state:'perfect', label:'Perfect!'     },
  { /* Too much (long wall) */min: 1001,          state:'high',    label:'Too much'     }
];

function coachForPrompt(tokens){
  for (const r of PROMPT_COACH_BANDS){
    const okMin = (r.min == null) || (tokens >= r.min);
    const okMax = (r.max == null) || (tokens <= r.max);
    if (okMin && okMax) return { state: r.state, label: r.label };
  }
  return { state: 'good', label: 'Looking good' };
}

/* Create/update the coach node inside #out based on current preview tokens */
function updateOutCoach(){
  const out = document.getElementById('out');
  if (!out) return;

  // Create once
  let coach = out.querySelector('.outCoach');
  if (!coach){
    coach = document.createElement('div');
    coach.className = 'outCoach';
    coach.setAttribute('role','status');
    coach.setAttribute('aria-live','polite');
    const pill = document.createElement('span');
    pill.className = 'pill';
    coach._pill = pill;
    coach.appendChild(pill);
    out.appendChild(coach);
  }

  const text = (out.textContent || '').trim();
  if (!text){
    coach.hidden = true;
    out.classList.remove('hasCoach');
    return;
  }

  const tokens = estimateTokens(text); // uses your existing heuristic/precise counter
  const { state, label } = coachForPrompt(tokens);
  coach.dataset.state = state;
  coach._pill.textContent = label;
  coach.hidden = false;
  out.classList.add('hasCoach');
}


/* ==== Master totals: across ALL templates ==== */
function gatherMasterText(){
  const deck = document.getElementById('outDeck');
  if (deck){
    const bodies = deck.querySelectorAll('.outBody');
    if (bodies && bodies.length){
      return Array.from(bodies)
        .map(n => (n.textContent || '').trim())
        .filter(Boolean)
        .join('\n\n---\n\n')
        .trim();
    }
  }
  // Fallback to the single current preview (#out) if no deck/cards
  const out = document.getElementById('out');
  return (out?.textContent || '').trim();
}

function updateMasterPromptTotal(){
  const el = document.getElementById('masterPromptTotal');
  if (!el) return;
  const text = gatherMasterText();
  if (!text){ el.textContent = ''; return; }
  const chars = text.length;
  const toks  = estimateTokens(text); // uses your existing heuristic/precise token estimator
  el.textContent = `${toks} tokens · ${chars} characters`;
}

/* ==== Current preview counter (top-right inside #out) ==== */
function updateOutPreviewCounter(){
  const out = document.getElementById('out');
  if (!out) return;

  let node = out.querySelector('.outCounter');
  if (!node){
    node = document.createElement('div');
    node.className = 'outCounter';
    node.setAttribute('aria-hidden', 'true');
    out.appendChild(node);
  }

  const text = (out.textContent || '').trim();
  if (!text){
    node.textContent = '';
    node.hidden = true;
    out.classList.remove('hasCounter');
    return;
  }

  const chars = text.length;
  const toks  = estimateTokens(text);
  node.textContent = `${toks}t · ${chars}c`;
  node.hidden = false;
  out.classList.add('hasCounter');
}

/* === Counter refresh scheduler (debounced to next frame) === */
function refreshPromptCountersSoon(){
  if (refreshPromptCountersSoon._pending) return;
  refreshPromptCountersSoon._pending = true;
  requestAnimationFrame(()=>{
    refreshPromptCountersSoon._pending = false;
    // Keep the original per-current-prompt updater:
    updatePromptTotal && updatePromptTotal();
    // ADD the new master updater (do not replace the old call):
    updateMasterPromptTotal && updateMasterPromptTotal();
    // Keep the tiny current-preview corner counter:
    updateOutPreviewCounter && updateOutPreviewCounter();
      updateOutCoach && updateOutCoach();     
  });
}

function formatCounts(chars, tokens){ return `${tokens}t · ${chars}c`; }

function setupCounter(inputEl){
  // Only for text & textarea
  const tag = inputEl.tagName.toLowerCase();
  if (!(tag === 'input' || tag === 'textarea')) return;

  // Wrap input in a positioned holder (if not already)
  if (!inputEl.parentElement || !inputEl.parentElement.classList.contains('fieldHolder')){
    const holder = document.createElement('div');
    holder.className = 'fieldHolder';
    inputEl.parentElement.insertBefore(holder, inputEl);
    holder.appendChild(inputEl);
  }
  // Create the counter once
  if (!inputEl._counterNode){
    const n = document.createElement('span');
    n.className = 'counter';
    n.setAttribute('aria-hidden', 'true');
    inputEl._counterNode = n;
    inputEl.parentElement.appendChild(n);
    inputEl.classList.add('hasCounter');
  }

  const update = ()=>{
    const val = inputEl.value || '';
    const chars = val.length;
    const tokens = estimateTokens(val);
    inputEl._counterNode.textContent = (chars > 0) ? formatCounts(chars, tokens) : '';
    inputEl._counterNode.hidden = chars === 0;
  };

  // Initial + live updates
  update();
  inputEl.addEventListener('input', update);
  inputEl.addEventListener('change', update);
}


function enrichFromGlossary(fw){
  const hit = (window.GLOSSARY || []).find(x => x.slug === fw.slug);
  if (!hit) return fw; // no change if not found
  return {
    ...fw,
    label: hit.term || fw.label,             // prefer glossary term as label
    status: hit.status || fw.status,
    tags: Array.from(new Set([...(fw.tags||[]), ...(hit.tags||[])])),
    categories: Array.from(new Set([...(fw.categories||[]), ...(hit.categories||[])])),
    sources: hit.sources || fw.sources
  };
}

if (searchEl){
  // Live filter as you type
  searchEl.addEventListener('input', ()=>{
    buildFrameworkOptions(searchEl.value);
  });

  // Keyboard niceties on the search box
  searchEl.addEventListener('keydown', (e)=>{
    // Ctrl/Cmd+K handled globally elsewhere — keep it
    if (e.key === 'Enter'){
      // Rebuild once more to be 100% in-sync with what's visible
      buildFrameworkOptions(searchEl.value);
      const first = sel.options[0];
      if (first){
        const t = activeTab();
        sel.value = first.value;   // mirror visually
        t.id = first.value;        // commit selection
        t.fields = {};
        renderFields(); emitAll(); nudgeFieldsSwap();
      }
    } else if (e.key === 'ArrowDown'){
      // Move focus into the result list so arrow keys can pick an item
      e.preventDefault();
      sel.focus();
    } else if (e.key === 'Escape'){
      // Clear filter and show all
      searchEl.value = '';
      buildFrameworkOptions('');
      const hint = document.getElementById('fwHint'); if (hint){ hint.hidden = true; hint.textContent = ''; }
      sel.focus();
    }
  });

  // Global: Ctrl/Cmd+K focuses the search bar
  document.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if ((k === 'k') && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      searchEl.focus();
      searchEl.select();
    }
  });
}


if (allBtn){
  allBtn.addEventListener('click', ()=>{
    searchEl.value = '';
    buildFrameworkOptions('');
    sel.focus(); // user can open the native dropdown
  });
}

function activeTab(){ return state.tabs[state.active]; }

function tabLabel(t){
  const fw = FRAMEWORKS.find(f=>f.id===t.id);
  return fw ? fw.label : 'Untitled';
}

function addTab(copyCurrent=true){
  // Always start new tabs blank on the placeholder template
  const none = FRAMEWORKS.find(f => f.id === 'none') || FRAMEWORKS[0];
  const next = { id: none?.id || null, fields:{}, extra: undefined };

  state.tabs.push(next);
  state.active = state.tabs.length - 1;

  renderTabs();
  buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
  renderFields();
  emitAll();
}


function closeTab(idx){
  if (state.tabs.length <= 1) return; // keep at least one
  state.tabs.splice(idx, 1);
  if (state.active >= state.tabs.length) state.active = state.tabs.length - 1;
  renderTabs(); buildFrameworkOptions(document.getElementById('fwSearch')?.value||'');
  renderFields(); emitAll();
}

function clearOrCloseTab(idx){
  // If there is more than one tab, behave like close.
  if (state.tabs.length > 1){
    closeTab(idx);
    return;
  }

  // Single tab: reset this tab to the default "— Select a template —"
  const none = FRAMEWORKS.find(f => f.id === 'none') || FRAMEWORKS[0];
  state.tabs[0] = { id: none?.id || null, fields: {}, extra: undefined };
  state.active = 0;

  // Re-render UI
  renderTabs();
  buildFrameworkOptions(document.getElementById('fwSearch')?.value || '');
  renderFields();
  emitAll();
}


function switchTab(idx){
  if (idx<0 || idx>=state.tabs.length) return;
  state.active = idx;
  renderTabs(); buildFrameworkOptions(document.getElementById('fwSearch')?.value||'');
  renderFields(); emitAll(); nudgeFieldsSwap();
}

function renderTabs(){
  const bar = document.getElementById('tabbar');
  if (!bar) return;
  bar.innerHTML = '';
  const many = state.tabs.length > 1;
  bar.hidden = !many;
  if (!many) return;

  state.tabs.forEach((t, i)=>{
    const b = document.createElement('div');
    b.className = 'tab' + (i===state.active?' active':'');
    b.title = 'Switch to this template';
    b.addEventListener('click', (e)=>{
      // ignore clicks on the close button itself
      if (e.target.closest('.x')) return;
      switchTab(i);
    });

    const title = document.createElement('span');
    title.textContent = tabLabel(t);
    b.appendChild(title);

    const x = document.createElement('button');
    x.className = 'x'; x.type='button'; x.textContent = 'x';
    x.title = 'Remove this template';
    x.addEventListener('click', (e)=>{ e.stopPropagation(); closeTab(i); });
    b.appendChild(x);

    bar.appendChild(b);
  });
}

      function nudgeFieldsSwap(){
  const f = document.getElementById('fields');
  if (!f) return;
  f.classList.remove('fields-swap');
  // reflow to restart animation
  void f.offsetWidth;
  f.classList.add('fields-swap');
}
      

function makePromptForTab(t){
  const fw = FRAMEWORKS.find(f=>f.id===t.id);
  if (!fw) return '';
  const meta = enrichFromGlossary ? enrichFromGlossary(fw) : fw; // safe if enrichment not present
  const ctx = ctxString ? ctxString() : '';
  const merged = {
    ctx,
    audience: document.getElementById('audience')?.value || '',
    style:    document.getElementById('style')?.value || '',
    tone:     document.getElementById('tone')?.value || '',
    ...(t.fields || {})
  };
  const body = fw.template(merged);
  // If the user hasn't typed anything, fall back to the framework's boosters
const boosterFallback = Array.isArray(fw.boosters) ? fw.boosters.join(' ') : '';
const rawExtra = (t.extra ?? '').trim();
const extra = rawExtra.length ? rawExtra : boosterFallback;
const extraText = extra ? `Additional instructions: ${extra}` : '';
  const header = meta.definition ? `Using ${meta.label}: ${meta.definition}` : `Using ${meta.label}.`;
  return [header, body, extraText].filter(Boolean).join('\n').replace(/\n{3,}/g,'\n\n').trim();
}

function emitAll(){
  // keep legacy preview in #out (active tab)
  const out = document.getElementById('out');
  if (out){
    const txt = makePromptForTab(activeTab() || {});
    out.textContent = txt || '';
    
 refreshPromptCountersSoon(); // keep counters in sync with any preview update

  }

  // render all cards
  const deck = document.getElementById('outDeck');
  if (!deck) return;
  deck.innerHTML = '';
  state.tabs.forEach((t, i)=>{
    const card = document.createElement('div');
    card.className = 'outCard';

    const head = document.createElement('div');
    head.className = 'outHead';
    const title = document.createElement('div');
    title.className = 'title';
    title.textContent = tabLabel(t);
    head.appendChild(title);

    const actions = document.createElement('div');
    actions.className = 'actions';

  // Clear from the card (resets when only one tab; closes when multiple)
const x = document.createElement('button');
x.className = 'x'; 
x.type = 'button'; 
x.textContent = 'Clear';
x.title = (state.tabs.length > 1) ? 'Remove this template' : 'Clear this template';
x.addEventListener('click', ()=> clearOrCloseTab(i));
actions.appendChild(x);


    head.appendChild(actions);
    card.appendChild(head);

    const body = document.createElement('div');
    body.className = 'outBody';
    body.textContent = makePromptForTab(t);
    card.appendChild(body);

    deck.appendChild(card);
  });
}


    function renderFields(){
      const t = activeTab();
const fw = FRAMEWORKS.find(f=>f.id===t.id);

// Tab context chip
{
  const ctx = document.createElement('div');
  ctx.id = 'tabContext';
  const idx = (Number.isInteger(state.active) ? state.active : 0) + 1;
  ctx.textContent = `Editing: Tab ${idx} • ` + (fw ? fw.label : 'No template');
  fieldsWrap.appendChild(ctx);
}


      help.textContent = fw.help;
      fieldsWrap.innerHTML='';
fw.fields.forEach(f=>{
  const wrap = document.createElement('div');
  wrap.className = 'field';

  // Label
  const lab = document.createElement('label');
  lab.textContent = f.label;
  lab.htmlFor = `${f.id || f.key}`;
  wrap.appendChild(lab);

  // Special case: dynamic tasks list (repeatable textareas)
  if (f.type === 'dynamic_tasks'){
    const list = document.createElement('div');
    list.className = 'tasksList';

    // Helper to read/write the field into state as a single newline-joined string
    const getValues = () =>
      Array.from(list.querySelectorAll('textarea'))
        .map(ta => ta.value.trim());

    const sync = ()=>{
      const tvals = getValues().filter(Boolean).join('\n');
      (t.fields || (t.fields = {}))[f.key] = tvals;
      emit();
    };

    const addTask = (value='')=>{
      const idx = list.querySelectorAll('textarea').length + 1;

      const item = document.createElement('div');
      item.style.marginTop = idx === 1 ? '0' : '10px';

      const small = document.createElement('div');
      small.className = 'tinyLabel';
      small.textContent = `Task ${idx}`;
      item.appendChild(small);

      const ta = document.createElement('textarea');
      ta.placeholder = f.ph ? `${f.ph}` : `Describe task ${idx}…`;
      ta.value = value;
      item.appendChild(ta);

      // Live updates + inline counter on each task field
      fieldInput(ta, sync);
      setupCounter(ta);

      list.appendChild(item);
      addBtn.parentElement.appendChild(addBtn); // keep button under the newest
      ta.focus();
    };

    // Seed from any saved value (newline-separated), else start with one empty
    const seed = (t.fields && t.fields[f.key]) ? String(t.fields[f.key]) : '';
    const parts = seed ? seed.split(/\n+/).map(s=>s.trim()).filter(Boolean) : [''];
    parts.forEach(v => addTask(v));
    // Ensure state is synced even if initial values came from seed
    sync();

    // Add Task button
    const addBtn = document.createElement('button');
    addBtn.type = 'button';
    addBtn.className = 'btn sm';
    addBtn.textContent = '+ Add task';
    addBtn.style.marginTop = '8px';
    addBtn.addEventListener('click', ()=> addTask(''));

    wrap.appendChild(list);
    wrap.appendChild(addBtn);

    // Optional helper text
    if (f.desc){
      const d = document.createElement('div');
      d.className = 'desc';
      d.textContent = f.desc;
      wrap.appendChild(d);
    }

    fieldsWrap.appendChild(wrap);
    return; // important: skip the default single-input branch
  }
  
    // SELECT (dropdown) branch
  if (f.type === 'select'){
    const holder = document.createElement('div');
    holder.className = 'fieldHolder';

    const sel = document.createElement('select');
    sel.id = f.key;

    // Accept either [{value,label}, ...] or ["value", ...]
    (f.options || []).forEach(opt => {
      const o = document.createElement('option');
      if (typeof opt === 'string'){
        o.value = opt; o.textContent = opt;
      } else {
        o.value = opt.value;
        o.textContent = opt.label || opt.value;
      }
      sel.appendChild(o);
    });

    // Initialize & wire state
    const current = (t.fields && t.fields[f.key]) || sel.options[0]?.value || '';
    sel.value = current;
    (t.fields || (t.fields = {}))[f.key] = sel.value;

    sel.addEventListener('change', ()=>{
      (t.fields || (t.fields = {}))[f.key] = sel.value;
      emit();
    });

    holder.appendChild(sel);
    wrap.appendChild(holder);

    // Optional helper text
    if (f.desc){
      const d = document.createElement('div');
      d.className = 'desc';
      d.textContent = f.desc;
      wrap.appendChild(d);
    }

    fieldsWrap.appendChild(wrap);
    return; // skip default branch
  }


  // DEFAULT single input/textarea branch
  const holder = document.createElement('div');
  holder.className = 'fieldHolder';
let input;
if (f.type === 'textarea'){
  input = document.createElement('textarea');
} else {
  input = document.createElement('input');
  input.type = 'text';
}

input.placeholder = f.ph || '';
input.id = f.key;
input.value = (t.fields && t.fields[f.key]) || '';

/* -- Special case: persona typeahead -- */
if (f.type === 'typeahead' && f.key === 'persona_name'){
  holder.classList.add('taWrap');
  const list = document.createElement('div');
  list.className = 'taList';
  list.hidden = true;
  holder.appendChild(input);
  holder.appendChild(list);

  let activeIndex = -1;
  function renderSuggestions(q){
    const hits = personaFilter(q, 30);
    list.innerHTML = '';
    activeIndex = -1;
    if (!hits.length){ list.hidden = true; return; }
    hits.forEach((p, idx)=>{
      const item = document.createElement('div');
      item.className = 'taItem';
      item.innerHTML = `<span class="name">${p.name}</span>
                        <span class="sub">${p.profession||''}${p.tags?.length?` • ${p.tags.join(', ')}`:''}</span>`;
item.addEventListener('click', (e)=>{
  // Keep UI and state in sync BEFORE re-render to beat any pending input events
  input.value = p.name || '';
  (t.fields || (t.fields = {})).persona_name = input.value;

  applyPersonaToTab(t, p);
  t.fields.end = (t.fields.end || '');

  // Hide suggestions and re-render fields
  list.hidden = true;
  renderFields(); 
  emit();

  // Optional: jump cursor to End goal next
  const endInput = document.querySelector('#end');
  if (endInput) endInput.focus();
});

      list.appendChild(item);
    });
    list.hidden = false;
  }

  input.addEventListener('input', ()=>{
    (t.fields || (t.fields = {}))[f.key] = input.value;
    if (input.value.trim().length === 0){ list.hidden = true; emit(); return; }
    renderSuggestions(input.value);
    emit();
  });

  input.addEventListener('keydown', (e)=>{
    const items = Array.from(list.children);
    if (list.hidden || !items.length) return;

    if (e.key === 'ArrowDown'){ e.preventDefault(); activeIndex = Math.min(items.length-1, activeIndex+1); }
    if (e.key === 'ArrowUp'){   e.preventDefault(); activeIndex = Math.max(0, activeIndex-1); }
    if (e.key === 'Escape'){ list.hidden = true; return; }

if (e.key === 'Enter' && activeIndex >= 0){
  e.preventDefault();
  items[activeIndex].dispatchEvent(new Event('click', {bubbles:true}));
  return;
}

    items.forEach((n,i)=> n.classList.toggle('active', i===activeIndex));
  });

  // Hide on blur (delay so clicks register)
  input.addEventListener('blur', ()=> setTimeout(()=> list.hidden = true, 120));
} else {
  // Normal field (text/textarea)
  holder.appendChild(input);
}

// Save + preview updates (works for both normal and typeahead)
wrap.appendChild(holder);
fieldInput(input, ()=>{
  (t.fields || (t.fields = {}))[f.key] = input.value;
  emit(); // will call emitAll() + totals
});


  // Inline counter (Stage 1)
  setupCounter(input);

  // Optional helper text (unchanged)
  if (f.desc){
    const d = document.createElement('div');
    d.className = 'desc';
    d.textContent = f.desc;
    wrap.appendChild(d);
  }

  fieldsWrap.appendChild(wrap);
});

      
      

// --- Additional instructions box (prefilled from per-framework boosters) ---
{
  const wrap = document.createElement('div');
  wrap.className = 'field';

  const label = document.createElement('label');
  label.textContent = 'Additional instructions';
  label.setAttribute('for', 'extra');

  const holder = document.createElement('div');
  holder.className = 'fieldHolder';

  const ta = document.createElement('textarea');
  ta.id = 'extra';
  ta.rows = 3;

  // Deterministic behavior: use placeholder for boosters; user text wins if present
  const def = defaultBooster(t.id);
  const cur = (t.extra || '').trim();
  if (cur) ta.value = cur;
  if (!cur && def) ta.placeholder = def;

  holder.appendChild(ta);
  wrap.appendChild(label);
  wrap.appendChild(holder);

  // Save + preview updates
  fieldInput(ta, ()=>{
    t.extra = ta.value.trim();
    emit();
  });

  // Inline counter (Stage 1)
  setupCounter(ta);

  fieldsWrap.appendChild(wrap);
}
// --- end Additional instructions box ---




// meta box (enriched from glossary when available)
chips.innerHTML = '';
const meta = enrichFromGlossary(fw);

// Build a boxed section so everything stacks nicely
const box = document.createElement('div');
box.className = 'metaBox';
chips.appendChild(box);

// Row 1: Open in Glossary (its own line)
if (meta?.slug){
  const row = document.createElement('div');
  row.className = 'metaRow';
  const a = document.createElement('a');
  a.className = 'chip metaLink';
  a.href = `../glossary/index.html#${meta.slug}`;
  a.textContent = 'Open in Glossary';
  a.title = meta.label;
  row.appendChild(a);
  box.appendChild(row);
}

// Optional status (still small, under its own row)
if (meta?.status){
  const row = document.createElement('div');
  row.className = 'metaRow';
  const st = document.createElement('span');
  st.className = 'chip';
  st.textContent = `Status: ${meta.status}`;
  row.appendChild(st);
  box.appendChild(row);
}

// Helper to group tags by key
function groupTags(list){
  const groups = {};
  (list || []).forEach(t=>{
    const [k, v] = String(t).split(':');
    if (!k || v === undefined) return;
    (groups[k] ||= []).push(v);
  });
  return groups;
}

// Row 2: CATEGORIES (title line + its own pill row)
if (meta?.categories?.length){
  const title = document.createElement('div');
  title.className = 'metaSectionTitle';
  title.textContent = 'Categories';
  box.appendChild(title);

  const row = document.createElement('div');
  row.className = 'metaPills';
  meta.categories.forEach(cat=>{
    const s = document.createElement('span');
    s.className = 'chip';
    s.textContent = cat;
    row.appendChild(s);
  });
  box.appendChild(row);
}

// Row 3: TAGS grouped by key (type/topic/phase/level/…)
const tagGroups = groupTags(meta?.tags);
const keys = Object.keys(tagGroups);
if (keys.length){
  const title = document.createElement('div');
  title.className = 'metaSectionTitle';
  title.textContent = 'Tags';
  box.appendChild(title);

  keys.sort().forEach(key=>{
    const row = document.createElement('div');
    row.className = 'metaPills';

    const k = document.createElement('span');
    k.className = 'tinyLabel';
    k.textContent = key;
    row.appendChild(k);

    tagGroups[key].forEach(val=>{
      const s = document.createElement('span');
      s.className = 'chip';
      s.textContent = val;
      row.appendChild(s);
    });

    box.appendChild(row);
  });
}


    }

    function ctxString(){
      const u = $('#usecase').value.trim();
      const a = $('#audience').value.trim();
      const s = $('#style').value.trim();
      const t = $('#tone').value.trim();
      const bits=[];
      if(u) bits.push(`Use‑case: ${u}`);
      if(a) bits.push(`Audience: ${a}`);
      if(s) bits.push(`Style: ${s}`);
      if(t) bits.push(`Tone: ${t}`);
      return bits.join(' | ');
    }

function emit(){
  emitAll();
  updatePromptTotal();
  updateOutPreviewCounter();
}

   sel.addEventListener('change', ()=>{
  const t = activeTab();
  t.id = sel.value;
  t.fields = {};      // reset fields when switching template
  if (!t.extra || !t.extra.trim()) delete t.extra; // NEW: allow booster prefill for new template
   renderTabs(); renderFields(); emitAll(); nudgeFieldsSwap();
});

// New: one-click commit of the top search hit when a filter is active.
// This avoids the awkward "pick something else, then come back" dance.
sel.addEventListener('mousedown', () => {
  const q = (document.getElementById('fwSearch')?.value || '').trim();
  if (!q) return; // only intervene when filtering
  const first = sel.options[0];
  if (!first) return;
  const t = activeTab();
  if (t.id !== first.value) {
    // Mirror UI and commit selection
    sel.value = first.value;
    t.id = first.value;
    t.fields = {};
    if (!t.extra || !t.extra.trim()) delete t.extra; // allow booster prefill on new template
    renderTabs(); renderFields(); emitAll(); nudgeFieldsSwap();
  }
});


    ['usecase','audience','style','tone'].forEach(id=>{
      const el = document.getElementById(id); fieldInput(el, emit);
    });
    
    // Persist common fields + visual filled state
const COMMON_IDS = ['usecase','audience','style','tone'];
function toggleFilled(el){ el.classList.toggle('filled', !!el.value.trim()); }
COMMON_IDS.forEach(id=>{
  const el = document.getElementById(id);
  const saved = localStorage.getItem('fw_'+id);
  if (saved !== null) el.value = saved;
  toggleFilled(el);
  el.addEventListener('input', ()=>{
    localStorage.setItem('fw_'+id, el.value);
    toggleFilled(el);
    emit();
  });
});

function getAllGeneratedText(){
  const deck = document.getElementById('outDeck');
  if (deck && deck.children.length){
    const titles = deck.querySelectorAll('.outCard .title');
    const bodies  = deck.querySelectorAll('.outCard .outBody');
    const parts = [];
    titles.forEach((t,i)=>{
      const head = (t.textContent || '').trim();
      const body = (bodies[i]?.textContent || '').trim();
      parts.push(`### ${head}\n${body}`);
    });
    return parts.join('\n\n').trim();
  }
  // fallback to single preview
  const out = document.getElementById('out');
  return (out?.textContent || '').trim();
}


    // Actions
$('#copyBtn').addEventListener('click', async ()=>{
  // If deck is visible, gather all card bodies; else copy the single preview
  const deck = document.getElementById('outDeck');
  const text = deck && !deck.hidden
    ? Array.from(deck.querySelectorAll('.outBody'))
        .map(n => n.textContent.trim())
        .filter(Boolean)
        .join('\n\n---\n\n')
    : (document.getElementById('out')?.textContent || '');
  try { await navigator.clipboard.writeText(text); }
  catch(e){ console.warn('Copy failed', e); }
  const dlg = document.getElementById('msg'); dlg?.showModal();
});



   $('#openBtn').addEventListener('click', async ()=>{
  const txt = getAllGeneratedText();
  const dlg = $('#msg');
  // 1) Copy to clipboard (primary guarantee)
  let copied = false;
  try { await navigator.clipboard.writeText(txt); copied = true; }
  catch(e){ console.warn('Clipboard write failed:', e); }
  try {
    const url = 'https://chat.openai.com/?q=' + encodeURIComponent(txt);
    window.open(url, '_blank', 'noopener,noreferrer');
  } catch(e){ console.warn('Open failed', e); }
  // message text is updated just below in your existing code





      // 2) Attempt to open ChatGPT with a prefilled query param (best-effort)
      function buildChatURL(prompt){
        const base = localStorage.getItem('chatgpt_target') || 'https://chatgpt.com/';
        try{
          const u = new URL(base);
          // Try multiple param names — ChatGPT may ignore them, but harmless.
          u.searchParams.set('q', prompt);
          u.searchParams.set('prompt', prompt);
          u.searchParams.set('input', prompt);
          return u.toString();
        }catch(err){
          console.warn('Bad chat target URL; falling back.', err);
          return 'https://chatgpt.com/';
        }
      }
      const url = buildChatURL(txt);
      window.open(url, '_blank', 'noopener');

      // 3) User feedback
      const msg = copied
        ? 'Prompt copied to clipboard. A ChatGPT tab opened. If the prompt did not auto-appear, paste with Cmd/Ctrl+V.'
        : 'Opened ChatGPT. Could not auto-copy the prompt (browser denied). Please select the text in the preview and copy it manually.';
      const msgEl = document.getElementById('msgText');
      if(msgEl) msgEl.textContent = msg; else console.info(msg);
      dlg.showModal();
    });
    
    // Add template (single, guarded wiring)
(function wireAddTemplate(){
  if (window.__addTemplateWired) return;
  window.__addTemplateWired = true;
  const btn = document.getElementById('addPromptBtn');
  if (!btn) return;
  btn.addEventListener('click', (e)=>{
    e.preventDefault();
    if (typeof addTab === 'function') addTab(true);
  });
})();


    // Theme
    const themeBtn = $('#theme');
    themeBtn.addEventListener('click', ()=>{
      const light = document.documentElement.getAttribute('data-theme')==='light';
      document.documentElement.setAttribute('data-theme', light?'' : 'light');
      themeBtn.setAttribute('aria-pressed', light? 'false':'true');
      themeBtn.querySelector('span:last-child').textContent = light? 'Light':'Dark';
    });
    
    // --- Dialog: make it closable via button and backdrop ---
const dlg = document.getElementById('msg');
const dlgClose = document.getElementById('dlgClose');

// Close when clicking the "Close" button
if (dlgClose) dlgClose.addEventListener('click', () => dlg.close());

// Close when clicking the backdrop (outside the dialog content)
dlg.addEventListener('click', (e) => {
  // If the click target is the <dialog> itself, it's the backdrop
  if (e.target === dlg) dlg.close();
});

// Optional: ensure Esc always closes (most browsers do this by default)
dlg.addEventListener('cancel', () => {
  // no-op; letting the default behavior close the dialog
});

// --- Draggable vertical resizer for the left panel ---
(function(){
  const resizer = document.getElementById('resizer');
  const root = document.documentElement;
  const MIN = 280, MAX = 900;

  // restore saved width if present
  const saved = parseInt(localStorage.getItem('fw_leftW') || '', 10);
  if (!isNaN(saved)) root.style.setProperty('--leftW', saved + 'px');

  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

  let dragging = false;

  function onMove(clientX){
    const wrapRect = document.querySelector('.wrap').getBoundingClientRect();
    const x = clientX - wrapRect.left;           // position inside the grid
    const newW = clamp(x, MIN, MAX);             // left column width
    root.style.setProperty('--leftW', newW + 'px');
    localStorage.setItem('fw_leftW', String(newW));
  }

  resizer.addEventListener('mousedown', (e)=>{
    dragging = true; e.preventDefault();
    document.body.style.userSelect = 'none';
  });
  window.addEventListener('mousemove', (e)=>{ if(dragging) onMove(e.clientX); });
  window.addEventListener('mouseup', ()=>{
    if(dragging){ dragging=false; document.body.style.userSelect=''; }
  });

  // Touch support
  resizer.addEventListener('touchstart', (e)=>{
    dragging = true; document.body.style.userSelect='none';
  }, {passive:true});
  window.addEventListener('touchmove', (e)=>{
    if(!dragging) return;
    const t = e.touches[0]; if(t) onMove(t.clientX);
  }, {passive:true});
  window.addEventListener('touchend', ()=>{
    if(dragging){ dragging=false; document.body.style.userSelect=''; }
  });

  // Keyboard resizing for accessibility
  resizer.addEventListener('keydown', (e)=>{
    const step = (e.shiftKey ? 40 : 20);
    const cur = parseInt(getComputedStyle(root).getPropertyValue('--leftW') || '360', 10);
    if (e.key === 'ArrowLeft'){ const w = clamp(cur - step, MIN, MAX); root.style.setProperty('--leftW', w + 'px'); localStorage.setItem('fw_leftW', String(w)); }
    if (e.key === 'ArrowRight'){ const w = clamp(cur + step, MIN, MAX); root.style.setProperty('--leftW', w + 'px'); localStorage.setItem('fw_leftW', String(w)); }
  });
})();

    // init
    renderFields(); emit();
  })();
  </script>
</body>
</html>
