<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Saved Prompts & Sessions</title>
  <style>
    /* === Borrow core theming from Prompt Builder === */
    :root{
      --bg:#0b0f14; --panel:#121821; --card:#0f151d; --muted:#9db0c3; --text:#e7eff7;
      --accent:#4ea1ff; --chip:#1b2533; --border:#1b2838; --radius:14px; --gap:14px;
      --green:#2ecc71; --yellow:#f1c40f; --red:#e74c3c; --purple:#a78bfa;
      --border-strong:#2a3a4f;
    }
    :root[data-theme="light"]{
      --bg:#f7fafc; --panel:#ffffff; --card:#ffffff; --muted:#5a6b7b; --text:#121621;
      --accent:#2563eb; --chip:#f1f5f9; --border:#d8e0ea; --border-strong:#b9c6d6;
    }
    *{ box-sizing: border-box }
    body{
      margin:0; background:var(--bg); color:var(--text);
      font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans",sans-serif;
    }
    a{ color:var(--accent); text-decoration:none }
    a:hover{ text-decoration:underline }

    header{
      display:flex; align-items:center; gap:12px;
      padding:12px 16px; position:sticky; top:0; z-index:10;
      background:linear-gradient(180deg,var(--panel),rgba(0,0,0,0));
      border-bottom:1px solid var(--border);
      backdrop-filter: blur(8px);
    }
    header .spacer{ flex:1 }
    .btn{ cursor:pointer; border:1px solid var(--border); background:var(--chip); color:var(--text); padding:8px 12px; border-radius:10px }
    .btn.primary{ background:var(--accent); color:#061422; border:none }
    :root[data-theme="light"] .btn.primary{ color:#fff }
    .btn.sm{ padding:6px 10px; font-size:14px; border-radius:8px }
    .btn.danger{ background:var(--red); color:#fff; border:none }
    .btn:hover{ transform:translateY(-1px); box-shadow:0 2px 8px rgba(0,0,0,.18) }
    .btn:active{ transform:none; box-shadow:none }

    .toggle{
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid var(--border); background:var(--chip);
      padding:6px 10px; border-radius:999px;
    }
    .dot{ width:16px; height:16px; border-radius:50%;
      background:linear-gradient(180deg,#fdd835,#fbc02d); box-shadow:inset 0 -3px 6px rgba(0,0,0,.25) }
    :root[data-theme="light"] .dot{ background:linear-gradient(180deg,#121621,#394554) }

    main{ max-width:1100px; margin:16px auto 96px; padding:0 16px }

    /* Section headings */
    h2.section{ font-size:16px; margin:18px 0 8px; color:var(--muted) }

    /* Session cards list */
    .list{ display:flex; flex-direction:column; gap:12px }

    .card{
      background:var(--panel); border:1px solid var(--border-strong);
      border-radius:var(--radius); overflow:hidden;
    }
    .cardHead{
      display:flex; align-items:center; gap:10px;
      padding:12px 14px; border-bottom:1px solid var(--border);
    }
    .title{ font-weight:700 }
    .subtle{ color:var(--muted); font-size:13px }
    .pill{
      padding:4px 8px; border-radius:999px; border:1px solid var(--border);
      font-size:12px; background:var(--chip);
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .spacer{ flex:1 }

    .cardBody{ padding:12px 14px }
    .meta{ display:flex; flex-wrap:wrap; gap:8px; margin:6px 0 10px }
    .meta .chip{
      background:var(--chip); border:1px solid var(--border);
      border-radius:999px; padding:6px 10px; font-size:12px; line-height:1;
    }

    details summary{
      cursor:pointer; list-style:none; padding:8px 10px; margin:-8px -10px 8px;
      border:1px dashed var(--border); border-radius:10px; background:transparent;
    }
    details[open] summary{ background:rgba(78,161,255,.06); border-style:solid }
    pre{
      margin:0; padding:10px 12px; background:var(--card);
      border:1px solid var(--border); border-radius:10px; white-space:pre-wrap
    }

    .empty{
      padding:16px; border:1px dashed var(--border); border-radius:10px; color:var(--muted);
      background:transparent;
    }

    .footerRow{ display:flex; gap:8px; justify-content:flex-end; margin-top:10px }
  </style>
</head>
<body>
  <header>
    <a class="btn sm" href="./prompt-builder.html" rel="noopener">← Back to Prompt Builder</a>
    <strong>Saved Prompts & Sessions</strong>
    <span class="pill" title="Your local saves">local only</span>
    <span class="spacer"></span>
<button id="importBtn" class="btn sm" title="Import session JSON">Import</button>

<button id="theme" class="toggle" aria-pressed="false" title="Toggle theme">
  <span class="dot"></span><span>Light</span>
</button>

<!-- hidden file input for import -->
<input id="importFile" type="file" accept="application/json,.json" hidden />
  </header>

  <main>
    <div id="status" class="subtle" aria-live="polite"></div>

    <!-- Manual saves section (if distinguishable) -->
    <h2 id="manualHdr" class="section" hidden>Manual saves</h2>
    <div id="manualList" class="list"></div>

    <!-- Autosaves section (if distinguishable) -->
    <h2 id="autoHdr" class="section" hidden>Autosaves</h2>
    <div id="autoList" class="list"></div>

    <!-- Fallback: all sessions (when kind is unknown) -->
    <h2 id="allHdr" class="section" hidden>All sessions</h2>
    <div id="allList" class="list"></div>

    <div id="empty" class="empty" hidden>
      No saved sessions were found. Open the Prompt Builder, make some changes,
      then come back — we’ll show your latest session here.
    </div>
  </main>

  <!-- Load templates so we can show human-friendly template names -->
  <script src="./templates.data.js"></script>

  <script>
  // === Theme toggle mirrors Prompt Builder behavior ===
  (function(){
    const btn = document.getElementById('theme');
    const ui = JSON.parse(localStorage.getItem('pb.v1.ui') || '{}');
    const initial = ui.theme || 'dark';
    document.documentElement.setAttribute('data-theme', initial);
    btn.setAttribute('aria-pressed', initial === 'light' ? 'true' : 'false');
    const label = btn.querySelector('span:last-child');
    if (label) label.textContent = initial === 'light' ? 'Dark' : 'Light';

    btn.addEventListener('click', ()=>{
      const cur  = document.documentElement.getAttribute('data-theme') || 'dark';
      const next = (cur === 'light') ? 'dark' : 'light';
      document.documentElement.setAttribute('data-theme', next);
      btn.setAttribute('aria-pressed', next === 'light' ? 'true' : 'false');
      if (label) label.textContent = next === 'light' ? 'Dark' : 'Light';
      try{
        const ui = JSON.parse(localStorage.getItem('pb.v1.ui') || '{}');
        ui.theme = next; ui.ts = Date.now();
        localStorage.setItem('pb.v1.ui', JSON.stringify(ui));
      }catch(_){}
    });
  })();

  // === Helpers to read sessions from localStorage ===
  
  // --- Import helpers ---------------------------------------------------------
const HISTORY_KEY = 'pb.v1.history';
const HISTORY_MAX = 200; // keep last N after import (tune as you like)

function readTextFile(file){
  return new Promise((resolve, reject)=>{
    const fr = new FileReader();
    fr.onload = () => resolve(String(fr.result || ''));
    fr.onerror = () => reject(fr.error || new Error('Read failed'));
    fr.readAsText(file);
  });
}

function normalizeSnapshot(obj, i=0){
  // Accept either the exported shape or a plain state
  // Exported shape: { ts, kind, state, ui }
  // We override ts so imports are "most recent" visually
  const isExportShape = obj && typeof obj === 'object' && ('state' in obj || 'ui' in obj || 'ts' in obj || 'kind' in obj);
  const state = isExportShape ? obj.state : obj;
  if (!state || typeof state !== 'object') return null;

  const ui = isExportShape ? (obj.ui || null) : (safeParse(localStorage.getItem(LS.ui)) || null);
  const kind = (isExportShape ? (obj.kind || 'import') : 'import');
  const ts = Date.now() + i; // force-most-recent ordering; preserve order within the file

  return { ts, kind, state, ui };
}

function upsertHistory(snaps){
  const hist = safeParse(localStorage.getItem(HISTORY_KEY)) || [];
  // Append all, then trim to HISTORY_MAX (keep newest)
  const merged = hist.concat(snaps).sort((a,b)=>(a.ts||0)-(b.ts||0)); // sort ascending
  // Trim from the start if needed
  while (merged.length > HISTORY_MAX) merged.shift();
  localStorage.setItem(HISTORY_KEY, JSON.stringify(merged));
}

async function importFromFiles(fileList){
  if (!fileList || !fileList.length) return;

  let added = 0, errors = 0;
  for (const f of fileList){
    try{
      const text = await readTextFile(f);
      const data = JSON.parse(text);

      let snaps = [];
      if (Array.isArray(data)) {
        snaps = data.map((obj,i)=> normalizeSnapshot(obj,i)).filter(Boolean);
      } else {
        const snap = normalizeSnapshot(data, 0);
        if (snap) snaps = [snap];
      }

      if (snaps.length){
        upsertHistory(snaps);
        added += snaps.length;
      }
    }catch(e){
      console.warn('Import failed for', f?.name, e);
      errors++;
    }
  }

  // UX feedback + refresh
  const s = document.getElementById('status');
  if (s){
    s.textContent = added
      ? `Imported ${added} snapshot${added===1?'':'s'}${errors?` (${errors} file${errors===1?'':'s'} failed)`:''}.`
      : `No snapshots imported${errors?` (${errors} file${errors===1?'':'s'} failed)`:''}.`;
  }
  render();
}

// Wire the header Import button
(function wireImport(){
  const btn = document.getElementById('importBtn');
  const file = document.getElementById('importFile');
  if (!btn || !file) return;

  btn.addEventListener('click', ()=> file.click());
  file.addEventListener('change', ()=>{
    const files = Array.from(file.files || []);
    // reset input so the same file can be re-imported later
    file.value = '';
    importFromFiles(files);
  });

  // Optional: drag & drop anywhere on page
  document.addEventListener('dragover', (e)=>{ e.preventDefault(); });
  document.addEventListener('drop', (e)=>{
    if (!e.dataTransfer) return;
    e.preventDefault();
    const files = Array.from(e.dataTransfer.files || [])
      .filter(f => /\.json$/i.test(f.name));
    if (files.length) importFromFiles(files);
  });
})();

  function safeParse(v){ try{ return JSON.parse(v); }catch(_){ return null; } }
  function fmtTs(ts){
    try{
      const d = new Date(Number(ts));
      if (!isFinite(d)) return 'Unknown time';
      return d.toLocaleString([], {year:'numeric', month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit'});
    }catch(_){ return 'Unknown time'; }
  }

  // Use the same IDs as Prompt Builder
  const LS = { state: 'pb.v1.state', ui: 'pb.v1.ui', history: 'pb.v1.history' };

  // Map template id -> label
  const TEMPLATE_LABEL = (() => {
    const src = (window.TEMPLATES || window.FRAMEWORKS || []);
    const map = {};
    src.forEach(t => { if (t && t.id) map[t.id] = t.label || t.id; });
    return id => map[id] || id || '(unknown)';
  })();

  // Pull all sessions we can find:
  // - Preferred: an array in pb.v1.history [{ ts, kind?, state }]
  // - Fallback: single current pb.v1.state (render as one entry)
  function loadSessions(){
    const hist = safeParse(localStorage.getItem(LS.history));
    if (Array.isArray(hist) && hist.length){
      // normalize + sort desc
      return hist
        .map(x => ({
          ts: x.ts || Date.now(),
          kind: x.kind || 'unknown',
          state: x.state || null,
          ui: x.ui || null
        }))
        .filter(x => x.state && typeof x.state === 'object')
        .sort((a,b) => (b.ts||0) - (a.ts||0));
    }

    // Fallback: synthesize a single session from current state
    const cur = safeParse(localStorage.getItem(LS.state));
    if (cur && typeof cur === 'object'){
      const ui = safeParse(localStorage.getItem(LS.ui));
      return [{ ts: (ui && ui.ts) || Date.now(), kind:'unknown', state:cur, ui }];
    }
    return [];
  }

  function summarizeTemplates(state){
    const tabs = Array.isArray(state.tabs) ? state.tabs : [];
    const ids  = tabs.map(t => t && t.id).filter(Boolean);
    const names = ids.map(TEMPLATE_LABEL);
    return { count: names.length, names };
  }

  function humanList(arr, max=6){
    if (!arr.length) return '—';
    const shown = arr.slice(0,max);
    const extra = arr.length - shown.length;
    return shown.join(', ') + (extra > 0 ? `, +${extra} more` : '');
  }

  // Restore = write chosen snapshot back and hop to builder
  function restoreSession(snap){
    try{
      if (snap.state) localStorage.setItem(LS.state, JSON.stringify(snap.state));
      // Keep existing UI unless snapshot provided one
      if (snap.ui)    localStorage.setItem(LS.ui, JSON.stringify(snap.ui));
    }catch(e){
      alert('Could not restore this session. ' + e);
      return;
    }
    location.href = './prompt-builder.html';
  }

  function exportJSON(snap){
    const blob = new Blob(
      [JSON.stringify({ ts:snap.ts, kind:snap.kind, state:snap.state, ui:snap.ui }, null, 2)],
      { type: 'application/json' }
    );
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `prompt-builder-session-${snap.ts||Date.now()}.json`;
    a.click();
    setTimeout(()=> URL.revokeObjectURL(a.href), 2000);
  }

  function deleteFromHistory(ts){
    const hist = safeParse(localStorage.getItem(LS.history));
    if (!Array.isArray(hist)) return;
    const next = hist.filter(x => x.ts !== ts);
    localStorage.setItem(LS.history, JSON.stringify(next));
    render(); // refresh UI
  }

  function renderCard(snap){
    const { state } = snap;
    const { count, names } = summarizeTemplates(state);
    const when = fmtTs(snap.ts);
    const title = count ? `${count} template${count>1?'s':''}` : 'Empty session';

    const el = document.createElement('div');
    el.className = 'card';
    el.innerHTML = `
      <div class="cardHead">
        <div class="row">
          <span class="title">${title}</span>
          <span class="pill">${when}</span>
          <span class="pill">${(snap.kind==='manual' ? 'Manual save' : (snap.kind==='auto' ? 'Autosave' : 'Saved'))}</span>
        </div>
        <div class="spacer"></div>
        <div class="row">
          <button class="btn sm" data-act="restore">Restore</button>
          <button class="btn sm" data-act="export">Export</button>
          <button class="btn sm danger" data-act="delete" ${Array.isArray(safeParse(localStorage.getItem(LS.history))) ? '' : 'hidden'}>Delete</button>
        </div>
      </div>
      <div class="cardBody">
        <div class="meta">
          <span class="chip"><strong>Templates:</strong> ${humanList(names)}</span>
          <span class="chip"><strong>Active tab:</strong> ${TEMPLATE_LABEL((state.tabs && state.tabs[state.active||0]?.id) || '')}</span>
        </div>

        <details>
          <summary>Details</summary>
          ${renderDetails(state)}
        </details>

        <div class="footerRow">
          <button class="btn primary" data-act="restore">Restore this session</button>
        </div>
      </div>
    `;

    // wire actions
    el.querySelectorAll('[data-act="restore"]').forEach(b => b.addEventListener('click', ()=> restoreSession(snap)));
    el.querySelector('[data-act="export"]').addEventListener('click', ()=> exportJSON(snap));
    const del = el.querySelector('[data-act="delete"]');
    if (del) del.addEventListener('click', ()=>{
      if (confirm('Delete this snapshot from your history? This cannot be undone.')) deleteFromHistory(snap.ts);
    });

    return el;
  }

  function renderDetails(state){
    const tabs = Array.isArray(state.tabs) ? state.tabs : [];
    if (!tabs.length) return `<div class="subtle">No templates were saved in this session.</div>`;
    const lines = tabs.map((t, i) => {
      const name = TEMPLATE_LABEL(t?.id);
      const filled = Object.entries(t?.fields || {})
        .filter(([_,v]) => String(v||'').trim().length)
        .length;
      const extras = (t?.extra && String(t.extra).trim()) ? ' • with additional instructions' : '';
      return `• ${i+1}. ${name} — ${filled} field${filled===1?'':'s'} filled${extras}`;
    }).join('\n');

    // We keep it user-friendly: no raw JSON, no internal keys.
    return `
      <div class="subtle" style="margin-bottom:6px">What’s included</div>
      <pre>${lines}</pre>
    `;
  }

  function render(){
    const status = document.getElementById('status');
    const manualHdr = document.getElementById('manualHdr');
    const autoHdr   = document.getElementById('autoHdr');
    const allHdr    = document.getElementById('allHdr');
    const manual    = document.getElementById('manualList');
    const auto      = document.getElementById('autoList');
    const all       = document.getElementById('allList');
    const empty     = document.getElementById('empty');

    [manual, auto, all].forEach(n => n.innerHTML = '');

    const sessions = loadSessions();

    if (!sessions.length){
      empty.hidden = false;
      manualHdr.hidden = autoHdr.hidden = allHdr.hidden = true;
      status.textContent = 'Nothing to show yet.';
      return;
    }

    empty.hidden = true;

    const hasKinds = sessions.some(s => s.kind === 'manual' || s.kind === 'auto');
    if (hasKinds){
      const manualList = sessions.filter(s => s.kind === 'manual');
      const autoList   = sessions.filter(s => s.kind === 'auto');
      const restList   = sessions.filter(s => s.kind !== 'manual' && s.kind !== 'auto');

      manualHdr.hidden = manualList.length === 0;
      autoHdr.hidden   = autoList.length === 0;
      allHdr.hidden    = restList.length === 0;

      manualList.forEach(s => manual.appendChild(renderCard(s)));
      autoList.forEach(s   => auto.appendChild(renderCard(s)));
      restList.forEach(s   => all.appendChild(renderCard(s)));
    }else{
      allHdr.hidden = false;
      sessions.forEach(s => all.appendChild(renderCard(s)));
      manualHdr.hidden = autoHdr.hidden = true;
    }

    status.textContent = `Showing ${sessions.length} saved snapshot${sessions.length===1?'':'s'}. Stored locally in your browser.`;
  }

  // Initial paint
  render();
  </script>
</body>
</html>