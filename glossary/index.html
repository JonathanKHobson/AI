<!doctype html>
<html lang="en-US">
<head>
  <meta charset="utf-8"/>
  
  <title>AI Glossary — definitions, tags & templates | Prompt Builder</title>
  
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

<meta name="description" content="Browse an AI glossary of terms, definitions, and tags. Search and filter to learn fast, compare concepts, and jump into prompt templates.">
<link rel="canonical" href="https://jonathankhobson.github.io/AI/glossary/index.html">

<!-- Robots -->
<meta name="robots" content="index,follow,max-image-preview:large,max-snippet:-1,max-video-preview:-1">

<!-- UI integration -->
<meta name="color-scheme" content="light dark">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#111111">

<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:site_name" content="Prompt Builder">
<meta property="og:locale" content="en_US">
<meta property="og:url" content="https://jonathankhobson.github.io/AI/glossary/index.html">
<meta property="og:title" content="AI Glossary — definitions, tags & templates">
<meta property="og:description" content="Search and filter terms, definitions, and tags. Learn fast and jump into prompt templates.">
<meta property="og:image" content="https://jonathankhobson.github.io/AI/assets/og/prompt-builder-og.png">
<meta property="og:image:alt" content="AI Glossary interface with search bar, filters, and term cards">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta property="og:image:type" content="image/png">

<!-- X (Twitter) -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="AI Glossary — definitions, tags & templates">
<meta name="twitter:description" content="Search and filter terms, definitions, and tags. Learn fast and jump into prompt templates.">
<meta name="twitter:image" content="https://jonathankhobson.github.io/AI/assets/og/prompt-builder-og.png">

<!-- Icons (placeholders are fine for now) -->
<link rel="icon" href="https://jonathankhobson.github.io/AI/favicon.ico" sizes="any">
<link rel="icon" type="image/png" sizes="32x32" href="https://jonathankhobson.github.io/AI/icons/favicon-32.png">
<link rel="icon" type="image/png" sizes="192x192" href="https://jonathankhobson.github.io/AI/icons/icon-192.png">
<link rel="apple-touch-icon" href="https://jonathankhobson.github.io/AI/icons/apple-touch-icon.png">

<!-- Font preload (safe even if the file isn’t uploaded yet) -->
<link rel="preload" as="font" href="https://jonathankhobson.github.io/AI/assets/fonts/inter-var.woff2" type="font/woff2" crossorigin>

<style>

/* Accessibility helpers */
.skip-link{position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden}
.skip-link:focus{position:static;width:auto;height:auto;padding:.5rem 1rem;background:#111;color:#fff;z-index:9999}
.visually-hidden{position:absolute!important;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0 0 0 0);white-space:nowrap;border:0}

</style>

  <style>
    /* ============ THEME TOKENS (kept your names; values aligned to index) ============ */
    :root{
  /* Neutrals (light) */
  --bg:#fafafa;      /* page */
  --fg:#0f1720;      /* primary text */
  --muted:#506070;   /* secondary text */
  --chip:#f3f6fa;    /* quiet surface for chips */
  --border:#e3e9f2;  /* hairline borders */
  --accent:#1e293b;  /* headings/strong accents */

  /* Interaction/effects */
  --focus:#0ea5e9;               /* global focus ring */
  --shadow:0 12px 40px rgba(0,0,0,.08);
  --radius:16px;

  /* Rainbow palette */
  --r1:#ff007a; --r2:#ff8d00; --r3:#ffd600;
  --r4:#00dc82; --r5:#00d2ff; --r6:#7850ff;

  /* ---------- Legacy bridge (so existing CSS keeps working) ---------- */
  --ink:var(--fg);            /* text */
  --ink-2:var(--muted);       /* secondary text */
  --panel:#fff;               /* surfaces/panels/cards */
  --panel-2:#fff;             /* inner surfaces */
  --line:var(--border);       /* borders */
  --br:var(--radius);         /* corner radius */

  /* Buttons (light) */
  --btn-bg:#fff;
  --btn-bg-hover:#f8fafc;
  --btn-border:var(--border);
  --btn-text:var(--fg);
  --btn-ghost-border:var(--border);
  --btn-ghost-text:var(--muted);
    /* Primary button (e.g., search) */
  --btn-primary-bg: var(--fg);
  --btn-primary-text: #fff;

  /* Prompt Builder / Ask buttons (inherit button tokens) */
  --pb-bg:var(--btn-bg);
  --pb-bg-hover:var(--btn-bg-hover);
  --pb-border:var(--btn-border);
  --pb-text:var(--btn-text);

 /* Light = dark dot */
      --theme-icon: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14'><circle cx='7' cy='7' r='5' fill='%23121621'/></svg>");

   
    }
  /* Optional dark mode mapping (your toggle will flip this) */
html[data-theme="dark"]{
  --bg:#0c1220; --fg:#e6ebf2; --muted:#9aa8b7; --chip:#111827; --border:#233041; --accent:#cbd5e1;
  --shadow:0 12px 40px rgba(0,0,0,.24);

  /* Bridge in dark */
  --panel:#0f1726; --panel-2:#0b1320; --ink:var(--fg); --ink-2:var(--muted); --line:var(--border);

  --btn-bg:#1b2533; --btn-bg-hover:#13202e; --btn-border:var(--border); --btn-text:var(--fg);
  --btn-ghost-border:var(--border); --btn-ghost-text:var(--fg);

  --pb-bg:var(--btn-bg); --pb-bg-hover:var(--btn-bg-hover); --pb-border:var(--btn-border); --pb-text:var(--btn-text);
  
    --btn-primary-bg: #1e293b;     /* deep slate background in dark */
  --btn-primary-text: #e6ebf2;   /* readable light text */
  
       /* Theme icon: dark = golden dot */
      --theme-icon: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14'><circle cx='7' cy='7' r='5' fill='%23fdd835'/></svg>");
    }

    /* ============ GLOBAL ============ */
    *{box-sizing:border-box}
    html,body{height:100%}
body{
  margin:0;
  background:var(--bg);
  color:var(--fg);
  font:16px/1.5 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
}
:focus-visible{ outline:2px solid var(--focus); outline-offset:2px }
    
    /* Ambient rainbow glimmer (soft conic glow from top-left) */
body::before{
  content:""; position:fixed; inset:auto auto 40% 0;
  width:min(70vw,920px); height:min(70vh,680px); pointer-events:none; z-index:-1;
  filter: blur(48px) saturate(115%);
  background:
    radial-gradient(120% 120% at 0% 0%, rgba(255,255,255,.85) 0 36%, transparent 52%),
    conic-gradient(from 210deg at 0% 0%,
      rgba(255,0,122,.22), rgba(255,141,0,.18),
      rgba(255,214,0,.18), rgba(0,220,130,.20),
      rgba(0,210,255,.18), rgba(120,80,255,.22), rgba(255,0,122,.22));
  opacity:.28;
}


@media (prefers-reduced-motion: reduce){
  body::before{ animation:none; }
}
    a{color:var(--link); text-decoration:none}
    a:hover{text-decoration:underline}
   .wrap{ max-width:1600px; width:100%; margin:0 auto; padding:48px 24px 40px; display:grid; gap:24px }   
    header{display:flex; gap:16px; align-items:center; justify-content:space-between; margin-bottom:12px}
    .hdr-actions{ display:flex; gap:8px; align-items:center }
#backToSearch{ text-transform:none } /* honor exact casing “back to home” */
#hdrPB{ text-transform:none }        /* keep label crisp */
    h1{font-size:24px; margin:0}
    .sub{color:var(--ink-2); font-size:13px}

    /* ============ PANELS & LAYOUT (unchanged structure) ============ */
.pane{
  background:var(--panel); border:1px solid var(--border);
  border-radius:var(--radius); padding:14px; box-shadow:var(--shadow);
}
.controls{
  display:grid;
  grid-template-columns: 1.3fr .9fr .9fr .9fr .9fr .9fr .9fr .9fr .9fr auto;
  gap:10px; align-items:end;
}

.filters.alpha{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-top:10px }
.filters.alpha label.sub{ margin:0 8px 0 2px }
.filters.alpha .chip{ cursor:pointer; user-select:none }
.filters.alpha .chip.active{ outline:2px solid var(--accent) }
    .filters{margin-top:10px}

/* ============ FORMS (light, airy) ============ */
label.sub{display:block; margin:0 0 6px 2px; color:var(--muted); text-transform:lowercase; letter-spacing:.2px}
input, select, textarea{
  width:100%; height:auto; padding:12px 14px;
  background:var(--panel); color:var(--fg);
  border:1px solid var(--border); border-radius:var(--radius); outline:none;
  box-shadow: var(--shadow);
  transition: border-color .12s ease, background-color .12s ease, box-shadow .12s ease;
}
input::placeholder, textarea::placeholder{ color:var(--muted) }
input:focus, select:focus, textarea:focus{ border-color: var(--focus) }

/* ============ BUTTONS ============ */
.btn{
  display:inline-flex; align-items:center; justify-content:center; gap:.5ch;
  padding:9px 14px; border-radius:999px; cursor:pointer; user-select:none;
  font-weight:600; text-transform:lowercase; text-decoration:none;
  background: var(--btn-bg); color: var(--btn-text); border:1px solid var(--btn-border);
  transition: transform .06s ease, box-shadow .12s ease, background-color .12s ease, color .12s ease, border-color .12s ease;
}
.btn:hover{ background:var(--btn-bg-hover) }
.btn:active{ transform:translateY(1px) }

.btn-ghost{ background:var(--panel); color:var(--muted); border:1px dashed var(--btn-ghost-border) }
.btn-link{ background:transparent; border:none; color:var(--fg); padding:6px 8px; font-size:13px }

.btn-sm{ padding:8px 12px; font-size:13px; border-radius:999px }
.btn-xs{ padding:6px 10px; font-size:12px; border-radius:999px }


    /* Theme button dot */
    #themeBtn::before{
      content:""; width:14px; height:14px; display:inline-block;
      background-image:var(--theme-icon);
      background-size:14px 14px; background-repeat:no-repeat;
      border-radius:50%;
    }
    
.card .pb-btn, .card .ask-btn{
  position:absolute; right:10px; border:none; isolation:isolate;
}
.card .pb-btn::after, .card .ask-btn::after{
  content:""; position:absolute; inset:-2px; border-radius:inherit; padding:2px;
  --angle:0deg;
  background: conic-gradient(from var(--angle),
    var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor; mask-composite: exclude;
  opacity:0; transition: opacity .2s ease, filter .2s ease; pointer-events:none; z-index:-1;
}
@keyframes spinRainbow{ to { --angle:360deg; } }
.card .pb-btn:hover, .card .ask-btn:hover,
.card .pb-btn:focus-visible, .card .ask-btn:focus-visible{
  transform: translateY(-2px) scale(1.02);
  box-shadow: 0 16px 28px -14px rgba(0,0,0,.35), 0 4px 10px -6px rgba(0,0,0,.25);
}
.card .pb-btn:hover::after, .card .ask-btn:hover::after,
.card .pb-btn:focus-visible::after, .card .ask-btn:focus-visible::after{
  opacity:1; filter:saturate(1.15); animation: spinRainbow 2.25s linear infinite;
}
@media (prefers-reduced-motion: reduce){
  .card .pb-btn, .card .ask-btn, .card .pb-btn::after, .card .ask-btn::after{ transition:none; animation:none; }
}


/* --- Card status badge (bottom-left) --- */
.card .status-badge{
  position:absolute;
  left:14px;
  bottom:10px;
  font-size:12px;
  font-weight:600;
  letter-spacing:.2px;
  opacity:.95;
  background:transparent;
  border:none;
  padding:0;
}

/* Colors per status */
.card .status-verified{   color:#0f766e; }  /* green-teal */
.card .status-draft{      color:#8b5e34; }  /* brownish */
.card .status-deprecated{ color:#b91c1c; }  /* red */
.card .status-duplicate{  color:#2563eb; }  /* blue */

/* Dark mode nudge (slightly brighter) */
html[data-theme="dark"] .card .status-verified{   color:#34d399; }
html[data-theme="dark"] .card .status-draft{      color:#d1a374; }
html[data-theme="dark"] .card .status-deprecated{ color:#f87171; }
html[data-theme="dark"] .card .status-duplicate{  color:#60a5fa; }

/* ============ CHIPS ============ */
.chip{
  display:inline-flex; align-items:center; gap:6px;
  padding:6px 10px; border-radius:999px;
  border:1px solid var(--border); background:var(--chip);
  color:var(--fg); font-size:12px; line-height:1;
}
.chip .x{ cursor:pointer; opacity:.9 }
.chip-plain{ background:transparent; border:1px solid var(--border); color:var(--muted) }

/* ============ CARDS ============ */
.grid{
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
  gap:16px;
  margin-top:12px;
}

/* Constrain only the results grid, keep header/pane full-width */
#list.grid{
  width: 100%;
  max-width: 1120px;      /* cap like the old centered layout */
  justify-self: center;   /* center this grid item inside .wrap (which is display:grid) */
  padding-inline: 20px;   /* keep the same side breathing room */
}

.grid{ display:grid; grid-template-columns:1fr; gap:14px; margin-top:12px }
@media(min-width:860px){ .grid{ grid-template-columns:1fr 1fr } }

.card{
  position:relative; overflow:hidden;
  background:var(--panel); border:1px solid var(--border); border-radius:20px;
  padding:24px; display:flex; flex-direction:column; gap:12px;
  box-shadow:var(--shadow);
  padding-bottom:116px; /* room for anchored buttons */
  transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease;
}
.card:hover{ transform: translateY(-1px) scale(1.02); box-shadow: 0 12px 44px rgba(0,0,0,.10); }
.card::before{
  content:""; position:absolute; inset:-12px; z-index:-1; border-radius:24px;
  filter: blur(26px) saturate(120%);
  background: conic-gradient(from 200deg, var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  opacity:.14; transition: opacity .2s ease;
}
.card:hover::before, .card:focus-visible::before{ opacity:.22 }

.card h3{ margin:0 0 6px 0; font-size:16px; font-weight:600; letter-spacing:.2px; text-transform:lowercase; color:var(--accent) }
.muted{ color:var(--muted) }
.meta{ display:flex; flex-wrap:wrap; gap:8px; margin-top:6px }
.pill{ display:inline-flex; padding:4px 8px; border-radius:999px; background:#eef1ff; border:1px solid #cfd8ff; color:#2a2b66; font-size:12px }
html[data-theme="dark"] .pill{ background:#1a2030; border-color:#2c3a58; color:#d6e2ff }

    /* Prompt Builder + Ask ChatGPT buttons, anchored bottom-right */
    .card .pb-btn{
      position:absolute; right:10px; bottom:48px;
      background:var(--pb-bg); color:var(--pb-text); border:1px solid var(--pb-border);
      display:inline-flex; flex:0 0 auto; width:auto; max-width:max-content; white-space:nowrap;
    }
    .card .ask-btn{
      position:absolute; right:10px; bottom:10px;
      background:var(--pb-bg); color:var(--pb-text); border:1px solid var(--pb-border);
      display:inline-flex; flex:0 0 auto; width:auto; max-width:max-content; white-space:nowrap;
    }
    
    /* NEW: stack the two CTAs with consistent spacing */
.card .card-cta{
  position:absolute; right:10px; bottom:10px;
  display:flex; flex-direction:column; align-items:flex-end; gap:10px;
}
/* When inside the CTA stack, let buttons be flow-positioned (no absolute overlap) */
.card .card-cta .pb-btn,
.card .card-cta .ask-btn{
  position:static; right:auto; bottom:auto;
}
    
    /* More breathing room above the fixed buttons */
#list .card{
  /* give the buttons more headroom */
  padding-bottom: 116px; /* was 80px */
  transition: box-shadow .18s ease, transform .06s ease, border-color .18s ease;
}

/* Add vertical space after the chips/tags stack inside cards */
#list .card .meta{ margin-bottom: 8px; }
#list .card .meta:last-child{ margin-bottom: 16px; }

/* Hover & focus affordance: lift, highlight border */
#list .card:hover,
#list .card:focus-visible{
  border-color: var(--accent);
  box-shadow: var(--shadow), 0 0 0 2px color-mix(in oklab, var(--accent) 35%, transparent);
  transform: translateY(-1px);
  outline: none; /* rely on the custom ring below */
}

/* Clear, lightweight focus ring for keyboard users */
#list .card:focus-visible{
  box-shadow: var(--shadow), 0 0 0 3px color-mix(in oklab, var(--accent) 45%, transparent);
}

/* Optional: tiny “Click to expand” hint badge (top-right) */
#list .card::after{
  content: "Click to expand";
  position: absolute;
  top: 10px;
  right: 12px;
  font-size: 11px;
  line-height: 1;
  padding: 4px 8px;
  border-radius: 999px;
  background: var(--chip);
  border: 1px solid var(--line);
  color: var(--ink-2);
  opacity: 0;
  transform: translateY(-6px);
  transition: opacity .18s ease, transform .18s ease;
  pointer-events: none;
}
#list .card:hover::after,
#list .card:focus-visible::after{ opacity: .9; transform: translateY(0); }

    
    .pb-btn:hover, .ask-btn:hover{ background:var(--pb-bg-hover) }

    /* COUNT */
    .hdr-wrap{display:flex; gap:12px; align-items:baseline}
    .count{color:var(--ink-2); font-size:13px}

    /* ============ MODALS ============ */
    dialog{ border:none; border-radius:16px; padding:0; width:min(920px, 96vw); color:var(--ink) }
    dialog::backdrop{ background:rgba(2,8,21,.55) }
    .modal{ display:grid; grid-template-columns:1.1fr .9fr; gap:0 }
    @media(max-width:900px){ .modal{ grid-template-columns:1fr } }
    .m-left{ padding:18px; background:var(--panel); border-right:1px solid #212a3a }
    .m-right{ padding:18px; background:var(--panel-2) }
    .close{ position:absolute; right:10px; top:10px }

    .field{margin:10px 0}
    .field label{display:block; font-size:13px; color:var(--ink-2); margin-bottom:6px}
    pre.out{background:#0c0f14; border:1px solid #223049; border-radius:10px; padding:12px; white-space:pre-wrap; word-break:break-word; max-height:42vh; overflow:auto}
    html[data-theme="light"] pre.out{ background:#f3f6fb; border-color:#d9e2f0 }

    /* Ask ChatGPT helper dialog */
    #copyDlg .content{ padding:16px; background:var(--panel); border-radius:16px }
    #copyDlg h3{ margin:0 0 8px 0; font-size:18px }
    #copyDlg p{ margin:0 0 10px 0; color:var(--ink-2) }
    #copyDlg textarea{
      width:100%; height:220px; resize:vertical;
      background:var(--panel-2); color:var(--ink);
      border:1px solid var(--line); border-radius:10px; padding:10px;
      font:13px/1.45 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    }
    #copyDlg .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:10px }
    
    /* ===== Slice 2: master search bar (tokens-aware; refined in Slice 3) ===== */
.searchWrap{ width:min(780px,100%); margin: 8px auto 16px; position:relative; z-index:10 }
.search{
  width:100%; display:flex; align-items:center; gap:8px; padding:8px;
  border-radius:999px; position:relative;
  background:var(--panel); border:2px solid transparent;
  background-image: linear-gradient(var(--panel),var(--panel)),
    conic-gradient(from 90deg, var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  background-origin: border-box; background-clip: padding-box, border-box;
  box-shadow: var(--shadow);
}
.search input{ flex:1; font:16px/1.2 inherit; border:none; outline:none; padding:12px 14px; background:transparent; color:var(--fg) }
.search button{
  border:none; border-radius:999px; padding:10px 14px; cursor:pointer; font-weight:600;
  background: var(--btn-primary-bg); color: var(--btn-primary-text); text-transform:lowercase
}

/* subtle glow behind search */
.search::before{
  content:""; position:absolute; inset:-10px; border-radius:999px; z-index:-1;
  filter: blur(22px) saturate(120%);
  background: conic-gradient(from 200deg, var(--r1), var(--r2), var(--r3), var(--r4), var(--r5), var(--r6), var(--r1));
  opacity:.16;
}

/* typeahead panel */
/* Dropdown / suggestion panel */
.ta{
  position:absolute; left:10px; right:10px; top:100%;
  background:var(--panel); border:1px solid var(--border); border-radius:16px;
  margin-top:8px; box-shadow: var(--shadow);
  max-height:260px; overflow:auto; z-index:1000;
}
.ta[hidden]{ display:none }
.ta .item{ padding:10px 12px; cursor:pointer; border-bottom:1px solid var(--border) }
.ta .item:last-child{ border-bottom:none }
.ta .item:hover, .ta .item.active{
  /* subtle theme-aware wash */
  background: color-mix(in oklab, var(--fg) 10%, transparent);
}
.ta .use{ font-size:14px; color:var(--fg) }
.ta .sub{ font-size:12px; color:var(--muted); display:none }

/* ===== Bucket headers inside #list (full-width rows) ===== */
#list .bucket-row { grid-column: 1 / -1; }

#list .section-row{
  display:flex; align-items:center; justify-content:center; gap:10px;
  margin:24px 0 8px;
}
#list .section-row::before,
#list .section-row::after{
  content:""; flex:1 1 auto; height:1px;
  background: linear-gradient(to right, rgba(0,0,0,.15), rgba(0,0,0,.05));
}
html[data-theme="dark"] #list .section-row::before,
html[data-theme="dark"] #list .section-row::after{
  background: linear-gradient(to right, rgba(255,255,255,.22), rgba(255,255,255,.08));
}

#list .section-row .title{
  display:inline-block; padding:6px 10px; border-radius:999px;
  background: var(--chip); border:1px solid var(--line);
  font: 800 11px/1 system-ui, sans-serif;
  letter-spacing:.14em; text-transform:uppercase; color: var(--ink);
}

#list .section-gap{ height:8px; }

  </style>
<!-- Beta/BMC UI -->
<link rel="stylesheet" href="./assets/beta-bmc.css?v=2025-09-29">
<script defer
        src="./assets/beta-bmc.js?v=2025-09-29"
        data-beta="pill"
        data-bmc="discrete"
        data-bmc-dismissible="true"></script>
        
          <!-- Data files -->
  <script>window.GLOSSARY = Array.isArray(window.GLOSSARY) ? window.GLOSSARY : [];</script>
  <script src="./js/glossary.data.js"></script>
  
  <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "Organization",
      "@id": "https://jonathankhobson.github.io/AI/#org",
      "name": "Prompt Builder",
      "url": "https://jonathankhobson.github.io/AI/index.html",
      "logo": {
        "@type": "ImageObject",
        "url": "https://jonathankhobson.github.io/AI/assets/brand/logo-512.png",
        "width": 512,
        "height": 512
      },
      "sameAs": [
        "https://www.linkedin.com/in/jonathankylehobson/"
      ]
    },
    {
      "@type": "WebSite",
      "@id": "https://jonathankhobson.github.io/AI/#website",
      "url": "https://jonathankhobson.github.io/AI/index.html",
      "name": "Prompt Builder",
      "inLanguage": "en-US",
      "publisher": { "@id": "https://jonathankhobson.github.io/AI/#org" },
      "potentialAction": {
        "@type": "SearchAction",
        "target": "https://jonathankhobson.github.io/AI/index.html?q={search_term_string}",
        "query-input": "required name=search_term_string"
      }
    },
    {
      "@type": ["WebPage","CollectionPage"],
      "@id": "https://jonathankhobson.github.io/AI/glossary/index.html#webpage",
      "url": "https://jonathankhobson.github.io/AI/glossary/index.html",
      "name": "AI Glossary — definitions, tags & templates | Prompt Builder",
      "isPartOf": { "@id": "https://jonathankhobson.github.io/AI/#website" },
      "inLanguage": "en-US",
      "description": "Browse an AI glossary of terms, definitions, and tags. Search and filter to learn fast, compare concepts, and jump into prompt templates.",
      "datePublished": "2025-09-30",
      "dateModified": "2025-09-30",
      "primaryImageOfPage": {
        "@type": "ImageObject",
        "url": "https://jonathankhobson.github.io/AI/assets/og/prompt-builder-og.png",
        "width": 1200,
        "height": 630
      },
      "breadcrumb": {
        "@type": "BreadcrumbList",
        "itemListElement": [
          { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://jonathankhobson.github.io/AI/index.html" },
          { "@type": "ListItem", "position": 2, "name": "Glossary", "item": "https://jonathankhobson.github.io/AI/glossary/index.html" }
        ]
      }
    }
  ]
}
</script>
  
</head>
<body data-beta="pill" data-bmc="discrete" data-bmc-dismissible="true">

<a class="skip-link" href="#main">Skip to content</a>



<main id="main">
  <div class="wrap">
    <header>
      <div class="hdr-wrap">
        <a id="backToSearch" class="btn btn-sm" href="../index.html" aria-label="back to home">← back to home</a>
        <h1>AI Glossary</h1>
        <div id="hdrCount" class="count">Showing …</div>
      </div>
      <div class="hdr-actions">
        <a id="hdrPB" class="btn btn-sm" href="prompt-builder.html">Prompt Builder</a>
        <a id="hdrAdd" class="btn btn-sm" href="add-glossaryterm.html">+ Add Term</a>
        <button id="themeBtn" class="btn btn-sm" title="Toggle theme">Light</button>
      </div>
    </header>

    <!-- Keep the pretty master search bar visible; it’s inert in this slice -->
<section class="searchWrap" id="masterSearch">
  <div class="search">
    <input id="qMaster" type="text" placeholder="Search uses, definitions, tags…" autocomplete="off" />
    <button id="goMaster" type="button" title="Search">search</button>
  </div>
  <div id="taMaster" class="ta" role="listbox" hidden></div>
</section>

<section class="pane">
  <div class="controls">
    <div><label class="sub">Search</label><input id="q" placeholder="Search label, definition, tags, notes"/></div>
    <div><label class="sub">Category</label><select id="cat"></select></div>
    <div><label class="sub">Tags</label><input id="tag" placeholder="Search tags"/></div>
    <div><label class="sub">Kind</label><select id="kind"></select></div>
    <div><label class="sub">Topic</label><select id="tagTopic"></select></div>
    <div><label class="sub">Phase</label><select id="tagPhase"></select></div>
    <div><label class="sub">Level</label><select id="tagLevel"></select></div>
    <div><label class="sub">Use</label><select id="tagUse"></select></div>
    <div><label class="sub">Sort</label>
      <select id="sort">
        <option value="term_az">A → Z</option>
        <option value="term_za">Z → A</option>
        <option value="slug">Slug</option>
        <option value="status_term">Status → Term</option>
        <option value="category_term">Category → Term</option>
      </select>
    </div>
    <div><label class="sub">&nbsp;</label><button id="reset" class="btn btn-ghost btn-sm">Reset</button></div>
  </div>

  <!-- A–Z bar -->
  <div id="alpha" class="filters alpha"></div>

  <!-- Active chips -->
  <div id="active" class="filters"></div>
</section>

    <!-- ✅ Cards render here from GLOSSARY -->
    <section id="list" class="grid" aria-live="polite"></section>

    <!-- ✅ Detail modal (rewired for glossary schema) -->
    <dialog id="dlg">
      <button class="btn btn-sm close" id="dlgClose" aria-label="Close">Close ✕</button>
      <div class="modal">
        <div class="m-left">
          <h2 id="dlgTitle" style="margin:0 0 6px 0; font-size:18px"></h2>
          <div class="meta" id="dlgMeta"></div>

          <!-- Definition: larger, primary content -->
          <div id="dlgDef" style="margin:14px 0 14px 0; line-height:1.6"></div>

          <!-- Notes (replaces Use cases/Boosters) -->
          <div id="dlgNotesWrap" style="margin-top:10px">
            <div class="sub">Notes</div>
            <div id="dlgNotes" class="muted" style="margin-top:6px; white-space:pre-wrap"></div>
          </div>

          <!-- Related -->
          <div id="dlgRelatedWrap" style="margin-top:14px">
            <div class="sub">Related</div>
            <div id="dlgRelated" class="meta"></div>
          </div>
        </div>

        <div class="m-right">
          <!-- Sources -->
          <div id="dlgSourcesWrap">
            <div class="sub" style="margin-bottom:6px">Sources</div>
            <ul id="dlgSources" style="margin:6px 0 0 18px; padding:0"></ul>
          </div>

          <!-- CTA stack (Prompt Builder only if type:template) + Ask ChatGPT -->
          <div class="meta" style="margin-top:14px; gap:8px">
            <a id="openPB" class="btn btn-sm pb-btn" href="#" target="_blank" rel="noopener" hidden>Open in Prompt Builder</a>
            <a id="askBtnModal" class="btn btn-sm ask-btn" href="#" target="_blank" rel="noopener">💬 Ask ChatGPT</a>
          </div>
        </div>
      </div>
    </dialog>

    <!-- Ask ChatGPT helper dialog (clipboard confirm) -->
    <dialog id="copyDlg">
      <div class="content">
        <h3 id="copyTitle">Prompt copied ✓</h3>
        <p>A new tab opened with ChatGPT. If the message isn’t prefilled there, just paste (Ctrl/⌘+V) into the chat box.</p>
        <textarea id="copyText" readonly></textarea>
        <div class="actions">
          <button id="copyAgain" class="btn btn-sm">Copy again</button>
          <button id="copyClose" class="btn btn-sm btn-ghost">Got it</button>
        </div>
      </div>
    </dialog>
  </div>
  
  </main>

<script>
/* ========== Utilities (kept) ========== */
const $=(s,e=document)=>e.querySelector(s);
const $$=(s,e=document)=>Array.from(e.querySelectorAll(s));
const h=(t,p={},...kids)=>{
  const el=document.createElement(t);
  for(const[k,v] of Object.entries(p)){
    if(k==='class') el.className=v;
    else if(k==='text') el.textContent=v;
    else if(k==='dataset') for(const[dk,dv] of Object.entries(v)) el.dataset[dk]=dv;
    else if(k.startsWith('on')) el.addEventListener(k.slice(2), v);
    else if(v!=null) el.setAttribute(k,v);
  }
  for(const kid of kids.flat()){
    if(kid==null) continue;
    el.appendChild(typeof kid==='string' ? document.createTextNode(kid) : kid);
  }
  return el;
};
const unique = a => Array.from(new Set(a));
const cleanTag = t => {
  if (typeof t !== 'string') return '';
  const i = t.indexOf(':');
  return i >= 0 ? t.slice(i+1).trim() : t.trim();
};
const slugify = s => String(s||'').toLowerCase().trim()
  .replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
  
  function hasTypeTemplateTag(tags){
  const arr = Array.isArray(tags) ? tags : [];
  return arr.some(t => {
    const s = String(t||'').toLowerCase().trim();
    if (s === 'type:template') return true;
    const i = s.indexOf(':');
    const val = i >= 0 ? s.slice(i+1).trim() : s;
    return val === 'template';
  });
}

function safeKey(t){
  const cands=[t.id,t.slug,t.label].map(x=>String(x||'').trim().toLowerCase()).filter(Boolean);
  const nonNone=cands.find(k=>k!=='none');
  return nonNone || cands[0] || Math.random().toString(36).slice(2);
}
function safeLinkId(t){
  const cand = (t.id && t.id.toLowerCase()!=='none') ? t.id
             : (t.slug && t.slug.toLowerCase()!=='none') ? t.slug
             : slugify(t.label)||'template';
  return cand;
}
function cleanCategories(arr){
  const inArr = Array.isArray(arr) ? arr : [];
  return unique(inArr.map(c => (String(c).toLowerCase()==='none' ? 'Framework' : c)));
}
async function copyText(txt){
  try { await navigator.clipboard.writeText(txt); return true; }
  catch {
    const ta = document.createElement('textarea');
    ta.style.position='fixed'; ta.style.left='-9999px'; ta.value=txt;
    document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove();
    return true;
  }
}

/* ========== Theme (label shows NEXT theme) ========== */
const THEME_KEY='templates.theme';
function applyTheme(){
  const t = localStorage.getItem(THEME_KEY) || 'light';
  document.documentElement.setAttribute('data-theme', t);
  $('#themeBtn').textContent = t === 'dark' ? 'Light' : 'Dark';
}
$('#themeBtn').addEventListener('click', ()=>{
  const cur = localStorage.getItem(THEME_KEY) || 'light';
  const next = cur === 'dark' ? 'light' : 'dark';
  localStorage.setItem(THEME_KEY, next);
  applyTheme();
});
applyTheme();

/* ========== Data aggregation (kept) ========== */
function aggregateGlossary(){
  const src = Array.isArray(window.GLOSSARY) ? window.GLOSSARY : [];
  const out = [];
  const seen = new Set();

  for (const g of src){
    if (!g) continue;
    const slug = g.slug || slugify(g.term||'');
    if (!slug || seen.has(slug)) continue;
    seen.add(slug);

    const cleanedTags = (Array.isArray(g.tags) ? g.tags : []).map(t=>{
      if (typeof t !== 'string') return '';
      const i = t.indexOf(':');
      return i >= 0 ? t.slice(i+1).trim() : t.trim();
    }).filter(Boolean);
    
        // Namespace split: { topic:[...], phase:[...], level:[...], ... }
    const ns = {};
    for (const raw of (g.tags || [])) {
      const s = String(raw || '');
      const i = s.indexOf(':');
      if (i > -1) {
        const k = s.slice(0, i).trim().toLowerCase();
        const v = s.slice(i + 1).trim();
        if (k && v) (ns[k] ||= []).push(v);
      }
    }
    
    // ---- Slice 2 additions: aliases + Notes→use
// 1) Merge `type:` into the Kind facet (present to the user as “Kind”)
if (ns.type && ns.type.length) {
  ns.kind = (ns.kind || []).concat(ns.type);
}

// 2) Treat `difficulty:` as an alias of Level
if (ns.difficulty && ns.difficulty.length) {
  ns.level = (ns.level || []).concat(ns.difficulty);
}

// 3) Build synthetic `use:` from notes.
//    Supports lines like:
//      - "Use cases: X, Y, Z"
//      - "Used in X, Y, Z."
//      - "Common in A and B."
//      - "Applied in …" / "Seen in …"
if (g.notes) {
  const raw = String(g.notes);

  // Helper: split a phrase list into tokens
  const splitList = (s) => {
    return s
      .split(/[,;/]|(?:\s+and\s+)/i)
      .map(x => x.replace(/\betc\.?$/i,'').trim())
      .filter(Boolean);
  };

  // A) Classic "Use cases:" line (same line only)
  const mUC = raw.match(/(^|\n)\s*Use\s*(?:cases?)?\s*:\s*([^\n]+)/i);
  if (mUC && mUC[2]) {
    ns.use = (ns.use || []).concat(splitList(mUC[2]));
  }

  // B) “Used/Common/Applied/Seen in …” sentences (capture until period or line end)
  const reIn = /(Used in|Common in|Applied in|Seen in)\s+([^.]+)(?:\.|$)/ig;
  let m;
  while ((m = reIn.exec(raw)) !== null) {
    ns.use = (ns.use || []).concat(splitList(m[2]));
  }
}

// 4) De-dup values in each namespace
for (const k of Object.keys(ns)) {
  ns[k] = Array.from(new Set(ns[k]));
}

    out.push({
      // Core identity
      label: g.term || slug,
      id: slug,
      slug,
      _tagsByNs: ns,

      // Display content
      definition: g.definition || '',
      notes: g.notes || '',

      // Vocab & metadata
      status: g.status || '',
      categories: Array.isArray(g.categories) ? g.categories : [],
      tags: Array.isArray(g.tags) ? g.tags : [],
      aliases: Array.isArray(g.aliases) ? g.aliases : [],
      related: Array.isArray(g.related) ? g.related : [],
      sources: Array.isArray(g.sources) ? g.sources : [],

      // Derived (so existing render/search code doesn’t explode)
      _cleanedTags: cleanedTags,
      _displayKind: g.status || 'Glossary',
      _displayCats: Array.isArray(g.categories) ? g.categories : []
    });
  }
  return out;
}
const DATA = aggregateGlossary();

/* search index */
for(const t of DATA){
  const bits = [
    t.label, t.slug, t.id, t._displayKind, t.definition, t.notes,
    ...(t.aliases||[]),
    ...(t._displayCats||[]),
    ...(t.tags||[]),
    ...(t._cleanedTags||[])
  ].filter(Boolean).join(' ').toLowerCase();
  t._search = bits;
}

/* ========== Filters (kept) ========== */
const state = {
  q:'', kind:'', cat:'', tag:'',
  topic:'', phase:'', level:'', use:'',
  sort:'term_az',    // default sort
  alpha:'',          // A–Z filter ('' means off)
  slug: []
};


function fillSelect(sel, list, labelAll='All'){
  sel.innerHTML = '';
  sel.append(h('option', {value:''}, labelAll));
  for(const v of list){ sel.append(h('option', {value:v}, v)); }
}

function setControlVisible(selectId, visible){
  const el = document.getElementById(selectId);
  if (!el) return;
  const wrapper = el.closest('div');
  if (wrapper) wrapper.style.display = visible ? '' : 'none';
}


// Namespaced tag helpers
const TAG_NAMESPACES = ['topic','phase','level','use'];

// Map state fields -> control IDs (so we can clear UI + state in sync)
const ID_FOR_FIELD = {
  q:'q', kind:'kind', cat:'cat', tag:'tag',
  topic:'tagTopic', phase:'tagPhase', level:'tagLevel', use:'tagUse',
  sort:'sort'
};

// One canonical "clear everything" helper
function clearAll(){
// reset state (including slug, alpha, sort)
state.q = state.kind = state.cat = state.tag =
state.topic = state.phase = state.level = state.use = '';
state.alpha = '';
state.sort = 'term_az';
state.slug = [];

  // reset controls (skip gracefully if an element doesn't exist)
  Object.values(ID_FOR_FIELD).forEach(id=>{
    const el = document.getElementById(id);
    if (el) el.value = '';
  });

  // remove `slug` from the URL (don’t reload)
  const params = new URLSearchParams(location.search);
  params.delete('slug');
  const qs = params.toString();
  history.replaceState(null, '', location.pathname + (qs ? ('?'+qs) : ''));

  // also clear master search UI (if present)
  const qm = document.getElementById('qMaster'); if (qm) qm.value = '';
  window.hideTAMaster?.();

  // keep the one-shot slug init guard consistent
  if (!window.__INIT_DONE__) { initSlugFromURL(); window.__INIT_DONE__ = true; }

  renderAlphaBar(); render();
}



// Namespace aliases for facets the user expects
const NS_ALIASES = {
  kind: ['kind','type'],
  level: ['level','difficulty'],
  use: ['use'],
  topic: ['topic'],
  phase: ['phase']
};

function allTagValuesBy(ns){
  const keys = NS_ALIASES[ns] || [ns];
  const vals = [];

  for (const d of DATA){
    // Prefer the pre-split namespaces (includes our synthetic `use`)
    for (const k of keys){
      if (d._tagsByNs && Array.isArray(d._tagsByNs[k])) {
        vals.push(...d._tagsByNs[k]);
      }
    }

    // Fallback: scan raw tags if _tagsByNs was missing this key
    if (d.tags && d.tags.length){
      for (const raw of d.tags){
        const s = String(raw||'');
        const i = s.indexOf(':');
        if (i > -1){
          const k = s.slice(0,i).trim().toLowerCase();
          const v = s.slice(i+1).trim();
          if (keys.includes(k) && v) vals.push(v);
        }
      }
    }
  }
  return Array.from(new Set(vals)).sort();
}

// NOW it’s safe to compute:
const allKinds = allTagValuesBy('kind');
const allCats  = unique(DATA.flatMap(d=>d._displayCats||[])).sort();

fillSelect($('#kind'), allKinds);
fillSelect($('#cat'), allCats);

// Fill the four dropdowns
const topics = allTagValuesBy('topic');
const phases = allTagValuesBy('phase');
const levels = allTagValuesBy('level');   // level + difficulty
const uses   = allTagValuesBy('use');     // from notes or tags

fillSelect($('#tagTopic'), topics, 'All Topics');
fillSelect($('#tagPhase'), phases, 'All Phases');
fillSelect($('#tagLevel'), levels, 'All Levels');
fillSelect($('#tagUse'),   uses,   'All Uses');

setControlVisible('tagLevel', levels.length > 0);
setControlVisible('tagUse',   uses.length   > 0);

// ----- Sorts
const STATUS_ORDER = ['verified','draft','duplicate_candidate','deprecated'];
const statusRank = s => {
  const i = STATUS_ORDER.indexOf(String(s||'').toLowerCase());
  return i === -1 ? 999 : i;
};
const cmp = (a,b) => String(a||'').localeCompare(String(b||''));

const SORTS = {
  term_az: (a,b)=> cmp(a.label, b.label) || cmp(a.slug, b.slug),
  term_za: (a,b)=> cmp(b.label, a.label) || cmp(a.slug, b.slug),
  slug:    (a,b)=> cmp(a.slug, b.slug)   || cmp(a.label, b.label),
  status_term: (a,b)=> (statusRank(a.status)-statusRank(b.status)) || cmp(a.label, b.label),
  category_term: (a,b)=> cmp((a._displayCats?.[0]||''), (b._displayCats?.[0]||'')) || cmp(a.label, b.label)
};


$('#q').addEventListener('input', ()=>{ state.q=$('#q').value; render(); });
$('#kind').addEventListener('change', ()=>{ state.kind=$('#kind').value; render(); });
$('#cat').addEventListener('change',  ()=>{ state.cat=$('#cat').value; render(); });
$('#tag').addEventListener('input',  ()=>{ state.tag=$('#tag').value; render(); });

$('#tagTopic').addEventListener('change', ()=>{ state.topic=$('#tagTopic').value; render(); });
$('#tagPhase').addEventListener('change', ()=>{ state.phase=$('#tagPhase').value; render(); });
$('#tagLevel').addEventListener('change', ()=>{ state.level=$('#tagLevel').value; render(); });
$('#tagUse').addEventListener('change',   ()=>{ state.use=$('#tagUse').value;   render(); });
$('#sort').addEventListener('change', ()=>{ state.sort=$('#sort').value; render(); });


$('#reset').addEventListener('click', ()=>{ clearAll(); });

// ----- A–Z filter bar
const ALPH = '#ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split(''); // '#' = non-letter

function renderAlphaBar(){
  const el = document.getElementById('alpha');
  if (!el) return;
  el.innerHTML = '';

  // label
  el.append(h('label', { class:'sub' }, 'A–Z'));

  for (const ch of ALPH){
    const chip = h('span', {
      class: 'chip' + (state.alpha===ch ? ' active' : ''),
      onclick: (e)=>{ 
        e.preventDefault();
        state.alpha = (state.alpha===ch ? '' : ch);
        render();
      },
      title: ch === '#' ? 'Non-letter' : `Starts with ${ch}`
    }, ch);
    el.append(chip);
  }
}

// --- Slice 1: one-time `?slug=` initialization ---
function initSlugFromURL(){
  const params = new URLSearchParams(location.search);
  const raw = (params.get('slug') || '').trim();
  if (!raw) return;

  // normalize to slug form; allow comma-separated
  const wanted = raw.split(',').map(s => slugify(s)).filter(Boolean);
  if (!wanted.length) return;

  // See if at least one template matches our normalized keys; otherwise ignore
  const anyMatch = DATA.some(d => {
    const keys = [
      d.id, d.slug, slugify(d.label), safeLinkId(d)
    ].map(x => String(x||'').toLowerCase());
    return wanted.some(w => keys.includes(w));
  });
  if (!anyMatch) return;

  state.slug = wanted; // adopt as pre-filter
}


function matches(d){
  const q = state.q.trim().toLowerCase();
  if (q && !d._search.includes(q)) return false;
    // Slug pre-filter: match id, slug, label-slug, or safeLinkId
  if (Array.isArray(state.slug) && state.slug.length){
    const keys = [d.id, d.slug, slugify(d.label), safeLinkId(d)]
      .map(x => String(x||'').toLowerCase());
    const hit = state.slug.some(w => keys.includes(w));
    if (!hit) return false;
  }

  function hasNsValue(d, ns, value){
  const keys = (NS_ALIASES && NS_ALIASES[ns]) || [ns];
  const want = String(value||'').toLowerCase();
  for (const k of keys){
    const arr = (d._tagsByNs?.[k] || []);
    if (arr.some(x => String(x).toLowerCase() === want)) return true;
  }
  return false;
}

// ...
if (state.kind && !hasNsValue(d, 'kind', state.kind)) return false;
  if (state.cat && !(d._displayCats||[]).includes(state.cat)) return false;
  
  const tg = state.tag.trim().toLowerCase();
  if (tg){
    const cleaned=(d._cleanedTags||[]).map(x=>x.toLowerCase());
    if (!cleaned.some(x => x.includes(tg))) return false;
  }
  
  // Namespaced tag filters (exact match against values, case-insensitive)
const want = (ns) => (state[ns]||'').trim().toLowerCase();
if (want('topic') && !(d._tagsByNs?.topic||[]).some(x => x.toLowerCase() === want('topic'))) return false;
if (want('phase') && !(d._tagsByNs?.phase||[]).some(x => x.toLowerCase() === want('phase'))) return false;
if (want('level') && !hasNsValue(d, 'level', want('level'))) return false;
if (want('use')   && !hasNsValue(d, 'use',   want('use')))   return false;


// A–Z filter on label (first character), non-letters bucketed to '#'
if (state.alpha){
  const first = (String(d.label||'').trim()[0] || '').toUpperCase();
  const bucket = /^[A-Z]$/.test(first) ? first : '#';
  if (bucket !== state.alpha) return false;
}
  
  return true;
}

function renderActiveFilters(rowsTotal){
  const all = DATA.length;
  const active = $('#active'); active.innerHTML = '';

  const chips=[];
  if(state.q)    chips.push(['Search', `"${state.q}"`, 'q']);
  if(state.kind) chips.push(['Kind', state.kind, 'kind']);
  if(state.cat)  chips.push(['Category', state.cat, 'cat']);
  if(state.tag)  chips.push(['Tags', `"${state.tag}"`, 'tag']);
  if(state.topic) chips.push(['Topic', state.topic, 'topic']);
  if(state.phase) chips.push(['Phase', state.phase, 'phase']);
  if(state.level) chips.push(['Level', state.level, 'level']);
  if(state.use)   chips.push(['Use',   state.use,   'use']);
    if(state.alpha) chips.push(['A–Z', state.alpha, 'alpha']);

  $('#hdrCount').textContent = `Showing ${rowsTotal} of ${all}`;

  // consider slug chips too — don’t early-return if only slug is active
  const hasSlug = Array.isArray(state.slug) && state.slug.length > 0;
  const hasAny = chips.length > 0 || hasSlug;

  if(!hasAny){
    active.append(h('span',{class:'chip chip-plain'}, 'No active filters'));
    return;
  }

  // normal chips
  for(const [k,v,field] of chips){
    const chip = h('span',{class:'chip'},
      `${k}: ${v} `,
      h('span',{class:'x', onclick:()=>{ 
  state[field]=''; 
  const el=$('#'+field); 
  if(el) el.value=''; 
  render(); 
}}, '✕')
    );
    active.append(chip);
  }

  // slug chips
  if (hasSlug){
    for (const s of state.slug){
      const chip = h('span',{class:'chip'},
        `Slug: ${s} `,
        h('span',{
          class:'x',
          onclick:()=>{
            state.slug = state.slug.filter(x => x !== s);
            if (!state.slug.length){
              const params = new URLSearchParams(location.search);
              params.delete('slug');
              const qs = params.toString();
              history.replaceState(null, '', location.pathname + (qs ? ('?'+qs) : ''));
            }
            render();
          }
        }, '✕')
      );
      active.append(chip);
    }
  }

  // one clear-all that also clears slug
  active.append(
    h('a', {href:'#', class:'btn-link', onclick:(e)=>{ e.preventDefault(); clearAll(); }}, 'Clear all')
  );
}

/* ===== Slice 2: Use-case Master Search (portable) ===== */
/* Data contract: uses window.TEMPLATES/FRAMEWORKS + window.TASK_TEMPLATES/tasks */

/* ===== Slice 3: Glossary Master Search (uses DATA built from glossary.data.js) ===== */
(function masterSearchGlossary(){
  // --- DOM
  const qEl  = document.getElementById('qMaster');
  const taEl = document.getElementById('taMaster');
  const goEl = document.getElementById('goMaster');
  const wrap = document.getElementById('masterSearch');
  if (!qEl || !taEl || !goEl || !wrap) return;

  // --- Recents
  const RECENT_KEY = 'glossary_recent_queries';
  const MAX_RECENT = 12;
  const loadRecent = () => { try{ return JSON.parse(localStorage.getItem(RECENT_KEY)||'[]'); }catch{ return []; } };
  const saveRecent = (q) => {
    q = String(q||'').trim(); if (!q) return;
    let list = loadRecent().filter(s => s && s.toLowerCase() !== q.toLowerCase());
    list.unshift(q); if (list.length > MAX_RECENT) list = list.slice(0, MAX_RECENT);
    localStorage.setItem(RECENT_KEY, JSON.stringify(list));
  };

  // --- Helpers
  const plain = (html) => String(html||'').replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').trim();
  const clip  = (s, n=160) => (s.length>n ? s.slice(0,n-1)+'…' : s);
  const escRe = (s) => s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');

  // pull `use` list from our Slice-2 aggregator (_tagsByNs.use already includes parsed Notes)
  const usesOf = (d) => Array.isArray(d._tagsByNs?.use) ? d._tagsByNs.use : [];

  // Build a lightweight index from DATA (already available)
  function buildIndex(){
    return DATA.map(d=>{
      const def = plain(d.definition||'');
      const nts = plain(d.notes||'');
      const uzz = usesOf(d);
      const tagsRaw = (d.tags||[]).map(String);
      const tagsClean = (d._cleanedTags||[]).map(String);
      const cats = (d._displayCats||[]).map(String);
      const aliases = (d.aliases||[]).map(String);
      const related = (d.related||[]).map(String);

      return {
        id: d.id, slug: d.slug, label: d.label,
        // display candidates (prefer use, else definition)
        uses: uzz,
        def,
        notes: nts,
        // rankable fields
        label_l: String(d.label||'').toLowerCase(),
        def_l: def.toLowerCase(),
        notes_l: nts.toLowerCase(),
        uses_l: uzz.map(u=>String(u).toLowerCase()),
        aliases_l: aliases.map(a=>a.toLowerCase()),
        cats_l: cats.map(c=>c.toLowerCase()),
        related_l: related.map(r=>r.toLowerCase()),
        tags_l: tagsClean.map(t=>t.toLowerCase()),
        tagsRaw_l: tagsRaw.map(t=>t.toLowerCase())
      };
    });
  }

  function rankSuggestions(q, idx, limit=8){
    const raw = String(q||'').trim().toLowerCase();
    const toks = raw.split(/[^a-z0-9]+/).filter(Boolean);
    if (!toks.length) return []; // we show recents on focus when empty

    const hits = [];

    for (const t of idx){
      let bestType = '';
      let bestText = '';
      let bestScore = 0;

      // field-weighted scoring
      const scoreField = (text, base)=> {
        const l = String(text||'').toLowerCase();
        if (!l) return 0;
        let s = 0;
        if (raw && l === raw) s += base + 120;          // exact
        else if (raw && l.includes(raw)) s += base + 60; // substring
        for (const tok of toks){
          if (!tok) continue;
          const re = new RegExp(`\\b${escRe(tok)}\\b`, 'i');
          if (re.test(l)) s += 30;
          const pos = l.indexOf(tok);
          if (pos >= 0){ s += 18; if (pos === 0) s += 8; }
        }
        // length bonus for succinct phrases
        s += Math.max(0, 18 - Math.min(18, Math.floor(l.length/12)));
        return s;
      };

      // 1) use-cases (highest priority)
      for (const u of (t.uses||[])){
        const s = scoreField(u, 200);
        if (s > bestScore){ bestScore = s; bestType='use'; bestText=u; }
      }

      // 2) definition (fallback if no good use match)
      const sDef = scoreField(t.def, 140);
      if (sDef > bestScore){ bestScore = sDef; bestType='def'; bestText=t.def; }

      // 3) other notes (slightly lower than def)
      const sNotes = scoreField(t.notes, 120);
      if (sNotes > bestScore){ bestScore = sNotes; bestType='note'; bestText=t.notes; }

      // 4) additional boosts from metadata (do not replace display text)
      const boost = (
          // use tags (again) but as booster
          (t.uses_l.some(u => toks.some(tok=>u.includes(tok))) ? 24 : 0)
        + (t.aliases_l.some(a => toks.some(tok=>a.includes(tok))) ? 18 : 0)
        + (t.cats_l.some(c => toks.some(tok=>c.includes(tok))) ? 14 : 0)
        + (t.related_l.some(r => toks.some(tok=>r.includes(tok))) ? 12 : 0)
        + (t.label_l.includes(raw) ? 22 : 0)
        + (t.tags_l.some(tag => toks.some(tok=>tag.includes(tok))) ? 8 : 0)
      );
      bestScore += boost;

      if (bestScore > 0){
        hits.push({
          score: bestScore,
          type: bestType,
          text: bestText,
          label: t.label,
          id: t.id, slug: t.slug
        });
      }
    }

    hits.sort((a,b)=> (b.score - a.score) || a.text.length - b.text.length || a.label.localeCompare(b.label));
    return hits.slice(0, limit).map(h => ({
      ...h,
      // Presentation: show "use phrase" (no prefix) or clipped definition/notes
      show: clip(h.text || '')
    }));
  }

  // Idle/recents suggestions
  function buildIdleSuggestions(idx, limit=8){
    const out = [];
    for (const r of loadRecent()){
      if (!r) continue;
      out.push({ score:1000, type:'recent', text:r, show:r, label:'recent' });
      if (out.length >= limit) break;
    }
    return out;
  }

  // UI: render dropdown
  function renderTA(list){
    if (!list.length){ taEl.hidden = true; taEl.innerHTML=''; active=-1; return; }
    taEl.innerHTML = list.map((s,i)=>`
      <div class="item${i===0?' active':''}" role="option" data-i="${i}">
        <div class="use">${s.show || ''}</div>
        <div class="sub" aria-hidden="true">${s.label || ''}</div>
      </div>
    `).join('');
    taEl.hidden = false; active = 0;
  }
  function hideTA(){ taEl.hidden = true; taEl.innerHTML=''; active=-1; }

  // Query plumbing
  const INDEX = buildIndex();
  let SUGS = [];
  let active = -1;
  let picked = null;

  function onQuery(){
    const q = qEl.value.trim();
    const focused = document.activeElement === qEl;
    if (!q){
      if (focused){ SUGS = buildIdleSuggestions(INDEX, 8); renderTA(SUGS); }
      else hideTA();
      return;
    }
    SUGS = rankSuggestions(q, INDEX, 8);
    renderTA(SUGS);
  }

  function runSearch(){
    const q = qEl.value.trim();
    if (!q) return;
    saveRecent(q);
    // mirror into pane search + render
    state.q = q;
    const qFilter = document.getElementById('q');
    if (qFilter) qFilter.value = q;
    render();
    hideTA();
    document.getElementById('list')?.scrollIntoView({ behavior:'smooth', block:'start' });
  }

  function choose(i){
    const items = Array.from(taEl.children);
    const it = items[i]; if (!it) return;
    const s  = SUGS[i];  if (!s)  return;
    // put suggestion text into the box and run
    qEl.value = s.text || s.show || '';
    runSearch();
  }

  // Events
  qEl.addEventListener('input', onQuery);
  qEl.addEventListener('keydown', (e)=>{
    const open = !taEl.hidden && taEl.children.length;
    if (open && (e.key === 'ArrowDown' || e.key === 'ArrowUp')){
      e.preventDefault();
      active = Math.max(0, Math.min(taEl.children.length-1, active + (e.key==='ArrowDown'?1:-1)));
      [...taEl.children].forEach((n,i)=> n.classList.toggle('active', i===active));
    } else if (e.key === 'Enter'){
      e.preventDefault();
      if (open){ choose(active>=0 ? active : 0); }
      else { if (!picked && SUGS[0]) picked = SUGS[0]; runSearch(); }
    } else if (e.key === 'Escape'){
      hideTA();
    }
  });
  taEl.addEventListener('mousedown', (e)=>{
    const el = e.target.closest('.item'); if (!el) return;
    const i = parseInt(el.dataset.i,10) || 0;
    choose(i);
  });
  goEl.addEventListener('click', ()=>{
    if (!picked && SUGS[0] && !taEl.hidden){ choose(0); }
    else runSearch();
  });
  qEl.addEventListener('focus', ()=>{
    if (!qEl.value.trim()){ SUGS = buildIdleSuggestions(INDEX, 8); renderTA(SUGS); }
    else onQuery();
  });
  qEl.addEventListener('blur', ()=> setTimeout(hideTA, 80));
  document.addEventListener('pointerdown', (e)=>{ if (!wrap.contains(e.target)) hideTA(); });

  // expose so clearAll() can close it
  window.hideTAMaster = hideTA;
})();




/* ========== Ask ChatGPT prompt builder ========== */
function buildTemplateSummary(t){
  const parts = [];
  const line = (k,v)=> v ? parts.push(`${k}: ${v}`) : null;

  line('Label', t.label || '');
  line('Kind', t._displayKind || '');
  if (t._displayCats?.length) line('Categories', t._displayCats.join(', '));
  if (t._cleanedTags?.length) line('Tags', t._cleanedTags.join(', '));
  if (t.definition) parts.push('\nDefinition:\n' + t.definition);
  if (t.help)       parts.push('\nHelp:\n' + t.help);
  if (t.use_cases?.length) parts.push('\nUse cases:\n- ' + t.use_cases.join('\n- '));
  if (t.boosters?.length) parts.push('\nBoosters:\n- ' + t.boosters.join('\n- '));

  const fields = Array.isArray(t.fields) ? t.fields : [];
  if (fields.length){
    parts.push('\nFields:');
    for (const f of fields){
      const bits=[];
      if (f.desc) bits.push(f.desc);
      if (f.placeholder||f.ph) bits.push('Hint: '+(f.placeholder||f.ph));
      if (f.type) bits.push('Type: '+f.type);
      if (Array.isArray(f.options) && f.options.length){
        const opts = f.options.map(o => typeof o==='object' ? (o.label||o.value) : o).filter(Boolean).join(', ');
        if (opts) bits.push('Options: '+opts);
      }
      parts.push(`- ${f.label || f.key || '(field)'}${bits.length? ' — ' + bits.join(' · ') : ''}`);
    }
  }
  return parts.join('\n');
}

function buildChatGPTPrompt(t){
  const kind = (t._displayKind || 'framework').toLowerCase();
  const summary = buildTemplateSummary(t);

  return [
    `You are an expert AI tutor specializing in prompt engineering. I am reviewing "${t.label}" in an AI glossary and I will share its full structure with you below to prime your understanding:`,
    ``,
    summary,
    ``,
    `Please begin by asking me what I would like to accomplish using this term. Then:`,
    `1) Explain the $${t.label} at a practitioner level with 1–2 concrete examples.`,
    `2) Contrast it with closely related terms (if any) and note common confusions.`,
    `3) Offer pitfalls, best practices, and a short checklist.`,
    `4) Suggest 3 reputable resources for deeper reading (link if possible).`,
    `5) Guide the user through the term "${t.label || t.slug || t.id || ''}".`
  ].join('\n');
}

function openChatGPTWithPrompt(prompt){
  const MAX_Q = 4000; // keep URL tolerable; full text still on clipboard
  const q = encodeURIComponent(prompt.slice(0, MAX_Q));
  const url = `https://chat.openai.com/?q=${q}`;
  window.open(url, '_blank', 'noopener');
}

function showCopyDialog(text, title='Prompt copied ✓'){
  $('#copyTitle').textContent = title;
  $('#copyText').value = text;
  $('#copyDlg').showModal();
}

$('#copyAgain').addEventListener('click', async ()=>{
  await copyText($('#copyText').value);
});
$('#copyClose').addEventListener('click', ()=> $('#copyDlg').close());
$('#copyDlg').addEventListener('click', (e)=>{
  const box = $('.content', $('#copyDlg'));
  if (!box.contains(e.target)) $('#copyDlg').close();
});

/* ========== List rendering (adds Ask ChatGPT button on cards) ========== */
const listEl = $('#list');

/* ===== Bucket config (first category wins) ===== */
const BUCKET_ORDER = [
  'foundations',
  'principles',
    'mental models',
  'prompt patterns',
  'types of prompts',
  'prompt architecture',
  'orchestration',
  'multi-prompt strategies',
  'evaluation'
].map(s => s.toLowerCase());

// Custom display labels (keys are lowercase BUCKET_ORDER entries)
const BUCKET_LABELS = {
  'orchestration': 'Prompt Orchestration',
  'evaluation': 'Prompt Evaluation'
};

const OTHER_LABEL = 'ALL OTHER TERMS';

/* Title-case helper for section headers */
function titleCaps(s){
  return String(s||'')
    .split(' ')
    .map(w => w ? (w[0].toUpperCase() + w.slice(1)) : w)
    .join(' ');
}

/* Section header + gap nodes (full-width inside the grid) */
function makeSectionHeader(label){
  const row = h('div', { class:'bucket-row' });
  const sr  = h('div', { class:'section-row' }, h('span', { class:'title' }, label));
  row.append(sr);
  return row;
}
function makeSectionGap(){ return h('div', { class:'bucket-row section-gap' }); }

/* Card builder (extracted from your existing loop, unchanged) */
function makeCard(t){
  const meta = h('div',{class:'meta'},
    ...(t._displayCats||[]).map(c=>h('span',{class:'pill'}, c))
  );
  const tags = h('div',{class:'meta'}, ...(t._cleanedTags||[]).map(tag=>h('span',{class:'chip'}, tag)));
  const def  = h('div',{class:'muted'}, t.definition || '');

  const linkId = safeLinkId(t);
  const pbUrl = `prompt-builder.html#${encodeURIComponent(linkId)}`;

  const askBtn = h('a',{
    class:'btn ask-btn btn-xs right',
    href: '#',
    onclick: async (e)=>{ e.preventDefault();
      const prompt = buildChatGPTPrompt(t);
      await copyText(prompt);
      openChatGPTWithPrompt(prompt);
      showCopyDialog(prompt);
    }
  }, '💬 Ask ChatGPT');

  const cardBody = h('div',{style:'flex:1'},
    h('h3',{}, t.label),
    def,
    meta,
    tags
  );

  const card = h('div',{
    class:'card',
    role:'button',
    tabIndex:'0',
    'aria-label': `Expand details for ${t.label || t.slug || t.id || 'template'}`
  });
  const ctaWrap = h('div', { class: 'card-cta' });

  if (hasTypeTemplateTag(t.tags)) {
    ctaWrap.append(
      h('a', {
        class: 'btn pb-btn btn-xs right',
        href: pbUrl, target: '_blank', rel: 'noopener'
      }, 'Open in Prompt Builder')
    );
  }
  ctaWrap.append(askBtn);
  card.append(cardBody, ctaWrap);

  // Bottom-left status badge
  const status = String(t.status||'').toLowerCase();
  const statusMap = {
    verified: ['Verified','status-verified'],
    draft: ['Draft','status-draft'],
    deprecated: ['Deprecated','status-deprecated'],
    duplicate_candidate: ['Duplicate','status-duplicate'],
    duplicate: ['Duplicate','status-duplicate']
  };
  if (status && statusMap[status]) {
    const [label, cls] = statusMap[status];
    const statusEl = h('div', { class: `status-badge ${cls}` }, label);
    card.append(statusEl);
  }

  // open modal on card (but not when PB/Ask clicked)
  card.addEventListener('click', (e)=>{
    if(e.target.closest('.pb-btn') || e.target.closest('.ask-btn')) return;
    openModal(t, pbUrl);
  });
  card.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter' || e.key === ' '){
      if(e.target.closest('.pb-btn') || e.target.closest('.ask-btn')) return;
      e.preventDefault();
      openModal(t, pbUrl);
    }
  });

  return card;
}

function render(){
  renderAlphaBar();
  const rows = DATA.filter(matches).sort(SORTS[state.sort] || SORTS.term_az);
  renderActiveFilters(rows.length);
  listEl.innerHTML = '';

  // 1) Build buckets by first category (case-insensitive)
  const buckets = new Map(BUCKET_ORDER.map(k => [k, []]));
  const other = [];

  for (const t of rows){
    const firstCat = String((t._displayCats?.[0] || '')).toLowerCase();
    if (firstCat && buckets.has(firstCat)) buckets.get(firstCat).push(t);
    else other.push(t);
  }

  // 2) Render in declared order, with headers and gaps
  let printed = 0;

  for (const key of BUCKET_ORDER){
    const items = buckets.get(key) || [];
    if (!items.length) continue;

    if (printed) listEl.append(makeSectionGap());
    listEl.append(makeSectionHeader(BUCKET_LABELS[key] || titleCaps(key)));

    for (const t of items) listEl.append(makeCard(t));
    printed++;
  }

  // 3) Render leftovers under "Other"
  if (other.length){
    if (printed) listEl.append(makeSectionGap());
    listEl.append(makeSectionHeader(OTHER_LABEL));
    for (const t of other) listEl.append(makeCard(t));
  }
}
if (!window.__INIT_DONE__) { initSlugFromURL(); window.__INIT_DONE__ = true; }
renderAlphaBar();
render();


/* ========== Detail modal (adds Ask ChatGPT in modal) ========== */
const dlg = $('#dlg');
const modalContent = ()=> $('.modal', dlg);

$('#dlgClose').addEventListener('click', ()=> dlg.close());
dlg.addEventListener('click', (e)=>{
  const m = modalContent();
  if(!m) return;
  if(!m.contains(e.target)) dlg.close();
});
dlg.addEventListener('keydown', (e)=>{ if(e.key==='Escape') dlg.close(); });

function openModal(t, pbUrl){
  // Title & meta
  $('#dlgTitle').textContent = t.label || t.slug || t.id || 'Template';

  const meta = $('#dlgMeta'); 
  meta.innerHTML = '';
  meta.append(h('span', { class:'pill' }, t._displayKind || '—'));
  for (const c of (t._displayCats || [])) meta.append(h('span', { class:'pill' }, c));
  for (const tag of (t._cleanedTags || [])) meta.append(h('span', { class:'chip' }, tag));

  // Definition (allow basic markup)
  $('#dlgDef').innerHTML = t.definition || '';

  // Notes (show only if present)
  const notesWrap = $('#dlgNotesWrap');
  const notesEl   = $('#dlgNotes');
  if (t.notes) {
    notesEl.textContent = t.notes;
    notesWrap.style.display = 'block';
  } else {
    notesEl.textContent = '';
    notesWrap.style.display = 'none';
  }

  // Related
  const relWrap = $('#dlgRelatedWrap');
  const rel     = $('#dlgRelated'); 
  rel.innerHTML = '';
  if ((t.related || []).length) {
    for (const r of t.related) rel.append(h('span', { class:'chip' }, r));
    relWrap.style.display = 'block';
  } else {
    relWrap.style.display = 'none';
  }

  // Sources
  const srcWrap = $('#dlgSourcesWrap');
  const src     = $('#dlgSources'); 
  src.innerHTML = '';
  if ((t.sources || []).length) {
    for (const s of t.sources) {
      const lbl = s.title || s.url || 'source';
      src.append(
        h('li', {}, h('a', { href: s.url || '#', target: '_blank', rel: 'noopener' }, lbl))
      );
    }
    srcWrap.style.display = 'block';
  } else {
    srcWrap.style.display = 'none';
  }

  // Modal Ask ChatGPT
  const askBtnModal = $('#askBtnModal');
  askBtnModal.onclick = async (e) => {
    e.preventDefault();
    const prompt = buildChatGPTPrompt(t);
    await copyText(prompt);
    openChatGPTWithPrompt(prompt);
    showCopyDialog(prompt);
  };

  // Prompt Builder visibility (only if tag indicates template)
  const pbEl   = $('#openPB');
  const linkId = safeLinkId(t);
  if (hasTypeTemplateTag(t.tags)) {
    pbEl.hidden = false;
    pbEl.href = `prompt-builder.html#${encodeURIComponent(linkId)}`;
  } else {
    pbEl.hidden = true;
    pbEl.removeAttribute('href');
  }

  dlg.showModal();
}

/* Initial theme label */
applyTheme();
</script>
</body>
</html>
