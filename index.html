<!doctype html>
<html lang="en-US">
<head>

<!-- SEO: tell crawlers the canonical location is the new page -->
<link rel="canonical" href="clare.html">
<meta name="robots" content="noindex, follow">

<!-- Primary redirect for real users - history safe and same-origin only -->
<script>
(function () {
  try {
    // Avoid loops if someone lands on CLARE.html already
    var here = location.pathname.replace(/\/+$/, "");
    if (here.endsWith("/clare.html")) return;

    // Build a safe same-origin URL for the new page
    var target = new URL("clare.html", location.href);
    if (target.origin !== location.origin) return; // security: never hop origins

    // Use replace so Back does not bounce the user back to the old URL
    location.replace(target.href);
  } catch (err) {
    // Fail silently - user stays on the old index.html
  }
})();
</script>

<!-- Fallback for no-JS environments and basic bots -->
<noscript>
  <meta http-equiv="refresh" content="0; url=clare.html">
</noscript>


  <meta charset="utf-8" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light only">
    <meta charset="utf-8">
  <title>Build better prompts with clear context | Prompt Builder</title>
  <meta name="description" content="Prompt Builder guides you to capture goals, context, constraints, and deliverables so AI outputs are clearer, faster, and reusable—fewer retries, better results.">
  <link rel="canonical" href="https://jonathankhobson.github.io/AI/index.html">

  <!-- Robots -->
  <meta name="robots" content="index,follow,max-image-preview:large,max-snippet:-1,max-video-preview:-1">

  <!-- Viewport & UI -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#111111">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="Prompt Builder">
  <meta property="og:locale" content="en_US">
  <meta property="og:url" content="https://jonathankhobson.github.io/AI/index.html">
  <meta property="og:title" content="Build better prompts with clear context">
  <meta property="og:description" content="Capture the right inputs—goals, context, constraints, deliverables—and get cleaner AI outputs with fewer retries.">
  <meta property="og:image" content="https://jonathankhobson.github.io/AI/assets/og/prompt-builder-og.png">
  <meta property="og:image:alt" content="Prompt Builder interface showing structured fields for building AI prompts">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:image:type" content="image/png">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Build better prompts with clear context">
  <meta name="twitter:description" content="Guide your AI tasks with structured inputs and reusable templates for clearer results.">
  <meta name="twitter:image" content="https://jonathankhobson.github.io/AI/assets/og/prompt-builder-og.png">

  <!-- Icons -->
  <link rel="icon" href="https://jonathankhobson.github.io/AI/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" sizes="32x32" href="https://jonathankhobson.github.io/AI/icons/favicon-32.png">
  <link rel="icon" type="image/png" sizes="192x192" href="https://jonathankhobson.github.io/AI/icons/icon-192.png">
  <link rel="apple-touch-icon" href="https://jonathankhobson.github.io/AI/icons/apple-touch-icon.png">

  <!-- Fonts (local) -->
  <link rel="preload" as="font" href="https://jonathankhobson.github.io/AI/assets/fonts/inter-var.woff2" type="font/woff2" crossorigin>

  <!-- Optional: skip link CSS (small, inlined for accessibility) -->
  <style>
    .skip-link{position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden}
    .skip-link:focus{position:static;width:auto;height:auto;padding:.5rem 1rem;background:#111;color:#fff;z-index:9999}
  </style>
  
  
  
  
  
  <style>
    :root{
      --bg:#fafafa; --fg:#0f1720; --muted:#506070; --chip:#f3f6fa; --border:#e3e9f2;
      --accent:#1e293b; --radius:16px; --shadow:0 12px 40px rgba(0,0,0,.08); --focus-ring:#0284C7;


      /* layout */
      --wrap-w: 1120px;
      --header-h: 60px; /* result header height */

      /* HERO slot timing + spacing */
      --slot-slide:520ms;       /* slide duration per word */
      --slot-hold:680ms;        /* dwell time per word */
      --slot-pad:0.3ch;         /* left/right padding inside slot */
      --slot-width:16ch;        /* will be overwritten by JS to “widest word” */
      --slot-gap-r: .90ch; /* ← tune this: .32ch (tighter) … .48ch (roomier) */
      
        /* === Prompt Builder panel tokens === */
  /* Spacing scale */
  --pb-space-8: 8px;
  --pb-space-10: 10px;
  --pb-space-12: 12px;
  --pb-space-14: 14px;
  --pb-space-16: 16px;

  /* Radii */
  --pb-radius-10: 10px;
  --pb-radius-12: 12px;

  /* Neutral borders (fallbacks if app tokens absent) */
  --pb-border-200: var(--border-200, #e5e7eb); /* neutral-200 */
  --pb-border-300: var(--border-300, #d1d5db); /* neutral-300 */

  /* Extra-soft shadow (very subtle) */
  --pb-shadow-extra-soft:
    0 1px 1px rgba(0,0,0,.04),
    0 2px 6px rgba(0,0,0,.04);

  /* Panel presets (used by the no-match panel) */
  --pb-panel-pad: var(--pb-space-16);
  --pb-panel-gap: var(--pb-space-10);
  --pb-panel-radius: var(--pb-radius-12);
  --pb-panel-border: var(--pb-border-300);
  --pb-panel-shadow: var(--pb-shadow-extra-soft);

  /* Button presets (secondary) */
  --pb-btn-sec-height: 44px;
  --pb-btn-sec-pad-x: var(--pb-space-12);
  --pb-btn-sec-radius: var(--pb-radius-10);
  --pb-btn-sec-fg: var(--fg-muted, #1f2937);
  --pb-btn-sec-bg: var(--surface, #ffffff);
  --pb-btn-sec-border: var(--pb-border-300);
  --pb-btn-sec-hover-bg: var(--surface-1, #f9fafb);
  --pb-btn-sec-active-bg: var(--surface-2, #f3f4f6);

  /* Muted text */
  --pb-text-muted: var(--muted, #6b7280);
  --pb-text-subtle: var(--muted-2, #70757d);
   --pb-icon-size: 16px; /* shared size for panel icons */
    }
    
    
    

/* Make wrappers and the search row respect the viewport width */
html.is-mobile .wrap,
html.is-mobile .searchWrap,
html.is-mobile .search,
html.is-mobile .searchRow { 
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
}

/* The search input itself (your #q) – full bleed with safe padding */
html.is-mobile #q {
  display:block;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  min-height: 48px;
  padding: 12px 16px;
  border-radius: 16px; /* or var(--radius-md) if defined */
}

/* Kill any overflow from fixed pixel widths in siblings */
html.is-mobile img, 
html.is-mobile video { max-width: 100%; height: auto; }

/* Avoid 100vw traps (where body padding causes sideways scroll) */
html.is-mobile [style*="width:100vw"] { width: 100% !important; }

/* =========================
   Mobile overflow guardrails (desktop-safe)
   ========================= */

/* 2.1 Clamp common containers to the viewport width */
@media (max-width: 720px){
  html.is-mobile .wrap,
  html.is-mobile .searchWrap,
  html.is-mobile .search,
  html.is-mobile .searchRow {
    max-width: 100%;
    box-sizing: border-box;
  }

  /* Search input should never be wider than the viewport */
  html.is-mobile #q{
    display:block;
    width:100%;
    max-width:100%;
    box-sizing:border-box;
    min-height:48px;
    padding:12px 16px;
    border-radius:16px; /* or var(--radius-md) */
  }

  /* 2.2 Make long content scrollable inside its own box instead of the whole page */
  html.is-mobile pre,
  html.is-mobile code,
  html.is-mobile .code,
  html.is-mobile table {
    max-width:100%;
    overflow-x:auto;
    -webkit-overflow-scrolling:touch;
  }

  /* 2.3 Let really long words/URLs wrap instead of expanding the layout */
  html.is-mobile .title,
  html.is-mobile .hint,
  html.is-mobile .card-title,
  html.is-mobile .card .title,
  html.is-mobile .desc,
  html.is-mobile .copy {
    overflow-wrap:anywhere; /* modern */
    word-break:break-word;  /* fallback */
  }

  /* 2.4 Media should shrink to fit */
  html.is-mobile img,
  html.is-mobile video,
  html.is-mobile svg {
    max-width:100%;
    height:auto;
  }

  /* 2.5 Fix 100vw traps: replace with 100% on mobile */
  html.is-mobile [style*="width:100vw"],
  html.is-mobile .full-bleed,
  html.is-mobile .edge-to-edge {
    width:100% !important;
    max-width:100% !important;
  }

  /* 2.6 Quick search buttons: compact and non-overflowing */
  html.is-mobile .searchCtas{
    display:grid;
    grid-template-columns:repeat(3, minmax(0,1fr)); /* minmax(0) prevents overflow */
    gap:8px;
    margin-top:10px;
  }
  html.is-mobile .searchCtas .btn{
    min-height:40px; padding:8px 10px; font-size:14px; line-height:1.2;
    border-radius:12px;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  }

  /* 2.7 If you use a horizontal chip rail, make that area scroll, not the page */
  html.is-mobile .chip-rail {
    display:flex; gap:8px;
    overflow-x:auto; -webkit-overflow-scrolling:touch;
  }

  /* 2.8 Neutralize any accidental horizontal transforms that can push width */
  html.is-mobile .searchWrap [style*="translateX"],
  html.is-mobile .searchWrap [style*="left:"],
  html.is-mobile .searchWrap [style*="right:"]{
    /* Only neutralize if you see a culprit; uncomment if needed */
    /* transform:none !important; left:auto !important; right:auto !important; */
  }
}

/* ===== Mobile-only details header tweaks (safe for desktop) ===== */
html.is-mobile .resultHeader .bar{
  position: relative; /* anchor the menu dropdown */
  gap: 8px;
}

/* Back button: show only the arrow on mobile, keep label for SR */
html.is-mobile #back.backBtn{
  min-width: 40px; min-height: 40px;
  padding: 6px 8px; border-radius: 12px;
  display: inline-flex; align-items: center; justify-content: center; gap: 8px;
}
html.is-mobile #back.backBtn .label{
  position:absolute; width:1px; height:1px; margin:-1px; overflow:hidden;
  clip:rect(0,0,0,0); white-space:nowrap; border:0; /* visually hidden */
}
html.is-mobile #back.backBtn .icon{
  font-size: 18px; line-height: 1;
}

/* Hide the inline CTAs on mobile; hamburger will expose them */


/* Show hamburger on mobile, keep desktop unchanged */
html.is-mobile #resultMenuBtn.menuBtn{
  display: inline-flex;        /* ← make sure this line exists */
  margin-left: auto;
  min-width: 40px; 
  min-height: 40px;
  align-items:center; 
  justify-content:center;
  border-radius:12px;
}

/* If the viewport is wide, never show the hamburger */
@media (min-width: 921px){
  #resultMenuBtn.menuBtn { display: none !important; }
}

/* The mobile dropdown menu */
html.is-mobile #resultMenu.resultMenu{
  position: absolute;
  right: 12px;
  top: calc(100% + 8px);
  background: #fff;
  border: 1px solid var(--border);
  border-radius: 12px;
  box-shadow: 0 18px 44px rgba(0,0,0,.18);
  padding: 6px;
  z-index: 3000;
  min-width: 200px;
}
html.is-mobile #resultMenu.resultMenu [role="menuitem"]{
  display: block; width: 100%; text-align:left;
  padding: 10px 12px; border-radius: 10px;
}
html.is-mobile #resultMenu.resultMenu [role="menuitem"]:focus-visible{
  outline: 2px solid var(--focus-ring, #0284C7);
  outline-offset: 1px;
}





    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font:16px/1.5 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    }

    :focus-visible{ outline:2px solid var(--focus-ring, #0284C7); outline-offset:2px }

    /* --- rainbow glimmer from top-left --- */
    body::before{
      content:"";
      position:fixed; inset:auto auto 40% 0; width:min(70vw,920px); height:min(70vh,680px);
      pointer-events:none; z-index:-1; filter: blur(48px) saturate(115%);
      background:
        radial-gradient(120% 120% at 0% 0%, rgba(255,255,255,.85) 0 36%, transparent 52%),
        conic-gradient(
          from 210deg at 0% 0%,
          rgba(255,0,122,.22), rgba(255,141,0,.18),
          rgba(255,214,0,.18), rgba(0,220,130,.20),
          rgba(0,210,255,.18), rgba(120,80,255,.22), rgba(255,0,122,.22)
        );
      opacity:.28;
      animation: glimmer 14s linear infinite;
      mask-image: radial-gradient(100% 100% at 0 0, #000 40%, transparent 80%);
    }
    @keyframes glimmer{
      0%{ transform: translate3d(0,0,0) rotate(0deg); }
      50%{ transform: translate3d(2%, -2%, 0) rotate(3deg); }
      100%{ transform: translate3d(0,0,0) rotate(0deg); }
    }

    .wrap{ max-width:var(--wrap-w); margin:0 auto; padding:72px 20px 40px; display:grid; gap:24px; }

    /* ====== RESULT HEADER (for details view) ====== */
    .resultHeader[hidden]{ display:none }
    .resultHeader{
      position:sticky; top:0; z-index:120;
      backdrop-filter: blur(10px) saturate(115%);
      background:rgba(255,255,255,.82);
      border-bottom:1px solid var(--border);
    }
    .resultHeader .bar{
      max-width:var(--wrap-w); margin:0 auto; padding:10px 16px; display:flex; align-items:center; gap:12px;
    }
    .resultHeader .spacer{ flex:1 }
    .resultHeader .ctas{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    /* Always hide inline header CTAs; actions live under mini bar + mobile hamburger */
.resultHeader .ctas{ display:none !important; }
    .resultHeader .rainbowLine{ height:3px; width:100%;
      background:linear-gradient(90deg,#ff007a,#ff8d00,#ffd600,#00dc82,#00d2ff,#7850ff,#ff007a);
      filter:saturate(115%); opacity:.85;
    }

    /* Buttons */
    .btn{ display:inline-flex; align-items:center; justify-content:center; gap:.5ch; cursor:pointer;
      border-radius:999px; padding:9px 14px; font-weight:600; text-decoration:none; text-transform:lowercase; user-select:none;
      transition: transform .06s ease, box-shadow .12s ease, background-color .12s ease, color .12s ease;
    }
    .btn:active{ transform:translateY(1px) }
    .btn.primary{ background:var(--fg); color:#fff; border:1px solid transparent; box-shadow:0 6px 16px rgba(15,23,32,.15); }
    .btn.secondary{ background:#fff; color:var(--fg); border:1px solid var(--border); }
    .btn.tertiary{ background:#fff; color:var(--muted); border:1px dashed var(--border); }
    .btn.link{ background:transparent; border:none; color:var(--fg); padding:6px 8px; }

    /* ----- hero ----- */
    .hero{ display:flex; flex-direction:column; align-items:center; text-align:center; gap:18px; padding:48px 16px 12px; }
    .heroTitle{ margin:0; font-weight:600; letter-spacing:.3px; text-transform:lowercase; font-size: clamp(28px, 5.8vw, 56px); line-height:1.15; }

    /* Slot (animated words) */
    .slot{ display:inline-flex; position:relative; align-items:center; justify-content:center; height:var(--slot-h, 1.25em); line-height:1; vertical-align:-0.01em; width:var(--slot-width); padding:0 var(--slot-pad); overflow:hidden; }
    .slot::after{ content:""; position:absolute; left:var(--slot-pad); right:var(--slot-pad); bottom:-0.07em; height:2px; border-radius:2px; background: linear-gradient(90deg, rgba(15,23,32,.10), rgba(15,23,32,.26), rgba(15,23,32,.10)); opacity:.38; pointer-events:none; }
    .reel{ height:var(--slot-h, 1.25em); width:calc(100%); margin-left:-20px; overflow:hidden; mask-image:linear-gradient(to bottom, transparent 0%, #000 10%, #000 90%, transparent 100%); -webkit-mask-image:linear-gradient(to bottom, transparent 0%, #000 10%, #000 90%, transparent 100%); }
    .slot.final .reel{ mask-image:none; -webkit-mask-image:none; }
    .reelList{ display:flex; flex-direction:column; transform:translate3d(0,0,0); transition:transform var(--slot-slide) cubic-bezier(.2,.9,.2,1); will-change:transform; }
    .reelList .w{ display:block; line-height:var(--slot-h, 1.25em); text-align:center; white-space:nowrap; }
    @keyframes slotBounce{ 0%{ transform:scale(1) } 38%{ transform:scale(1.035) } 72%{ transform:scale(1) } 88%{ transform:scale(1.015) } 100%{ transform:scale(1) } }
    .slot.final{ animation: slotBounce .55s ease-out 1; }
    
    
    
    /* ===== MANTRA REEL (below quickLinks) ===== */
.mantra{
  margin: clamp(36px, 6vh, 80px) auto 0;
  max-width: var(--wrap-w);
  padding: 0 20px;
  text-align: center;
}
.mantraLine{
  --mantra-shift-x: 0px;      /* ← tweak horizontal nudge; positive = right */
  display: inline-flex;
  align-items: baseline;
  gap: .6ch;
  transform: translateX(var(--mantra-shift-x));
  font-weight: 300;
  letter-spacing: .3px;
  text-transform: lowercase;
  font-size: clamp(26px, 5.2vw, 54px);
  line-height: 1.16;
}

/* make the words hug a bit more */
#mantra .mantraLine{ gap:.1ch; }  /* try .2ch → .1ch */

/* tighten left/right padding inside the scrolling slot */
#mantra #mantraSlot{ --slot-pad:.12ch; }  /* try .12ch → 0 */

.mantraLine .prefix{ opacity: .85; }

.mantraSlot{
  display:inline-flex; position:relative; align-items:center; justify-content:center;
  height: var(--mantra-slot-h, 1.2em); vertical-align: -0.03em;
  width: var(--mantra-slot-w, 30ch);     /* JS will adjust to widest phrase */
  padding: 0 var(--slot-pad, .3ch);
  overflow:hidden;
}
.mantraReel{
  height: var(--mantra-slot-h, 1.2em); width: 100%;
  overflow:hidden;
  mask-image: linear-gradient(to bottom, transparent 0%, #000 12%, #000 88%, transparent 100%);
  -webkit-mask-image: linear-gradient(to bottom, transparent 0%, #000 12%, #000 88%, transparent 100%);
}
.mantraList{
  display:flex; flex-direction:column;
  transform: translate3d(0,0,0);
  transition: transform var(--mantra-slide, 900ms) cubic-bezier(.2,.9,.2,1);
  will-change: transform;
}
.mantraList .w{
  display:block; white-space:nowrap; text-align:center;
  line-height: var(--mantra-slot-h, 1.2em);
}

/* keep it visually consistent on small screens */
@media (max-width: 520px){
  .mantraLine{ font-size: clamp(22px, 6vw, 34px); }
  .mantraSlot{ width: var(--mantra-slot-w, 24ch); }
}

    /* ----- search ----- */
    .searchWrap{ width:min(780px, 100%); margin: 6px auto 0; position:relative; transform-origin: center; animation: popIn .56s cubic-bezier(.2, .9, .2, 1.2) both; }
    /* keep the suggestions above anything below the search */
.searchWrap{ z-index: 10; }
    @keyframes popIn{ 0%{ transform: scale(.88); opacity:0 } 60%{ transform: scale(1.03); opacity:1 } 100%{ transform: scale(1) } }
    .search{ width:100%; display:flex; align-items:center; gap:8px; padding:8px; border-radius:999px; position:relative; background: #fff; border:2px solid transparent; background-image: linear-gradient(#fff,#fff), conic-gradient(from 90deg, #ff007a, #ff8d00, #ffd600, #00dc82, #00d2ff, #7850ff, #ff007a); background-origin: border-box; background-clip: padding-box, border-box; box-shadow: var(--shadow); }
    .search input{ flex:1; font:16px/1.2 inherit; border:none; outline:none; padding:12px 14px; background:transparent; color:var(--fg); }
    .search button{ border:none; border-radius:999px; padding:10px 14px; cursor:pointer; font-weight:600; background: var(--fg); color:#fff; text-transform:lowercase; }

/* subtle rainbow glow behind the search bar */
.search{ position:relative } /* reinforce positioning */
.search::before{
  content:""; position:absolute; inset:-10px; border-radius:999px; z-index:-1;
  filter: blur(22px) saturate(120%);
  background: conic-gradient(from 200deg, #ff007a, #ff8d00, #ffd600, #00dc82, #00d2ff, #7850ff, #ff007a);
  opacity:.16;
}

.searchCtas{
  display:flex; justify-content:center; gap:8px; flex-wrap:wrap; margin-top:10px;
}
@media (max-width:480px){
  .searchCtas .btn{ padding:8px 12px }
}


/* ===== Mini redo search (details header area) ===== */
.detailSearchWrap{
  position: relative;
  max-width: var(--wrap-w);
  margin: 12px auto 12px;   /* equal top/bottom spacing */
  padding: 0 2px;
  z-index: 40;
}

@media (max-width: 720px){
  .detailSearchWrap{ margin: 10px auto 10px; }
}

/* Mini search: rainbow border, soft glow, micro-motion */
.detailSearch{
  position: relative;                           /* anchors the glow */
  display:flex; align-items:center; gap:8px;
  border-radius: 999px; padding:6px;
  background: #fff;
  border: 2px solid transparent;                /* gradient border like .search */
  background-image:
    linear-gradient(#fff, #fff),
    conic-gradient(from 200deg, #ff007a, #ff8d00, #ffd600, #00dc82, #00d2ff, #7850ff, #ff007a);
  background-origin: border-box;
  background-clip: padding-box, border-box;
  box-shadow: var(--shadow);
  transition: transform .08s ease, box-shadow .18s ease, filter .18s ease;
}

/* subtle rainbow glow behind (same idea as .search::before) */
.detailSearch::before{
  content:"";
  position:absolute; inset:-10px; border-radius:999px; z-index:-1;
  filter: blur(20px) saturate(118%);
  background: conic-gradient(from 200deg, #ff007a, #ff8d00, #ffd600, #00dc82, #00d2ff, #7850ff, #ff007a);
  opacity:.14;
  transition: opacity .18s ease, filter .18s ease;
}

/* hover/focus lift */
.detailSearch:hover,
.detailSearch:focus-within{
  transform: translateY(-1px);
  box-shadow: 0 16px 32px rgba(0,0,0,.12), 0 4px 10px rgba(0,0,0,.10);
}
.detailSearch:hover::before,
.detailSearch:focus-within::before{
  opacity:.20;
  filter: blur(22px) saturate(125%);
}



.detailSearch input{
  flex:1; border:none; outline:none; padding:10px 12px;
  background:transparent; color:var(--fg); min-height:40px;
}
.detailSearch button{
  border:none; border-radius:999px; padding:8px 12px;
  font-weight:600; text-transform:lowercase; cursor:pointer;
}

/* mini input/button polish */
.detailSearch input{
  flex:1; border:none; outline:none; padding:10px 12px;
  background:transparent; color:var(--fg); min-height:40px;
}

/* buttons: small lift & clarity */
.detailSearch button{
  border:none; border-radius:999px; padding:8px 12px;
  font-weight:600; text-transform:lowercase; cursor:pointer;
  transition: transform .06s ease, box-shadow .18s ease, background-color .12s ease, color .12s ease;
}
.detailSearch button:hover{ transform: translateY(-1px); }
.detailSearch button:active{ transform: translateY(0); }

.detailSearch .go{
  background:var(--fg); color:#fff;
  box-shadow: 0 6px 16px rgba(15,23,32,.15);
}
.detailSearch .go:hover{ box-shadow: 0 10px 24px rgba(15,23,32,.18); }

.detailSearch .retry{
  background:#fff; color:var(--muted);
  border:1px dashed var(--border);
}
.detailSearch .retry:hover{
  color:var(--fg);
  border-color: color-mix(in lab, var(--border), var(--fg) 24%);
}


.detailSearch .go{ background:var(--fg); color:#fff; }
.detailSearch .retry{ background:#fff; color:var(--muted); border:1px dashed var(--border); }


/* ===== Centered CTA row under mini redo search ===== */
.detailCtas{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:10px;
  flex-wrap:wrap;
  margin: 8px auto 6px;           /* tight to the mini bar */
  max-width: var(--wrap-w);
  padding: 0 4px;
}

/* visual hierarchy:
   - primary: ask, prompt builder
   - secondary: copy, worksheet
   - tertiary: all templates (lowest prominence) */
.detailCtas .btn{ min-height:40px; padding:8px 12px; }
.detailCtas .btn.primary{ order: 3; }   /* keep primaries toward the right */
.detailCtas .btn.secondary{ order: 2; }
.detailCtas .btn.tertiary{ order: 1; opacity:.92; }

/* mobile: slightly tighter & ensure wrap looks good */
@media (max-width:720px){
  .detailCtas{ gap:8px; margin: 6px auto 6px; }
  .detailCtas .btn{ min-height:38px; padding:8px 10px; font-size:14px; }
}

/* smaller dropdown tied to the mini search */
.ta.ta--mini{
  left:8px; right:8px; top:calc(100% + 6px);
  max-height:220px; z-index: 400;    /* above card content */
}

/* ===== Slice 3: A11y + Shake ===== */

/* Visually hidden but screen-reader accessible */
.visually-hidden {
  position: absolute !important;
  width: 1px; height: 1px;
  padding: 0; margin: -1px;
  overflow: hidden; clip: rect(0 0 1px 1px);
  clip-path: inset(50%); border: 0;
}

/* Shake animation keyframes */
@keyframes pb-shake-x {
  0%, 100% { transform: translateX(0); }
  15% { transform: translateX(-6px); }
  30% { transform: translateX(6px); }
  45% { transform: translateX(-5px); }
  60% { transform: translateX(5px); }
  75% { transform: translateX(-3px); }
  90% { transform: translateX(3px); }
}

/* Apply shake to the search wrapper when .shake is toggled */
.searchWrap.shake {
  animation: pb-shake-x 0.42s ease-in-out;
}

/* Respect users who prefer reduced motion */
@media (prefers-reduced-motion: reduce) {
  .searchWrap.shake {
    animation: none !important;
  }
}


/* --- rainbow pop-out buttons (like quickLinks) --- */
.searchCtas .btn{
  position:relative;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:.5ch;
  padding:10px 16px;
  border-radius:999px;
  font-weight:600;
  line-height:1;
  background: var(--btn-bg, #fff);
  color: var(--btn-fg, #111);
  border: none; /* anchors will ignore this */
  transform: translateZ(0);
  transition:
    transform .2s ease,
    box-shadow .2s ease,
    background-color .2s ease,
    color .2s ease,
    opacity .2s ease;
  box-shadow: 0 0 0 0 rgba(0,0,0,0);
  isolation:isolate; /* keeps pseudo ring crisp */
}

/* Animated rainbow ring on hover/focus */
.searchCtas .btn::after{
  content:"";
  position:absolute;
  inset:-2px;
  border-radius:inherit;
  padding:2px;
  /* animated conic rainbow */
  --angle: 0deg;
  background:
    conic-gradient(from var(--angle),
      #ff6b6b, #f8e71c, #7ed321, #50e3c2, #4a90e2, #bd10e0, #ff6b6b);
  /* punch out the middle so it looks like a border */
  -webkit-mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity:0;
  transition: opacity .2s ease, filter .2s ease;
  pointer-events:none;
  z-index:-1; /* sits behind button content but above the page */
}

/* subtle shine inside on hover */
.searchCtas .btn::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:inherit;
  background: radial-gradient(120% 120% at 50% -20%, rgba(255,255,255,.16), transparent 60%);
  opacity:0;
  transition: opacity .2s ease;
  pointer-events:none;
}

@keyframes spinRainbow { to { --angle: 360deg; } }

.searchCtas .btn:hover,
.searchCtas .btn:focus-visible{
  transform: translateY(-2px) scale(1.025);
  box-shadow: 0 16px 28px -14px rgba(0,0,0,.35),
              0 4px 10px -6px rgba(0,0,0,.25);
}

.searchCtas .btn:hover::after,
.searchCtas .btn:focus-visible::after{
  opacity:1;
  filter: saturate(1.15);
  animation: spinRainbow 2.25s linear infinite;
}

.searchCtas .btn:hover::before,
.searchCtas .btn:focus-visible::before{
  opacity:1;
}

/* press feedback */
.searchCtas .btn:active{
  transform: translateY(0) scale(.99);
  box-shadow: 0 8px 18px -12px rgba(0,0,0,.35);
}

/* respect reduced motion */
@media (prefers-reduced-motion: reduce){
  .searchCtas .btn,
  .searchCtas .btn::after{
    transition: none;
    animation: none;
  }
}



/* hint under search */
.hint{
  margin-top:10px; font-size:14px; color:var(--muted); opacity:.9; text-align:center;
}

/* quick link cards */
.quickLinks{
  width:min(980px,100%); margin:16px auto 0;
  display:grid; gap:14px;
  grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
}
.tile{
  position:relative; display:block; padding:18px 16px 52px;
  border-radius:20px; background:#fff; color:inherit; text-decoration:none;
  border:1px solid var(--border); box-shadow: var(--shadow); overflow:hidden;
  transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease;
}
.tile:hover{ transform: translateY(-1px) scale(1.02); box-shadow: 0 12px 44px rgba(0,0,0,.10); }
.tile::before{
  content:""; position:absolute; inset:-12px; z-index:-1; border-radius:24px;
  filter: blur(26px) saturate(120%);
  background: conic-gradient(from 200deg, #ff007a, #ff8d00, #ffd600, #00dc82, #00d2ff, #7850ff, #ff007a);
  opacity:.18; transition: opacity .2s ease;
}
.tile:hover::before{ opacity:.28 }
.tile h4{ margin:0 0 6px; font-size:16px; font-weight:700; text-transform:lowercase; letter-spacing:.2px; }
.tile p{ margin:0; font-size:14px; color:var(--muted); }
.tile .cta{
  position:absolute; right:12px; bottom:12px; padding:8px 12px;
  border-radius:999px; border:1px solid var(--border); background:#fff;
  font-weight:600; text-transform:lowercase;
}
.tile:hover .cta{ background:var(--fg); color:#fff; border-color:transparent; }


.quickLinks{ position:relative; z-index:0; }

    /* typeahead */
    .ta{ position:absolute; left:10px; right:10px; top:100%; background:#fff; border:1px solid var(--border); border-radius:14px; margin-top:8px; box-shadow: var(--shadow); max-height:260px; overflow:auto; z-index: 300; /* was 50 */
 }
 
 /* No-good-match: show full panel + 2 closest with no inner scrolling */
.ta.ta--noMatch{
  max-height: none;
  overflow: visible;
}
    .ta[hidden]{ display:none }
    .ta .item{ padding:10px 12px; cursor:pointer; border-bottom:1px solid #f1f5fb; }
    .ta .item:last-child{ border-bottom:none }
    .ta .item:hover, .ta .item.active{ background:#f7fafc }
    .ta .use{ font-size:14px }
    .ta .sub{ font-size:12px; color:var(--muted); display:none }

    /* ----- faux scanning ----- */
    .scan{ position:fixed; inset:0; z-index:1000; display:none; align-items:center; justify-content:center; background:#fff; }
    .scan .roll{ position:relative; width:100vw; height:100vh; overflow:hidden; background:#fff; mask-image: linear-gradient(to bottom, transparent 0%, #000 16%, #000 84%, transparent 100%); -webkit-mask-image: linear-gradient(to bottom, transparent 0%, #000 16%, #000 84%, transparent 100%); }
    .scan ul{ position:absolute; inset:0; list-style:none; margin:0; padding:24px clamp(22px, 6vw, 90px) 24px clamp(34px, 9vw, 140px); display:flex; flex-direction:column; gap:10px; align-items:flex-start; text-align:left; font-family: ui-sans-serif, system-ui, "Helvetica Neue", Arial, sans-serif; font-weight:600; letter-spacing:.2px; text-transform:lowercase; font-stretch: condensed; will-change: transform; }
    .scan li{ font-size: clamp(16px, 2.2vw, 26px); color:#0c1220; opacity:.45; transition:transform .18s ease, opacity .18s ease; max-width: 90vw; }
    .scan li.hit{ color:#000; opacity:1; transform: scale(1.06); text-decoration:underline; text-underline-offset: .12em; will-change: transform; }
    .scan .roll::before, .scan .roll::after{ content:""; position:absolute; top:50%; transform: translateY(-50%); height: 2.2em; width:2px; pointer-events:none; background: linear-gradient(to bottom, rgba(15,23,32,0), rgba(15,23,32,.28) 50%, rgba(15,23,32,0) ); filter: blur(.2px); }
    .scan .roll::before{ left: 16%; }
    .scan .roll::after{ right: 16%; }
    .centerBand{ position:absolute; left:0; right:0; top:50%; transform:translateY(-50%); height:3.0em; pointer-events:none; background: linear-gradient(90deg, rgba(255,0,122,.12), rgba(255,141,0,.10), rgba(255,214,0,.10), rgba(0,220,130,.12), rgba(0,210,255,.12), rgba(120,80,255,.14)); mask-image: linear-gradient(to bottom, transparent 0, #000 18%, #000 82%, transparent 100%); -webkit-mask-image: linear-gradient(to bottom, transparent 0, #000 18%, #000 82%, transparent 100%); filter: saturate(120%); }
    .centerBand::after{ content:""; position:absolute; inset:0; background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,.55), rgba(255,255,255,0)); mix-blend-mode: overlay; animation: centerSweep 2600ms ease-in-out infinite alternate; }
    @keyframes centerSweep{ 0%{ transform: translateX(-10%) } 100%{ transform: translateX(10%) } }
    .scan::before{ content:""; position:fixed; inset:auto auto 0 0; width:min(90vw,1200px); height:min(70vh,780px); pointer-events:none; opacity:.18; filter: blur(36px) saturate(125%); background: radial-gradient(110% 110% at 0% 0%, rgba(255,255,255,.85) 0 36%, transparent 52%), conic-gradient( from 210deg at 0% 0%, rgba(255,0,122,.22), rgba(255,141,0,.18), rgba(255,214,0,.18), rgba(0,220,130,.20), rgba(0,210,255,.18), rgba(120,80,255,.22), rgba(255,0,122,.22) ); animation: scanGlimmer 16s linear infinite; }
    @keyframes scanGlimmer{ 0%{ transform: translate3d(0,0,0) rotate(0deg) } 50%{ transform: translate3d(2%,-1.5%,0) rotate(3deg) } 100%{ transform: translate3d(0,0,0) rotate(0deg) } }

    /* ----- details card ----- */
    .details[hidden]{ display:none }
    .details{ position:relative; }
    .details::before{ content:""; position:fixed; inset:auto -15vw 8% -15vw; height:52vh; background: conic-gradient(from 220deg, rgba(255,0,122,.10), rgba(255,141,0,.08), rgba(255,214,0,.08), rgba(0,220,130,.10), rgba(0,210,255,.10), rgba(120,80,255,.12), rgba(255,0,122,.10)); filter: blur(70px) saturate(115%); opacity:.32; pointer-events:none; z-index:-1; }

    .card{ display:grid; grid-template-columns: 1.3fr .9fr; gap:28px; align-items:flex-start; border:1px solid var(--border); border-radius:24px; background:#fff; box-shadow: var(--shadow); padding:24px; }
    @media (max-width: 900px){ .card{ grid-template-columns: 1fr; } }

    .left h2{ margin:4px 0 6px; text-transform:lowercase; font-size: clamp(24px, 3.4vw, 34px); letter-spacing:.2px; }
    .meta{ display:flex; flex-wrap:wrap; gap:10px; margin:10px 0 16px; }
    .chip{ padding:6px 10px; border-radius:999px; border:1px solid var(--border); background:var(--chip); font-size:12px }

    .block + .block{ margin-top:18px }
    .block h3{ margin:.4rem 0 .4rem; font-size:14px; letter-spacing:.12px; color:#101828; text-transform:lowercase; }
    .uc, .booster{ background:#f8fbff; border:1px dashed #e6eef8; padding:10px 12px; border-radius:12px; font-size:13px; }

    .fields .row + .row{ margin-top:10px }
    .row label{ display:block; font-size:12px; color:var(--muted); margin-bottom:4px; text-transform:lowercase }
    .row .fake{ width:100%; padding:12px 14px; border-radius:12px; border:1px dashed var(--border); background:#f9fafb; color:#0f1720; font-size:14px; }

    /* Right column stickiness for taller screens */
    @media (min-width: 901px){ .right{ position:sticky; top: calc(var(--header-h) + 18px); } }

    /* Footer actions inside card */
    .actions.footer{ display:flex; flex-wrap:wrap; gap:10px; margin-top:18px }
    .divider{ height:1px; background:linear-gradient(90deg, transparent, #e7edf6, transparent); margin:8px 0 4px }
  
  
  /* Desktop/default: hide the hamburger unless we explicitly show it on mobile */
#resultMenuBtn.menuBtn { display: none; }




/* === COPY DIALOG (Slice 1a–1i final) — canonical skin, desktop-safe === */
/* Backdrop: simple dim — no blur */
#actionModal::backdrop {
  background: rgba(0,0,0,.45);
}

/* Centered card */
#actionModal {
  /* native dialog defaults removed */
  padding: 0;
  border: 1px solid var(--border);
  border-radius: 18px;
  background: var(--bg, #fff);
  color: var(--fg, #0f1720);
  box-shadow: var(--shadow);
  width: min(880px, 92vw);
  max-height: 90vh;
  margin: 8vh auto;
  overflow: visible; /* inner grid controls scroll */
}

/* 3-row card: header / body / footer */
#actionForm.modal-body {
  display: grid;
  grid-template-rows: auto 1fr auto;
  border-radius: inherit;
  overflow: hidden; /* keeps hairlines crisp */
}

/* Header: title left, × right (inline, not stacked) */
#actionModal .modal-header {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 14px 16px;
  border-bottom: 1px solid var(--border);
}
#actionModal .modal-header h3 {
  margin: 0;
  font: 600 1.05rem/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  text-transform: lowercase;
  letter-spacing: .2px;
}
#actionModal .modal-header .icon.close {
  margin-left: auto;
  inline-size: 34px;
  block-size: 34px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: transparent;
  color: inherit;
  cursor: pointer;
}
#actionModal .modal-header .icon.close:hover {
  background: rgba(0,0,0,.06);
}
#actionModal .modal-header .icon.close:focus-visible {
  outline: 2px solid var(--focus-ring);
  outline-offset: 2px;
}

/* Body: tidy spacing + full-width preview */
#actionModal .modal-section {
  padding: 16px;
  display: grid;
  gap: 10px;
}
#actionModal .modal-section .field label {
  display: block;
  margin-bottom: 6px;
  font-size: 12px;
  color: var(--muted);
  text-transform: lowercase;
}
#actionPreview {
  width: 100%;
  min-height: min(54vh, 520px);
  resize: vertical;
  padding: 12px;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: #f9fafb;
  color: inherit;
  font: 500 0.94rem/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  tab-size: 2;
}
#actionPreview:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(2,132,199,.18) inset; /* matches site focus ring */
}

/* Inline note under preview (length warnings, copied msg, etc.) */
#actionNote.note {
  margin: 8px 2px 0;
  font-size: 12.5px;
  color: var(--muted);
}

/* Footer: right-aligned actions, re-using your .btn look */
#actionModal .modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  padding: 12px 16px 14px;
  border-top: 1px solid var(--border);
}

/* Buttons inherit your global .btn styles; keep overrides minimal and scoped */
#actionModal .btn {
  text-decoration: none;                  /* never show underlines in the dialog */
  border-radius: 10px;                    /* match header close’s radius */
}
#actionModal .btn:hover { background: rgba(0,0,0,.06); }
#actionModal .btn:focus-visible { outline: 2px solid var(--focus-ring); outline-offset: 2px; }
#actionModal .btn.primary {
  /* rely on your existing .btn.primary colors; only small nudge */
  filter: saturate(1.02);
}



/* Mobile polish */
@media (max-width: 720px){
  #actionModal {
    width: min(520px, 92vw);
    margin: 6vh auto;
    border-radius: 16px;
  }
  #actionPreview { min-height: 220px; }
  #actionModal .modal-footer { flex-wrap: wrap; gap: 8px; }
}

/* Motion safety */
@media (prefers-reduced-motion: reduce){
  #actionModal { transition: none; }
}







  
  
  /* =========================
   SLICE 1 — Mobile Layout Skeleton
   ========================= */
   
   /* === MOBILE HEADER MENU (Slice 4) — scoped & desktop-safe === */

/* Make the header bar a positioned anchor so the menu can be absolutely placed */
.resultHeader .bar { position: relative; }

/* Desktop: we already hide the hamburger. On mobile, show it. */
@media (max-width: 720px){
  html.is-mobile #resultMenuBtn.menuBtn{
    display: inline-flex;
    align-items: center; justify-content: center;
  }
  /* Hide the desktop CTAs row on mobile; the menu replaces it */
  html.is-mobile #resultHeader .ctas{ display: none; }
}

/* Menu panel */
#resultHeader .resultMenu[hidden]{ display:none !important; }
#resultHeader .resultMenu{
  position: absolute;
  right: 12px;
  top: calc(100% + 8px);             /* just below the header bar */
  min-width: 220px;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 12px;
  box-shadow: var(--shadow);
  padding: 6px;
  z-index: 3000;
}

/* Menu items */
#resultHeader .resultMenu .menuItem{
  display: block;
  width: 100%;
  text-align: left;
  border: 0;
  background: transparent;
  color: inherit;
  padding: 10px 10px;
  border-radius: 10px;
  cursor: pointer;
  -webkit-appearance: none; appearance: none;
  text-decoration: none;           /* anchors look like buttons */
}
#resultHeader .resultMenu .menuItem:hover{ background: rgba(0,0,0,.06); }
#resultHeader .resultMenu .menuItem:focus-visible{
  outline: 2px solid var(--focus-ring); outline-offset: 2px;
}
#resultHeader .resultMenu .menuItem[aria-disabled="true"]{
  opacity: .45; cursor: default; pointer-events: none;
}
   

/* a) Skip link: visible when tabbed, hidden visually otherwise */
.skip-link{
  position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden;
}
.skip-link:focus{
  position:fixed; left:16px; top:14px; width:auto; height:auto; padding:10px 14px;
  background:#fff; color:var(--fg); border:2px solid var(--focus-ring); border-radius:12px;
  box-shadow: 0 10px 24px rgba(0,0,0,.12);
  z-index: 10000;
}



/* b) Mobile scaffold: search + hint + 3 primary buttons under the hint */

/* Ensure input and button meet 44x44 min touch size */
.search input{ min-height:48px; }
.search button{ min-height:48px; }

/* Make each bar the positioning context */
.search, .detailSearch { position: relative; }

/* Dropdown spans the bar width and sits just below it */
.search > .ta{
  left: 0; right: 0;
  top: calc(100% + 8px);
  margin-top: 0;          /* override the old margin trick */
  z-index: 300;           /* already above nearby content */
}
.detailSearch > .ta{
  left: 0; right: 0;
  top: calc(100% + 6px);
  margin-top: 0;
  z-index: 400;           /* above the details card */
}



/* Keep overall mobile container padding sane */
@media (max-width:720px){
  .wrap{ padding-left:16px; padding-right:16px; }
}

/* c) Disable hover-only affordances on touch; prefer press/focus states */
@media (hover: none) and (pointer: coarse){
  /* Search CTA buttons: remove hover lift/animation; keep press/focus */
  .searchCtas .btn:hover,
  .searchCtas .btn:hover::before,
  .searchCtas .btn:hover::after{
    transform:none; box-shadow:none; opacity:1; animation:none;
  }
  /* Make press/focus clearly visible */
  .searchCtas .btn:active{
    transform: translateY(0) scale(.99);
    box-shadow: 0 8px 18px -12px rgba(0,0,0,.28);
  }
  .searchCtas .btn:focus-visible{
    outline: none;
    box-shadow: 0 0 0 2px var(--focus-ring) inset, 0 0 0 3px rgba(2,132,199,.15);
  }

  /* Quick-link tiles: kill heavy hover lifts on touch */
  .tile:hover{ transform:none; box-shadow: var(--shadow); }
  .tile:hover::before{ opacity:.18; }
}

/* d) Hint text remains readable and compact on XS screens */
@media (max-width:360px){
  .hint{ font-size:13px; }
}

/* e) Keep the search cluster centered and full-width within its max */
@media (max-width:720px){
  .searchWrap{ width:100%; max-width:780px; }
}

/* Slice 1: mobile spacing rhythm */
@media (max-width: 720px){
  .wrap{ padding-left:16px; padding-right:16px; }
  .search input{ margin-bottom:16px; }
  .hint{ margin-bottom:16px; }
  .searchCtas{ margin-bottom:24px; }
  
  
  /* Details mode: reduce top padding so content sits closer under the sticky header */
body.is-details .wrap{
  padding-top: 14px;   /* was 72px; tweak 10–18px to taste */
}


/* =========================
   SLICE 2 — Mobile Suggestions Overlay (desktop-safe)
   Everything is gated under html.is-mobile
   ========================= */

/* Lock page scroll when overlay is open */
html.is-mobile body.scroll-locked {
  overflow: hidden;
  touch-action: none;
}

/* Dim background */
html.is-mobile .suggestions-scrim {
  position: fixed;
  inset: 0;
  background: rgba(15,23,32,.20);  /* lighter, not opaque, and no blur */
  -webkit-backdrop-filter: none;
  backdrop-filter: none;
  z-index: 2100;
}

/* Keep the search field above the scrim when overlay is open */
html.is-mobile.overlay-open .searchWrap{
  position: relative;
  z-index: 2150; /* above scrim (2100), below overlay (2200) */
}


/* Overlay box that will hold #ta */
html.is-mobile .suggestions-overlay {
  position: fixed; /* JS sets top/left/width/max-height */
  background: var(--surface-1, #fff);
  border-radius: var(--radius, 16px);
  box-shadow: 0 24px 64px rgba(0,0,0,.18);
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 2200;
  max-height: 60vh; /* JS also sets this as a precise value */
}

/* When #ta is inside the overlay, neutralize its desktop absolute layout */
html.is-mobile .suggestions-overlay #ta {
  position: static;
  left: auto; right: auto; top: auto; margin-top: 0;
  max-height: inherit;
  border: none;
  box-shadow: none;
  background: transparent;
}


/* =========================
   MOBILE SHRINK KIT (desktop-safe)
   Tightens sizes, kills sideways scroll, keeps CTAs horizontal & compact
   ========================= */


/* Avoid Safari “bump up” and weird zoom behavior */
html.is-mobile html, 
html.is-mobile body { -webkit-text-size-adjust: 100%; }

/* 1) Global spacing + type on mobile */
@media (max-width: 720px){
  html.is-mobile .wrap{ padding: 40px 16px 24px; }     /* was 72/20/40 */
  html.is-mobile .hero{ padding: 28px 12px 8px; gap: 12px; }
  html.is-mobile .heroTitle{ font-size: clamp(22px, 6.2vw, 32px); } /* smaller hero */
  html.is-mobile .hint{ font-size: 13px; margin-top: 8px; }
}

/* 2) Search: make sure it never exceeds viewport and trim padding */
@media (max-width: 720px){
  html.is-mobile .searchWrap,
  html.is-mobile .search,
  html.is-mobile .searchRow{ width:100%; max-width:100%; box-sizing:border-box; }

  html.is-mobile #q{
    display:block; width:100%; max-width:100%; box-sizing:border-box;
    min-height:48px; padding:10px 12px; border-radius:16px;
    font-size:16px; /* keeps iOS from zooming on focus */
  }
  html.is-mobile .search{ padding:6px; }  /* tighter than desktop’s 8px */
}

/* 3) CTAs: compact, horizontal (single row that can scroll if needed) */
@media (max-width: 720px){
  html.is-mobile .searchCtas{
    display:flex; align-items:stretch; justify-content:center;
    gap:8px; margin-top:10px;
    overflow-x:auto; -webkit-overflow-scrolling:touch;
    padding-bottom: 2px; scroll-snap-type:x proximity;
  }
  html.is-mobile .searchCtas .btn{
    flex:0 0 auto; scroll-snap-align:start;
    min-height:40px; padding:8px 12px; border-radius:12px;
    font-size:14px; line-height:1.2;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  }
}

/* 4) QuickLinks: vertical stack (1 per row) + smaller tiles */
@media (max-width: 720px){
  html.is-mobile .quickLinks{
    display:grid; grid-template-columns:1fr; gap:10px; width:100%;
    margin:12px auto 0;
  }
  html.is-mobile .quickLinks > *{ width:100%; box-sizing:border-box; }
  html.is-mobile .tile{
    padding:14px 12px 44px; border-radius:16px;
    box-shadow: var(--shadow);
    transform:none !important;  /* no hover pop on touch */
  }
  html.is-mobile .tile h4{ font-size:15px; }
  html.is-mobile .tile p{ font-size:13px; }
  html.is-mobile .tile .cta{ padding:6px 10px; }
}

/* 5) Mantra: slightly smaller on tight screens to reduce scroll */
@media (max-width: 520px){
  html.is-mobile .mantra{ margin: clamp(24px, 5vh, 48px) auto 0; padding:0 12px; }
  html.is-mobile .mantraLine{ font-size: clamp(20px, 5.4vw, 30px); }
  html.is-mobile #mantraSlot{ --slot-pad:.12ch; }
}

/* 6) Details view: compress paddings and grid */
@media (max-width: 720px){
  html.is-mobile .resultHeader .bar{ padding:8px 12px; gap:8px; }
  html.is-mobile .card{
    grid-template-columns:1fr !important; gap:16px; padding:16px; border-radius:18px;
  }
  html.is-mobile .left h2{ font-size: clamp(20px, 4.8vw, 26px); }
}

/* 7) Common overflow guards */
@media (max-width: 720px){
  /* Anything trying to be wider than the viewport gets clamped */
  html.is-mobile [style*="width:100vw"],
  html.is-mobile .full-bleed,
  html.is-mobile .edge-to-edge{
    width:100% !important; max-width:100% !important;
  }
  /* Long content scrolls inside itself instead of the page */
  html.is-mobile pre,
  html.is-mobile code,
  html.is-mobile .code,
  html.is-mobile table{
    max-width:100%; overflow-x:auto; -webkit-overflow-scrolling:touch;
  }
  /* Media fits the container */
  html.is-mobile img, html.is-mobile video, html.is-mobile svg{ max-width:100%; height:auto; }
  /* Let long words/URLs wrap */
  html.is-mobile .title,
  html.is-mobile .hint,
  html.is-mobile .card-title,
  html.is-mobile .desc,
  html.is-mobile .copy{
    overflow-wrap:anywhere; word-break:break-word;
  }
}

html.is-mobile .tile{ padding:12px 10px 40px; }
html.is-mobile .tile h4{ font-size:14px; }
html.is-mobile .tile p{ font-size:12.5px; }

html.is-mobile .wrap{ padding-top:28px; }
html.is-mobile .hero{ padding-top:18px; }

/* Mobile: allow the search input to shrink inside the flex row */
@media (max-width: 720px){
  html.is-mobile .search{ min-width: 0; }   /* the container can shrink */
  html.is-mobile .search input{ min-width: 0; } /* the field can shrink */
  html.is-mobile .searchWrap{ padding-left:12px; padding-right:12px; } /* safe gutter */
  html.is-mobile #q{ width:100%; max-width:100%; box-sizing:border-box; }
}

/* Keep hero “slot” and mantra bounded on small screens */
@media (max-width: 720px){
  html.is-mobile .slot,
  html.is-mobile .mantraSlot{
    max-width: 100%;
    overflow: hidden;   /* if a word is mismeasured, it won't push the page */
  }

  /* Long words/URLs wrap instead of expanding layout */
  html.is-mobile .heroTitle,
  html.is-mobile .hint,
  html.is-mobile .tile h4,
  html.is-mobile .tile p{
    overflow-wrap:anywhere;
    word-break:break-word;
  }

  /* Tables/code blocks scroll inside themselves, not the whole page */
  html.is-mobile table,
  html.is-mobile pre,
  html.is-mobile code,
  html.is-mobile .code{
    max-width:100%;
    overflow-x:auto;
    -webkit-overflow-scrolling:touch;
  }
}


/* === AI settings button — site-consistent look & placement === */
.ai-settings-btn{
  /* adopt your pill button look (you already have .btn + .secondary) */
  padding: 8px 12px;
  border: 1px solid var(--border);
  background: #fff;
  color: var(--fg);
  box-shadow: none;
  gap: .6ch;
}

/* default placement: fixed top-right on the start page */
.ai-settings-btn{
  position: fixed;
  inset-block-start: 16px;       /* top */
  inset-inline-end: 16px;        /* right */
  z-index: 1200;
}

/* when we move it into the sticky header, let flex push it to the right */
.resultHeader .bar{ position: relative; }
.ai-settings-btn.is-in-header{
  position: static;
  margin-inline-start: auto;     /* pushes it to the right in the flex row */
}

/* small polish */
.ai-settings-btn svg{ display:inline-block; width:16px; height:16px }
.ai-settings-btn:hover{ transform: translateY(-1px); box-shadow: 0 10px 24px rgba(15,23,32,.12); }
.ai-settings-btn:active{ transform: translateY(0); }

/* mobile spacing */
@media (max-width:720px){
  .ai-settings-btn{ inset-block-start:12px; inset-inline-end:12px; padding:8px 10px; }
}

/* AI settings button: same pill look as your other CTAs */
.ai-settings-btn{
  /* your .btn + .secondary styles already apply; this just ensures placement */
  position: fixed;
  inset-block-start: 16px;  /* logical top */
  inset-inline-end: 16px;   /* logical right */

  /* physical fallbacks for older engines */
  top: 16px; right: 16px; left: auto;

  z-index: 1200;
  padding: 8px 12px;
  border: 1px solid var(--border);
  background: #fff; color: var(--fg);
  box-shadow: none; gap: .6ch;
}

/* When inside the header’s flex row, let it sit at the far right */
.ai-settings-btn.is-in-header{
  position: static;          /* participate in header layout */
  margin-inline-start: auto; /* push to the right */
}

/* keep the subtle lift to match other header buttons */
.ai-settings-btn:hover{ transform: translateY(-1px); box-shadow: 0 10px 24px rgba(0,0,0,.12); }
.ai-settings-btn:active{ transform: translateY(0); }

/* no-match panel styles */
.ta .noMatch{ padding:12px; }
/* Slice 8 — hybrid list + panel layout (closest matches above options) */
.ta .noMatch .pb-near{
  margin: 2px 0 10px;
  padding: 6px 4px 8px;
}
.ta .noMatch .pb-near .hdr.sm{
  margin: 0 0 6px;
  font-size: 12px;
  letter-spacing: .02em;
  text-transform: none;
  color: var(--muted);
  opacity: .8;
}
.ta .noMatch .pb-div{
  border: 0;
  border-top: 1px solid var(--border, #e3e9f2);
  margin: 10px 0 0;
}
.ta .noMatch .hdr{ font-weight:600; margin-bottom:6px; }
.ta .noMatch .sub{ font-size:12px; color:var(--muted); margin-bottom:10px; }
.ta .noMatch .actions{ display:flex; flex-wrap:wrap; gap:8px; }


/* Slice C: consistent focus rings for panel CTAs */
.ta .noMatch .btn.secondary:focus,
.ta .noMatch .btn.secondary:focus-visible{
  outline: 2px solid var(--focus, #2563eb);
  outline-offset: 2px;
}

/* Avoid showing focus when not keyboard-focused (where supported) */
.ta .noMatch .btn.secondary:focus:not(:focus-visible){
  outline: none;
}

/* Firefox inner focus fix for <button> */
.ta .noMatch .btn.secondary::-moz-focus-inner{ border: 0; }
  
  </style>
  
  
  
  <style id="ai-settings-hotfix">
/* === AI Settings dialog — last-in-cascade, high-specificity hotfix === */

/* 1) Match common variants your JS might emit */
:is(
  #aiSettingsDialog,
  dialog#aiSettingsDialog,
  dialog#aiSettings,
  dialog.ai-settings,
  [role="dialog"][data-modal="ai-settings"],
  [id*="ai"][id*="setting"][class*="modal"]
){
  /* Card shell */
  padding: 0 !important;
  border: 1px solid var(--border, #e3e9f2) !important;
  border-radius: 18px !important;
  background: var(--bg, #fff) !important;
  color: var(--fg, #0f1720) !important;
  box-shadow: 0 12px 40px rgba(0,0,0,.08) !important;
  width: min(720px, 92vw) !important;
  max-height: 90vh !important;
  margin: 8vh auto !important;
}

/* Backdrop dim */
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings)::backdrop{
  background: rgba(0,0,0,.45) !important;
}

/* 2) Interior layout: header / body / footer */
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) .modal-body{
  display: grid !important;
  grid-template-rows: auto 1fr auto !important;
  border-radius: inherit !important;
  overflow: hidden !important;
}

/* Header with title left, X on the right */
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) .modal-header{
  position: relative !important;
  display: flex !important;
  align-items: center !important;
  gap: 12px !important;
  padding: 14px 16px !important;
  border-bottom: 1px solid var(--border, #e3e9f2) !important;
}
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) .modal-header h3{
  margin: 0 !important;
  font: 600 1.05rem/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif !important;
  text-transform: lowercase !important;
  letter-spacing: .2px !important;
}

/* Put the close “X” in the true upper-right */
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) .modal-header :is(.icon.close,#aiClose,.btn-close,[data-close]){
  position: absolute !important;
  top: 10px !important;
  right: 10px !important;
  inline-size: 34px !important;
  block-size: 34px !important;
  border-radius: 10px !important;
  border: 1px solid var(--border, #e3e9f2) !important;
  background: #fff0 !important;
  color: inherit !important;
  cursor: pointer !important;
}
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) .modal-header :is(.icon.close,#aiClose,.btn-close,[data-close]):hover{
  background: rgba(0,0,0,.06) !important;
}

/* Body padding and comfy spacing */
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) .modal-section{
  padding: 18px 16px !important;
  display: grid !important;
  gap: 12px !important;
}
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) .modal-section .field label{
  display: block !important;
  margin-bottom: 6px !important;
  font-size: 12px !important;
  color: var(--muted, #506070) !important;
  text-transform: lowercase !important;
}

/* Footer buttons aligned right with real space between */
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) .modal-footer{
  display: flex !important;

  gap: 10px !important;
  padding: 12px 16px 14px !important;
  border-top: 1px solid var(--border, #e3e9f2) !important;
}

/* Button polish (inherits your .btn look) */
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) .modal-footer .btn{
  border-radius: 10px !important;
  text-decoration: none !important;
  padding: 9px 14px !important;
}

/* 3) Exact button variants per your spec */
/* Forget keys → red */
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) :is(#aiForget,[data-action="forget-keys"],.btn-danger){
  background: #ef4444 !important;  /* red-500 */
  color: #fff !important;
  border: 1px solid transparent !important;
}

/* Test → discrete/subtle */
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) :is(#aiTest,[data-action="test"],.btn-subtle){
  opacity: .78 !important;
  background: #fff !important;
  color: var(--muted, #506070) !important;
  border: 1px dashed var(--border, #e3e9f2) !important;
}

/* Close → white button */
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) :is(#aiCancel,[data-action="cancel"],.btn-white){
  background: #fff !important;
  color: var(--fg, #0f1720) !important;
  border: 1px solid var(--border, #e3e9f2) !important;
}

/* Save (if present) stays primary, with small nudge */
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) :is(#aiSave,[data-action="save"],.btn.primary){
  filter: saturate(1.02) !important;
}

/* 4) Inputs inside the dialog (consistent, modern) */
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) input,
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) select,
:is(#aiSettingsDialog, dialog.ai-settings, dialog#aiSettingsDialog, dialog#aiSettings) textarea{
  padding: 10px 12px !important;
  border-radius: 12px !important;
  border: 1px solid var(--border, #e3e9f2) !important;
  background: #f9fafb !important;
  color: inherit !important;
  box-shadow: none !important;
}


/* === No-match panel: unified secondary buttons (scoped) === */
.ta .noMatch .btn.secondary{
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--pb-space-8);
  height: var(--pb-btn-sec-height);
  padding: 0 var(--pb-btn-sec-pad-x);
  border-radius: var(--pb-btn-sec-radius);
  border: 1px solid var(--pb-btn-sec-border);
  background: var(--pb-btn-sec-bg);
  color: var(--pb-btn-sec-fg);
  text-decoration: none;
  line-height: 1;
  white-space: nowrap;
  cursor: pointer;
  box-shadow: none;
}

/* Slice 7 — subtle rainbow edges + minimal sparkle (scoped) */

/* 7.1 — Tokens (panel scope only) */
.ta .noMatch{
  /* very gentle rainbow; we’ll fade it via alpha */
  --pb-rainbow: conic-gradient(
    from 180deg at 50% 50%,
    #ff6b6b, #ffd166, #06d6a0, #118ab2, #c77dff, #ff6b6b
  );
  /* strengths */
  --pb-rainbow-alpha:        0.08; /* default: faint */
  --pb-rainbow-alpha-strong: 0.14; /* AI: one notch stronger */
}

/* default per-button alpha (can be overridden per-button) */
.ta .noMatch .btn.secondary{ --_rbw: var(--pb-rainbow-alpha); }
/* AI gets a slightly stronger edge (used only on :hover/:focus-visible) */
.ta .noMatch #btnAI{ --_rbw: var(--pb-rainbow-alpha-strong); }

/* 7.2 — Hover/focus: border becomes a faint rainbow edge */
.ta .noMatch .btn.secondary:hover,
.ta .noMatch .btn.secondary:focus-visible{
  /* let the gradient show through the border */
  border-color: transparent;
  /* layer 1: solid button fill (hover color if defined), layer 2: rainbow edge */
  background-image:
    linear-gradient(var(--pb-btn-sec-hover-bg, var(--pb-btn-sec-bg)), var(--pb-btn-sec-hover-bg, var(--pb-btn-sec-bg))),
    /* fade the rainbow via alpha; keep it classy */
    conic-gradient(
      from 180deg at 50% 50%,
      rgba(255,107,107, var(--_rbw)),
      rgba(255,209,102, var(--_rbw)),
      rgba(6,214,160,   var(--_rbw)),
      rgba(17,138,178,  var(--_rbw)),
      rgba(199,125,255, var(--_rbw)),
      rgba(255,107,107, var(--_rbw))
    );
  background-origin: border-box;
  background-clip: padding-box, border-box;
  transition: background-image .18s ease, border-color .18s ease;
}

/* 7.3 — Tiny sparkle micro-motion on AI icon (hover/focus only) */
@keyframes pb-sparkle-wiggle{
  0%   { transform: none; filter: none; }
  40%  { transform: rotate(6deg) scale(1.04); filter: brightness(1.08); }
  100% { transform: none; filter: none; }
}

/* Run once per hover/focus; no idle animation */
.ta .noMatch #btnAI:hover .pb-ico,
.ta .noMatch #btnAI:focus-visible .pb-ico,
.ta .noMatch #btnAI:hover .pb-icon,
.ta .noMatch #btnAI:focus-visible .pb-icon{
  animation: pb-sparkle-wiggle 380ms cubic-bezier(.2,.9,.2,1) 1;
  transform-origin: 50% 50%;
}

/* 7.4 — Respect reduced motion: no icon motion at all */
@media (prefers-reduced-motion: reduce){
  .ta .noMatch #btnAI:hover .pb-ico,
  .ta .noMatch #btnAI:focus-visible .pb-ico,
  .ta .noMatch #btnAI:hover .pb-icon,
  .ta .NoMatch #btnAI:focus-visible .pb-icon{
    animation: none !important;
    transform: none !important;
    filter: none !important;
  }
}

transition: background-color .15s ease, box-shadow .15s ease, transform .15s ease;

.ta .noMatch .btn.secondary:hover{
  background: var(--pb-btn-sec-hover-bg);
}

.ta .noMatch .btn.secondary:active{
  background: var(--pb-btn-sec-active-bg);
}

.ta .noMatch .btn.secondary:focus{
  outline: 2px solid var(--focus, #2563eb);
  outline-offset: 2px;
}

/* Force icon size in no-match panel (beats global svg rules) */
.ta .noMatch .btn.secondary svg.pb-icon{
  width: var(--pb-icon-size) !important;
  height: var(--pb-icon-size) !important;
  flex: 0 0 var(--pb-icon-size) !important;
}


/* === Subtle text utilities (muted, small) === */
.pb-subtle{
  color: var(--pb-text-muted);
}

.pb-fineprint{
  font-size: 12.5px;
  line-height: 1.35;
  color: var(--pb-text-subtle);
}

/* === Subtle text utilities (muted, small) === */
.pb-subtle{
  color: var(--pb-text-muted);
}

.pb-fineprint{
  font-size: 12.5px;
  line-height: 1.35;
  color: var(--pb-text-subtle);
}

/* Ensure panel CTAs are clickable even if a parent has pointer-events:none */
.pb-panel .btn { pointer-events: auto; }


/* ==== AI-Results modal (cards) ==== */
.ai-results::backdrop{ background: rgba(15,23,42,.48); }
.ai-results .modal-body{ padding:16px; border:1px solid var(--border); border-radius:16px; background:#fff; box-shadow: var(--shadow); }
.ai-results .results{ display:grid; grid-template-columns: repeat(auto-fit,minmax(260px,1fr)); gap:12px; }
.ai-results .result{
  border:1px solid var(--border); border-radius:14px; padding:12px; background:#fff; box-shadow: var(--shadow);
  display:flex; flex-direction:column; gap:8px; cursor:pointer;
  transition: transform .12s ease, box-shadow .18s ease;
}
.ai-results .result:hover{ transform: translateY(-1px); box-shadow: 0 12px 44px rgba(0,0,0,0.10); }
.ai-results .use{ margin:0; font-size:15px; font-weight:700; text-transform:lowercase; letter-spacing:.2px; }
.ai-results .label{ font-size:12px; color:var(--muted); }
.ai-results .def{ font-size:13px; color:#0c1220; margin:2px 0 0; }
.ai-results .def .full[hidden]{ display:none; }
.ai-results .row{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
.ai-results .actions{ margin-top:2px; display:flex; justify-content:flex-end; }
.ai-results .btn.small{ padding:6px 10px; font-size:12px; border-radius:10px; }


  /* index.html header: invisible container, right-aligned contents */
  .site-header {
    /* No background, no border, no shadow */
    background: transparent;
    border: 0;
    box-shadow: none;
  }
  .site-header .header-row {
    min-height: 48px;                /* adjust if you want more/less vertical room */
    display: flex;
    align-items: center;
    justify-content: flex-end;       /* ⇦ puts AI Settings on the right */
    padding: 8px 16px;               /* horizontal breathing room */
    gap: 12px;
  }


</style>

  
<!-- Beta/BMC UI -->
<link rel="stylesheet" href="./glossary/assets/beta-bmc.css?v=2025-09-29">
<script defer
        src="./glossary/assets/beta-bmc.js?v=2025-09-29"
        data-beta="pill"
        data-bmc="discrete"
        data-bmc-dismissible="true"></script>
        
        
 <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "Organization",
      "@id": "https://jonathankhobson.github.io/AI/#org",
      "name": "Prompt Builder",
      "url": "https://jonathankhobson.github.io/AI/index.html",
      "logo": {
        "@type": "ImageObject",
        "url": "https://jonathankhobson.github.io/AI/assets/brand/logo-512.png",
        "width": 512,
        "height": 512
      },
      "sameAs": [
        "https://www.linkedin.com/in/jonathankylehobson/"
      ]
    },
    {
      "@type": "WebSite",
      "@id": "https://jonathankhobson.github.io/AI/#website",
      "url": "https://jonathankhobson.github.io/AI/index.html",
      "name": "Prompt Builder",
      "inLanguage": "en-US",
      "publisher": { "@id": "https://jonathankhobson.github.io/AI/#org" },
      "potentialAction": {
        "@type": "SearchAction",
        "target": "https://jonathankhobson.github.io/AI/index.html?q={search_term_string}",
        "query-input": "required name=search_term_string"
      }
    },
    {
      "@type": "WebPage",
      "@id": "https://jonathankhobson.github.io/AI/index.html#webpage",
      "url": "https://jonathankhobson.github.io/AI/index.html",
      "name": "Build better prompts with clear context | Prompt Builder",
      "isPartOf": { "@id": "https://jonathankhobson.github.io/AI/#website" },
      "inLanguage": "en-US",
      "description": "Prompt Builder guides you to capture goals, context, constraints, and deliverables so AI outputs are clearer, faster, and reusable—fewer retries, better results.",
      "datePublished": "2025-09-15",
      "dateModified": "2025-09-30",
      "primaryImageOfPage": {
        "@type": "ImageObject",
        "url": "https://jonathankhobson.github.io/AI/assets/og/prompt-builder-og.png",
        "width": 1200,
        "height": 630
      },
      "breadcrumb": {
        "@type": "BreadcrumbList",
        "itemListElement": [
          { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://jonathankhobson.github.io/AI/index.html" },
          { "@type": "ListItem", "position": 2, "name": "Prompt Builder" }
        ]
      }
    }
  ]
}
</script>
  
  
  
  <!-- HTML STARTS HERE -->
  
  
</head>
<body data-beta="bar" data-bmc="obvious">
<a class="skip-link" href="#main">skip to content</a>

<noscript>
  <p style="padding:12px;border:1px solid #e3e9f2;border-radius:8px;background:#f9fafb;">
    You are moving to our new home. If nothing happens, 
    <a href="clare.html">click here to continue</a>.
  </p>
</noscript>


<header>
<header id="siteHeader" class="site-header" role="banner">
  <div class="header-row">
  

<!-- Keep your existing button -->
<button id="aiSettingsBtn" class="btn secondary ai-settings-btn" type="button" title="AI Assist settings">
  <span class="label">ai settings</span>
</button>

  </div>

  </header>
  

  <main id="main" class="wrap">

    <!-- HERO -->
    <section class="hero" id="hero">
      <h1 class="heroTitle">
        start building your 
        <span id="slot" class="slot" aria-live="polite" aria-atomic="true"> 
          <span id="reel" class="reel"> 
            <span id="reelList" class="reelList"></span>
          </span>
       </span>  
      </h1>

      <div class="searchWrap">
        <div class="search">
          <input id="q" type="text" placeholder="type what you’re trying to build…" autocomplete="off" />
          <div id="srStatus" class="visually-hidden" aria-live="polite"></div>
          <button id="go" type="button" title="Search">search</button>
        </div>
        <div id="ta" class="ta" role="listbox" hidden></div>
        <p class="hint">type what you want to make in everyday words — we’ll shape it into a clear ai prompt.</p>
      </div>
      
      <div class="searchCtas" aria-label="quick search actions">
  <a id="btnAdv" class="btn tertiary" href="./glossary/templates-glossary.html">advanced search</a>
  <!-- You can rename to “where do I start?” later; wiring stays the same -->
  <button id="btnHelp" class="btn secondary" type="button" title="Pick a helper & use-case">help me</button>
  <button id="btnLucky" class="btn secondary" type="button" title="Random use-case from everything">i’m feeling lucky</button>
</div>

      
      <div class="quickLinks">
  <!-- If your full glossary lives on a different page than this index,
       change the href below to that page. -->
  <a class="tile" href="./glossary/ai-glossary.html" aria-label="open full ai glossary">
    <h4>full ai glossary</h4>
    <p>everyday definitions for ai and prompting — search clear, plain-language terms.</p>
    <br>
    <span class="cta">open glossary</span>
  </a>

  <a class="tile" href="./glossary/templates-glossary.html" aria-label="open template glossary">
    <h4>template glossary</h4>
    <p>browse prompt-making templates with one-line summaries and examples.</p>
    <span class="cta">open templates</span>
  </a>

  <a class="tile" href="./glossary/prompt-builder.html" aria-label="open prompt builder config">
    <h4>prompt builder config</h4>
    <p>power-user controls for building and saving prompts with full options.</p>
    <span class="cta">open builder</span>
  </a>

  <a class="tile" href="./glossary/startup-wizard.html" aria-label="start the setup wizard">
    <h4>startup wizard (alpha)</h4>
    <p>a lighter, guided flow to set things up without the overwhelm.</p>
    <span class="cta">start wizard</span>
  </a>
</div>

<!-- MANTRA REEL -->
<section id="mantra" class="mantra" aria-label="prompting mantras">
  <div class="mantraLine">
    <span id="mantraSlot" class="mantraSlot" aria-live="polite" aria-atomic="true">
      <span id="mantraReel" class="mantraReel">
        <span id="mantraList" class="mantraList"></span>
      </span>
    </span>
  </div>
</section>


    </section>

    <!-- FAUX SCANNING -->
    <section class="scan" id="scan">
      <div class="roll">
        <ul id="rollList"></ul>
      </div>
    </section>
    
    <!-- AI RESULTS MODAL -->
<dialog id="aiResultsDlg" class="modal ai-results">
  <form method="dialog" class="modal-body" style="max-width:860px;">
    <div class="modal-header" style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
      <h3 style="margin:0;font-size:18px;line-height:1;">Pick the best match</h3>
      <button id="aiResultsClose" class="btn secondary" type="button" aria-label="Close">close</button>
    </div>
    <p class="hint" style="margin:.5rem 0 1rem;color:var(--muted);">
      Based on “<em id="aiResultsQuery" style="font-style:normal;"></em>”
    </p>
    <div id="aiResultsList" class="results"></div>
  </form>
</dialog>


    <!-- DETAILS -->
    <section class="details" id="details" hidden>
    
    <!-- MINI SEARCH (redo) -->
<div class="detailSearchWrap" aria-label="redo search">
  <div class="detailSearch">
    <input id="q2" type="text" placeholder="tweak or redo your search…" autocomplete="off" />
    <button id="go2" class="go" type="button" title="run search">search</button>
    <button id="retry" class="retry" type="button" title="try a different close match">re-roll</button>
  </div>
  <div id="ta2" class="ta ta--mini" role="listbox" hidden></div>

  <!-- DETAILS CTAs (centered row under mini search) -->
<div class="detailCtas" role="group" aria-label="actions">
  <div class="ctaGroup left">
    <a id="openGlossary"   class="btn secondary" href="#">all templates</a>
    <a id="printWorksheet" class="btn secondary" href="#">worksheet</a>
  </div>

  <a id="openBuilder" class="btn primary" href="#">prompt builder</a>

  <div class="ctaGroup right">
    <button id="copyPrompt" class="btn secondary" type="button">copy</button>
    <button id="ask"        class="btn secondary" type="button">ask</button>
  </div>
</div>
    
    
      <div class="card">
        <div class="left">
          <h2 id="tplTitle">template</h2>

          <div class="block">
            <h3>definition</h3>
            <div id="def" class="uc"></div>
          </div>

          <div class="block">
            <h3>use-cases</h3>
            <div id="useCases"></div>
          </div>

          <div class="block" id="boostersBlock" hidden>
            <h3>boosters</h3>
            <div id="boosters"></div>
          </div>
          
          <div class="meta" id="meta"></div>

          <div class="divider"></div>
        

         
        </div>

        <div class="right">
          <div class="block">
            <h3>fields</h3>
            <div class="fields" id="fields"></div>
          </div>
        </div>
      </div>
    </section>
  </main>
  
  
  <!-- Action modal (shared by Copy + Ask) -->
<dialog id="actionModal" class="modal" aria-modal="true">
  <form method="dialog" class="modal-body" id="actionForm" aria-labelledby="actionTitle">
    <header class="modal-header">
      <h3 id="actionTitle">Action</h3>
      <button type="button" class="icon close" aria-label="Close" id="actionClose">×</button>
    </header>

    <section class="modal-section">
      <div class="field">
        <label for="actionPreview">Preview (you can edit before confirming)</label>
        <textarea id="actionPreview" rows="14" spellcheck="false"></textarea>
      </div>
      <p id="actionNote" class="note" hidden></p>
    </section>

    <footer class="modal-footer">
      <button type="submit" class="btn primary" id="actionConfirm">confirm</button>
      <button type="button" class="btn" id="actionCancel">cancel</button>
    </footer>
  </form>
</dialog>

  <!-- datasets -->
  
     <script src="./glossary/js/aisettings.js" defer></script>
    <script src="./glossary/js/templates.data.js"></script>
    
     <script>
    // lazy-load tasks dataset
    (function ensureTasksLoaded(){
      if (Array.isArray(window.TEMPLATES)) return;
      const s = document.createElement('script');
      s.src = './glossary/templates.data.js';
      s.onerror = ()=> console.info('tasks dataset not found at ./glossary/templates.data.js');
      document.head.appendChild(s);
    })();
  </script>
  
  <script>
    // lazy-load tasks dataset
    (function ensureTasksLoaded(){
      if (Array.isArray(window.TASK_TEMPLATES)) return;
      const s = document.createElement('script');
      s.src = './glossary/templates.tasks.data.js';
      s.onerror = ()=> console.info('tasks dataset not found at ./glossary/templates.tasks.data.js');
      document.head.appendChild(s);
    })();
  </script>
  
<script>
  // Always bust cache in dev
  const DATA_VERSION = Date.now();

  function injectScript(src){
    const s = document.createElement('script');
    s.src = src + (src.includes('?') ? '&' : '?') + 'v=' + DATA_VERSION;
    s.crossOrigin = 'anonymous';
    document.head.appendChild(s);
    return s;
  }

  // Rebuild the search index any time a dataset arrives
function rebuild(){
  INDEX = buildIndex();
  // Keep the AI library markdown cache fresh, but don’t break if pb.ai isn’t ready yet
  try{ if (pb && pb.ai && typeof pb.ai.rebuildLibraryMd === 'function') pb.ai.rebuildLibraryMd(); }catch(_){}
  onQuery();
}

  injectScript('./glossary/templates.data.js').onload = rebuild;
  injectScript('./glossary/templates.tasks.data.js').onload = rebuild;
</script>



  <script>
/* ===== HERO: fixed-width slot + vertical reel (anti-clipping) ===== */
(function heroSlot(){
  const words = ['project.', 'life.', 'plan.', 'system.', 'idea.', 'prompt.'];

  const slot = document.getElementById('slot');
  const reel = document.getElementById('reel');
  const list = document.getElementById('reelList');

  list.innerHTML = words.map(w => `<span class="w">${w}</span>`).join('');

  const cs = getComputedStyle(document.documentElement);
  const holdMs  = parseFloat(cs.getPropertyValue('--slot-hold'))  || 680;
  const dpr = window.devicePixelRatio || 1;

  function widestWordPx(){
    const slotEl = document.getElementById('slot');
    const cs = getComputedStyle(slotEl);

    const meas = document.createElement('span');
    meas.style.position = 'absolute';
    meas.style.visibility = 'hidden';
    meas.style.whiteSpace = 'nowrap';
    meas.style.left = '-9999px';
    meas.style.top = '-9999px';

    // copy all width-affecting text styles
    meas.style.font = cs.font;
    meas.style.letterSpacing = cs.letterSpacing;
    meas.style.textTransform = cs.textTransform;
    meas.style.fontKerning = cs.fontKerning;
    meas.style.fontFeatureSettings = cs.fontFeatureSettings;
    meas.style.fontVariationSettings = cs.fontVariationSettings;
    meas.style.fontStretch = cs.fontStretch;

    document.body.appendChild(meas);

    let max = 0;
    for (const w of words){
      meas.textContent = w;
      const wpx = meas.getBoundingClientRect().width;
      if (wpx > max) max = wpx;
    }
    meas.remove();

    return Math.ceil(max + 20); // base guard; DPR fudge added separately
  }

  // Measure and lock the row height + slot width
  let rowH = 0;
  function lockMetrics(){
    // Row height in pixels (use rendered metrics, not ems)
    const first = list.firstElementChild;
    let h = first ? first.getBoundingClientRect().height : 0;
    if (!h){
      // fallback to slot font-size if fonts not ready
      h = parseFloat(getComputedStyle(slot).fontSize) || 32;
    }
    // Add a tiny cushion so mask never touches glyphs
    rowH = Math.ceil(h + 2);
    slot.style.setProperty('--slot-h', rowH + 'px');

    // Lock the slot width to the widest word (prevents horizontal clipping)
    const wpx = widestWordPx();
    // add one physical pixel to dodge subpixel rounding on high-DPI
    const fudge = Math.max(1, Math.round((window.devicePixelRatio || 1)));
    slot.style.setProperty('--slot-width', (wpx + fudge) + 'px');
  }

  function translateToRow(idx){
    // snap to device pixels so we never land on a half pixel under the mask
    const y = Math.round((idx * rowH) * dpr) / dpr;
    list.style.transform = `translate3d(0, ${-y}px, 0)`;
  }

  function run(){
    lockMetrics();
    let i = 0;

    const advance = ()=>{
      if (i < words.length - 1){
        i++;
        translateToRow(i);
        setTimeout(advance, holdMs);
      } else {
        // Landed on "prompt": remove mask and bounce
        slot.classList.add('final');
      }
    };

    // initial dwell so the first word is readable
    setTimeout(advance, holdMs);
  }

  // Wait for fonts so measurements are stable, then run
  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(run);
  } else {
    window.addEventListener('load', run, { once:true });
  }

  // Re-lock on resize or zoom
  window.addEventListener('resize', ()=>{ lockMetrics(); /* keep current row in view */ });
})();


  /* ===== Search + typeahead (same API, updated ranking) ===== */
  function allTemplates(){
    const base  = Array.isArray(window.TEMPLATES) ? window.TEMPLATES
                : Array.isArray(window.FRAMEWORKS) ? window.FRAMEWORKS : [];
    const tasks = Array.isArray(window.TASK_TEMPLATES) ? window.TASK_TEMPLATES
                : Array.isArray(window.tasks) ? window.tasks : [];

    // Preserve everything; just tag the origin so we can prioritize “task” kind
    const mark = (arr, isTask)=> arr.map(t => ({ ...t, __isTask:isTask }));

    return [...mark(base,false), ...mark(tasks,true)].map(t=>{
      const cats = Array.isArray(t.categories) ? t.categories : (t.category ? [t.category] : []);
      return { ...t, categories: cats, use_cases: Array.isArray(t.use_cases)? t.use_cases : [] };
    });
  }

// Replace your buildIndex() with this (adds kind/isTask but keeps existing fields)
  function buildIndex(){
    const src = allTemplates();
    return src.map(t=>{
      const useTags = (t.tags || [])
        .map(String).map(s => s.trim().toLowerCase())
        .filter(s => s.startsWith('use:'))
        .map(s => s.split(':',2)[1])
        .filter(Boolean);

      const uc    = (t.use_cases || []).map(String);
      const kind  = String(t.kind || t.type || '').toLowerCase();
      const isTask = (kind === 'task')
        || /^task[_-]/.test(String(t.id||''))
        || /^task[_-]/.test(String(t.slug||''));

      return {
        id: t.id || t.slug || t.label,
        slug: t.slug || t.id,
        label: t.label || t.name || t.slug || t.id || 'untitled',
        use_cases: uc,
        use_tags: useTags,
        tags: (t.tags || []).slice(),
        categories: t.categories || [],
        boosters: Array.isArray(t.boosters) ? t.boosters.slice() : [],
        definition: t.definition || t.help || '',
        fields: Array.isArray(t.fields) ? t.fields.slice() : [],
        // NEW: metadata for ranking only
        kind, isTask
      };
    });
  }
  

// ==== Slice 0: Flags, Tunables, Logger (no behavior changes) ====

window.pb = window.pb || {};
pb.flags = pb.flags || {
  // feature flags (defaults ON for shipping)
  search: {
    useConfidence: true,         // ON: rank/gate by confidence
    showClosestMatches: true,    // ON: show 1–2 closest hits with panel
    helperGrace: true,           // ON: show helper 4..6 chars if no good hit
    tailPenalty: true,           // ON: suppress last-word hijacks
    idf: true                    // ON: rarity weighting
  }
};

// AI-assisted search flags (Slice A)
pb.flags.aiAssist = pb.flags.aiAssist || {
  enabled: true,        // master kill switch for AI-assisted search
  allowOpenAI: true,    // allow using OpenAI if user selected it in AI Settings
  allowGemini: true,     // allow using Gemini if user selected it in AI Settings
  allowApertus: true   // allow using Apertus if user selected it in AI Settings
};

// Tunables (safe defaults; used later when flags flip ON)
pb.tuning = pb.tuning || {
  minPanelLen: 7,          // flip to panel at >=7 chars (when confidence logic enabled)
  helperGraceMin: 4,       // show helper ideas between 4..6 chars (if helperGrace=true)
  helperGraceMax: 6,
  confidenceThreshold: 0.70
};

// Lightweight counters (in-memory only)
pb.metrics = pb.metrics || {
  panelShown: 0,
  goodMatchShown: 0,
  actionChosen: { ai: 0, advanced: 0, continue: 0 },
  confidenceBucket: { lt30: 0, lt55: 0, gte55: 0 }
};

// Tiny logger (counts only; noop-safe)
pb.log = function(evt, data){
  try{
    if (evt === 'panelShown') pb.metrics.panelShown++;
    else if (evt === 'goodMatchShown') pb.metrics.goodMatchShown++;
    else if (evt === 'actionChosen' && data && data.action){
      const k = String(data.action);
      if (pb.metrics.actionChosen[k] != null) pb.metrics.actionChosen[k]++;
    } else if (evt === 'confidenceBucket' && data && typeof data.confidence === 'number'){
      const c = data.confidence;
      if (c < 0.30) pb.metrics.confidenceBucket.lt30++;
      else if (c < pb.tuning.confidenceThreshold) pb.metrics.confidenceBucket.lt55++;
      else pb.metrics.confidenceBucket.gte55++;
    }
    // Optional: expose last event for debugging in devtools
    pb._lastLog = { evt, data, ts: Date.now() };
  }catch(_){}
};

// Dev helper: window.pbStats() prints current counters (remove in prod if desired)
window.pbStats = function(){ try{ console.table(pb.metrics); }catch(_){ console.log(pb.metrics); } };


// Helper to read flags/tunables in one place (future slices use this)
pb.feature = function(path, fallback){
  try{
    const parts = path.split('.');
    let cur = (path.startsWith('search.') ? pb.flags : pb)[parts.shift()];
    for (const p of parts) cur = cur[p];
    return (typeof cur === 'undefined') ? fallback : cur;
  }catch(_){ return fallback; }
};

/* ==== Slice A: AI-assist plumbing (no network yet) ==== */
pb.ai = (function(){
  // LocalStorage keys used by aisettings.js (v2 first, then fallback)
  const LS_KEYS = ['pb.ai.settings.v2', 'pb.ai.settings'];

  // Normalize settings into a stable shape
  function normalize(s){
    const out = {
      provider: (s?.provider || '').toLowerCase(), // 'openai' | 'gemini' | ''
      noApi: !!s?.noApi,
      // canonical model fields (both kept; callers pick what they need)
      model: s?.model || '',
      geminiModel: s?.geminiModel || s?.model || '',
      // canonical apiKey field (provider-specific fallbacks)
      apiKey: s?.apiKey || s?.openaiKey || s?.geminiKey || ''
    };
    // If provider hints exist (e.g., openaiKey is present), prefer them
    if (!out.apiKey){
      if (out.provider === 'openai' && s?.openaiKey) out.apiKey = s.openaiKey;
      if (out.provider === 'gemini' && s?.geminiKey) out.apiKey = s.geminiKey;
    }
    return out;
  }

  // Try to read settings from the AISettings module, then from localStorage
  function readSettings(){
    // 1) Preferred: module API (if it’s loaded)
    try{
      const mod = window.AISettings || window.aiSettings || window.ai;
      if (mod && typeof mod.get === 'function'){
        const got = mod.get();
        return normalize(got || {});
      }
    }catch(_){}
    // 2) Fallback: localStorage (v2 then legacy)
    for (const k of LS_KEYS){
      try{
        const raw = localStorage.getItem(k);
        if (raw){
          const got = JSON.parse(raw);
          return normalize(got || {});
        }
      }catch(_){}
    }
    // 3) Empty defaults
    return normalize({});
  }

  // Public: mirror of AISettings.get() (normalized)
  function getSettings(){ return readSettings(); }

  // Public: do we have a usable API key for the selected provider?
function hasKey(){
  const s = getSettings();                     // mirrors AISettings.get()
  const provider = (s.provider || '').toLowerCase();

  // No-API mode is never valid for AI-assisted search
  if (s.noApi) return { ok:false, provider, reason:'no-api-mode' };

  if (provider === 'openai'){
    if (!s.apiKey) return { ok:false, provider, reason:'missing-key' };
    return { ok:true, provider, key:s.apiKey, model:s.model || 'gpt-4o-mini' };
  }

  if (provider === 'gemini'){
    if (!s.apiKey) return { ok:false, provider, reason:'missing-key' };
    return { ok:true, provider, key:s.apiKey, model:s.geminiModel || 'gemini-2.0-flash' };
  }

  // APERTUS
if (provider === 'apertus'){
  const route = (s.apertusRoute || 'publicai').toLowerCase();
  const model = s.apertusModel || 'swiss-ai/apertus-8b-instruct';

  // PUBLICAI ROUTE: proxy holds the upstream key → allow keyless operation
  if (route === 'publicai'){
    return {
      ok: true,
      provider,
      route,
      key: s.publicAIKey || '',  // optional; adapter won’t send Authorization when empty
      model
    };
  }

  // HUGGINGFACE ROUTE: client must provide token
  if (!s.hfToken){
    return { ok:false, provider, reason:'missing-key' };
  }
  return { ok:true, provider, route, key:s.hfToken, model };
}

  return { ok:false, provider:null, reason:'no-provider' };
}

  // Public: placeholder for the intent rewrite pipeline (no network yet)
  // Returns a Promise that resolves to a typed stub so wiring can proceed safely.
  // Public: provider-dispatch with 12s timeout
  // NOTE: we still ignore any universal prompt/promptSeed on purpose.
function runIntentRewrite(opts){
  const q = String(opts?.q || '').trim();
  const md = (opts && opts.libraryMd) || (pb.ai.getLibraryMarkdown ? pb.ai.getLibraryMarkdown() : '');
  const s = getSettings();
  const k = hasKey();

  if (!k.ok){
    return Promise.resolve({ ok:false, provider: s.provider || null, error: { type:'no_key', reason:k.reason }});
  }

  const allow = pb.flags && pb.flags.aiAssist || {};
  if (s.provider === 'openai'  && allow.allowOpenAI  === false){
    return Promise.resolve({ ok:false, provider:'openai', error:{ type:'blocked', reason:'provider-blocked' }});
  }
  if (s.provider === 'gemini'  && allow.allowGemini  === false){
    return Promise.resolve({ ok:false, provider:'gemini', error:{ type:'blocked', reason:'provider-blocked' }});
  }
  if (s.provider === 'apertus' && allow.allowApertus === false){
    return Promise.resolve({ ok:false, provider:'apertus', error:{ type:'blocked', reason:'provider-blocked' }});
  }

  // Build common args
  const base = { q, libraryMd: md, timeoutMs: 12000 };

  if (s.provider === 'gemini'){
    return pb.ai.callGemini({ ...base, key: s.apiKey, model: s.geminiModel || 'gemini-2.5-flash' });
  }
// ▼▼ REPLACE ONLY THE APERTUS BRANCH WITH THIS ▼▼
if (s.provider === 'apertus'){
  // Settings
  const route = String(s.apertusRoute || 'publicai').toLowerCase();
  const model = s.apertusModel || 'swiss-ai/apertus-8b-instruct';

  // When using your PublicAI Worker (proxy holds the upstream key),
  // it’s OK for 'key' to be empty. For Hugging Face route, we do need the token.
  const key   = (route === 'huggingface') ? (s.hfToken || '') : (s.publicAIKey || '');

  // Call the new demo-parity adapter (20s timeout, same as Gemini)
  return pb.ai.callApertus({
    q,
    libraryMd,
    key,
    model,
    route,
    timeoutMs
  });
}
// ▲▲ REPLACE ONLY THE APERTUS BRANCH WITH THIS ▲▲
  // default → openai
  return pb.ai.callOpenAI({ ...base, key: s.apiKey, model: s.model || 'gpt-4o-mini' });
}

  // Optional: tiny dev helper
  window.pbAI = function(){
    const s = getSettings();
    console.info('[pb.ai] settings:', s, 'hasKey:', hasKey());
    return s;
  };

  return { getSettings, hasKey, runIntentRewrite };
})();

/* ==== Slice B: Library Markdown builder (templates + tasks) ==== */
(function(){
  // Guard namespace
  window.pb = window.pb || {};
  pb.ai = pb.ai || {};

  // Lightweight local fold (safe even if pb.fold isn’t ready yet)
  function foldLocal(s){
    try{
      return String(s ?? '')
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g,'')
        .toLowerCase()
        .replace(/[_~`^"'.,!?;:(){}$begin:math:display$$end:math:display$<>/\\|@#$%&*=+]/g,' ')
        .replace(/\s+/g,' ')
        .trim();
    }catch{ return String(s ?? '').toLowerCase().trim(); }
  }

  // Use global stopwords if present; otherwise a tiny fallback set
  const STOP = (pb && pb.stop) || new Set(['a','an','the','i','you','we','to','for','of','and','or','with','on','in']);

  // Cache record
  pb.ai._libCache = pb.ai._libCache || null;

  // Helpers
  const MAX_DEF = 80;   // truncate definition text
  const MAX_KW  = 8;    // max keyword tokens per row

  function def80(s){
    if (!s) return '';
    s = String(s).replace(/\s+/g,' ').trim();
    if (s.length <= MAX_DEF) return s;
    return s.slice(0, MAX_DEF - 1).trimEnd() + '…';
  }

  function kwFromTemplate(t){
    const pool = [];
    if (Array.isArray(t.tags))        pool.push(...t.tags);
    if (Array.isArray(t.categories))  pool.push(...t.categories);
    if (Array.isArray(t.use_tags))    pool.push(...t.use_tags);
    if (Array.isArray(t.use_cases))   pool.push(...t.use_cases.slice(0,3));
    if (Array.isArray(t.fields))      pool.push(...t.fields.map(f => f && (f.label || f.key || '')).filter(Boolean));
    if (t.label)                      pool.push(t.label);

    const toks = [];
    const seen = new Set();
    const folded = foldLocal(pool.filter(Boolean).join(' '));
    for (const tok of folded.split(/\s+/)){
      if (!tok || tok.length < 2) continue;
      if (STOP.has(tok)) continue;
      if (seen.has(tok)) continue;
      seen.add(tok);
      toks.push(tok);
      if (toks.length >= MAX_KW) break;
    }
    return toks;
  }

  function collectItems(){
    // Prefer your allTemplates() merger so we get { isTask, kind, use_cases, ... }
    const src = (typeof allTemplates === 'function') ? allTemplates() : [];
    // Dedupe by slug; first wins
    const map = new Map();
    for (const t of src){
      const slug = String(t.slug || t.id || '').trim();
      if (!slug) continue;
      if (!map.has(slug)) map.set(slug, t);
    }
    // Deterministic stable order: tasks first, then label ASC (lightweight hinting)
    return Array.from(map.values()).sort((a,b)=>
      ((b.__isTask?1:0) - (a.__isTask?1:0)) || String(a.label||'').localeCompare(String(b.label||''))
    );
  }

  function buildMd(items){
    const esc = s => String(s).replace(/\|/g, '\\|');
    const rows = [
      '| slug | definition | keywords |',
      '|---|---|---|'
    ];
    for (const t of items){
      const slug = String(t.slug || t.id || '').trim();
      if (!slug) continue;
      const def  = def80(t.definition || t.help || (t.use_cases && t.use_cases[0]) || '');
      const kws  = kwFromTemplate(t).join(', ');
      rows.push(`| ${esc(slug)} | ${esc(def)} | ${esc(kws)} |`);
    }
    return rows.join('\n');
  }

  // Public: build on demand (optionally from custom items)
  pb.ai.buildLibraryMarkdown = function(items){
    const list = (Array.isArray(items) && items.length) ? items : collectItems();
    return buildMd(list);
  };

  // Public: cached getter (keyed by dataset version + rough slug count)
  pb.ai.getLibraryMarkdown = function(){
    const version = (window.DATA_VERSION != null) ? String(window.DATA_VERSION) : '0';
    const slugCount = (Array.isArray(INDEX) ? INDEX.length : 0);
    const cacheKey = version + '|' + slugCount;

    const c = pb.ai._libCache;
    if (c && c.key === cacheKey) return c.text;

    const items = collectItems();
    const text  = buildMd(items);
    pb.ai._libCache = { key: cacheKey, text, bytes: text.length, rows: items.length };
    return text;
  };

  // Public: invalidate + rebuild now (used by rebuild() on dataset load)
  pb.ai.rebuildLibraryMd = function(){
    pb.ai._libCache = null;
    try { return pb.ai.getLibraryMarkdown(); } catch { return ''; }
  };
})();

    function rankSuggestions(q, idx, limit = 8){
    // Slice 1: compute tokens for the current query (no behavior change yet)
const _Q = pb.tokenizeQueryCached(q);
// Expose for future slices / debugging (safe)
pb._lastQ = _Q;
    if (pb && pb.flags && pb.flags.search && pb.flags.search.idf){
  if (!pb.idf) pb.buildIDF(INDEX);
}
  const rawQ  = String(q || '').trim().toLowerCase();
  const terms = rawQ.split(/[^a-z0-9]+/).filter(Boolean);
  if (!terms.length) return [];

  const esc = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const hits = [];

  for (const t of idx){
    let bestUC = '';
    let ucScore = 0;

    // ========= 1) USE-CASES (now gated on real lexical match) =========
    for (const uc of t.use_cases){
      const l = uc.toLowerCase();
      let s = 0;
      let matched = false;          // <-- NEW: track if any lexical match happened
      let firstPos = Infinity;

      // phrase / exact line
      if (rawQ && l === rawQ){ s += 220; matched = true; }
      else if (rawQ && l.includes(rawQ)){ s += 120; matched = true; }

      // token scoring
      for (const tok of terms){
        if (l === tok){ s += 80; matched = true; }
        const re = new RegExp(`\\b${esc(tok)}\\b`);
        if (re.test(l)){ s += 40; matched = true; }
        const pos = l.indexOf(tok);
        if (pos >= 0){
          s += 24;                   // substring
          matched = true;
          firstPos = Math.min(firstPos, pos);
          if (pos === 0) s += 10;    // starts-with
        }
      }

      // ⛔️ If nothing matched, this UC should NOT enter the pool
      if (!matched) continue;

      // position + brevity nudges only apply when there was a match
      if (firstPos < Infinity){
        s += Math.max(0, 30 - Math.min(30, firstPos));
      }
      s += Math.max(0, 18 - Math.min(18, Math.floor(l.length / 12)));

      // gentle task nudge (ordering only) — only after a real match
      if (t.isTask) s += 30;

      // tiny kind-mention nudge
      if (t.kind && terms.some(tok => t.kind.includes(tok))) s += 12;

      if (s > ucScore){ ucScore = s; bestUC = uc; }
    }

    // ========= 2) use: TAGS (fallback only if no UC hit) =========
    let tagScore = 0;
    if (ucScore === 0 && t.use_tags.length){
      for (const tag of t.use_tags){
        const tl = String(tag).toLowerCase();
        for (const tok of terms){
          if (tl === tok) tagScore += 20;
          else if (tl.includes(tok)) tagScore += 12;
        }
      }
      if (tagScore > 0){
        if (t.isTask) tagScore += 12;
        if (t.kind && terms.some(tok => t.kind.includes(tok))) tagScore += 8;
      }
    }

    if (ucScore > 0){
      hits.push({ bucket:'uc', score: ucScore, use: bestUC || (t.use_cases[0] || ''), label:t.label, template:t, id:t.id, slug:t.slug });
    } else if (tagScore > 0){
      hits.push({ bucket:'tag', score: tagScore, use: bestUC || (t.use_cases[0] || ''), label:t.label, template:t, id:t.id, slug:t.slug });
    }
  }

  // primary sort (unchanged)
  hits.sort((a,b)=>
    (a.bucket === b.bucket ? 0 : (a.bucket === 'uc' ? -1 : 1)) ||
    (b.score - a.score) ||
    ((b.template.isTask?1:0) - (a.template.isTask?1:0)) ||
    (a.use.length - b.use.length) ||
    a.use.localeCompare(b.use)
  );

  // ========= Wild-query fallback (now triggers correctly) =========
  const TOP = hits[0]?.score || 0;
  const WILD_MIN_HITS  = 2;
  const WILD_TOP_SCORE = 60;
  const isWild = (hits.length === 0) || (hits.length <= WILD_MIN_HITS && TOP < WILD_TOP_SCORE);

  if (isWild){
    const HELPER_LABELS = new Set(['— Task Picker —','— Pattern Picker —']);
    const helperTemplates = idx.filter(t=>{
      const lbl = String(t.label||'').trim();
      const id  = String(t.id||'').trim().toLowerCase();
      const kind= String(t.kind||'').trim().toLowerCase();
      return HELPER_LABELS.has(lbl) && (id === 'none' || kind === 'helper');
    });

    const helperBase = Math.max(TOP + 5, 240);
    const seenUse = new Set(hits.map(h => h.use));
    let step = 0;

    for (const t of helperTemplates){
      for (const uc of (t.use_cases || [])){
        if (seenUse.has(uc)) continue;
 hits.push({
  bucket:'uc',
  score: helperBase - (step++ * 0.5),
  use: uc,
  label: t.label,
  template: t,
  id: t.id,
  slug: t.slug,
  origin: 'helper' // <-- CRITICAL: mark as helper so DIRECT excludes these
});
        seenUse.add(uc);
      }
    }

    hits.sort((a,b)=>
      (a.bucket === b.bucket ? 0 : (a.bucket === 'uc' ? -1 : 1)) ||
      (b.score - a.score) ||
      ((b.template.isTask?1:0) - (a.template.isTask?1:0)) ||
      (a.use.length - b.use.length) ||
      a.use.localeCompare(b.use)
    );
  }

  return hits.slice(0, limit);
}


// ===== Recent + idle helper suggestions =====
const RECENT_KEY  = 'pb_recent_queries';
const MAX_RECENT  = 12;
const LAST_KEY    = 'pb_last_search';   // <- single, structured handoff record

function loadRecent(){
  try { return JSON.parse(localStorage.getItem(RECENT_KEY) || '[]'); }
  catch { return []; }
}
function saveRecent(q){
  q = String(q||'').trim();
  if (!q) return;
  let list = loadRecent().filter(s => s && s.toLowerCase() !== q.toLowerCase());
  list.unshift(q);
  if (list.length > MAX_RECENT) list = list.slice(0, MAX_RECENT);
  localStorage.setItem(RECENT_KEY, JSON.stringify(list));
}

function saveLastSearch(ctx){
  try{
    const safe = {
      q: String(ctx?.q || '').trim() || null,
      slug: ctx?.slug || null,
      label: ctx?.label || null,
      confidence: (typeof ctx?.confidence === 'number') ? ctx.confidence : null,
      state: ctx?.state || null,               // 'GoodMatch' | 'NoGoodMatch' | 'Helper'
      tokens: Array.isArray(ctx?.tokens) ? ctx.tokens.slice(0, 32) : [], // cap to stay tiny
      ts: Date.now(),
      from: ctx?.from || 'index'
    };
    localStorage.setItem(LAST_KEY, JSON.stringify(safe));
  }catch(_){}
}

function loadLastSearch(){
  try{ return JSON.parse(localStorage.getItem(LAST_KEY) || 'null'); }
  catch{ return null; }
}

function helperTemplates(idx){
  const HELPER_LABELS = new Set(['— Task Picker —','— Pattern Picker —']);
  return idx.filter(t=>{
    const lbl = String(t.label||'').trim();
    const id  = String(t.id||'').trim().toLowerCase();
    const kind= String(t.kind||'').trim().toLowerCase();
    return HELPER_LABELS.has(lbl) && (id === 'none' || kind === 'helper');
  });
}

function helperUsecaseSuggestions(idx, limit, seen=new Set()){
  const out = [];
  for (const t of helperTemplates(idx)){
    for (const uc of (t.use_cases || [])){
      if (seen.has(uc)) continue;
      out.push({
        bucket:'uc', score: 999,
        use: uc, label: t.label,
        template: t, id: t.id, slug: t.slug,
        origin:'helper'
      });
      seen.add(uc);
      if (out.length >= limit) return out;
    }
  }
  return out;
}

function buildIdleSuggestions(idx, limit=8){
  const seen = new Set();
  const out  = [];

  // Recent searches first
  const rec = loadRecent();
  for (const r of rec){
    if (!r || seen.has(r)) continue;
    out.push({
      bucket:'uc', score: 1000,
      use: r, label:'recent',
      template:null, id:null, slug:null,
      origin:'recent'
    });
    seen.add(r);
    if (out.length >= limit) return out;
  }

  // Then helper picker use-cases
  return out.concat(helperUsecaseSuggestions(idx, Math.max(0, limit - out.length), seen));
}

    const qEl  = document.getElementById('q');
    const taEl = document.getElementById('ta');
    const goEl = document.getElementById('go');
    
    window.pb = window.pb || {};
window.pb.srStatusEl = document.getElementById('srStatus');

    let INDEX = [];
    let active = -1;
    let picked = null;
    // remember last search + last shown template so "try another" can exclude it
let LAST_CTX = { q:'', slug:null };

    function renderTA(list){
      if (!list.length){ taEl.hidden = true; taEl.innerHTML = ''; active=-1; return; }
      taEl.innerHTML = list.map((s,i)=>`
        <div class="item${i===0?' active':''}" role="option" data-i="${i}">
          <div class="use">${s.use}</div>
          <div class="sub" aria-hidden="true">${s.label}</div>
        </div>
      `).join('');
      taEl.hidden = false; active = 0;
    }
    
    
    // Build the "Closest matches" mini-list (1–2 items) for NoGoodMatch.
// Uses the same .item markup & data-i indices so existing handlers work.
function buildClosestMatchesHTML(list, max = 2){
  if (!Array.isArray(list) || !list.length) return '';
  const idxs = [];
  for (let i = 0; i < list.length && idxs.length < max; i++){
    if (list[i] && list[i].origin !== 'helper') idxs.push(i);
  }
  if (!idxs.length) return '';

  const items = idxs.map(i => `
    <div class="item" role="option" data-i="${i}">
      <div class="use">${list[i].use}</div>
      <div class="sub" aria-hidden="true">${list[i].label}</div>
    </div>
  `).join('');

  return `
    <hr class="pb-div">
    <div class="pb-near" role="group" aria-label="Closest matches">
      <div class="hdr sm">Closest matches</div>
      ${items}
    </div>
  `;
}

function buildNoMatchPanelHTML(q){
  // Escape user text for safe HTML
  const esc = (s)=>String(s||'').replace(/[&<>"]/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[m]));
  const txt = esc(q);

  // Markup structure: Title → Guidance → Actions (3 buttons) → (no global fine print)
  // Spacing: actions gap = 14px; panel bottom margin = 16px (inline styles per Slice 6)
  return `
    <div class="pb-panel" role="group" aria-labelledby="noMatchTitle" style="margin-bottom:16px;">
      <!-- Title -->
      <div id="noMatchTitle" class="hdr">No good match yet for “${txt}”</div>

      <!-- Guidance (not a button) -->
      <p class="pb-subtle gap">
        Tip: try fewer words or a different use case
        (e.g., ‘break down a goal’, ‘write a résumé’, ‘design inclusive policies’).
      </p>

      <!-- Actions row: three equal secondary buttons (AI first) -->
      <div class="actions gap" style="gap:14px;">
        <!-- 1) AI-assisted search -->
        <button id="btnAI" class="btn secondary" type="button">
          <svg class="pb-ico" width="32" height="32" viewBox="0 0 24 24"
               aria-hidden="true" focusable="false" fill="currentColor"
               style="width:16px!important;height:16px!important;max-width:none!important;max-height:none!important;transform:none!important;display:inline-block;flex:0 0 16px;vertical-align:middle;">
            <path d="M9 3l1.5 3.5L14 8l-3.5 1.5L9 13l-1.5-3.5L4 8l3.5-1.5L9 3zM17 10l.8 1.8L19.5 13l-1.7.2L17 15l-.8-1.8L14.5 13l1.7-.2L17 10zM12 16l1 2 2 1-2 .3-1 1.7-1-1.7-2-.3 2-1 1-2z"/>
          </svg>
          <span>AI-assisted search</span>
        </button>

        <!-- 2) Advanced search -->
        <a id="btnadv" class="btn secondary" href="./glossary/templates-glossary.html">
          <svg class="pb-ico" width="32" height="32" viewBox="0 0 24 24"
               aria-hidden="true" focusable="false" fill="currentColor"
               style="width:16px!important;height:16px!important;max-width:none!important;max-height:none!important;transform:none!important;display:inline-block;flex:0 0 16px;vertical-align:middle;">
            <path d="M10 18a8 8 0 1 1 5.293-14.293A8 8 0 0 1 10 18zm0-2a6 6 0 1 0 0-12 6 6 0 0 0 0 12zm8.707 3.293l-3.4-3.4 1.414-1.414 3.4 3.4a1 1 0 0 1-1.414 1.414z"/>
          </svg>
          <span>Advanced search</span>
        </a>

        <!-- 3) Continue anyway (with inline caveat tied via aria-describedby) -->
        <button id="btnContinue" class="btn secondary" type="button" aria-describedby="continueCaveat">
          <svg class="pb-ico" width="32" height="32" viewBox="0 0 24 24"
               aria-hidden="true" focusable="false" fill="none"
               style="width:16px!important;height:16px!important;max-width:none!important;max-height:none!important;transform:none!important;display:inline-block;flex:0 0 16px;vertical-align:middle;">
            <path d="M5 12h12M13 6l6 6-6 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          <span>Continue anyway</span>
          <!-- Inline sublabel (small, muted) -->
          <div id="continueCaveat" class="pb-fineprint"
               style="display:block;font-size:12px;line-height:1.25;opacity:.75;margin-top:2px;">
            May be off-target.
          </div>
        </button>
      </div>
    </div>
  `;
}

// ==== Slice 2: IDF prep (rarity points), built once, behind flag ====

// ==== Slice 1: Tokenization, normalization, and weights (improved) ====
// No external deps. Works with window.TEMPLATES/FRAMEWORKS and TASK_TEMPLATES/TASKS.

// 0) Namespace
window.pb = window.pb || {};

// 1) Stopwords (drop completely from matching)
//    Includes pronouns, auxiliaries, common preps/conjs, contractions shards, and boilerplate adverbs.
pb.stop = pb.stop || new Set([
  // articles, determiners, pronouns
  'a','an','the','this','that','these','those','some','any','each','every','either','neither',
  'i','me','my','mine','you','your','yours','we','us','our','ours','they','them','their','theirs',
  'he','him','his','she','her','hers','it','its','one','ones','someone','something','everyone','everything',
  // wh-words & fillers
  'who','whom','whose','what','when','where','why','how',
  // auxiliaries & modals
  'be','am','is','are','was','were','been','being',
  'do','does','did','doing',
  'have','has','had','having',
  'will','would','shall','should','can','could','may','might','must',
  // negation shards from folding contractions
  'not','no','nor','n','t','s','d','ll','re','ve','m',
  // prepositions / conjunctions / adverbs (common)
  'to','for','of','and','or','with','on','in','into','at','by','from','as','than','then',
  'so','too','very','just','only','also','about','because','before','after','between','during','until','while',
  'against','through','throughout','per','without','within','across','toward','towards','via',
  'over','under','again','further','more','most','few','many','much','own','same','other','another',
  'all','both','either','else',
  // misc boilerplate
  'etc','eg','e.g','ie','i.e','aka','vs'
]);

// 1a) Query boilerplate phrases to strip early (kept separate so UI can still echo the raw text)
pb.stripPhrases = pb.stripPhrases || [
  /^(how\s+to)\s+/i,
  /^(what\s+is|what's)\s+/i,
  /^(best\s+way\s+to)\s+/i,
  /^(i\s+need\s+to|i\s+want\s+to)\s+/i,
  /^(help\s+me\s+(to\s+)?)\s+/i
];

// 2) Downweighted “utility” terms (keep, but reduce scoring weight)
//    Keep your original + expand a bit. These are common verbs/adjectives that add low discriminative value.
pb.utility = pb.utility || new Set([
  'make','do','get','help','plan','create','write','use',
  'need','want','try','start','add','set','take','give','show','work','change','build',
  'fix','improve','manage','simple','easily','fast','quick','best','good','bad','new'
]);

// 3) High-signal boosts (static core + dynamic library-derived later)
//    These are tokens we know matter in your domain (frameworks, methods, task nouns).
pb.boost = pb.boost || new Set([
  // methods & patterns (seed list; dynamic builder adds many more)
  'okr','okrs','wsjf','rice','ice','pas','bab','aida','par','star','scqa','hmw',
  'triz','toulmin','feynman','bayesian','abm','dag','liwc','vader','nrc','afinn',
  // UX/Researchy nouns
  'screener','interview','survey','usability','codebook','journey','persona','heuristic',
  // ops / comms
  'postmortem','press','release','announcement','apology','roadmap','backlog','prioritization'
]);

// 4) Alias map (variant → canonical). Hyphens are preserved by our folder; map to hyphenated forms.
pb.aliasIndex = pb.aliasIndex || (function(){
  const map = new Map();
  const pairs = [
    // diacritics / punctuation
    ['résumé','resume'], ['e-mail','email'], ['emails','email'],
    // plural/singular and morphology
    ['policies','policy'], ['roadmaps','roadmap'], ['roadmapping','roadmap'],
    ['frameworks','framework'], ['methods','method'],
    // synonyms / abbreviations
    ['cv','resume'], ['curriculum-vitae','resume'],
    ['okrs','okr'], ['a/b','ab'], ['a-b','ab'],
    ['u.x','ux'], ['uxr','ux-research'], ['user-research','ux-research'],
    // common UK/US variants
    ['prioritisation','prioritization'], ['behaviour','behavior'], ['colour','color'],
    // library proper nouns & acronyms (normalize)
    ['press-release','press-release'], ['post-mortem','postmortem'],
  ];
  for (const [variant, canon] of pairs) map.set(variant, canon);
  return map;
})();

// 5) Sentiment / intent lexicons (used for small nudges, not hard filters)
pb.sentiments = pb.sentiments || {
  // People ask for repair, growth, or evaluation flavored tasks
  repair: new Set(['apology','regret','sorry','outage','incident','bug','failure','postmortem','remediation']),
  growth: new Set(['improve','increase','optimize','grow','scale','accelerate','launch','announce','go-live']),
  risk:   new Set(['risk','bias','ethics','safety','privacy','security','consent','accessibility','guardrail']),
  distress: new Set(['stuck','overwhelmed','confused','blocked','friction']),
  urgency:  new Set(['urgent','asap','immediately','now','today'])
};
pb.sentimentWeights = pb.sentimentWeights || {
  repair: 1.15, growth: 1.10, risk: 1.12, distress: 1.08, urgency: 1.06
};

// 6) Unicode fold: lowercase, remove accents, keep hyphens; trim light punctuation
pb.fold = pb.fold || function(s){
  try{
    return String(s ?? '')
      .normalize('NFKD')
      .replace(/[\u0300-\u036f]/g,'')      // strip diacritics
      .toLowerCase()
      .replace(/[_~`^"'.,!?;:(){}\[\]<>/\\|@#$%&*=+]/g,' ') // keep hyphens
      .replace(/\s+/g,' ')
      .trim();
  }catch{
    return String(s ?? '').toLowerCase().trim();
  }
};

// 7) Optional boilerplate stripping (non-destructive to pb.qCache.raw)
pb.preclean = function(raw){
  let s = String(raw || '');
  for (const re of pb.stripPhrases) s = s.replace(re,'');
  return s;
};

// Cache of last tokenized query
pb.qCache = pb.qCache || { raw:'', folded:'', tokens:[], tokensMeaningful:[], tokensUtility:[], tokensDownweighted:[], tokensBoosted:[], aliasesApplied:[], toneBuckets:[] };

// 8) Tokenize + annotate classes
pb.tokenizeQuery = function(raw){
  const cleaned = pb.preclean(raw);
  const folded = pb.fold(cleaned);
  const parts = folded ? folded.split(' ') : [];
  const tokens = [];
  const aliasesApplied = [];
  for (let t of parts){
    if (!t || t.length < 2) continue; // drop 1-char noise
    const canon = pb.aliasIndex.get(t) || t; // alias normalization
    if (canon !== t) aliasesApplied.push([t, canon]);
    tokens.push(canon);
  }

  // drop true stopwords
  const tokensMeaningful = tokens.filter(t => !pb.stop.has(t));

  // classify
  const tokensUtility     = tokensMeaningful.filter(t => pb.utility.has(t));
  const tokensDownweighted= tokensUtility; // synonym; kept for clarity
  const tokensBoosted     = tokensMeaningful.filter(t => pb.boost.has(t));

  // tone / intent buckets (lightweight)
  const toneBuckets = [];
  for (const [k,set] of Object.entries(pb.sentiments)){
    if (tokensMeaningful.some(t => set.has(t))) toneBuckets.push(k);
  }

  return { raw, folded, tokens, tokensMeaningful, tokensUtility, tokensDownweighted, tokensBoosted, aliasesApplied, toneBuckets };
};

// 9) Cached wrapper
pb.tokenizeQueryCached = function(raw){
  if (pb.qCache && pb.qCache.raw === raw) return pb.qCache;
  const res = pb.tokenizeQuery(raw);
  pb.qCache = res;
  return res;
};

// Dev helper: inspect last tokenization quickly in console
window.pbQ = function(){ try{ console.table(pb._lastQ || pb.qCache); }catch(e){ console.log(pb._lastQ || pb.qCache); } };


// 10) Lightweight IDF compiled from your library (labels/tags/use_cases/boosters/fields)
//     Relies on meta.search_text that your data builders attach to items.
//     See: templates.data.js & templates.tasks.data.js builders that set t.meta.search_text. 
pb.idf = pb.idf || new Map();
pb.buildIdfWeights = function(){
  const docs = [];

  const pull = (arr) => {
    if (!Array.isArray(arr)) return;
    for (const t of arr){
      const text = (t && t.meta && t.meta.search_text) ? t.meta.search_text : [
        t?.label, t?.slug, t?.definition, t?.help,
        ...(t?.tags || []), ...(t?.categories || []), ...(t?.use_cases || []), ...(t?.boosters || []),
        ...(Array.isArray(t?.fields) ? t.fields.map(f => f?.label || f?.key || '') : [])
      ].filter(Boolean).join(' ').toLowerCase();
      docs.push(pb.fold(text));
    }
  };

  // Your libs export under both names; use whichever is present.
  pull(window.TEMPLATES || window.FRAMEWORKS || []);
  pull(window.TASK_TEMPLATES || window.TASKS || []);

  // DF counts
  const df = new Map();
  const N = docs.length || 1;
  for (const d of docs){
    const seen = new Set();
    for (const tok of d.split(/[^a-z0-9-]+/)){
      if (!tok || tok.length < 2) continue;
      if (pb.stop.has(tok)) continue;
      if (seen.has(tok)) continue;
      seen.add(tok);
      df.set(tok, (df.get(tok) || 0) + 1);
    }
  }

  // Compute IDF; also fold rare library tokens into pb.boost
  pb.idf.clear();
  for (const [tok, n] of df.entries()){
    const idf = Math.log(1 + N / (1 + n)); // smooth
    pb.idf.set(tok, idf);
    if (idf >= 0.9) pb.boost.add(tok); // rare/diagnostic → boost
  }
};

// 11) Shared term weight function (use in scoring elsewhere)
//     Base multipliers: stop=0, utility~0.6, boost~1.5, sentiment nudges up to ~1.15.
pb.termWeight = function(tok, toneBuckets = []){
  if (!tok) return 0;
  if (pb.stop.has(tok)) return 0;

  let w = 1.0;
  if (pb.utility.has(tok)) w *= 0.6;
  if (pb.boost.has(tok))   w *= 1.5;

  // sentiment/intent nudges (applied once per query if bucket present)
  if (toneBuckets && toneBuckets.length){
    for (const b of toneBuckets){
      const m = pb.sentimentWeights[b];
      if (m) w *= m;
    }
  }

  // add IDF if known
  const idf = pb.idf.get(tok);
  if (idf != null) w *= (1 + idf); // modest bump: 1..~2

  return w;
};

// Cache of the last tokenized query (helps with rapid onInput calls)
pb.qCache = pb.qCache || { raw:'', folded:'', tokens:[], tokensMeaningful:[], aliasesApplied:[] };

// Tokenize a user query into tokens + "meaningful" tokens (no stopwords).
// - Keeps hyphenated tokens
// - Applies alias normalization (variant -> canonical) and tracks changes
// - Marks utility verbs (kept; downweighted later)
// Returns: { raw, folded, tokens, tokensMeaningful, tokensUtility, aliasesApplied }
pb.tokenizeQuery = function(raw){
  const folded = pb.fold(raw);
  const parts = folded ? folded.split(' ') : [];
  const tokens = [];
  const aliasesApplied = [];
  for (let t of parts){
    if (!t || t.length < 2) continue;                // drop 1-char noise
    // alias normalization
    const canon = pb.aliasIndex.get(t) || t;
    if (canon !== t) aliasesApplied.push([t, canon]);
    tokens.push(canon);
  }
  // meaningful = exclude stopwords; keep utilities (but track them)
  const tokensMeaningful = tokens.filter(t => !pb.stop.has(t));
  const tokensUtility = tokensMeaningful.filter(t => pb.utility.has(t));
  return { raw, folded, tokens, tokensMeaningful, tokensUtility, aliasesApplied };
};

// Cached wrapper: returns cached result when the raw string is identical.
// (We’ll keep it simple for now; full incremental diffing isn’t required.)
pb.tokenizeQueryCached = function(raw){
  if (pb.qCache && pb.qCache.raw === raw) return pb.qCache;
  const res = pb.tokenizeQuery(raw);
  pb.qCache = res;
  return res;
};


// Tokenizer for IDF: split, trim, drop numeric-ish tokens, drop stopwords, minLen=2
pb.tokenizeForIDF = function(text){
  const out = [];
  const seen = new Set();
  const parts = pb.fold(text).split(/\s+/);
  for (let t of parts){
    if (!t || t.length < 2) continue;
    if (/^\d+([.-]\d+)?$/.test(t)) continue; // numbers
    if (pb.stop.has(t)) continue;
    if (!seen.has(t)){ out.push(t); seen.add(t); } // unique per document
  }
  return out;
};

pb.idf = pb.idf || null;           // Map<string, number> when built
pb.idfMeta = pb.idfMeta || null;   // { N, kept, dropped, bytesGuess }

// Build IDF once from the current INDEX (templates/use-cases)
pb.buildIDF = function(INDEX){
  try{
    if (!pb.flags.search.idf) return null;   // gated by feature flag
    if (pb.idf) return pb.idf;               // already built

    // 1) Collect “documents” = every use-case line across all templates
    // Each distinct use-case counts as one doc for DF purposes
    const docs = [];
    const NMAX = 20000; // sanity cap
    if (Array.isArray(INDEX)){
      for (const t of INDEX){
        const ucs = (t && Array.isArray(t.use_cases)) ? t.use_cases : [];
        for (const uc of ucs){
          if (docs.length >= NMAX) break;
          const tokens = pb.tokenizeForIDF(uc);
          if (tokens.length) docs.push(tokens);
        }
        if (docs.length >= NMAX) break;
      }
    }
    const N = docs.length || 1;

    // 2) Document frequency (DF): count in how many docs each token appears
    const df = new Map();
    for (const doc of docs){
      for (const tok of doc){
        df.set(tok, (df.get(tok)||0) + 1);
      }
    }

    // 3) Compute IDF = log(N / (1 + df)), clamp & prune to stay < ~50KB
    //    - drop tokens that are ultra-common (df/N > 0.6)
    //    - drop ultra-rare singletons if desired (not necessary here)
    //    - keep a max of MAX_TOKENS most informative tokens by IDF
    const MAX_TOKENS = 3000;        // ~3k entries ~ < 50KB when stored as Map/object
    const CLAMP_MIN = 0.20;         // sane floor so nothing becomes 0
    const CLAMP_MAX = 3.50;         // sane ceiling; avoids runaway weights

    let candidates = [];
    df.forEach((count, tok) => {
      const freq = count / N;
      if (freq > 0.60) return; // too common → not informative
      // raw idf & clamp
      let idf = Math.log(N / (1 + count));
      if (idf < CLAMP_MIN) idf = CLAMP_MIN;
      else if (idf > CLAMP_MAX) idf = CLAMP_MAX;
      candidates.push([tok, idf]);
    });

    // Sort informative-first (higher IDF first), then keep top MAX_TOKENS
    candidates.sort((a,b) => b[1] - a[1]);
    if (candidates.length > MAX_TOKENS) candidates = candidates.slice(0, MAX_TOKENS);

    // 4) Store into pb.idf (Map for speed) and meta
    const idfMap = new Map(candidates);
    pb.idf = idfMap;
    const kept = idfMap.size;
    const dropped = df.size - kept;
    // VERY rough bytes guess (key avg ~6 chars + number): ~16 bytes/entry + Map overhead
    const bytesGuess = kept * 16;

    pb.idfMeta = { N, kept, dropped, bytesGuess };
    // Optional console note for devs:
    // console.info('[IDF] built', pb.idfMeta);

    return idfMap;
  }catch(e){
    // Fail-safe: never break search if build fails
    pb.idf = null;
    pb.idfMeta = null;
    return null;
  }
};

// Dev helper: print IDF summary (remove in prod if desired)
window.pbIDF = function(){
  try{
    if (!pb.idf) return console.log('IDF not built (flag off or not triggered)');
    console.table({ N: pb.idfMeta.N, kept: pb.idfMeta.kept, dropped: pb.idfMeta.dropped, bytesGuess: pb.idfMeta.bytesGuess+'B' });
  }catch(e){ console.log('pbIDF error', e); }
};


// ==== Slice 3: Confidence scoring (coverage + phrase + IDF + tail penalty) ====
// We compute confidence per suggestion using the tokenized query from Slice 1
// and the IDF map from Slice 2 (if enabled).

// Build one folded text blob from a suggestion for matching (cheap & stable)
pb.docTextForSuggestion = function(s){
  const t = s && s.template || {};
  const pieces = [];
  if (s && s.use)   pieces.push(String(s.use));
  if (s && s.label) pieces.push(String(s.label));
  if (t && t.label) pieces.push(String(t.label));
  if (Array.isArray(t.tags) && t.tags.length)         pieces.push(t.tags.join(' '));
  if (Array.isArray(t.categories) && t.categories.length) pieces.push(t.categories.join(' '));
  // include up to 3 use-cases from the template to help phrase/bigram matches
  if (Array.isArray(t.use_cases) && t.use_cases.length) pieces.push(t.use_cases.slice(0,3).join(' '));
  return pb.fold(pieces.filter(Boolean).join(' '));
};

// Compute confidence parts and final score for one suggestion.
// Returns { confidence, matchedTokens, matchedNgrams: { longest, hasFull } }
pb.computeConfidence = function(s, _Q){
  const qTokens = Array.from(new Set((_Q && _Q.tokensMeaningful) || [])); // unique meaningful tokens
  const totalQ  = qTokens.length;
  if (!totalQ){
    return { confidence: 0, matchedTokens: [], matchedNgrams: { longest: 0, hasFull: false } };
  }

  // Candidate doc tokens/set
  const doc   = pb.docTextForSuggestion(s);
  const dToks = doc ? doc.split(/\s+/).filter(x => x && x.length >= 2) : [];
  const dSet  = new Set(dToks);

  // Coverage
  const matched = qTokens.filter(t => dSet.has(t));
  const coverage = matched.length / totalQ;

  // Phrase score: full phrase > trigrams > bigrams > singletons
  let longest = 0, hasFull = false;
  if (totalQ >= 1){
    const full = qTokens.join(' ');
    if (full && doc.includes(full)){
      hasFull = true;
      longest = totalQ;
    } else {
      // scan down from 3 to 2
      const maxN = Math.min(3, totalQ);
      outer: for (let n = maxN; n >= 2; n--){
        for (let i = 0; i <= totalQ - n; i++){
          const gram = qTokens.slice(i, i + n).join(' ');
          if (doc.includes(gram)){ longest = n; break outer; }
        }
      }
    }
  }
  let phrase = totalQ ? (longest / totalQ) : 0;
  if (hasFull) phrase = Math.min(1, phrase + 0.15); // small “big bonus” for full-substring hit

  // IDF blend (flag-gated): matched rarity vs. query rarity mass
  let idfBlend = 0;
  if (pb.flags.search.idf && pb.idf instanceof Map){
    let sumQ = 0, sumM = 0;
    for (const t of qTokens){
      const w = pb.idf.get(t) || 0;
      sumQ += w;
    }
    for (const t of matched){
      const w = pb.idf.get(t) || 0;
      sumM += w;
    }
    if (sumQ > 0) idfBlend = Math.max(0, Math.min(1, sumM / sumQ));
    else idfBlend = coverage; // fallback if IDF yields zeros
  } else {
    // If IDF isn’t enabled, a light proxy (keeps weights summing to 1)
    idfBlend = coverage;
  }

  // Blend
  const w1 = 0.40, w2 = 0.35, w3 = 0.25;
  let conf = (w1 * coverage) + (w2 * phrase) + (w3 * idfBlend);

  // Tail penalty (flag-gated): if only last token matched and there are ≥2 tokens
  if (pb.flags.search.tailPenalty && totalQ >= 2 && matched.length === 1){
    const last = qTokens[totalQ - 1];
    if (matched[0] === last) conf *= 0.5;
  }

  // Clamp + return
  conf = Math.max(0, Math.min(1, conf));
  return { confidence: conf, matchedTokens: matched, matchedNgrams: { longest, hasFull } };
};


    let SUGS = [];
    
    // Choose a "best" suggestion for Continue anyway, preferring helper pickers
function pickBestForContinue(q, list, idx){
  const L = Array.isArray(list) ? list : [];
  const helperLabels = new Set(['— Task Picker —','— Pattern Picker —']);

  // 1) If any current hit is a helper (or labeled as such), take it
  const directHelper = L.find(s =>
    s?.origin === 'helper' ||
    helperLabels.has(String(s?.label || '').trim()) ||
    /(^|-)helper$/i.test(String(s?.template?.kind || s?.template?.type || ''))
  );
  if (directHelper) return directHelper;

  // 2) Otherwise, rerank quickly and prefer a helper if it appears in the top 12
  const reranked = rankSuggestions(q, idx, 12);
  const rerankedHelper = reranked.find(s =>
    s?.origin === 'helper' ||
    helperLabels.has(String(s?.label || '').trim())
  );
  if (rerankedHelper) return rerankedHelper;

  // 3) Fallback: synthesize a helper UC from the first helper template
  const helpers = helperTemplates(idx);
  if (helpers.length){
    const t = helpers[0];
    const uc = (t.use_cases && t.use_cases[0]) || q || 'prompt';
    return { bucket:'uc', score:999, use: uc, label: t.label, template: t, id: t.id, slug: t.slug, origin:'helper' };
  }

  // 4) Ultimate fallback: top suggestion
  return L[0] || null;
}

    
function onQuery(){
  const q = qEl.value.trim();
  const focused = document.activeElement === qEl;

  if (!q){
    if (focused){
      SUGS = buildIdleSuggestions(INDEX, 8);
      renderTA(SUGS);
      pb.log('goodMatchShown', { q, len: q.length });
    } else {
      hideTA(); // collapsed when not focused
    }
    return;
  }

SUGS = rankSuggestions(q, INDEX, 8);

// Slice 3: attach confidence to each suggestion and (optionally) reorder
{
  // Ensure IDF map exists if flagged on
  if (pb.flags.search.idf && !pb.idf) { try { pb.buildIDF(INDEX); } catch(_){} }

  const _Q = pb.tokenizeQueryCached(q);
  SUGS = (SUGS || []).map(s => {
    const parts = pb.computeConfidence(s, _Q);
    // log the top suggestion’s confidence bucket once per onQuery
    return Object.assign({}, s, parts);
  });

  if (pb.flags.search.useConfidence){
    // Highest confidence first; tie-break by existing score if present
    SUGS.sort((a, b) => {
      const d = (b.confidence||0) - (a.confidence||0);
      if (d !== 0) return d;
      return (b.score||0) - (a.score||0);
    });
    if (SUGS[0] && typeof SUGS[0].confidence === 'number'){
      pb.log('confidenceBucket', { confidence: SUGS[0].confidence });
    }
  }
}

// ==== Slice 4: State machine (Helper | NoGoodMatch | GoodMatch) ====
// Flags used: search.helperGrace, search.useConfidence, search.showClosestMatches
// Tunables: helperGraceMin/helperGraceMax, minPanelLen, confidenceThreshold

// 1) Derive quick facts from SUGS
const DIRECT = (SUGS || []).filter(s => s && s.origin !== 'helper');
const useConf = !!(pb.flags.search && pb.flags.search.useConfidence);
const thresh  = Number(pb.tuning.confidenceThreshold || 0.55);
const hasGood = useConf ? (SUGS || []).some(s => (s.confidence || 0) >= thresh) : (DIRECT.length > 0);
const weakAll = useConf ? ((SUGS || []).length > 0 && (SUGS || []).every(s => (s.confidence || 0) < thresh)) : false;
const noHits  = DIRECT.length === 0;

// 2) Helper grace window?
const HG  = !!(pb.flags.search && pb.flags.search.helperGrace);
const len = q.length;
const inGrace = HG && len >= (pb.tuning.helperGraceMin || 4) && len <= (pb.tuning.helperGraceMax || 6) && !hasGood;

// 3) Compute state
let STATE = 'GoodMatch';
if (inGrace){
  STATE = 'Helper';
} else if (len >= (pb.tuning.minPanelLen || 7) && (noHits || (useConf && weakAll))){
  STATE = 'NoGoodMatch';
}

// 4) Render per state
if (STATE === 'Helper'){
  // Show helper use-cases during grace window
  SUGS = helperUsecaseSuggestions(INDEX, 8);
  taEl.classList.remove('ta--noMatch');
  renderTA(SUGS);
  
    // Slice 5: Primary button reads "search" in Helper state
  (function(){
    if (!goEl) return;
    goEl.dataset.mode = 'search';
    const lab = goEl.querySelector('.label');
    if (lab) lab.textContent = 'search';
    else goEl.textContent = 'search';
    goEl.setAttribute('aria-label', 'search');
  })();
  
  
  if (window.pb && window.pb.srStatusEl) window.pb.srStatusEl.textContent = '';
  pb.log('goodMatchShown', { q, len: q.length, state: 'Helper' });

} else if (STATE === 'NoGoodMatch'){
  // Sticky panel: optional “Closest matches” + panel
  taEl.classList.add('ta--noMatch');
  active = -1;
  
    // Slice 8: render up to 2 closest matches above the panel when enabled
  const nearHtml = (pb.flags.search && pb.flags.search.showClosestMatches)
    ? buildClosestMatchesHTML(SUGS, 2)
    : '';

  taEl.innerHTML = buildNoMatchPanelHTML(q) + nearHtml;
  taEl.hidden = false;
  
    // Slice 5: Primary button reads "review options" in NoGoodMatch
  (function(){
    if (!goEl) return;
    goEl.dataset.mode = 'review';
    const lab = goEl.querySelector('.label');
    if (lab) lab.textContent = 'review options';
    else goEl.textContent = 'review options';
    goEl.setAttribute('aria-label', 'review options');
  })();

  // Optional: top 1–2 closest (non-helper) matches above the panel


  pb.log('panelShown', { q, len: q.length, state: 'NoGoodMatch' });

  // A11y announce
  if (window.pb && window.pb.srStatusEl) {
    window.pb.srStatusEl.textContent = `No good match yet for "${q}". Choose an option below.`;
  }

  // --- Panel CTAs (already Slice-4 wired; this keeps it in scope) ---

  // Try another (clear) — optional, present only if #btnClear exists in markup
  {
    const btnClear = taEl.querySelector('#btnClear');
    if (btnClear){
      btnClear.addEventListener('click', (ev)=>{
        ev.preventDefault();
        picked = null;
        qEl.value = '';
        onQuery();
        qEl.focus();
      }, { once:false });
    }
  }


} else {
  // GoodMatch — standard suggestions; panel hidden
  taEl.classList.remove('ta--noMatch');
  renderTA(SUGS);
  
    // Slice 5: Primary button reads "search" in GoodMatch
  (function(){
    if (!goEl) return;
    goEl.dataset.mode = 'search';
    const lab = goEl.querySelector('.label');
    if (lab) lab.textContent = 'search';
    else goEl.textContent = 'search';
    goEl.setAttribute('aria-label', 'search');
  })();
  
  if (window.pb && window.pb.srStatusEl) window.pb.srStatusEl.textContent = '';
  pb.log('goodMatchShown', { q, len: q.length, state: 'GoodMatch' });
}
}

    qEl.addEventListener('input', onQuery);
    qEl.addEventListener('keydown', (e)=>{
    // Slice 2: Block Enter while the "No-match" panel is showing
// Slice 5: In NoGoodMatch, Enter does not launch — focus AI button instead
if (e.key === 'Enter' && taEl.classList.contains('ta--noMatch')){
  e.preventDefault();
  const ai = taEl.querySelector('#btnAI');
  if (ai && typeof ai.focus === 'function'){
    ai.focus();
  }
  triggerSearchShake(); // subtle feedback; reduced-motion respected inside
  return;
}
      const open = !taEl.hidden && taEl.children.length;
      if (open && (e.key === 'ArrowDown' || e.key === 'ArrowUp')){
        e.preventDefault();
        active = Math.max(0, Math.min(taEl.children.length-1, active + (e.key==='ArrowDown'?1:-1)));
        Array.from(taEl.children).forEach((n,i)=> n.classList.toggle('active', i===active));
} else if (e.key === 'Enter'){
  e.preventDefault();
  if (!taEl.hidden && taEl.children.length){
    // choose() will call startScan() for us
    choose(active >= 0 ? active : 0);
  } else {
    if (!picked && SUGS[0]) picked = SUGS[0];
    if (qEl.value.trim()) startScan();
  }
} else if (e.key === 'Escape'){
        taEl.hidden = true; active=-1;
      }
    });
// Only stop propagation when the MOBILE overlay is open
taEl.addEventListener('pointerdown', function(e){
  if (document.documentElement.classList.contains('overlay-open')) {
    e.stopPropagation();
  }
}, true);

let __lastPickTs = 0;
function handlePick(e){
  const el = e.target.closest('.item');
  if (!el) return;

  // De-dupe across pointerdown/mousedown/click within 200ms
  const now = Date.now();
  if (now - __lastPickTs < 200) { e.preventDefault(); e.stopPropagation(); return; }
  __lastPickTs = now;

  e.preventDefault();   // avoid focus/blur races
  e.stopPropagation();  // don't bubble to any outside closers
  choose(parseInt(el.dataset.i,10) || 0);
}

// Fire on all common pathways
taEl.addEventListener('pointerdown', handlePick, { passive:false });
taEl.addEventListener('mousedown',  handlePick);
taEl.addEventListener('click',      handlePick);
goEl.addEventListener('click', ()=>{
  // Slice 5: In NoGoodMatch, do not launch; focus AI and keep panel visible
  if (taEl.classList.contains('ta--noMatch')){
    const ai = taEl.querySelector('#btnAI');
    if (ai && typeof ai.focus === 'function') ai.focus();
    triggerSearchShake();
    return;
  }
  if (!picked && SUGS[0] && !taEl.hidden){ choose(0); }  // choose() triggers start
  else if (qEl.value.trim()) startScan();
});

/* Panel CTAs — global capture on pointerdown (fires before click + before teardown) */
(function(){
  let __ctaTs = 0; // dedupe pointerdown→click double fire

  function handleCta(e){
    const cta = e.target && (e.target.closest && e.target.closest('#btnadv, #btnContinue, #btnAI'));
    if (!cta) return;

    // Dedupe: if we just handled a pointerdown, ignore the trailing click
    const now = Date.now();
    if (now - __ctaTs < 180) { e.preventDefault(); e.stopPropagation(); return; }
    __ctaTs = now;

    // Own the event early; other handlers won’t swallow or teardown first
    if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
    e.stopPropagation();
    e.preventDefault();

    // Defensive: collapse whatever host is active without assuming container
    try {
      // Desktop path
      if (taEl) { taEl.hidden = true; taEl.innerHTML = ''; }
      // Portal path
      const portal = document.getElementById('suggestions-portal');
      if (portal) portal.innerHTML = '';
    } catch {}

    // Route action
    switch (cta.id) {
      case 'btnadv': {
        try { pb.log('actionChosen', { action: 'advanced' }); } catch {}
        window.location.href = './glossary/templates-glossary.html';
        return;
      }
      case 'btnContinue': {
        try { pb.log('actionChosen', { action: 'continue' }); } catch {}
        if (!picked && Array.isArray(SUGS) && SUGS[0]) picked = SUGS[0];
        if (typeof startScan === 'function') startScan();
        return;
      }
case 'btnAI': {
  try { pb.log('actionChosen', { action: 'ai' }); } catch {}
  const qNow = (qEl && qEl.value ? qEl.value : '').trim();
  if (typeof triggerSearchShake === 'function') triggerSearchShake();
  pb.ai.handlePanelAI(qNow);
  return;
}
    }
  }

  // Capture-phase pointerdown fires even if other code kills click later
  document.addEventListener('pointerdown', handleCta, true);
  // Backup: capture click too (e.g., keyboard activation via Enter/Space)
  document.addEventListener('click', handleCta, true);
})();

/* Panel CTAs (delegated) — works across re-renders and overlay moves */
taEl.addEventListener('click', function onPanelCta(e){
  // Only care about our three CTAs inside the panel
  const cta = e.target && e.target.closest('#btnadv, #btnContinue, #btnAI');
  if (!cta) return; // let normal typeahead clicks keep working

  // Prevent typeahead's own click logic / outside-closers from interfering
  e.preventDefault();
  e.stopPropagation();
    // Also stop *other* click listeners on #ta from running
  if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();

  // Always collapse the dropdown before we do anything else
  try { taEl.hidden = true; taEl.innerHTML = ''; } catch {}

  // Route by ID
  switch (cta.id) {
 case 'btnadv': {
  try { pb.log('actionChosen', { action: 'advanced' }); } catch {}
  // Navigate immediately; no need to clear DOM first
  window.location.href = './glossary/templates-glossary.html';
  return;
}
    case 'btnContinue': {
      // Continue anyway: mimic current fallback (prefer the top suggestion)
      try { pb.log('actionChosen', { action: 'continue' }); } catch {}
      if (!picked && Array.isArray(SUGS) && SUGS[0]) picked = SUGS[0];
      // startScan() already reads qEl.value and optional picked
      if (typeof startScan === 'function') startScan();
      return;
    }
  case 'btnAI': {
  try { pb.log('actionChosen', { action: 'ai' }); } catch {}
  const qNow = (qEl && qEl.value ? qEl.value : '').trim();
  if (typeof triggerSearchShake === 'function') triggerSearchShake();
  pb.ai.handlePanelAI(qNow);
  return;
}
  }
});

/* Panel CTAs — portal handler (only fires when panel is mounted in #suggestions-portal) */
document.addEventListener('click', function onPortalPanelCta(e){
  const portal = document.getElementById('suggestions-portal');
  if (!portal) return;

  // Only match our 3 CTAs, and only when they live under the portal
  const cta = e.target && e.target.closest('#btnadv, #btnContinue, #btnAI');
  if (!cta || !portal.contains(cta)) return;

  // Take ownership before any other click plumbing
  e.preventDefault();
  e.stopPropagation();
  if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();

  // Tidy the portal DOM (desktop DOM is separate; we don't touch #ta here)
  try { portal.innerHTML = ''; } catch {}

  switch (cta.id) {
    case 'btnadv': {
      try { pb.log('actionChosen', { action: 'advanced' }); } catch {}
      window.location.href = './glossary/templates-glossary.html';
      return;
    }
    case 'btnContinue': {
      try { pb.log('actionChosen', { action: 'continue' }); } catch {}
      if (!picked && Array.isArray(SUGS) && SUGS[0]) picked = SUGS[0];
      if (typeof startScan === 'function') startScan();
      return;
    }
    case 'btnAI': {
      try { pb.log('actionChosen', { action: 'ai' }); } catch {}
      if (typeof triggerSearchShake === 'function') triggerSearchShake();
      console.log('[AI Assist] TODO → send query to provider:', qEl.value);
      return;
    }
  }
});

// Show idle suggestions (recent → helper) the moment the field is focused & blank
qEl.addEventListener('focus', ()=>{
  if (!qEl.value.trim()){
    SUGS = buildIdleSuggestions(INDEX, 8);
    renderTA(SUGS);
  } else {
    onQuery(); // if user had text, refresh suggestions on focus
  }
});

qEl.addEventListener('blur', ()=>{
  // Let mousedown on a suggestion run first, then hide.
  setTimeout(hideTA, 80);
});

// Click anywhere outside the search area → hide dropdown
document.addEventListener('pointerdown', (e)=>{
  // If the mobile overlay is open, let the scrim/overlay manage closing.
  if (document.documentElement.classList.contains('overlay-open')) return;

  // Defensive: if the event is inside the mobile portal, ignore it here.
  var portal = document.getElementById('suggestions-portal');
  if (portal && portal.contains(e.target)) return;

  if (!searchWrap.contains(e.target)) hideTA();
});

function choose(i){
  const items = Array.from(taEl.children);
  const it = items[i]; if (!it) return;
  const s = SUGS[i];   if (!s) return;

  qEl.value = s.use;
  taEl.hidden = true; active = -1;

  // If it's a "recent" chip, convert it to a real search:
  if (s.origin === 'recent'){
    picked = null;           // not a specific template yet
    onQuery();               // recompute SUGS synchronously for this query
    if (SUGS[0] && SUGS[0].origin !== 'recent'){ picked = SUGS[0]; } // auto-pick top result if present
    if (qEl.value.trim()) startScan(); // run immediately
    return;
  }

  // Normal/helper suggestion → lock and run immediately
  picked = s;
  if (qEl.value.trim()) startScan();
}

// --- quick buttons under the search ---
const btnAdv   = document.getElementById('btnAdv');   // pure link, no JS needed
const btnHelp  = document.getElementById('btnHelp');
const btnLucky = document.getElementById('btnLucky');

// Pick a helper template (— Task Picker — or — Pattern Picker — preferred),
// otherwise anything with id:"none" or kind:"helper", then grab a random use-case.
function pickHelperUC(){
  const ALL = allTemplates();
  const HELPER_LABELS = new Set(['— Task Picker —','— Pattern Picker —']);
  const helpers = ALL.filter(t=>{
    const lbl  = String(t.label||'').trim();
    const id   = String(t.id||'').trim().toLowerCase();
    const kind = String(t.kind||t.type||'').trim().toLowerCase();
    return HELPER_LABELS.has(lbl) || id === 'none' || kind === 'helper';
  });
  const pool = helpers.length ? helpers : ALL.filter(t => (t.use_cases||[]).length);
  if (!pool.length) return null;
  const t = pool[Math.floor(Math.random()*pool.length)];
  const ucs = (t.use_cases || []);
  if (!ucs.length) return null;
  const uc = ucs[Math.floor(Math.random()*ucs.length)];
  return { uc, t };
}

btnHelp?.addEventListener('click', ()=>{
  const pick = pickHelperUC();
  if (!pick){
    // Fallback: use existing helper suggestion builder
    const h = helperUsecaseSuggestions(INDEX, 1);
    if (h[0]){
      picked = h[0];
      qEl.value = h[0].use;
      startScan();
    }
    return;
  }
  picked = {
    bucket:'uc', score:999,
    use: pick.uc,
    label: pick.t.label || pick.t.slug || pick.t.id,
    template: pick.t, id: pick.t.id, slug: pick.t.slug
  };
  qEl.value = pick.uc;
  startScan();
});

// Lucky: random use-case across ALL templates equally
btnLucky?.addEventListener('click', ()=>{
  const ALL = allTemplates();
  const bag = [];
  for (const t of ALL){
    for (const uc of (t.use_cases || [])){
      bag.push({ uc, t });
    }
  }
  if (!bag.length){
    // Fallback to helper if no use-cases exist yet
    const h = helperUsecaseSuggestions(INDEX, 1);
    if (h[0]){
      picked = h[0]; qEl.value = h[0].use; startScan();
    }
    return;
  }
  const { uc, t } = bag[Math.floor(Math.random()*bag.length)];
  picked = {
    bucket:'uc', score:999,
    use: uc,
    label: t.label || t.slug || t.id,
    template: t, id: t.id, slug: t.slug
  };
  qEl.value = uc;
  startScan();
});


/* ===== Mini redo search under details header ===== */
(function miniSearch(){
  const q2   = document.getElementById('q2');
  const ta2  = document.getElementById('ta2');
  const go2  = document.getElementById('go2');
  const retryBtn = document.getElementById('retry');
  const wrap = document.querySelector('.detailSearchWrap');

  if (!q2 || !ta2 || !go2 || !retryBtn || !wrap) return;

  let SUGS2 = [];
  let active2 = -1;
  let __lastPickTs2 = 0;

  function hideTA2(){
    ta2.hidden = true;
    ta2.innerHTML = '';
    active2 = -1;
  }
  function renderTA2(list){
    if (!list.length){ hideTA2(); return; }
    ta2.innerHTML = list.map((s,i)=>`
      <div class="item${i===0?' active':''}" role="option" data-i="${i}">
        <div class="use">${s.use}</div>
        <div class="sub" aria-hidden="true">${s.label}</div>
      </div>
    `).join('');
    ta2.hidden = false; active2 = 0;
  }

  q2.addEventListener('input', ()=>{
    SUGS2 = q2.value.trim()
      ? rankSuggestions(q2.value.trim(), INDEX, 8)
      : buildIdleSuggestions(INDEX, 6);
    renderTA2(SUGS2);
  });

  q2.addEventListener('keydown', (e)=>{
    const open = !ta2.hidden && ta2.children.length;
    if (open && (e.key === 'ArrowDown' || e.key === 'ArrowUp')){
      e.preventDefault();
      active2 = Math.max(0, Math.min(ta2.children.length-1, active2 + (e.key==='ArrowDown'?1:-1)));
      [...ta2.children].forEach((n,i)=> n.classList.toggle('active', i===active2));
    } else if (e.key === 'Enter'){
      e.preventDefault();
      if (open && SUGS2[0]) choose2(active2 >= 0 ? active2 : 0);
      else if (q2.value.trim()){
        picked = null;
        qEl.value = q2.value.trim();
        startScan();
      }
    } else if (e.key === 'Escape'){ hideTA2(); }
  });

  function choose2(i){
    const el = ta2.children[i]; if (!el) return;
    const s  = SUGS2[i];        if (!s)  return;

    qEl.value = s.use;
    picked = s;
    hideTA2();
    startScan();
  }

  function handlePick2(e){
    const el = e.target.closest('.item'); if (!el) return;
    const now = Date.now();
    if (now - __lastPickTs2 < 200){ e.preventDefault(); e.stopPropagation(); return; }
    __lastPickTs2 = now;

    e.preventDefault(); e.stopPropagation();
    choose2(parseInt(el.dataset.i,10) || 0);
  }

  ta2.addEventListener('pointerdown', handlePick2, { passive:false });
  ta2.addEventListener('mousedown',  handlePick2);
  ta2.addEventListener('click',      handlePick2);

  // click-away close for the mini list
  document.addEventListener('pointerdown', (e)=>{
    if (!wrap.contains(e.target)) hideTA2();
  }, true);

  // run search when pressing the mini "search" button
  go2.addEventListener('click', ()=>{
    if (!ta2.hidden && SUGS2[0]) choose2(0);
    else if (q2.value.trim()){
      picked = null;
      qEl.value = q2.value.trim();
      startScan();
    }
  });

  // "Try another" — same query, different closest template
  function tryAnother(){
    const q = (q2.value.trim() || LAST_CTX.q || '').trim();
    if (!q) return;

    const currentSlug = LAST_CTX.slug;
    const ranked = rankSuggestions(q, INDEX, 24);
    const alt = ranked.find(r=>{
      const slug = (r?.template?.slug || r?.template?.id || '').toString();
      return slug && slug !== currentSlug;
    });

    if (alt){
      picked = alt;
      qEl.value = alt.use;
      startScan();
      return;
    }

    // fallback: similar tags/cats, else any different template
    const current = INDEX.find(t => (t.slug || t.id) === currentSlug);
    let pool = INDEX.filter(t=>{
      const slug = (t.slug || t.id);
      if (!slug || slug === currentSlug) return false;
      const shareTag = (t.tags||[]).some(tag => (current?.tags||[]).includes(tag));
      const shareCat = (t.categories||[]).some(cat => (current?.categories||[]).includes(cat));
      return shareTag || shareCat;
    });
    if (!pool.length) pool = INDEX.filter(t => (t.slug||t.id) && (t.slug||t.id)!==currentSlug);

    if (pool.length){
      const t = pool[0];
      const uc = (t.use_cases && t.use_cases[0]) || (LAST_CTX.q || 'prompt');
      picked = { bucket:'uc', score:999, use: uc, label: t.label, template: t, id: t.id, slug: t.slug };
      qEl.value = uc;
      startScan();
    }
  }
  retryBtn.addEventListener('click', tryAnother);

  // Prefill when details open (also set in showDetails for freshness)
  try { q2.value = LAST_CTX.q; } catch(e){}
})();

    /* ===== Faux scan to details ===== */
    const hero = document.getElementById('hero');
    const scan = document.getElementById('scan');
    const details = document.getElementById('details');
    const rollList = document.getElementById('rollList');
    const resultHeader = document.getElementById('resultHeader');

    function startScan(){
    
    // Slice: cross-page handoff — persist last search context for wizard/AI
try{
  // raw query and best pick (if any)
  const qNow   = String(qEl?.value || LAST_CTX.q || '').trim();
  const best   = picked || (Array.isArray(SUGS) ? SUGS[0] : null);

  // classify current state from UI (matches our state machine)
  const state  = taEl.classList.contains('ta--noMatch') ? 'NoGoodMatch' : 'GoodMatch';

  // keep recent text history as before
  saveRecent(qNow);

  // persist the structured last-search record
  saveLastSearch({
    q: qNow,
    slug: best?.slug || null,
    label: best?.label || null,
    confidence: (typeof best?.confidence === 'number') ? best.confidence : null,
    state,
    tokens: (pb?.qCache?.tokensMeaningful) ? pb.qCache.tokensMeaningful : [],
    from: 'index'
  });
}catch(_){}

    saveRecent(qEl.value.trim()); // ← NEW: remember it
    LAST_CTX.q = qEl.value.trim(); 
    
      hero.style.display = 'none';
      scan.style.display = 'flex';

      // ensure the center rainbow band exists (added once)
      const rollEl = document.querySelector('.scan .roll');
      if (rollEl && !rollEl.querySelector('.centerBand')){
        const band = document.createElement('div');
        band.className = 'centerBand';
        rollEl.appendChild(band);
      }

      const labels = allTemplates().map(t => t.label || t.slug || t.id).filter(Boolean);
      const unique = Array.from(new Set(labels));
      const chosenLabel = (picked && picked.label) || unique[0] || 'template';

      // Plenty above and below so the center has neighbors to fade
      const above = unique.sort(()=>Math.random()-.5).slice(0, 40);
      const below = unique.sort(()=>Math.random()-.5).slice(0, 12);
      const finalList = [...above, chosenLabel, ...below];

      rollList.innerHTML = finalList.map(l => `<li${l===chosenLabel?' class="hit"':''}>${l}</li>`).join('');

  // Skip fancy motion for reduced-motion users
const prefersReduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
// NEW: AI-assist can set this flag to run the scan as “visual only”
const visualOnly = !!window.__scanVisualOnly;

function finishOrReveal(){
  if (visualOnly){
    try { scan.style.display = 'none'; } catch {}
    try { hero.style.display = 'block'; } catch {}
    // Let listeners know the scan visual finished
    try { document.dispatchEvent(new CustomEvent('scan:done')); } catch {}
    window.__scanVisualOnly = false;
  } else {
    // legacy behavior → proceed to details (which currently routes to wizard)
    showDetails(picked?.template || INDEX.find(t => t.label === chosenLabel));
  }
}

if (prefersReduce){
  hardCenterHit();
  setTimeout(finishOrReveal, 250);
} else {
  animateToCenterHit({ overshoot: 48, scrollMs: 2200, backMs: 420, fwdMs: 320, settleMs: 200, jiggleBack: 18, jiggleFwd: 9 })
    .then(finishOrReveal);
}

    }

    function getHitGeometry(){
      const roll = document.querySelector('.scan .roll');
      const hit  = rollList.querySelector('.hit');
      if (!roll || !hit) return null;

      const ulRect  = rollList.getBoundingClientRect();
      const hitRect = hit.getBoundingClientRect();
      const viewportH = roll.clientHeight;

      // Distance from UL top to place hit in the vertical center of the roll viewport
      const target = (hitRect.top - ulRect.top) - (viewportH - hitRect.height)/2;

      return { roll, hit, target: Math.max(0, target) };
    }

    function hardCenterHit(){
      const g = getHitGeometry(); if (!g) return;
      rollList.style.transition = 'none';
      rollList.style.transform  = `translate3d(0, ${-g.target}px, 0)`;
    }

    function animateToCenterHit({ overshoot = 22, scrollMs = 1400, backMs = 300, fwdMs = 200, settleMs = 140, jiggleBack = 8, jiggleFwd = 4 } = {}){
      const g = getHitGeometry();
      if (!g) return Promise.resolve();

      const yPast   = g.target - overshoot;
      const yBack   = g.target + jiggleBack;
      const yFwd    = g.target - jiggleFwd;
      const yFinal  = g.target;

      const easingMain = 'cubic-bezier(.2,.9,.2,1)';
      const easingSnap = 'cubic-bezier(.15,.95,.2,1)';

      const transitionTo = (y, ms, easing) => new Promise((resolve)=>{
        const onEnd = (e)=> {
          if (e.propertyName !== 'transform') return;
          rollList.removeEventListener('transitionend', onEnd);
          resolve();
        };
        const failSafe = setTimeout(()=>{ rollList.removeEventListener('transitionend', onEnd); resolve(); }, ms + 60);

        rollList.addEventListener('transitionend', onEnd, { once:true });
        rollList.style.transition = `transform ${ms}ms ${easing}`;
        rollList.style.transform  = `translate3d(0, ${-y}px, 0)`;
      });

      rollList.style.transition = 'none';

      return Promise.resolve()
        .then(()=> transitionTo(yPast,  scrollMs, easingMain))
        .then(()=> transitionTo(yBack,   backMs,  easingSnap))
        .then(()=> transitionTo(yFwd,     fwdMs,  easingSnap))
        .then(()=> transitionTo(yFinal, settleMs, easingSnap));
    }
    
    
    /* ===== Slice 0: Flags + routing helper (SAFE, inert) ===== */
(function initFlagsAndRouting(){
  // Feature flags (all OFF by default; turn on per-slice during testing)
  window.PB_FLAGS = window.PB_FLAGS || {
    newActionModal:   false,  // Slice 1
    newWorksheetUrl:  false,  // later
    askUrlPrompt:     false,  // later
    mobileMenuParity: false   // later
  };

  // Compute stable routing bits for a template (not used yet in Slice 1)
  window.getRoutingFromTemplate = window.getRoutingFromTemplate || function(t){
    t = t || {};
    const id   = String(t.id   || t.slug || '').trim();
    const slug = String(t.slug || t.id   || '').trim();
    const kindRaw = String(t._displayKind || t.kind || t.type || 'framework').toLowerCase();

    // pluralization map (falls back to naive “+s”)
    const PLURALS = {
      pattern:'patterns',
      strategy:'strategies',
      framework:'frameworks',
      task:'tasks',
      heuristic:'heuristics',
      term:'terms',
      helper:'helpers'
    };
    const kindPlural =
      PLURALS[kindRaw] ||
      (kindRaw ? (kindRaw.endsWith('s') ? kindRaw : kindRaw + 's') : 'frameworks');

    const xfer = id ? `pb.v1.xfer.${kindPlural}.${id}` : '';
    return { id, slug, kindRaw, kindPlural, xfer };
  };
})();

// TEMP: enable Slice 1 during testing
window.PB_FLAGS.newActionModal = true;
window.PB_FLAGS.askUrlPrompt = true;
window.PB_FLAGS.newWorksheetUrl = true;
window.PB_FLAGS.mobileMenuParity = true;

/* ===== Slice 1: Modal manager (copy only) ===== */
/* ===== Slice 1: Modal manager (copy only) — FINAL UI/UX ===== */
/* ===== Slice 1+3: Modal manager (copy + ask) — FINAL UI/UX ===== */
function openAction({ mode='copy', prompt='', routing=null } = {}){
  const dlg        = document.getElementById('actionModal');
  const form       = document.getElementById('actionForm');
  const titleEl    = document.getElementById('actionTitle');
  const previewEl  = document.getElementById('actionPreview');
  const noteEl     = document.getElementById('actionNote');
  const confirmBtn = document.getElementById('actionConfirm');
  const cancelBtn  = document.getElementById('actionCancel');
  const closeBtn   = document.getElementById('actionClose');

  if (!dlg || !form || !titleEl || !previewEl || !confirmBtn) return;

  // Remember the opener to restore focus later
  const opener = document.activeElement instanceof HTMLElement ? document.activeElement : null;

  // --- Configure per mode ---
  if (mode === 'ask'){
    titleEl.textContent = 'ask chatgpt';
    confirmBtn.textContent = 'open in chatgpt';
  } else {
    titleEl.textContent = 'copy prompt';
    confirmBtn.textContent = 'copy';
  }

  // Seed editable preview
  previewEl.value = String(prompt || '');

  // Notes differ by mode: show "already copied" only for copy mode
  if (noteEl){
    if (mode === 'copy'){
      noteEl.textContent = 'copied to clipboard. you can edit and copy again.';
      noteEl.hidden = false;
      form.setAttribute('aria-describedby', noteEl.id);
    } else {
      noteEl.hidden = true;
      form.removeAttribute('aria-describedby');
    }
  }

  // Submit behaviors
  const onSubmit = async (e)=>{
    e.preventDefault();

    if (mode === 'ask'){
      // Always copy the preview text as a fallback
      try { await navigator.clipboard.writeText(previewEl.value); } catch {}

      // Build ChatGPT URL with ?prompt=
      let url = 'https://chat.openai.com/?prompt=' + encodeURIComponent(previewEl.value);

      // Try to open in a new tab; detect block
      let win = null;
      try { win = window.open(url, '_blank', 'noopener'); } catch {}

      // If blocked or failed, keep dialog open and instruct the user
      if (!win || win.closed){
        if (noteEl){
          noteEl.textContent = 'popup blocked — prompt is copied. open chat.openai.com and paste with ⌘/Ctrl+V.';
          noteEl.hidden = false;
          form.setAttribute('aria-describedby', noteEl.id);
        }
        return; // keep dialog open so they can read/copy again
      }

      // Success → close dialog
      closeDialog();
      return;
    }

    // mode === 'copy'
    try {
      await navigator.clipboard.writeText(previewEl.value);
      if (noteEl){ noteEl.textContent = 'copied!'; noteEl.hidden = false; }
    } catch {
      if (noteEl){
        noteEl.textContent = 'could not copy automatically — select all and press ⌘/Ctrl+C.';
        noteEl.hidden = false;
      }
    }
    // keep open so they can tweak/copy again
  };

  // Cmd/Ctrl+Enter submits (opens ChatGPT in ask mode; copies in copy mode)
  const onKeyPreview = (e)=>{
    if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)){
      e.preventDefault();
      onSubmit(e);
    }
  };

  // Click-outside close — ignore while actively resizing the textarea
  const onBackdropClick = (e)=>{
    const r = form.getBoundingClientRect();
    const inside =
      e.clientX >= r.left && e.clientX <= r.right &&
      e.clientY >= r.top  && e.clientY <= r.bottom;
    if (inside) return;
    if (e.target === previewEl && previewEl.matches(':active')) return;
    closeDialog();
  };

  const closeDialog = ()=>{
    try { dlg.close(); } catch {}
    form.removeEventListener('submit', onSubmit);
    previewEl.removeEventListener('keydown', onKeyPreview);
    cancelBtn && cancelBtn.removeEventListener('click', closeDialog);
    closeBtn  && closeBtn.removeEventListener('click', closeDialog);
    dlg.removeEventListener('cancel', closeDialog);
    dlg.removeEventListener('click', onBackdropClick);
    if (opener && typeof opener.focus === 'function'){
      setTimeout(()=>{ try{ opener.focus({ preventScroll:true }); }catch{} }, 0);
    }
  };

  // Fresh bindings
  form.addEventListener('submit', onSubmit);
  previewEl.addEventListener('keydown', onKeyPreview);
  cancelBtn && cancelBtn.addEventListener('click', closeDialog);
  closeBtn  && closeBtn.addEventListener('click', closeDialog);
  dlg.addEventListener('cancel', closeDialog);
  dlg.addEventListener('click', onBackdropClick);

  // Open and focus the preview so users can edit immediately
  try { dlg.showModal(); } catch {}
  setTimeout(()=>{
    try {
      previewEl.focus({ preventScroll: true });
      previewEl.setSelectionRange(0, previewEl.value.length);
    } catch {}
  }, 0);
}


    /* ===== Details page wiring ===== */
    const tplTitle = document.getElementById('tplTitle');
    const meta = document.getElementById('meta');
    const def = document.getElementById('def');
    const useCases = document.getElementById('useCases');
    const boosters = document.getElementById('boosters');
    const boostersBlock = document.getElementById('boostersBlock');
    const fields = document.getElementById('fields');

    const openBuilder = document.getElementById('openBuilder');
    const openGlossary = document.getElementById('openGlossary');
    const printWorksheet = document.getElementById('printWorksheet');
    const copyPrompt = document.getElementById('copyPrompt');
    const ask = document.getElementById('ask');
    const back = document.getElementById('back');

    function htmlEsc(s){ return String(s||'').replace(/[&<>"]/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[m])); }

    function showDetails(t){
      scan.style.display = 'none';
      details.hidden = false;
      resultHeader.hidden = false;
      document.body.classList.add('is-details');
      if (!t){ tplTitle.textContent = 'template'; return; }

      tplTitle.textContent = (t.label || t.slug || t.id || 'template').toLowerCase();
      meta.innerHTML = [
        ...(t.categories||[]).map(c => `<span class="chip">${htmlEsc(c)}</span>`),
        ...(t.tags||[]).map(tag => `<span class="chip">${htmlEsc(tag)}</span>`)
      ].join('');

      def.textContent = t.definition || 'No definition provided yet.';
      useCases.innerHTML = (t.use_cases||[]).map(u => `<div class="uc">${htmlEsc(u)}</div>`).join('') || '<div class="uc">No use-cases listed.</div>';

      if (t.boosters && t.boosters.length){
        boostersBlock.hidden = false;
        boosters.innerHTML = t.boosters.map(b => `<div class="booster">${htmlEsc(b)}</div>`).join('');
      } else {
        boostersBlock.hidden = true;
      }

      fields.innerHTML = (t.fields||[]).map(f => `
        <div class="row">
          <label>${htmlEsc(f.label || f.key || 'field')}</label>
          <div class="fake">${htmlEsc(f.ph || '')}</div>
        </div>
      `).join('') || '<div class="row"><div class="fake">No fields for this template.</div></div>';

      const slug = (t.slug || t.id || '').toString();
      openBuilder.href = './glossary/prompt-builder.html' + (slug ? ('?slug=' + encodeURIComponent(slug)) : '');
      openGlossary.href = './glossary/templates-glossary.html' + (slug ? ('?slug=' + encodeURIComponent(slug)) : '');
      // Slice 2: Worksheet URL — prefer ?kind=<plural>&id=<id>&xfer=pb.v1.xfer.<plural>.<id>
if (window.PB_FLAGS && window.PB_FLAGS.newWorksheetUrl){
  const r = getRoutingFromTemplate(t); // uses _displayKind || kind || type
  if (r && r.id && r.kindPlural){
    const params = new URLSearchParams();
    params.set('kind', r.kindPlural);
    params.set('id',   r.id);
    if (r.xfer) params.set('xfer', r.xfer);
    printWorksheet.href = './glossary/prompt-worksheet.html?' + params.toString();
  } else {
    // Safety fallback: keep legacy slug behavior if we somehow lack id/kind
    printWorksheet.href = './glossary/prompt-worksheet.html' + (slug ? ('?slug=' + encodeURIComponent(slug)) : '');
  }
} else {
  // Rollback path (flag off): legacy slug behavior
  printWorksheet.href = './glossary/prompt-worksheet.html' + (slug ? ('?slug=' + encodeURIComponent(slug)) : '');
}
      // remember what we just opened, so "try another" can exclude it
  LAST_CTX.slug = slug;
  LAST_CTX.q = qEl.value.trim() || LAST_CTX.q;

  // keep the mini search prefilled with the last query
  try { document.getElementById('q2').value = LAST_CTX.q; } catch(e){}  
    
      // Build the ChatGPT primer prompt from the template
      const fullPrompt = buildChatGPTPrompt(normalizeTemplateForSummary(t));
      // Expose for mobile menu parity
window.__lastRouting = getRoutingFromTemplate(t);
window.__lastFullPrompt = fullPrompt;

      // Slice 1: copy to clipboard, then (if enabled) open confirmation modal
copyPrompt.onclick = async ()=>{
  try { await navigator.clipboard.writeText(fullPrompt); } catch {}
  if (window.PB_FLAGS && window.PB_FLAGS.newActionModal){
    // routing not used in Slice 1, but passed for future slices
    openAction({ mode:'copy', prompt: fullPrompt, routing: getRoutingFromTemplate(t) });
  }
};
// Slice 3: Ask → open modal (edit), then open ChatGPT with ?prompt= on confirm
ask.onclick = async ()=>{
  if (window.PB_FLAGS && window.PB_FLAGS.askUrlPrompt){
    openAction({ mode:'ask', prompt: fullPrompt, routing: getRoutingFromTemplate(t) });
  } else {
    // Rollback path: legacy behavior if flag is off
    try { await navigator.clipboard.writeText(fullPrompt); } catch {}
    window.open('https://chat.openai.com/', '_blank', 'noopener');
  }
};
      back.onclick = ()=>{
        details.hidden = true;
        resultHeader.hidden = true;
        document.body.classList.remove('is-details');
        hero.style.display = 'block';
        qEl.focus();
      };
      
      window.__pushDetailsState(String(t.slug || t.id || ''));
    }

    function normalizeTemplateForSummary(t){
      return { ...t, _displayKind: (t._displayKind || t.kind || t.type || 'framework') };
    }
    function buildTemplateSummary(t){
      const lines = [];
      lines.push(`Template: ${t.label || t.slug || t.id || 'untitled'}`);
      lines.push(`Kind: ${t._displayKind || t.kind || 'framework'}`);
      if (t.definition) lines.push(`Definition: ${t.definition}`);
      if (t.categories?.length) lines.push(`Categories: ${t.categories.join(', ')}`);
      if (t.tags?.length) lines.push(`Tags: ${t.tags.join(', ')}`);
      if (t.use_cases?.length){ lines.push(`Use-cases:`); for (const u of t.use_cases) lines.push(`- ${u}`); }
      if (t.fields?.length){
        lines.push(`Fields:`); for (const f of t.fields){
          const label = f.label || f.key || 'field';
          const ph = f.ph ? ` — ${f.ph}` : '';
          lines.push(`- ${label}${ph}`);
        }
      }
      if (t.boosters?.length){ lines.push(`Boosters:`); for (const b of t.boosters) lines.push(`- ${b}`); }
      return lines.join('\n');
    }
    function buildChatGPTPrompt(t){
      const kind = (t._displayKind || 'framework').toLowerCase();
      const summary = buildTemplateSummary(t);
      return [
        `You are an expert AI tutor specializing in prompt engineering. I am reviewing a "${kind}"-type prompt template and will share its full structure with you below to prime your understanding:`,
        ``,
        summary,
        ``,
        `Please begin by asking me what I would like to accomplish using this template. Then:`,
        `1) Explain the ${kind} at a practitioner level with 1–2 concrete examples.`,
        `2) Contrast it with closely related terms (if any) and note common confusions.`,
        `3) Offer pitfalls, best practices, and a short checklist.`,
        `4) Suggest 3 reputable resources for deeper reading (link if possible).`,
        `5) Guide the user through the template provided for "${t.label || t.slug || t.id || ''}" (${kind}).`
      ].join('\n');
    }
    
    const searchWrap = document.querySelector('.searchWrap');

function hideTA(){
  taEl.hidden = true;
  taEl.innerHTML = '';
  active = -1;
}

    /* ===== Boot index for search ===== */
    function boot(){ INDEX = buildIndex(); onQuery(); }

(function watchDatasets(){
  let lastSeen = '';
  const timer = setInterval(()=>{
    const haveTpl  = Array.isArray(window.TEMPLATES) || Array.isArray(window.FRAMEWORKS);
    const haveTask = Array.isArray(window.TASK_TEMPLATES) || Array.isArray(window.tasks);
    const sig = (haveTpl ? 'T' : '_') + (haveTask ? 'K' : '_');
    if (sig !== lastSeen){
      lastSeen = sig;
      boot();            // rebuild when either dataset changes readiness
      if (haveTpl && haveTask) clearInterval(timer);  // stop once both are loaded
    }
  }, 80);
})();
  </script>
  
<script>
// Slice 3 — Respect reduced motion + live announcement + clean animation end
function triggerSearchShake(){
  try {
    if (!searchWrap) return;

    // Announce for assistive tech even if we animate
    if (window.pb && window.pb.srStatusEl) {
      window.pb.srStatusEl.textContent = 'No direct match. Choose an option below.';
    }

    // If user prefers reduced motion, skip animation entirely
    const rm = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (rm) return;

    // Replayable animation: remove -> reflow -> add
    searchWrap.classList.remove('shake');
    void searchWrap.offsetWidth;
    searchWrap.classList.add('shake');

    // Ensure we clear the class at the end (and also after a timeout as fallback)
    const onEnd = () => { try { searchWrap.classList.remove('shake'); } catch {} };
    searchWrap.addEventListener('animationend', onEnd, { once: true });
    setTimeout(onEnd, 600);
  } catch {}
}
</script>

<script>
// Slice 3 — Cache the live region; create it if missing for resilience
window.pb = window.pb || {};
(function ensureSRStatus(){
  const q = document.getElementById('q');
  let el = document.getElementById('srStatus');
  if (!el && q && q.parentNode) {
    el = document.createElement('div');
    el.id = 'srStatus';
    el.className = 'visually-hidden';
    el.setAttribute('aria-live', 'polite');
    q.parentNode.insertBefore(el, q.nextSibling);
  }
  window.pb.srStatusEl = el || null;
})();
</script>

  
  <script>
/* ===== MANTRA REEL: slow, infinite, resize-safe vertical scroller ===== */
(function mantraReel(){
  // Tweakables
  var HOLD_MS  = 2200;   // dwell time per line
  var SLIDE_MS = 900;    // slide animation duration
  var MANTRA_SHIFT_RIGHT = 0; // px; positive pushes the whole line to the right

  var PHRASES = [
    "clarity is kindness to the model.",
    "context is half the answer.",
    "easy for you, easy for it.",
    "put smart, get smart.",
    "the divergent intern.",
    "the collaborative partner.",
    "the 10,000 experts.",
    "garbage in, garbage out.",
    "precision paints the picture.",
    "tone travels through tokens.",
    "the model mirrors your mind.",
    "examples are the skeleton key.",
    "what you frame is what you get.",
    "be the director, not the spectator.",
    "define the stage, script the play.",
    "a vague prompt breeds vague answers.",
    "specificity is the superpower.",
    "ask like a teacher, check like a scientist.",
    "layer tasks, don’t overload.",
    "persona shapes performance."
  ];

  var slot  = document.getElementById('mantraSlot');
  var reel  = document.getElementById('mantraReel');
  var list  = document.getElementById('mantraList');
  var line  = document.querySelector('#mantra .mantraLine');

  if (!slot || !reel || !list || !line) return;

  // Apply shift control (matches your earlier SHIFT_RIGHT pattern)
  line.style.setProperty('--mantra-shift-x', (MANTRA_SHIFT_RIGHT|0) + 'px');

  // Build DOM
  list.innerHTML = PHRASES.map(s => `<span class="w">${s}</span>`).join('');

  // Adopt timing to CSS custom prop so transitions stay in sync
  slot.style.setProperty('--mantra-slide', SLIDE_MS + 'ms');

  var dpr = window.devicePixelRatio || 1;
  var rowH = 0, i = 0, paused = false;

  function widestWidthPx(){
    // measure using the slot's computed font to avoid clipping
    var cs = getComputedStyle(slot);
    var meas = document.createElement('span');
    meas.style.position='absolute'; meas.style.visibility='hidden';
    meas.style.whiteSpace='nowrap'; meas.style.left='-9999px'; meas.style.top='-9999px';
    meas.style.font = cs.font;
    meas.style.letterSpacing = cs.letterSpacing;
    meas.style.textTransform = cs.textTransform;
    meas.style.fontKerning = cs.fontKerning;
    meas.style.fontFeatureSettings = cs.fontFeatureSettings;
    meas.style.fontVariationSettings = cs.fontVariationSettings;
    meas.style.fontStretch = cs.fontStretch;

    document.body.appendChild(meas);
    var max = 0;
    for (var s of PHRASES){ meas.textContent = s; var w = meas.getBoundingClientRect().width; if (w > max) max = w; }
    meas.remove();
    // +1 physical pixel fudge to avoid subpixel mask grazing
    var fudge = Math.max(1, Math.round(dpr));
    return Math.ceil(max + 20 + fudge);
  }

  function lockMetrics(){
    // lock row height from first child (rendered pixels, not ems)
    var first = list.firstElementChild;
    var h = first ? first.getBoundingClientRect().height : parseFloat(getComputedStyle(slot).fontSize) || 32;
    rowH = Math.ceil(h + 2); // cushion
    slot.style.setProperty('--mantra-slot-h', rowH + 'px');

    // lock slot width to widest phrase so we never clip mid-line
    var wpx = widestWidthPx();
    slot.style.setProperty('--mantra-slot-w', wpx + 'px');
  }

  function translateTo(idx){
    // snap to device pixels to prevent creeping drift under the mask
    var y = Math.round((idx * rowH) * dpr) / dpr;
    list.style.transform = 'translate3d(0,' + (-y) + 'px,0)';
  }

  function tick(){
    if (paused) { schedule(); return; }
    i = (i + 1) % PHRASES.length;
    translateTo(i);
    schedule();
  }
  function schedule(){ setTimeout(tick, HOLD_MS); }

  // Reduced motion: render first line only
  var prefersReduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  function start(){
    lockMetrics();
    translateTo(0);
    if (!prefersReduce){ schedule(); }
  }

  // Pause when off-screen (saves CPU; also halts motion while not visible)
  var mantraSection = document.getElementById('mantra');
  if ('IntersectionObserver' in window && mantraSection){
    var io = new IntersectionObserver(function(entries){
      entries.forEach(function(e){ paused = !e.isIntersecting; });
    }, { threshold: 0.1 });
    io.observe(mantraSection);
  }

  // Wait for fonts for stable measurements, then run
  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(start);
  } else {
    window.addEventListener('load', start, { once:true });
  }

  // On resize or zoom, re-lock metrics and keep current index visible
  window.addEventListener('resize', function(){
    var current = i;
    lockMetrics();
    translateTo(current);
  });
})();
</script>

<script>
/* ==== Slice C — Provider adapters (Gemini + OpenAI). No wire-up yet. ==== */
(function(){
  window.pb = window.pb || {};
  pb.ai = pb.ai || {};

  // ---------------------------
  // Helpers (local to adapters)
  // ---------------------------



  // Tiny timeout wrapper so a bad network doesn’t hang the UI
  async function fetchJsonWithTimeout(url, opts={}, timeoutMs=20000){
    const c = new AbortController();
    const t = setTimeout(()=>c.abort(), timeoutMs);
    try{
      const res  = await fetch(url, { ...opts, signal:c.signal });
      const json = await res.json().catch(()=>null);
      return { ok: res.ok, status: res.status, json };
    } finally {
      clearTimeout(t);
    }
  }

  // Build the exact intent-matching prompt (same contract for both providers).
  // NOTE: we *intentionally ignore* any AI Settings "promptSeed" / universal prompt here.
  pb.ai.buildIntentPrompt = function(q, libraryMd){
 const userQuery = String(q ?? '').trim();
const lib = String(libraryMd ?? '').trim();
    // The demo uses a strict JSON schema and application/json response mode.
    // We mirror that here so both providers emit the same shape. 
    return [
       "You are an intent rewriter and taxonomy expert for a mixed toolbox library of tools containing frameworks, patterns, heuristics, strategies, and methods. The library spans phases of work (explore, define, ideate, plan, compose, evaluate, review, prioritize, troubleshoot, compare/decide), topics (prompting, debiasing, logic, ethics, psychology, design, storytelling, etc.), and uses (ideation, decision-making, process improvement, teaching, content, coding) to guide a user through a template.  Include is a library of the template's identified by a slug. Each library slug contributes “search text” from definition/keywords so lightweight matching works.",
        "",
        "Return STRICT JSON only (no prose), exactly in this schema:",
        '{ "query_rewrite":"...", "top_slugs":["...","...","...","...","..."] }',
        "",
        "Guidelines (follow all):",
        "- Rewrite the user’s sentence into a concise, canonical intent in \"query_rewrite\" and match it to the best fitting slugs.",
        "- Use ONLY slugs that appear in the Library. Slugs are canonical, lowercase, kebab-case (e.g., \"a3-problem-solving-toyota\", \"abcde-cbt-framework\", \"woop-wish-outcome-obstacle-plan\", \"triangulation-methods\").",
        "- Rank slugs from the library provided by semantic fit using the provided library search text (definition + keywords) and your inferred knowledge of that tool. Consider phase/topic/use cues in the query and match them to the best fit in the library.",
        "- Always output exactly 5 unique slugs in \"top_slugs\" (no commentary, no extra keys). If matches are weak or ambiguous, include the best available five.",
        "- Never invent slugs; never alter spelling; no duplicates; no explanations.",
        "",
        "User use case to match:",
      userQuery,
      "",
      "Library =",
      "",
      lib
    ].join("\n");
  };

  // Normalize/validate a provider’s JSON into { query_rewrite, top_slugs }
  function coerceResult(obj){
    const out = { query_rewrite: "", top_slugs: [] };
    if (!obj || typeof obj !== 'object') return out;
    if (typeof obj.query_rewrite === 'string') out.query_rewrite = obj.query_rewrite.trim();
    if (Array.isArray(obj.top_slugs)){
      const seen = new Set();
      for (const s of obj.top_slugs){
        const v = String(s||'').trim();
        if (!v) continue;
        if (seen.has(v)) continue;
        seen.add(v);
        out.top_slugs.push(v);
        if (out.top_slugs.length >= 5) break;
      }
    }
    // If fewer than 5 came back, leave as-is; caller can handle fallback.
    return out;
  }

  function typedError(provider, type, message, extra){
    return { ok:false, provider, error:{ type, message, ...(extra||{}) } };
  }



  // ---------------------------
  // OpenAI adapter
  // ---------------------------
  // Uses Chat Completions (JSON mode). We set response_format:{type:"json_object"}
  // and ask for the same strict JSON shape. (We still *ignore* any promptSeed/universal prompt here.)
  pb.ai.callOpenAI = async function({ q, libraryMd, key, model='gpt-4o-mini', timeoutMs=20000 }){
    const provider = 'openai';
    try{
      const prompt = pb.ai.buildIntentPrompt(q, libraryMd);

      const endpoint = 'https://api.openai.com/v1/chat/completions';
      const body = {
        model,
        temperature: 0.2,
        response_format: { type: "json_object" },
        messages: [
          // Keep system concise; all rules live in the user prompt built above.
          { role: "system", content: "Return strict JSON only for intent→slug matching." },
          { role: "user",   content: prompt }
        ]
      };

      const res = await fetchJsonWithTimeout(endpoint, {
        method: "POST",
        headers: {
          "Content-Type":"application/json",
          "Authorization": "Bearer " + String(key || '')
        },
        body: JSON.stringify(body)
      }, timeoutMs);

      if (!res.ok){
        return typedError(provider, 'api', `OpenAI HTTP ${res.status}`, { status:res.status, raw:res.json });
      }

      const content = res.json?.choices?.[0]?.message?.content ?? '';
      const cleaned = String(content || '').trim().replace(/^```json\s*/i,'').replace(/^```/,'').replace(/```$/,'');
      let parsed = null;
      try{ parsed = JSON.parse(cleaned); }catch(_){}

      if (!parsed){
        return typedError(provider, 'parse', 'OpenAI returned non-JSON or empty response', { raw: res.json });
      }

      const coerced = coerceResult(parsed);
      if (!coerced.query_rewrite && coerced.top_slugs.length === 0){
        return typedError(provider, 'parse', 'OpenAI JSON missing expected fields', { parsed });
      }

      return { ok:true, provider, query_rewrite: coerced.query_rewrite, top_slugs: coerced.top_slugs, raw: res.json };
    }catch(err){
      if (err?.name === 'AbortError') return typedError(provider, 'timeout', 'OpenAI request timed out');
      return typedError(provider, 'network', String(err && err.message || err));
    }
  };

  // Dev convenience: quick probe to see which provider you’re about to hit
  pb.ai._who = function(){ try{ return (pb.ai.getSettings && pb.ai.getSettings().provider) || null; }catch{ return null; } };

})();
</script>


<script>
(function(){
  window.pb = window.pb || {};
  pb.ai = pb.ai || {};

  function norm(x){
  return String(x || '')
    .trim()
    .toLowerCase()
    .replace(/[\s_]+/g, '-')      // spaces/underscores → hyphens
    .replace(/[^a-z0-9-]/g, '');  // keep only slug-safe chars
}

  pb.ai.routeTopSlugs = function(topSlugs){
    const ALL = (typeof allTemplates === 'function') ? allTemplates() : (Array.isArray(INDEX) ? INDEX : []);
    const set = new Set(ALL.map(t => norm(t.slug || t.id)).filter(Boolean));
    const seen = new Set();
    for (const s of (topSlugs || [])){
      const n = norm(s);
      if (!n || seen.has(n)) continue;
      seen.add(n);
      if (set.has(n)) return { slug:n, fallback:false };
    }
    for (const h of ['pattern-picker','task-picker']) if (set.has(h)) return { slug:h, fallback:true };
    const helper = ALL.find(t => norm(t.kind||t.type) === 'helper');
    if (helper) return { slug:norm(helper.slug||helper.id), fallback:true };
    const any = ALL.find(t => (t.slug||t.id));
    return { slug: any ? norm(any.slug||any.id) : 'pattern-picker', fallback:true };
  };

  pb.ai.openSettingsWithError = function(reason, providerMsg){
    try { AISettings.open(); } catch {}
    setTimeout(function(){
      const form  = document.getElementById('aiSettingsForm');
      if (!form) return;
      let banner  = document.getElementById('aiKeyError');
      if (!banner){
        banner = document.createElement('div');
        banner.id = 'aiKeyError';
        banner.className = 'alert error';
        banner.style.cssText = 'margin:0 0 10px 0;padding:8px 10px;border-radius:8px;background:#fee;color:#900';
        const header = form.querySelector('.modal-header');
        (header && header.nextSibling)
          ? form.insertBefore(banner, header.nextSibling)
          : form.insertBefore(banner, form.firstChild);
      }
      let msg = 'Add your API key to use AI-assisted search.';
      if (reason === 'no-api-mode')       msg = 'Turn off “No API mode” and enter your API key.';
      else if (reason === 'no-provider')  msg = 'Choose a provider to use AI-assisted search.';
      else if (reason === 'missing-key')  msg = 'Enter your API key for the selected provider.';
      else if (reason === 'provider-blocked') msg = 'This provider is disabled in app settings.';
      else if (reason === 'api')          msg = providerMsg || 'Your API key didn’t work. Check the key or billing status.';
      banner.textContent = msg;

      try {
        if (reason === 'no-provider'){
          (document.getElementById('aiProvOpenAI') || document.getElementById('aiProvGemini') || document.getElementById('aiProvApertus'))?.focus();
        } else if (reason === 'no-api-mode'){
          document.getElementById('aiNoApi')?.focus();
        } else {
          document.getElementById('aiApiKey')?.focus();
        }
      } catch {}
    }, 10);
  };

  pb.ai._fallbackRoute = function(reason, q){
    try { if (window.pb && window.pb.srStatusEl) window.pb.srStatusEl.textContent = 'Network was slow; we fell back to a safe choice.'; } catch {}
    const r = pb.ai.routeTopSlugs([]);
    try {
      saveLastSearch({ q: (q||'').trim(), slug: r.slug, state: 'AI-fallback:' + reason, tokens: (pb?.qCache?.tokensMeaningful)||[], from: 'index' });
    } catch {}
    const base = './glossary/startup-wizard.html';
    window.location.assign(`${base}?slug=${encodeURIComponent(r.slug)}`);
  };

pb.ai.handlePanelAI = async function(q){
  const k = pb.ai.hasKey();
  if (!k.ok){
    try { pb.log && pb.log('ai:no_key', { reason: k.reason }); } catch {}
    pb.ai.openSettingsWithError(k.reason);
    return;
  }

  // 1) Kick off the scan animation as a *visual-only* interstitial
  try { window.__scanVisualOnly = true; startScan(); } catch {}

  // 2) Call provider (currently Gemini override lives in runIntentRewrite)
  const md = (pb.ai.getLibraryMarkdown && pb.ai.getLibraryMarkdown()) || '';
  let res;
  try {
    res = await pb.ai.runIntentRewrite({ q, libraryMd: md });
  } catch (e){
    try { pb.log && pb.log('ai:network_exception', { message: String(e && e.message || e) }); } catch {}
    return pb.ai._fallbackRoute('timeout', q);
  }

  if (!res || res.ok !== true){
    const err = (res && res.error) || {};
    if (err.type === 'api'){
      const hint = err.message || (err.raw && (err.raw.error?.message)) || 'Your API key didn’t work.';
      pb.ai.openSettingsWithError('api', hint);
      try { pb.log && pb.log('ai:api_error', { provider: k.provider, status: err.status || null }); } catch {}
      return;
    }
    const why = err.type || 'unknown';
    try { pb.log && pb.log('ai:fallback', { reason: why }); } catch {}
    return pb.ai._fallbackRoute(why, q);
  }

  // 3) Map top 5 slugs → concrete template objects
  const ALL = (typeof allTemplates === 'function') ? allTemplates() : (Array.isArray(INDEX) ? INDEX : []);
  const norm = s => String(s||'').trim().toLowerCase().replace(/[\s_]+/g,'-').replace(/[^a-z0-9-]/g,'');
  const bySlug = new Map(ALL.map(t => [norm(t.slug || t.id), t]));
  const picks = [];
  for (const s of (res.top_slugs || [])){
    const t = bySlug.get(norm(s));
    if (t) picks.push(t);
  }
  if (!picks.length) return pb.ai._fallbackRoute('no-matches', q);

  // 4) Stop the scan overlay (in case it’s still up) and open modal
  try { document.getElementById('scan').style.display = 'none'; } catch {}
  try { document.getElementById('hero').style.display = 'block'; } catch {}

  // Persist for history/debug
  try {
    saveLastSearch({
      q: (res.query_rewrite || q || '').trim(),
      slug: String(picks[0].slug || picks[0].id || ''),
      state: 'AI-top5',
      tokens: (pb?.qCache?.tokensMeaningful) || [],
      from: 'index'
    });
  } catch {}

  try { pb.log && pb.log('ai:ok', { provider: k.provider, count: picks.length }); } catch {}

  // 5) Show the chooser modal
  openAIResultsModal({ templates: picks, query: res.query_rewrite || q });
};

})();
</script>

<script>
/* ============ Slice 2 — Mobile-only suggestions overlay ============ */

/* A) Mobile detection: toggles .is-mobile on <html> */
(function mobileGate(){
  var mq = matchMedia('(hover: none) and (pointer: coarse)');
  var ua = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile/i;

  function compute(){
    var touchy = mq.matches;                 // real touch (no hover + coarse pointer)
    var uaMobile = ua.test(navigator.userAgent);
    var narrow = Math.min(window.innerWidth, window.innerHeight) <= 920; // phones/tablets
    return (touchy || uaMobile) && narrow;
  }
  function apply(){
    document.documentElement.classList.toggle('is-mobile', compute());
  }
  try{ mq.addEventListener ? mq.addEventListener('change', apply) : mq.addListener(apply);}catch(e){}
  window.addEventListener('resize', apply, {passive:true});
  window.addEventListener('orientationchange', apply, {passive:true});
  apply();
})();

/* B) Overlay portal controller (uses #q and #ta that you already have) */
(function portal(){
  var input = document.getElementById('q');   // your search field
  var ta    = document.getElementById('ta');  // your suggestions listbox
  if (!input || !ta) return;

  var portalRoot, scrim, overlay, origParent, origNext, observer;
  var opened = false;

  function isMobile(){ return document.documentElement.classList.contains('is-mobile'); }

  function ensurePortal(){
    if (portalRoot) return;
    portalRoot = document.createElement('div');
    portalRoot.id = 'suggestions-portal';
    document.body.appendChild(portalRoot);

    scrim = document.createElement('div');
    scrim.className = 'suggestions-scrim';
    scrim.hidden = true;
    portalRoot.appendChild(scrim);

    overlay = document.createElement('div');
    overlay.className = 'suggestions-overlay';
    overlay.hidden = true;
    portalRoot.appendChild(overlay);

    /* stop document pointerdown from hiding #ta when tapping suggestions */
    overlay.addEventListener('pointerdown', function(e){
  // Allow taps on the actual suggestion items (#ta descendants) to reach their handlers
  var taInOverlay = overlay.querySelector('#ta');
  if (taInOverlay && taInOverlay.contains(e.target)) return;
  // Otherwise, prevent document’s global pointerdown from hiding the list prematurely
  e.stopPropagation();
}, true);
    scrim.addEventListener('click', function(){
      // close and also hide #ta so your app state stays consistent
      closeOverlay();
      if (window.hideTA) window.hideTA(); else { ta.hidden = true; ta.innerHTML = ''; }
    }, { passive: true });
  }

  function position(){
  if (!opened) return;

  var r  = input.getBoundingClientRect();
  var vv = window.visualViewport || { offsetTop: 0, offsetLeft: 0, width: window.innerWidth, height: window.innerHeight };

  var gutter = 8;                                  // keep a small left/right padding
  var vLeft  = vv.offsetLeft || 0;
  var vTop   = vv.offsetTop  || 0;
  var vWidth = vv.width || window.innerWidth;
  var vHeight= vv.height|| window.innerHeight;

  // Start by aligning to the input
  var left = r.left - vLeft;
  var top  = r.bottom - vTop;
  var width= r.width;

  // Clamp to viewport so the overlay never goes off-screen
  if (left < gutter) left = gutter;
  var maxWidth = Math.max(140, vWidth - left - gutter);
  if (width > maxWidth) width = maxWidth;

  overlay.style.top  = Math.round(top)  + 'px';
  overlay.style.left = Math.round(left) + 'px';
  overlay.style.width= Math.round(width)+ 'px';
  overlay.style.maxHeight = Math.round(vHeight * 0.60) + 'px';
}
  function openOverlay(){
    if (!isMobile() || opened) { position(); return; }
    ensurePortal();

    // remember original slot to restore later
    if (!origParent){ origParent = ta.parentNode; origNext = ta.nextSibling; }

    overlay.appendChild(ta);
    scrim.hidden = false;
    overlay.hidden = false;
    document.body.classList.add('scroll-locked');
    document.documentElement.classList.add('overlay-open');
    input.setAttribute('aria-expanded','true');
    position();

    // keep it anchored on viewport/keyboard changes
    window.addEventListener('resize', position, { passive: true });
    window.addEventListener('scroll', position, { passive: true });
    if (window.visualViewport){
      visualViewport.addEventListener('resize', position, { passive: true });
      visualViewport.addEventListener('scroll', position, { passive: true });
    }
    document.addEventListener('keydown', onKey, true);
    opened = true;
  }

  function closeOverlay(){
    if (!opened) return;
    scrim.hidden = true;
    overlay.hidden = true;

    // restore #ta to original DOM so desktop is unchanged
    try {
      if (origParent) origParent.insertBefore(ta, origNext);
    } catch(e){}

    document.body.classList.remove('scroll-locked');
    document.documentElement.classList.remove('overlay-open');
    input.setAttribute('aria-expanded','false');

    window.removeEventListener('resize', position, { passive: true });
    window.removeEventListener('scroll', position, { passive: true });
    if (window.visualViewport){
      visualViewport.removeEventListener('resize', position, { passive: true });
      visualViewport.removeEventListener('scroll', position, { passive: true });
    }
    document.removeEventListener('keydown', onKey, true);
    opened = false;
  }

  function onKey(e){ if (e.key === 'Escape'){ e.preventDefault(); closeOverlay(); } }

  /* C) Sync overlay with your existing show/hide logic via MutationObserver */
  observer = new MutationObserver(function(){
    if (!isMobile()) return;
    // If app has shown #ta, open overlay; if it hid it, close overlay.
    (!ta.hidden && ta.children.length) ? openOverlay() : closeOverlay();
  });
  observer.observe(ta, { attributes:true, attributeFilter:['hidden'], childList:true, subtree:false });

  /* D) Also react to input focus (your code already renders idle suggestions on focus) */
  input.addEventListener('focus', function(){ if (isMobile() && !ta.hidden) openOverlay(); });

  /* E) If device flips to desktop midsession, close & restore */
  var mq = window.matchMedia('(hover: none) and (pointer: coarse)');
  function maybeClose(){ if (!isMobile()) closeOverlay(); }
  try { mq.addEventListener ? mq.addEventListener('change', maybeClose) : mq.addListener(maybeClose); } catch(e){}
})();
</script>

<script>
(function findWidest(){
  if (!document.documentElement.classList.contains('is-mobile')) return;
  var widest = { el:null, w:0 };
  document.querySelectorAll('body *').forEach(function(el){
    var r = el.getBoundingClientRect();
    if (r.width > widest.w) widest = { el: el, w: r.width };
  });
  console.log('Widest element:', widest.el, 'width:', widest.w, 'viewport:', window.innerWidth);
})();
</script>

<script>
(function detailsHeaderMobile(){
  var root = document.getElementById('resultHeader');
  if (!root) return;

  var btn  = document.getElementById('resultMenuBtn');
  var menu = document.getElementById('resultMenu');

  // Desktop safety: do nothing if pieces are missing
  if (!btn || !menu) return;

  function isMobile(){
    return document.documentElement.classList.contains('is-mobile');
  }
  function haveDetails(){
    return document.body.classList.contains('is-details') &&
           !!window.__lastRouting && !!window.__lastFullPrompt;
  }

  function clearMenu(){
    while (menu.firstChild) menu.removeChild(menu.firstChild);
  }

  // Build an item that can be a button or link depending on href
  function addItem(label, opts){
    opts = opts || {};
    var href = opts.href || '';
    var onClick = opts.onClick || null;
    var disabled = !!opts.disabled;

    var el = document.createElement(href ? 'a' : 'button');
    el.className = 'menuItem';
    el.setAttribute('role','menuitem');
    el.textContent = label;

    if (href) el.href = href;

    if (disabled){
      el.setAttribute('aria-disabled','true');
    } else if (onClick){
      el.addEventListener('click', function(e){
        e.preventDefault();
        e.stopPropagation();
        close();
        onClick();
      });
    } else if (href){
      // Navigate via href on click (close first for tidiness)
      el.addEventListener('click', function(e){
        // Allow normal link behavior, just close menu visually
        close();
      });
    }

    menu.appendChild(el);
    return el;
  }

  function buildParityMenu(){
    clearMenu();

    // Defensive lookups so we mirror the same links desktop uses
    var openGlossary = document.getElementById('openGlossary');
    var printWorksheet = document.getElementById('printWorksheet');
    var openBuilder = document.getElementById('openBuilder');

    var routing = window.__lastRouting || {};
    var fullPrompt = String(window.__lastFullPrompt || '');

    // 1) all templates — unchanged link
    var glossHref = (openGlossary && openGlossary.href) || './glossary/templates-glossary.html';
    addItem('all templates', { href: glossHref });

    // 2) worksheet — kind/id/xfer when available; else disabled
    var canWorksheet = !!(routing.id && routing.kindPlural);
    var wsHref = (printWorksheet && printWorksheet.href) || '';
    addItem('worksheet', {
      href: canWorksheet ? wsHref : '',
      disabled: !canWorksheet,
      onClick: canWorksheet ? function(){ window.location.href = wsHref; } : null
    });

    // 3) prompt builder — existing ?slug
    var pbHref = (openBuilder && openBuilder.href) || './glossary/prompt-builder.html';
    addItem('prompt builder', { href: pbHref });

    // 4) ask — open the same action modal as desktop
    addItem('ask', {
      disabled: !haveDetails(),
      onClick: function(){
        if (!haveDetails()) return;
        if (window.PB_FLAGS && window.PB_FLAGS.askUrlPrompt){
          openAction({ mode:'ask', prompt: fullPrompt, routing: routing });
        } else {
          // rollback path if flag off
          try { navigator.clipboard.writeText(fullPrompt); } catch(e){}
          window.open('https://chat.openai.com/', '_blank', 'noopener');
        }
      }
    });

    // 5) copy — open the same action modal as desktop
    addItem('copy', {
      disabled: !haveDetails(),
      onClick: function(){
        if (!haveDetails()) return;
        // keep initial quick copy for parity with desktop flow
        (async function(){
          try { await navigator.clipboard.writeText(fullPrompt); } catch(e){}
          if (window.PB_FLAGS && window.PB_FLAGS.newActionModal){
            openAction({ mode:'copy', prompt: fullPrompt, routing: routing });
          }
        })();
      }
    });
  }

  // Legacy fallback: clone the header CTAs if parity flag is OFF
  function buildLegacyMenu(){
    clearMenu();
    var ctas = root.querySelector('.ctas');
    if (!ctas) return;
    Array.from(ctas.children).forEach(function(node){
      if (!(node instanceof HTMLElement)) return;
      var isLink = node.tagName.toLowerCase() === 'a';
      var item = document.createElement(isLink ? 'a' : 'button');
      item.setAttribute('role','menuitem');
      item.className = 'menuItem';
      item.textContent = (node.getAttribute('aria-label') || node.textContent || 'Action').trim();
      if (isLink && node.getAttribute('href')) {
        item.href = node.getAttribute('href');
      }
      item.addEventListener('click', function(e){
        e.preventDefault(); e.stopPropagation();
        close();
        if (isLink && node.href) { window.location.href = node.href; return; }
        node.click();
      });
      menu.appendChild(item);
    });
  }

  function ensureMenu(){
    if (!isMobile()) return;
    if (window.PB_FLAGS && window.PB_FLAGS.mobileMenuParity) buildParityMenu();
    else buildLegacyMenu();
  }

  function open(){
    if (!isMobile()) return;
    ensureMenu();
    menu.hidden = false;
    btn.setAttribute('aria-expanded','true');
    trapOutsideOnce();
  }
  function close(){
    if (menu.hidden) return;
    menu.hidden = true;
    btn.setAttribute('aria-expanded','false');
  }

  function trapOutsideOnce(){
    var onDoc = function(e){
      if (!menu.contains(e.target) && e.target !== btn) {
        close();
        document.removeEventListener('click', onDoc, true);
      }
    };
    document.addEventListener('click', onDoc, true);

    var onKey = function(e){
      if (e.key === 'Escape') { e.preventDefault(); close(); document.removeEventListener('keydown', onKey, true); }
    };
    document.addEventListener('keydown', onKey, true);
  }

  btn.addEventListener('click', function(e){
    if (!isMobile()) return;
    e.preventDefault(); e.stopPropagation();
    menu.hidden ? open() : close();
  });

  // If device context flips to desktop, ensure the menu is closed
  var mq = matchMedia('(hover: none) and (pointer: coarse)');
  function maybeClose(){ if (!isMobile()) close(); }
  try { mq.addEventListener ? mq.addEventListener('change', maybeClose) : mq.addListener(maybeClose); } catch(e){}
})();
</script>

<script>
// === 1) History wiring: add near your other top-level refs (after hero/scan/details/resultHeader are defined) ===
(function wireHistory(){
  // Make sure we have an initial "home" state
  try {
    if (!(history.state && history.state.view)) {
      history.replaceState({ view: 'home' }, '', location.pathname + location.search);
    }
  } catch(e){}

  // Respond to browser back/forward
  window.addEventListener('popstate', function(e){
    var st = e.state || { view: 'home' };

    if (st.view === 'home'){
      // Show hero; hide details/scan/header
      try { scan.style.display = 'none'; } catch(e){}
      try { details.hidden = true; } catch(e){}
      try { resultHeader.hidden = true; } catch(e){}
      try { hero.style.display = 'block'; } catch(e){}
      try { qEl && qEl.focus(); } catch(e){}
    } else if (st.view === 'details'){
      // Optional: restore details by slug if present; otherwise fall back to hero
      var slug = st.slug;
      var t = slug && Array.isArray(INDEX) ? INDEX.find(function(x){
        return String(x.slug || x.id) === String(slug);
      }) : null;
      if (t) { showDetails(t); }
      else {
        try { scan.style.display = 'none'; } catch(e){}
        try { details.hidden = true; } catch(e){}
        try { resultHeader.hidden = true; } catch(e){}
        try { hero.style.display = 'block'; } catch(e){}
      }
    }
  });

  // Helper we’ll call when entering details
  window.__pushDetailsState = function(slug){
    try { history.pushState({ view:'details', slug: slug || null }, '', '#details'); } catch(e){}
  };
})();
</script>

<script>
// Anchor both dropdowns under their respective bars
(function anchorTypeaheads(){
  var ta  = document.getElementById('ta');
  var bar = document.querySelector('.searchWrap .search');
  if (ta && bar && ta.parentNode !== bar) bar.appendChild(ta);

  var ta2  = document.getElementById('ta2');
  var bar2 = document.querySelector('.detailSearchWrap .detailSearch');
  if (ta2 && bar2 && ta2.parentNode !== bar2) bar2.appendChild(ta2);
})();
</script>


<script>
  // --- redirect helper ---
  function gotoWizard(t) {
    if (!t) return;
    const slug = t.slug || (t.label || '').toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9\-]/g, '')
      .replace(/\-+/g, '-')
      .replace(/^\-|\-$/g, '');
    // If your wizard lives under /glossary/, swap to './glossary/startup-wizard.html'
    const base = './glossary/startup-wizard.html';
    window.location.assign(`${base}?slug=${encodeURIComponent(slug)}`);
  }

  // --- hijack details to route to the wizard ---
  (function hijackShowDetails(){
    const prev = window.showDetails;  // keep a reference just in case
    window.showDetails = function(t){
      gotoWizard(t);
      // If you ever need to fall back to the old behavior for debugging,
      // comment the line above and uncomment the line below:
      // return prev ? prev(t) : undefined;
    };
  })();
</script>

<script>
(function(){
  function truncate(s, n){ s = String(s||''); return s.length <= n ? s : (s.slice(0, n-1) + '…'); }
  function bestUseCase(t, hint){
    const ucs = Array.isArray(t.use_cases) ? t.use_cases : [];
    if (!ucs.length) return t.label || t.slug || 'template';
    if (hint){
      const h = String(hint||'').toLowerCase();
      const hit = ucs.find(u => u.toLowerCase().includes(h.split(/\s+/)[0]||''));
      if (hit) return hit;
    }
    return ucs[0];
  }

  window.openAIResultsModal = function({ templates=[], query='' }){
    const dlg   = document.getElementById('aiResultsDlg');
    const list  = document.getElementById('aiResultsList');
    const qslot = document.getElementById('aiResultsQuery');
    if (!dlg || !list){ 
      // safety: fall back to first
      if (templates[0]) gotoWizard(templates[0]);
      return;
    }
    if (qslot) qslot.textContent = String(query||'').trim();

    // Build cards
    list.innerHTML = templates.map(t=>{
      const slug = String(t.slug || t.id || '').trim();
      const title = bestUseCase(t, query);
      const defFull = String(t.definition || 'No definition provided yet.');
      const defShort = truncate(defFull, 100);
      return `
        <article class="result" data-slug="${slug}">
          <div class="row">
            <h4 class="use">${title}</h4>
          </div>
          <div class="label">${(t.label || t.slug || t.id || '').toLowerCase()}</div>
          <p class="def">
            <span class="short">${defShort}</span>
            <span class="full" hidden>${defFull}</span>
            ${defFull.length > 100 ? `<button class="btn small more" type="button">more</button>` : ``}
          </p>
          <div class="actions">
            <button class="btn primary small choose" type="button">use this</button>
          </div>
        </article>`;
    }).join('');

    // Delegate clicks (card, button, and “more” toggle)
    list.onclick = function(e){
      const moreBtn = e.target.closest('.more');
      if (moreBtn){
        e.preventDefault();
        const card = e.target.closest('.result');
        if (!card) return;
        const full  = card.querySelector('.def .full');
        const short = card.querySelector('.def .short');
        const on = full && full.hasAttribute('hidden');
        if (full){ on ? full.removeAttribute('hidden') : full.setAttribute('hidden',''); }
        if (short){ on ? short.setAttribute('hidden','') : short.removeAttribute('hidden'); }
        moreBtn.textContent = on ? 'less' : 'more';
        return;
      }

      const choose = e.target.closest('.choose') || e.target.closest('.result');
      if (choose){
        e.preventDefault();
        const card = e.target.closest('.result') || choose;
        const slug = card.getAttribute('data-slug') || '';
        // Resolve template by slug/id
        const ALL = (typeof allTemplates === 'function') ? allTemplates() : (Array.isArray(INDEX) ? INDEX : []);
        const norm = s => String(s||'').trim().toLowerCase().replace(/[\s_]+/g,'-').replace(/[^a-z0-9-]/g,'');
        const t = ALL.find(x => norm(x.slug||x.id) === norm(slug));
        try { dlg.close(); } catch {}
        if (t) return gotoWizard(t);
      }
    };

    // Close button + ESC support
    const closeBtn = document.getElementById('aiResultsClose');
    if (closeBtn){ closeBtn.onclick = ()=>{ try { dlg.close(); } catch {} }; }
    try { dlg.showModal(); } catch { dlg.open = true; }
  };
})();
</script>


<script>
(function(){
  // ---- helpers you already have or can adapt ----
  function activePromptText(){
    // TODO: reuse your existing function that builds the final prompt text.
    const ta = document.getElementById('actionPreview') || document.querySelector('textarea[data-role="prompt"]');
    return (ta && ta.value) ? ta.value.trim() : '';
  }

  function buildAskURL(provider, prompt){
    const txt = String(prompt || '');
    if (provider === 'gemini'){
      const base = 'https://gemini.google.com/app'; // no stable ?prompt param
      let url = base;
      try { const u = new URL(base); u.searchParams.set('q', txt); url = u.toString(); } catch(_){}
      const tooLong = url.length > 7800;
      return { url, base: base + '/', tooLong };
    }
    // ChatGPT supports ?prompt= (often works; long URLs can fail)
    const base = 'https://chat.openai.com';
    let url = base + '/?prompt=' + encodeURIComponent(txt);
    const tooLong = url.length > 7800;
    return { url, base: base + '/', tooLong };
  }

  function setAskLabels(){
    const ai = AISettings.get();
    const label = (ai.provider === 'gemini') ? '💬 Ask Gemini' : '💬 Ask ChatGPT';
    const openBtn2 = document.getElementById('openBtn2');
    const footerAsk = document.getElementById('openAllBtnFooter');
    if (openBtn2)   openBtn2.textContent = label;
    if (footerAsk)  footerAsk.textContent = label;

    // If you have template-field Ask buttons, unify by class:
    document.querySelectorAll('.ask-btn').forEach(btn => btn.textContent = label);
  }

  // ---- provider-aware Action modal wiring ----
  function openAskModalWith(text){
    const ai = AISettings.get();
    const dlg = document.getElementById('actionModal');
    const form = document.getElementById('actionForm');
    const title = document.getElementById('actionTitle');
    const previewWrap = dlg?.querySelector('.field');
    const preview = document.getElementById('actionPreview');
    const note = document.getElementById('actionNote');
    const confirm = document.getElementById('actionConfirm');
    const cancel = document.getElementById('actionCancel');
    const closeX = document.getElementById('actionClose');
    if (!dlg || !form || !title || !preview || !confirm) {
      // Fallback: open directly
      return openDirect(text);
    }

    const providerName = (ai.provider === 'gemini') ? 'Gemini' : 'ChatGPT';
    title.textContent = `💬 Ask ${providerName}`;
    confirm.textContent = `Open in ${providerName}`;
    if (previewWrap) previewWrap.style.display = '';
    preview.value = text;
    note.hidden = true;

    // Clean previous handlers
    const newConfirm = confirm.cloneNode(true);
    confirm.parentNode.replaceChild(newConfirm, confirm);

    newConfirm.addEventListener('click', (e)=>{
      e.preventDefault();
      const finalTxt = (preview.value || '').trim();
      const built = buildAskURL(ai.provider, finalTxt);

      if (built.tooLong){
        try { navigator.clipboard.writeText(finalTxt); } catch {}
        openBaseAndNotify(built.base, providerName, true);
      } else {
        window.open(built.url, '_blank', 'noopener,noreferrer');
        openBaseAndNotify(built.base, providerName, false);
      }
      try { dlg.close(); } catch {}
    });

    cancel && cancel.addEventListener('click', ()=>{ try { dlg.close(); } catch {} }, {once:true});
    closeX && closeX.addEventListener('click', ()=>{ try { dlg.close(); } catch {} }, {once:true});

    try { dlg.showModal(); } catch { dlg.open = true; }
  }

  function openBaseAndNotify(base, providerName, copied){
    // Post-launch dialog (if you have it), otherwise toast
    const post = document.getElementById('postLaunchDlg');
    const title = document.getElementById('postLaunchTitle');
    const msg   = document.getElementById('postLaunchMsg');
    const note  = document.getElementById('postLaunchNote');
    const openBase = document.getElementById('postLaunchOpenBase');

    if (post && post.showModal){
      if (title) title.textContent = `Did the prompt appear in ${providerName}?`;
      if (msg)   msg.textContent   = copied
        ? `Prompt copied. A ${providerName} tab opened. If it didn’t prefill, paste (Cmd/Ctrl+V).`
        : `A ${providerName} tab opened. If it didn’t prefill, paste with Cmd/Ctrl+V.`;
      if (note)  note.textContent  = `Why this happens: very long URLs can be ignored, and ${providerName} can restore a cached draft.`;
      if (openBase) {
        openBase.onclick = ()=> window.open(base, '_blank','noopener,noreferrer');
      }
      post.showModal();
      return;
    }
    // minimal fallback
    try { showToast(`${providerName} opened. Paste your prompt if it didn’t prefill.`); } catch {}
  }

  function openDirect(text){
    const ai = AISettings.get();
    const providerName = (ai.provider === 'gemini') ? 'Gemini' : 'ChatGPT';
    const built = buildAskURL(ai.provider, text);
    if (built.tooLong){
      try { navigator.clipboard.writeText(text); } catch {}
      window.open(built.base, '_blank', 'noopener,noreferrer');
    } else {
      window.open(built.url, '_blank', 'noopener,noreferrer');
    }
    try { showToast(`${providerName} opened. Paste your prompt if it didn’t prefill.`); } catch {}
  }

  // ---- wire header + ask buttons ----
  function wirePage(){
    // Header: Settings launcher
    const settingsBtn = document.getElementById('aiSettingsBtn');
    settingsBtn && settingsBtn.addEventListener('click', ()=> AISettings.open());

    // Secondary Ask (Template Fields): provider-aware modal open
    const openBtn2 = document.getElementById('openBtn2');
    if (openBtn2){
      openBtn2.onclick = async ()=>{
        // Build or read your composed prompt:
        const txt = activePromptText();
        // Keep current UX: copy prompt before opening modal:
        try { await navigator.clipboard.writeText(txt); } catch {}
        openAskModalWith(txt);
      };
    }

    // Footer Ask (if present)
    const footerAsk = document.getElementById('openAllBtnFooter');
    if (footerAsk){
      footerAsk.onclick = async ()=>{
        const txt = activePromptText();
        try { await navigator.clipboard.writeText(txt); } catch {}
        openAskModalWith(txt);
      };
    }

    // Initial label set + subscribe to changes
    setAskLabels();
    AISettings.onSaved(setAskLabels);
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', wirePage);
  } else wirePage();
  
  
  
})();
</script>

<script>
/* === Apertus adapter (demo-parity) — single source of truth for MVP === */
(function(){
  // Build the same exact prompt as Gemini’s adapter (don’t “improve”)
  function buildPromptForApertus(userQuery, libraryMd){
    return [
      "You are an intent rewriter and taxonomy matcher for a small prompt library.",
      "Rewrite the user’s sentence into a concise, canonical intent (query_rewrite).",
      "Then pick the best 5 slugs from the Library below (top_slugs).",
      "",
      "Rules:",
      "- Use ONLY slugs that appear in the Library (exact spelling).",
      "- Rank by semantic fit; short definitions/keywords hint the topic.",
      "- Output STRICT JSON only, exactly in this schema (no prose):",
      '{ "query_rewrite":"...", "top_slugs":["...","...","...","...","..."] }',
      "",
      "User use case to match:",
      userQuery,
      "",
      "Library =",
      libraryMd
    ].join("\n");
  }

  // Strip ``` fences and trim to outer JSON before parse (same as Gemini)
  function stripFences(s){
    if (!s) return "";
    let t = String(s).trim();
    t = t.replace(/^```(?:json)?\s*/i, "").replace(/\s*```$/i, "");
    const first = t.indexOf("{");
    const last  = t.lastIndexOf("}");
    if (first >= 0 && last >= first) t = t.slice(first, last + 1);
    return t.trim();
  }

  // NOTE on headers:
  // - Browsers cannot set the real 'User-Agent'. If your Worker needs a UA, use a custom header like 'X-User-Agent'.
  // - You said your PublicAI Worker carries the upstream API key. If so, 'Authorization' may be omitted for route='publicai'.
  async function callApertus({ q, libraryMd, key, model, route='publicai', timeoutMs=20000, userAgent }){
    // Cap library size to keep latency predictable (same policy as Gemini)
    if (libraryMd && libraryMd.length > 120_000){
      console.warn("[AI] Library too large; trimming for speed.", libraryMd.length);
      libraryMd = libraryMd.slice(0, 119_000) + "\n<!-- trimmed -->";
    }

    const prompt = buildPromptForApertus(q, libraryMd);

    // Endpoints
    const basePublic = (String(window.PB_PUBLICAI_BASE || 'https://pb-publicai-proxy.composer01.workers.dev').replace(/\/+$/,'') + '/v1/chat/completions');
    const url = (String(route||'publicai').toLowerCase() === 'huggingface')
      ? 'https://router.huggingface.co/v1/chat/completions'
      : basePublic;

    // OpenAI-compatible Chat Completions payload
    const body = {
      model: model || 'swiss-ai/apertus-8b-instruct',
      response_format: { type: 'json_object' },
      messages: [
        // Keep system minimal; all strict rules live in the user content
        { role: 'system', content: 'Return strict JSON only.' },
        { role: 'user',   content: prompt }
      ],
      temperature: 0.2
    };

    // Headers
    const headers = { 'Content-Type':'application/json' };
    const addAuth = (String(route||'publicai').toLowerCase() === 'huggingface') || !!key;
    if (addAuth && key) headers['Authorization'] = 'Bearer ' + String(key);
    if (userAgent) headers['X-User-Agent'] = String(userAgent); // custom UA if you want your Worker to log it

    // Timeout + fetch
    const ctrl = new AbortController();
    const timer = setTimeout(()=> ctrl.abort(), timeoutMs);
    const t0 = performance.now();

    try{
      console.info("[AI] Apertus call → start", { route, model: body.model, timeoutMs });
      const res = await fetch(url, {
        method: 'POST',
        headers,
        body: JSON.stringify(body),
        signal: ctrl.signal
      });

      const latency = Math.round(performance.now() - t0);
      if (!res.ok){
        let raw = '';
        try { raw = await res.text(); } catch {}
        console.warn("[AI] Apertus call → fail http", res.status, raw?.slice?.(0,180));
        return { ok:false, provider:'apertus', error:{ type:'http', status:res.status, body:raw }, latency };
      }

      const json = await res.json().catch(()=> ({}));
      const content = json?.choices?.[0]?.message?.content ?? '';
      const clean   = stripFences(content);
      let parsed = null;
      try { parsed = JSON.parse(clean); } catch(e){
        console.warn("[AI] Apertus call → fail parse", e, { preview: clean.slice(0,180) });
        return { ok:false, provider:'apertus', error:{ type:'parse', message:String(e) }, latency };
      }

      const top = Array.isArray(parsed.top_slugs) ? parsed.top_slugs.filter(s => typeof s === 'string') : [];
      const qr  = typeof parsed.query_rewrite === 'string' ? parsed.query_rewrite : "";
      console.info("[AI] Apertus call → ok", { latency, n: top.length });
      return { ok:true, provider:'apertus', top_slugs: top.slice(0,5), query_rewrite: qr, latency };
    } catch(e){
      const latency = Math.round(performance.now() - t0);
      const type = (e && e.name === 'AbortError') ? 'timeout' : 'net';
      console.warn("[AI] Apertus call → fail", type, e);
      return { ok:false, provider:'apertus', error:{ type }, latency };
    } finally{
      clearTimeout(timer);
    }
  }

  // Export
  window.pb = window.pb || {};
  pb.ai = pb.ai || {};
  pb.ai.callApertus = callApertus;
})();
</script>

<!-- ▼▼ paste this block inside the pb.ai IIFE, right after runIntentRewrite() ▼▼ -->
<script>
/* === Gemini adapter (demo-parity) — single source of truth for MVP === */
(function(){
  // Build the exact prompt we send to Gemini (keep it stable; don’t “improve”)
  function buildPromptForGemini(userQuery, libraryMd){
    // Keep this structure tight: short system brief → strict schema → the query → the library table
    // The schema is minimal and matches our parser below.
    return [
      "You are an intent rewriter and taxonomy matcher for a small prompt library.",
      "Rewrite the user’s sentence into a concise, canonical intent (query_rewrite).",
      "Then pick the best 5 slugs from the Library below (top_slugs).",
      "",
      "Rules:",
      "- Use ONLY slugs that appear in the Library (exact spelling).",
      "- Rank by semantic fit; short definitions/keywords hint the topic.",
      "- Output STRICT JSON only, exactly in this schema (no prose):",
      '{ "query_rewrite":"...", "top_slugs":["...","...","...","...","..."] }',
      "",
      "User use case to match:",
      userQuery,
      "",
      "Library =",
      libraryMd
    ].join("\n");
  }

  // Strip code-fences/backticks and surrounding whitespace before JSON.parse
  function stripFences(s){
    if (!s) return "";
    let t = String(s).trim();
    // strip ```json ... ``` or ``` ... ```
    t = t.replace(/^```(?:json)?\s*/i, "").replace(/\s*```$/i, "");
    // strip stray leading/trailing non-json junk
    const first = t.indexOf("{");
    const last  = t.lastIndexOf("}");
    if (first >= 0 && last >= first) t = t.slice(first, last + 1);
    return t.trim();
  }

  async function callGemini({ q, libraryMd, key, model, timeoutMs=20000 }){
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(key)}`;

    // Safety: cap library size so we don’t balloon latency (keep ≤ ~120KB)
    if (libraryMd && libraryMd.length > 120_000){
      console.warn("[AI] Library too large; trimming for speed.", libraryMd.length);
      libraryMd = libraryMd.slice(0, 119_000) + "\n<!-- trimmed -->";
    }

    const prompt = buildPromptForGemini(q, libraryMd);

    // Gemini JSON mode + schema (enforces that we get pure JSON text back)
    const req = {
      contents: [{ role: "user", parts: [{ text: prompt }]}],
      generationConfig: {
        temperature: 0.2,
        topK: 40,
        topP: 0.9,
        candidateCount: 1,
        responseMimeType: "application/json",
        responseSchema: {
          type: "OBJECT",
          properties: {
            query_rewrite: { type: "STRING" },
            top_slugs: { type: "ARRAY", items: { type: "STRING" } }
          },
          required: ["top_slugs"]
        }
      }
    };

    const ctrl = new AbortController();
    const t = setTimeout(()=> ctrl.abort(), timeoutMs);
    const t0 = performance.now();

    try{
      console.info("[AI] Gemini call → start", { model, timeoutMs });
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(req),
        signal: ctrl.signal
      });
      const latency = Math.round(performance.now()-t0);
      if (!res.ok){
        const errText = await res.text().catch(()=> "");
        console.warn("[AI] Gemini HTTP error", res.status, errText);
        return { ok:false, provider:'gemini', error:{ type:'http', status:res.status, body:errText }, latency };
      }
      const json = await res.json();
      // Pull the model’s text response (JSON string), then parse
      const raw = json?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";
      const clean = stripFences(raw);
      let parsed = null;
      try{ parsed = JSON.parse(clean); }catch(e){
        console.warn("[AI] parse error", e, { raw: raw.slice(0,200) });
        return { ok:false, provider:'gemini', error:{ type:'parse', message:String(e) }, latency };
      }
      // Normalize result
      const top = Array.isArray(parsed.top_slugs) ? parsed.top_slugs.filter(s => typeof s === 'string') : [];
      const qr  = typeof parsed.query_rewrite === 'string' ? parsed.query_rewrite : "";
      console.info("[AI] Gemini call → ok", { latency, n: top.length });
      return { ok:true, provider:'gemini', top_slugs: top.slice(0,5), query_rewrite: qr, latency };
    }catch(e){
      const latency = Math.round(performance.now()-t0);
      const type = (e && e.name === 'AbortError') ? 'timeout' : 'net';
      console.warn("[AI] Gemini call → fail", type, e);
      return { ok:false, provider:'gemini', error:{ type }, latency };
    }finally{
      clearTimeout(t);
    }
  }

  // Expose as the canonical Gemini caller for pb.ai
  pb.ai.callGemini = callGemini;
})();
</script>
<!-- ▲▲ paste ends here ▲▲ -->

<script>
/* === AI Assist → cross-page handoff (v1) ================================
   Saves the final suggestions shown to the user into localStorage so that
   other pages (e.g., startup-wizard.html) can retrieve and render them.

   What it does:
   - Watches #aiResultsList for changes (when your Gemini results render)
   - Persists a compact payload with query, provider/model, and items
   - Records which suggestion the user clicked (pickedSlug)
   - Exposes a tiny global API: window.PBAIHandoff.{load,clear,getCandidates,getPicked}
========================================================================= */

(function(){
  // Namespace & storage key
  window.pb = window.pb || {};
  pb.ai = pb.ai || {};
  const KEY = 'pb_ai_handoff_v1';

  // Small utility to be reused anywhere
  pb.ai.handoff = {
    key: KEY,
    save(payload){
      try{ localStorage.setItem(KEY, JSON.stringify(payload)); }
      catch(e){ console.info('[handoff] save failed:', e); }
    },
    load(){
      try{ return JSON.parse(localStorage.getItem(KEY) || 'null'); }
      catch{ return null; }
    },
    clear(){ try{ localStorage.removeItem(KEY); }catch{} },
    setPicked(slug){
      const h = this.load(); if (!h) return;
      h.pickedSlug = slug || null;
      h.ts = Date.now();
      this.save(h);
    }
  };

  // Elements your UI already has
  const dlg    = document.getElementById('aiResultsDlg');
  const listEl = document.getElementById('aiResultsList');
  const queryEl= document.getElementById('aiResultsQuery');

  // Extract a single suggestion card into a compact record
  function extractCard(el){
    const pick = sel => (el.querySelector(sel)?.textContent || '').trim();
    const slug = el.dataset.slug || el.getAttribute('data-slug') || '';
    const id   = el.dataset.id   || el.getAttribute('data-id')   || '';
    const label= pick('.label') || el.getAttribute('data-label') || '';
    const use  = pick('.use')   || el.getAttribute('data-use')   || '';
    const defT = (el.querySelector('.def .full:not([hidden])')?.textContent
                  || el.querySelector('.def')?.textContent || '').trim();
    const conf = parseFloat(el.dataset.confidence || el.getAttribute('data-confidence') || '') || null;
    return { slug: slug || id || null, label, use, def: defT, confidence: conf };
  }

  // Read the current results grid into a list
  function snapshot(){
    if (!listEl) return [];
    return Array.from(listEl.querySelectorAll('.result'))
      .map(extractCard)
      .filter(it => it.label || it.slug || it.use);
  }

  // Persist the current suggestions + context
  function persistNow(reason){
    const items = snapshot();
    const q     = (queryEl?.textContent || '').trim();
    if (!items.length && !q) return;

    const s = (pb.ai && typeof pb.ai.getSettings === 'function') ? pb.ai.getSettings() : {};
    pb.ai.handoff.save({
      v: 1,
      from: 'index',
      ts: Date.now(),
      query: q || (window.pb && window.pb.qCache && window.pb.qCache.raw) || '',
      provider: s.provider || null,
      model: s.model || s.geminiModel || null,
      items
    });

    try{
      window.dispatchEvent(new CustomEvent('pb:ai-handoff:saved', {
        detail: { reason, count: items.length }
      }));
    }catch(_){}
  }

  // 1) Persist whenever the results list is populated/changed
  if (listEl){
    new MutationObserver(muts=>{
      for (const m of muts){
        if (m.type === 'childList' && (m.addedNodes.length || m.removedNodes.length)){
          persistNow('mutated');
          break;
        }
      }
    }).observe(listEl, { childList: true, subtree: false });
  }

  // 2) Record the user’s pick before navigation
  document.addEventListener('click', ev=>{
    const card = ev.target.closest?.('.ai-results .result, #aiResultsList .result');
    if (!card) return;
    const rec = extractCard(card);
    if (rec.slug || rec.label){
      pb.ai.handoff.setPicked(rec.slug || null);
      // also ensure the latest list is saved (covers last-second updates)
      persistNow('picked');
    }
  }, true);

  // 3) First-time save when the dialog opens (if your code toggles the "open" attr)
  if (dlg){
    new MutationObserver(()=>{
      if (dlg.open) persistNow('dialog-open');
    }).observe(dlg, { attributes: true, attributeFilter: ['open'] });
  }

  // Public helper so ANY page can read the handoff without importing all of pb.*
  window.PBAIHandoff = {
    load:         () => pb.ai.handoff.load(),
    clear:        () => pb.ai.handoff.clear(),
    getCandidates:() => (pb.ai.handoff.load() || {}).items || [],
    getPicked:    () => (pb.ai.handoff.load() || {}).pickedSlug || null
  };
})();
</script>

<script>
/* Read & render AI handoff suggestions on this page */
(function(){
  const handoff = (window.PBAIHandoff && window.PBAIHandoff.load && window.PBAIHandoff.load()) || null;
  if (!handoff || !handoff.items || !handoff.items.length) return;

  // Example: mount quick “switch suggestion” chips if you have a slot
  const mount = document.getElementById('ai-suggestions'); // create a div with this id where you want chips
  if (!mount) return;

  const chips = handoff.items.map(it=>{
    const slug = it.slug ? encodeURIComponent(it.slug) : '';
    const label = it.label || it.use || '(untitled)';
    // Point to your page with ?slug=
    return `<a class="chip" href="./startup-wizard.html?slug=${slug}" title="${(it.use || label).replace(/"/g,'&quot;')}">${label}</a>`;
  }).join(' ');

  mount.innerHTML = `
    <div class="pb-aiswitch" style="display:flex;flex-wrap:wrap;gap:8px;">
      ${chips}
    </div>
  `;
})();
</script>

<!-- Wire the header button to the modal (keeps aisettings.js untouched) -->
<script>
  window.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('aiSettingsBtn');
    if (btn && window.AISettings && typeof AISettings.open === 'function') {
      btn.addEventListener('click', () => AISettings.open());
    }
  });
</script>

  
</body>
</html>
