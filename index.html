<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Prompt Builder — start</title>
  <meta name="color-scheme" content="light only">
  <style>
    :root{
      --bg:#fafafa; --fg:#0f1720; --muted:#506070; --chip:#f3f6fa; --border:#e3e9f2;
      --accent:#1e293b; --radius:16px; --shadow:0 12px 40px rgba(0,0,0,.08); --focus-ring:#0284C7;


      /* layout */
      --wrap-w: 1120px;
      --header-h: 60px; /* result header height */

      /* HERO slot timing + spacing */
      --slot-slide:520ms;       /* slide duration per word */
      --slot-hold:680ms;        /* dwell time per word */
      --slot-pad:0.3ch;         /* left/right padding inside slot */
      --slot-width:16ch;        /* will be overwritten by JS to “widest word” */
      --slot-gap-r: .90ch; /* ← tune this: .32ch (tighter) … .48ch (roomier) */
    }
    

/* Make wrappers and the search row respect the viewport width */
html.is-mobile .wrap,
html.is-mobile .searchWrap,
html.is-mobile .search,
html.is-mobile .searchRow { 
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
}

/* The search input itself (your #q) – full bleed with safe padding */
html.is-mobile #q {
  display:block;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  min-height: 48px;
  padding: 12px 16px;
  border-radius: 16px; /* or var(--radius-md) if defined */
}

/* Kill any overflow from fixed pixel widths in siblings */
html.is-mobile img, 
html.is-mobile video { max-width: 100%; height: auto; }

/* Avoid 100vw traps (where body padding causes sideways scroll) */
html.is-mobile [style*="width:100vw"] { width: 100% !important; }

/* =========================
   Mobile overflow guardrails (desktop-safe)
   ========================= */

/* 2.1 Clamp common containers to the viewport width */
@media (max-width: 720px){
  html.is-mobile .wrap,
  html.is-mobile .searchWrap,
  html.is-mobile .search,
  html.is-mobile .searchRow {
    max-width: 100%;
    box-sizing: border-box;
  }

  /* Search input should never be wider than the viewport */
  html.is-mobile #q{
    display:block;
    width:100%;
    max-width:100%;
    box-sizing:border-box;
    min-height:48px;
    padding:12px 16px;
    border-radius:16px; /* or var(--radius-md) */
  }

  /* 2.2 Make long content scrollable inside its own box instead of the whole page */
  html.is-mobile pre,
  html.is-mobile code,
  html.is-mobile .code,
  html.is-mobile table {
    max-width:100%;
    overflow-x:auto;
    -webkit-overflow-scrolling:touch;
  }

  /* 2.3 Let really long words/URLs wrap instead of expanding the layout */
  html.is-mobile .title,
  html.is-mobile .hint,
  html.is-mobile .card-title,
  html.is-mobile .card .title,
  html.is-mobile .desc,
  html.is-mobile .copy {
    overflow-wrap:anywhere; /* modern */
    word-break:break-word;  /* fallback */
  }

  /* 2.4 Media should shrink to fit */
  html.is-mobile img,
  html.is-mobile video,
  html.is-mobile svg {
    max-width:100%;
    height:auto;
  }

  /* 2.5 Fix 100vw traps: replace with 100% on mobile */
  html.is-mobile [style*="width:100vw"],
  html.is-mobile .full-bleed,
  html.is-mobile .edge-to-edge {
    width:100% !important;
    max-width:100% !important;
  }

  /* 2.6 Quick search buttons: compact and non-overflowing */
  html.is-mobile .searchCtas{
    display:grid;
    grid-template-columns:repeat(3, minmax(0,1fr)); /* minmax(0) prevents overflow */
    gap:8px;
    margin-top:10px;
  }
  html.is-mobile .searchCtas .btn{
    min-height:40px; padding:8px 10px; font-size:14px; line-height:1.2;
    border-radius:12px;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  }

  /* 2.7 If you use a horizontal chip rail, make that area scroll, not the page */
  html.is-mobile .chip-rail {
    display:flex; gap:8px;
    overflow-x:auto; -webkit-overflow-scrolling:touch;
  }

  /* 2.8 Neutralize any accidental horizontal transforms that can push width */
  html.is-mobile .searchWrap [style*="translateX"],
  html.is-mobile .searchWrap [style*="left:"],
  html.is-mobile .searchWrap [style*="right:"]{
    /* Only neutralize if you see a culprit; uncomment if needed */
    /* transform:none !important; left:auto !important; right:auto !important; */
  }
}

/* ===== Mobile-only details header tweaks (safe for desktop) ===== */
html.is-mobile .resultHeader .bar{
  position: relative; /* anchor the menu dropdown */
  gap: 8px;
}

/* Back button: show only the arrow on mobile, keep label for SR */
html.is-mobile #back.backBtn{
  min-width: 40px; min-height: 40px;
  padding: 6px 8px; border-radius: 12px;
  display: inline-flex; align-items: center; justify-content: center; gap: 8px;
}
html.is-mobile #back.backBtn .label{
  position:absolute; width:1px; height:1px; margin:-1px; overflow:hidden;
  clip:rect(0,0,0,0); white-space:nowrap; border:0; /* visually hidden */
}
html.is-mobile #back.backBtn .icon{
  font-size: 18px; line-height: 1;
}

/* Hide the inline CTAs on mobile; hamburger will expose them */


/* Show hamburger on mobile, keep desktop unchanged */
html.is-mobile #resultMenuBtn.menuBtn{
  display: inline-flex;        /* ← make sure this line exists */
  margin-left: auto;
  min-width: 40px; 
  min-height: 40px;
  align-items:center; 
  justify-content:center;
  border-radius:12px;
}

/* If the viewport is wide, never show the hamburger */
@media (min-width: 921px){
  #resultMenuBtn.menuBtn { display: none !important; }
}

/* The mobile dropdown menu */
html.is-mobile #resultMenu.resultMenu{
  position: absolute;
  right: 12px;
  top: calc(100% + 8px);
  background: #fff;
  border: 1px solid var(--border);
  border-radius: 12px;
  box-shadow: 0 18px 44px rgba(0,0,0,.18);
  padding: 6px;
  z-index: 3000;
  min-width: 200px;
}
html.is-mobile #resultMenu.resultMenu [role="menuitem"]{
  display: block; width: 100%; text-align:left;
  padding: 10px 12px; border-radius: 10px;
}
html.is-mobile #resultMenu.resultMenu [role="menuitem"]:focus-visible{
  outline: 2px solid var(--focus-ring, #0284C7);
  outline-offset: 1px;
}





    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font:16px/1.5 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    }

    :focus-visible{ outline:2px solid var(--focus-ring, #0284C7); outline-offset:2px }

    /* --- rainbow glimmer from top-left --- */
    body::before{
      content:"";
      position:fixed; inset:auto auto 40% 0; width:min(70vw,920px); height:min(70vh,680px);
      pointer-events:none; z-index:-1; filter: blur(48px) saturate(115%);
      background:
        radial-gradient(120% 120% at 0% 0%, rgba(255,255,255,.85) 0 36%, transparent 52%),
        conic-gradient(
          from 210deg at 0% 0%,
          rgba(255,0,122,.22), rgba(255,141,0,.18),
          rgba(255,214,0,.18), rgba(0,220,130,.20),
          rgba(0,210,255,.18), rgba(120,80,255,.22), rgba(255,0,122,.22)
        );
      opacity:.28;
      animation: glimmer 14s linear infinite;
      mask-image: radial-gradient(100% 100% at 0 0, #000 40%, transparent 80%);
    }
    @keyframes glimmer{
      0%{ transform: translate3d(0,0,0) rotate(0deg); }
      50%{ transform: translate3d(2%, -2%, 0) rotate(3deg); }
      100%{ transform: translate3d(0,0,0) rotate(0deg); }
    }

    .wrap{ max-width:var(--wrap-w); margin:0 auto; padding:72px 20px 40px; display:grid; gap:24px; }

    /* ====== RESULT HEADER (for details view) ====== */
    .resultHeader[hidden]{ display:none }
    .resultHeader{
      position:sticky; top:0; z-index:120;
      backdrop-filter: blur(10px) saturate(115%);
      background:rgba(255,255,255,.82);
      border-bottom:1px solid var(--border);
    }
    .resultHeader .bar{
      max-width:var(--wrap-w); margin:0 auto; padding:10px 16px; display:flex; align-items:center; gap:12px;
    }
    .resultHeader .spacer{ flex:1 }
    .resultHeader .ctas{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    /* Always hide inline header CTAs; actions live under mini bar + mobile hamburger */
.resultHeader .ctas{ display:none !important; }
    .resultHeader .rainbowLine{ height:3px; width:100%;
      background:linear-gradient(90deg,#ff007a,#ff8d00,#ffd600,#00dc82,#00d2ff,#7850ff,#ff007a);
      filter:saturate(115%); opacity:.85;
    }

    /* Buttons */
    .btn{ display:inline-flex; align-items:center; justify-content:center; gap:.5ch; cursor:pointer;
      border-radius:999px; padding:9px 14px; font-weight:600; text-decoration:none; text-transform:lowercase; user-select:none;
      transition: transform .06s ease, box-shadow .12s ease, background-color .12s ease, color .12s ease;
    }
    .btn:active{ transform:translateY(1px) }
    .btn.primary{ background:var(--fg); color:#fff; border:1px solid transparent; box-shadow:0 6px 16px rgba(15,23,32,.15); }
    .btn.secondary{ background:#fff; color:var(--fg); border:1px solid var(--border); }
    .btn.tertiary{ background:#fff; color:var(--muted); border:1px dashed var(--border); }
    .btn.link{ background:transparent; border:none; color:var(--fg); padding:6px 8px; }

    /* ----- hero ----- */
    .hero{ display:flex; flex-direction:column; align-items:center; text-align:center; gap:18px; padding:48px 16px 12px; }
    .heroTitle{ margin:0; font-weight:600; letter-spacing:.3px; text-transform:lowercase; font-size: clamp(28px, 5.8vw, 56px); line-height:1.15; }

    /* Slot (animated words) */
    .slot{ display:inline-flex; position:relative; align-items:center; justify-content:center; height:var(--slot-h, 1.25em); line-height:1; vertical-align:-0.01em; width:var(--slot-width); padding:0 var(--slot-pad); overflow:hidden; }
    .slot::after{ content:""; position:absolute; left:var(--slot-pad); right:var(--slot-pad); bottom:-0.07em; height:2px; border-radius:2px; background: linear-gradient(90deg, rgba(15,23,32,.10), rgba(15,23,32,.26), rgba(15,23,32,.10)); opacity:.38; pointer-events:none; }
    .reel{ height:var(--slot-h, 1.25em); width:calc(100%); margin-left:-20px; overflow:hidden; mask-image:linear-gradient(to bottom, transparent 0%, #000 10%, #000 90%, transparent 100%); -webkit-mask-image:linear-gradient(to bottom, transparent 0%, #000 10%, #000 90%, transparent 100%); }
    .slot.final .reel{ mask-image:none; -webkit-mask-image:none; }
    .reelList{ display:flex; flex-direction:column; transform:translate3d(0,0,0); transition:transform var(--slot-slide) cubic-bezier(.2,.9,.2,1); will-change:transform; }
    .reelList .w{ display:block; line-height:var(--slot-h, 1.25em); text-align:center; white-space:nowrap; }
    @keyframes slotBounce{ 0%{ transform:scale(1) } 38%{ transform:scale(1.035) } 72%{ transform:scale(1) } 88%{ transform:scale(1.015) } 100%{ transform:scale(1) } }
    .slot.final{ animation: slotBounce .55s ease-out 1; }
    
    
    
    /* ===== MANTRA REEL (below quickLinks) ===== */
.mantra{
  margin: clamp(36px, 6vh, 80px) auto 0;
  max-width: var(--wrap-w);
  padding: 0 20px;
  text-align: center;
}
.mantraLine{
  --mantra-shift-x: 0px;      /* ← tweak horizontal nudge; positive = right */
  display: inline-flex;
  align-items: baseline;
  gap: .6ch;
  transform: translateX(var(--mantra-shift-x));
  font-weight: 300;
  letter-spacing: .3px;
  text-transform: lowercase;
  font-size: clamp(26px, 5.2vw, 54px);
  line-height: 1.16;
}

/* make the words hug a bit more */
#mantra .mantraLine{ gap:.1ch; }  /* try .2ch → .1ch */

/* tighten left/right padding inside the scrolling slot */
#mantra #mantraSlot{ --slot-pad:.12ch; }  /* try .12ch → 0 */

.mantraLine .prefix{ opacity: .85; }

.mantraSlot{
  display:inline-flex; position:relative; align-items:center; justify-content:center;
  height: var(--mantra-slot-h, 1.2em); vertical-align: -0.03em;
  width: var(--mantra-slot-w, 30ch);     /* JS will adjust to widest phrase */
  padding: 0 var(--slot-pad, .3ch);
  overflow:hidden;
}
.mantraReel{
  height: var(--mantra-slot-h, 1.2em); width: 100%;
  overflow:hidden;
  mask-image: linear-gradient(to bottom, transparent 0%, #000 12%, #000 88%, transparent 100%);
  -webkit-mask-image: linear-gradient(to bottom, transparent 0%, #000 12%, #000 88%, transparent 100%);
}
.mantraList{
  display:flex; flex-direction:column;
  transform: translate3d(0,0,0);
  transition: transform var(--mantra-slide, 900ms) cubic-bezier(.2,.9,.2,1);
  will-change: transform;
}
.mantraList .w{
  display:block; white-space:nowrap; text-align:center;
  line-height: var(--mantra-slot-h, 1.2em);
}

/* keep it visually consistent on small screens */
@media (max-width: 520px){
  .mantraLine{ font-size: clamp(22px, 6vw, 34px); }
  .mantraSlot{ width: var(--mantra-slot-w, 24ch); }
}

    /* ----- search ----- */
    .searchWrap{ width:min(780px, 100%); margin: 6px auto 0; position:relative; transform-origin: center; animation: popIn .56s cubic-bezier(.2, .9, .2, 1.2) both; }
    /* keep the suggestions above anything below the search */
.searchWrap{ z-index: 10; }
    @keyframes popIn{ 0%{ transform: scale(.88); opacity:0 } 60%{ transform: scale(1.03); opacity:1 } 100%{ transform: scale(1) } }
    .search{ width:100%; display:flex; align-items:center; gap:8px; padding:8px; border-radius:999px; position:relative; background: #fff; border:2px solid transparent; background-image: linear-gradient(#fff,#fff), conic-gradient(from 90deg, #ff007a, #ff8d00, #ffd600, #00dc82, #00d2ff, #7850ff, #ff007a); background-origin: border-box; background-clip: padding-box, border-box; box-shadow: var(--shadow); }
    .search input{ flex:1; font:16px/1.2 inherit; border:none; outline:none; padding:12px 14px; background:transparent; color:var(--fg); }
    .search button{ border:none; border-radius:999px; padding:10px 14px; cursor:pointer; font-weight:600; background: var(--fg); color:#fff; text-transform:lowercase; }

/* subtle rainbow glow behind the search bar */
.search{ position:relative } /* reinforce positioning */
.search::before{
  content:""; position:absolute; inset:-10px; border-radius:999px; z-index:-1;
  filter: blur(22px) saturate(120%);
  background: conic-gradient(from 200deg, #ff007a, #ff8d00, #ffd600, #00dc82, #00d2ff, #7850ff, #ff007a);
  opacity:.16;
}

.searchCtas{
  display:flex; justify-content:center; gap:8px; flex-wrap:wrap; margin-top:10px;
}
@media (max-width:480px){
  .searchCtas .btn{ padding:8px 12px }
}


/* ===== Mini redo search (details header area) ===== */
.detailSearchWrap{
  position: relative;
  max-width: var(--wrap-w);
  margin: 12px auto 12px;   /* equal top/bottom spacing */
  padding: 0 2px;
  z-index: 40;
}

@media (max-width: 720px){
  .detailSearchWrap{ margin: 10px auto 10px; }
}

/* Mini search: rainbow border, soft glow, micro-motion */
.detailSearch{
  position: relative;                           /* anchors the glow */
  display:flex; align-items:center; gap:8px;
  border-radius: 999px; padding:6px;
  background: #fff;
  border: 2px solid transparent;                /* gradient border like .search */
  background-image:
    linear-gradient(#fff, #fff),
    conic-gradient(from 200deg, #ff007a, #ff8d00, #ffd600, #00dc82, #00d2ff, #7850ff, #ff007a);
  background-origin: border-box;
  background-clip: padding-box, border-box;
  box-shadow: var(--shadow);
  transition: transform .08s ease, box-shadow .18s ease, filter .18s ease;
}

/* subtle rainbow glow behind (same idea as .search::before) */
.detailSearch::before{
  content:"";
  position:absolute; inset:-10px; border-radius:999px; z-index:-1;
  filter: blur(20px) saturate(118%);
  background: conic-gradient(from 200deg, #ff007a, #ff8d00, #ffd600, #00dc82, #00d2ff, #7850ff, #ff007a);
  opacity:.14;
  transition: opacity .18s ease, filter .18s ease;
}

/* hover/focus lift */
.detailSearch:hover,
.detailSearch:focus-within{
  transform: translateY(-1px);
  box-shadow: 0 16px 32px rgba(0,0,0,.12), 0 4px 10px rgba(0,0,0,.10);
}
.detailSearch:hover::before,
.detailSearch:focus-within::before{
  opacity:.20;
  filter: blur(22px) saturate(125%);
}



.detailSearch input{
  flex:1; border:none; outline:none; padding:10px 12px;
  background:transparent; color:var(--fg); min-height:40px;
}
.detailSearch button{
  border:none; border-radius:999px; padding:8px 12px;
  font-weight:600; text-transform:lowercase; cursor:pointer;
}

/* mini input/button polish */
.detailSearch input{
  flex:1; border:none; outline:none; padding:10px 12px;
  background:transparent; color:var(--fg); min-height:40px;
}

/* buttons: small lift & clarity */
.detailSearch button{
  border:none; border-radius:999px; padding:8px 12px;
  font-weight:600; text-transform:lowercase; cursor:pointer;
  transition: transform .06s ease, box-shadow .18s ease, background-color .12s ease, color .12s ease;
}
.detailSearch button:hover{ transform: translateY(-1px); }
.detailSearch button:active{ transform: translateY(0); }

.detailSearch .go{
  background:var(--fg); color:#fff;
  box-shadow: 0 6px 16px rgba(15,23,32,.15);
}
.detailSearch .go:hover{ box-shadow: 0 10px 24px rgba(15,23,32,.18); }

.detailSearch .retry{
  background:#fff; color:var(--muted);
  border:1px dashed var(--border);
}
.detailSearch .retry:hover{
  color:var(--fg);
  border-color: color-mix(in lab, var(--border), var(--fg) 24%);
}


.detailSearch .go{ background:var(--fg); color:#fff; }
.detailSearch .retry{ background:#fff; color:var(--muted); border:1px dashed var(--border); }


/* ===== Centered CTA row under mini redo search ===== */
.detailCtas{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:10px;
  flex-wrap:wrap;
  margin: 8px auto 6px;           /* tight to the mini bar */
  max-width: var(--wrap-w);
  padding: 0 4px;
}

/* visual hierarchy:
   - primary: ask, prompt builder
   - secondary: copy, worksheet
   - tertiary: all templates (lowest prominence) */
.detailCtas .btn{ min-height:40px; padding:8px 12px; }
.detailCtas .btn.primary{ order: 3; }   /* keep primaries toward the right */
.detailCtas .btn.secondary{ order: 2; }
.detailCtas .btn.tertiary{ order: 1; opacity:.92; }

/* mobile: slightly tighter & ensure wrap looks good */
@media (max-width:720px){
  .detailCtas{ gap:8px; margin: 6px auto 6px; }
  .detailCtas .btn{ min-height:38px; padding:8px 10px; font-size:14px; }
}

/* smaller dropdown tied to the mini search */
.ta.ta--mini{
  left:8px; right:8px; top:calc(100% + 6px);
  max-height:220px; z-index: 400;    /* above card content */
}

/* --- rainbow pop-out buttons (like quickLinks) --- */
.searchCtas .btn{
  position:relative;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:.5ch;
  padding:10px 16px;
  border-radius:999px;
  font-weight:600;
  line-height:1;
  background: var(--btn-bg, #fff);
  color: var(--btn-fg, #111);
  border: none; /* anchors will ignore this */
  transform: translateZ(0);
  transition:
    transform .2s ease,
    box-shadow .2s ease,
    background-color .2s ease,
    color .2s ease,
    opacity .2s ease;
  box-shadow: 0 0 0 0 rgba(0,0,0,0);
  isolation:isolate; /* keeps pseudo ring crisp */
}

/* Animated rainbow ring on hover/focus */
.searchCtas .btn::after{
  content:"";
  position:absolute;
  inset:-2px;
  border-radius:inherit;
  padding:2px;
  /* animated conic rainbow */
  --angle: 0deg;
  background:
    conic-gradient(from var(--angle),
      #ff6b6b, #f8e71c, #7ed321, #50e3c2, #4a90e2, #bd10e0, #ff6b6b);
  /* punch out the middle so it looks like a border */
  -webkit-mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity:0;
  transition: opacity .2s ease, filter .2s ease;
  pointer-events:none;
  z-index:-1; /* sits behind button content but above the page */
}

/* subtle shine inside on hover */
.searchCtas .btn::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:inherit;
  background: radial-gradient(120% 120% at 50% -20%, rgba(255,255,255,.16), transparent 60%);
  opacity:0;
  transition: opacity .2s ease;
  pointer-events:none;
}

@keyframes spinRainbow { to { --angle: 360deg; } }

.searchCtas .btn:hover,
.searchCtas .btn:focus-visible{
  transform: translateY(-2px) scale(1.025);
  box-shadow: 0 16px 28px -14px rgba(0,0,0,.35),
              0 4px 10px -6px rgba(0,0,0,.25);
}

.searchCtas .btn:hover::after,
.searchCtas .btn:focus-visible::after{
  opacity:1;
  filter: saturate(1.15);
  animation: spinRainbow 2.25s linear infinite;
}

.searchCtas .btn:hover::before,
.searchCtas .btn:focus-visible::before{
  opacity:1;
}

/* press feedback */
.searchCtas .btn:active{
  transform: translateY(0) scale(.99);
  box-shadow: 0 8px 18px -12px rgba(0,0,0,.35);
}

/* respect reduced motion */
@media (prefers-reduced-motion: reduce){
  .searchCtas .btn,
  .searchCtas .btn::after{
    transition: none;
    animation: none;
  }
}



/* hint under search */
.hint{
  margin-top:10px; font-size:14px; color:var(--muted); opacity:.9; text-align:center;
}

/* quick link cards */
.quickLinks{
  width:min(980px,100%); margin:16px auto 0;
  display:grid; gap:14px;
  grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
}
.tile{
  position:relative; display:block; padding:18px 16px 52px;
  border-radius:20px; background:#fff; color:inherit; text-decoration:none;
  border:1px solid var(--border); box-shadow: var(--shadow); overflow:hidden;
  transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease;
}
.tile:hover{ transform: translateY(-1px) scale(1.02); box-shadow: 0 12px 44px rgba(0,0,0,.10); }
.tile::before{
  content:""; position:absolute; inset:-12px; z-index:-1; border-radius:24px;
  filter: blur(26px) saturate(120%);
  background: conic-gradient(from 200deg, #ff007a, #ff8d00, #ffd600, #00dc82, #00d2ff, #7850ff, #ff007a);
  opacity:.18; transition: opacity .2s ease;
}
.tile:hover::before{ opacity:.28 }
.tile h4{ margin:0 0 6px; font-size:16px; font-weight:700; text-transform:lowercase; letter-spacing:.2px; }
.tile p{ margin:0; font-size:14px; color:var(--muted); }
.tile .cta{
  position:absolute; right:12px; bottom:12px; padding:8px 12px;
  border-radius:999px; border:1px solid var(--border); background:#fff;
  font-weight:600; text-transform:lowercase;
}
.tile:hover .cta{ background:var(--fg); color:#fff; border-color:transparent; }


.quickLinks{ position:relative; z-index:0; }

    /* typeahead */
    .ta{ position:absolute; left:10px; right:10px; top:100%; background:#fff; border:1px solid var(--border); border-radius:14px; margin-top:8px; box-shadow: var(--shadow); max-height:260px; overflow:auto; z-index: 300; /* was 50 */
 }
    .ta[hidden]{ display:none }
    .ta .item{ padding:10px 12px; cursor:pointer; border-bottom:1px solid #f1f5fb; }
    .ta .item:last-child{ border-bottom:none }
    .ta .item:hover, .ta .item.active{ background:#f7fafc }
    .ta .use{ font-size:14px }
    .ta .sub{ font-size:12px; color:var(--muted); display:none }

    /* ----- faux scanning ----- */
    .scan{ position:fixed; inset:0; z-index:1000; display:none; align-items:center; justify-content:center; background:#fff; }
    .scan .roll{ position:relative; width:100vw; height:100vh; overflow:hidden; background:#fff; mask-image: linear-gradient(to bottom, transparent 0%, #000 16%, #000 84%, transparent 100%); -webkit-mask-image: linear-gradient(to bottom, transparent 0%, #000 16%, #000 84%, transparent 100%); }
    .scan ul{ position:absolute; inset:0; list-style:none; margin:0; padding:24px clamp(22px, 6vw, 90px) 24px clamp(34px, 9vw, 140px); display:flex; flex-direction:column; gap:10px; align-items:flex-start; text-align:left; font-family: ui-sans-serif, system-ui, "Helvetica Neue", Arial, sans-serif; font-weight:600; letter-spacing:.2px; text-transform:lowercase; font-stretch: condensed; will-change: transform; }
    .scan li{ font-size: clamp(16px, 2.2vw, 26px); color:#0c1220; opacity:.45; transition:transform .18s ease, opacity .18s ease; max-width: 90vw; }
    .scan li.hit{ color:#000; opacity:1; transform: scale(1.06); text-decoration:underline; text-underline-offset: .12em; will-change: transform; }
    .scan .roll::before, .scan .roll::after{ content:""; position:absolute; top:50%; transform: translateY(-50%); height: 2.2em; width:2px; pointer-events:none; background: linear-gradient(to bottom, rgba(15,23,32,0), rgba(15,23,32,.28) 50%, rgba(15,23,32,0) ); filter: blur(.2px); }
    .scan .roll::before{ left: 16%; }
    .scan .roll::after{ right: 16%; }
    .centerBand{ position:absolute; left:0; right:0; top:50%; transform:translateY(-50%); height:3.0em; pointer-events:none; background: linear-gradient(90deg, rgba(255,0,122,.12), rgba(255,141,0,.10), rgba(255,214,0,.10), rgba(0,220,130,.12), rgba(0,210,255,.12), rgba(120,80,255,.14)); mask-image: linear-gradient(to bottom, transparent 0, #000 18%, #000 82%, transparent 100%); -webkit-mask-image: linear-gradient(to bottom, transparent 0, #000 18%, #000 82%, transparent 100%); filter: saturate(120%); }
    .centerBand::after{ content:""; position:absolute; inset:0; background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,.55), rgba(255,255,255,0)); mix-blend-mode: overlay; animation: centerSweep 2600ms ease-in-out infinite alternate; }
    @keyframes centerSweep{ 0%{ transform: translateX(-10%) } 100%{ transform: translateX(10%) } }
    .scan::before{ content:""; position:fixed; inset:auto auto 0 0; width:min(90vw,1200px); height:min(70vh,780px); pointer-events:none; opacity:.18; filter: blur(36px) saturate(125%); background: radial-gradient(110% 110% at 0% 0%, rgba(255,255,255,.85) 0 36%, transparent 52%), conic-gradient( from 210deg at 0% 0%, rgba(255,0,122,.22), rgba(255,141,0,.18), rgba(255,214,0,.18), rgba(0,220,130,.20), rgba(0,210,255,.18), rgba(120,80,255,.22), rgba(255,0,122,.22) ); animation: scanGlimmer 16s linear infinite; }
    @keyframes scanGlimmer{ 0%{ transform: translate3d(0,0,0) rotate(0deg) } 50%{ transform: translate3d(2%,-1.5%,0) rotate(3deg) } 100%{ transform: translate3d(0,0,0) rotate(0deg) } }

    /* ----- details card ----- */
    .details[hidden]{ display:none }
    .details{ position:relative; }
    .details::before{ content:""; position:fixed; inset:auto -15vw 8% -15vw; height:52vh; background: conic-gradient(from 220deg, rgba(255,0,122,.10), rgba(255,141,0,.08), rgba(255,214,0,.08), rgba(0,220,130,.10), rgba(0,210,255,.10), rgba(120,80,255,.12), rgba(255,0,122,.10)); filter: blur(70px) saturate(115%); opacity:.32; pointer-events:none; z-index:-1; }

    .card{ display:grid; grid-template-columns: 1.3fr .9fr; gap:28px; align-items:flex-start; border:1px solid var(--border); border-radius:24px; background:#fff; box-shadow: var(--shadow); padding:24px; }
    @media (max-width: 900px){ .card{ grid-template-columns: 1fr; } }

    .left h2{ margin:4px 0 6px; text-transform:lowercase; font-size: clamp(24px, 3.4vw, 34px); letter-spacing:.2px; }
    .meta{ display:flex; flex-wrap:wrap; gap:10px; margin:10px 0 16px; }
    .chip{ padding:6px 10px; border-radius:999px; border:1px solid var(--border); background:var(--chip); font-size:12px }

    .block + .block{ margin-top:18px }
    .block h3{ margin:.4rem 0 .4rem; font-size:14px; letter-spacing:.12px; color:#101828; text-transform:lowercase; }
    .uc, .booster{ background:#f8fbff; border:1px dashed #e6eef8; padding:10px 12px; border-radius:12px; font-size:13px; }

    .fields .row + .row{ margin-top:10px }
    .row label{ display:block; font-size:12px; color:var(--muted); margin-bottom:4px; text-transform:lowercase }
    .row .fake{ width:100%; padding:12px 14px; border-radius:12px; border:1px dashed var(--border); background:#f9fafb; color:#0f1720; font-size:14px; }

    /* Right column stickiness for taller screens */
    @media (min-width: 901px){ .right{ position:sticky; top: calc(var(--header-h) + 18px); } }

    /* Footer actions inside card */
    .actions.footer{ display:flex; flex-wrap:wrap; gap:10px; margin-top:18px }
    .divider{ height:1px; background:linear-gradient(90deg, transparent, #e7edf6, transparent); margin:8px 0 4px }
  
  
  /* Desktop/default: hide the hamburger unless we explicitly show it on mobile */
#resultMenuBtn.menuBtn { display: none; }




/* === COPY DIALOG (Slice 1a–1i final) — canonical skin, desktop-safe === */
/* Backdrop: simple dim — no blur */
#actionModal::backdrop {
  background: rgba(0,0,0,.45);
}

/* Centered card */
#actionModal {
  /* native dialog defaults removed */
  padding: 0;
  border: 1px solid var(--border);
  border-radius: 18px;
  background: var(--bg, #fff);
  color: var(--fg, #0f1720);
  box-shadow: var(--shadow);
  width: min(880px, 92vw);
  max-height: 90vh;
  margin: 8vh auto;
  overflow: visible; /* inner grid controls scroll */
}

/* 3-row card: header / body / footer */
#actionForm.modal-body {
  display: grid;
  grid-template-rows: auto 1fr auto;
  border-radius: inherit;
  overflow: hidden; /* keeps hairlines crisp */
}

/* Header: title left, × right (inline, not stacked) */
#actionModal .modal-header {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 14px 16px;
  border-bottom: 1px solid var(--border);
}
#actionModal .modal-header h3 {
  margin: 0;
  font: 600 1.05rem/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  text-transform: lowercase;
  letter-spacing: .2px;
}
#actionModal .modal-header .icon.close {
  margin-left: auto;
  inline-size: 34px;
  block-size: 34px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: transparent;
  color: inherit;
  cursor: pointer;
}
#actionModal .modal-header .icon.close:hover {
  background: rgba(0,0,0,.06);
}
#actionModal .modal-header .icon.close:focus-visible {
  outline: 2px solid var(--focus-ring);
  outline-offset: 2px;
}

/* Body: tidy spacing + full-width preview */
#actionModal .modal-section {
  padding: 16px;
  display: grid;
  gap: 10px;
}
#actionModal .modal-section .field label {
  display: block;
  margin-bottom: 6px;
  font-size: 12px;
  color: var(--muted);
  text-transform: lowercase;
}
#actionPreview {
  width: 100%;
  min-height: min(54vh, 520px);
  resize: vertical;
  padding: 12px;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: #f9fafb;
  color: inherit;
  font: 500 0.94rem/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  tab-size: 2;
}
#actionPreview:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(2,132,199,.18) inset; /* matches site focus ring */
}

/* Inline note under preview (length warnings, copied msg, etc.) */
#actionNote.note {
  margin: 8px 2px 0;
  font-size: 12.5px;
  color: var(--muted);
}

/* Footer: right-aligned actions, re-using your .btn look */
#actionModal .modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  padding: 12px 16px 14px;
  border-top: 1px solid var(--border);
}

/* Buttons inherit your global .btn styles; keep overrides minimal and scoped */
#actionModal .btn {
  text-decoration: none;                  /* never show underlines in the dialog */
  border-radius: 10px;                    /* match header close’s radius */
}
#actionModal .btn:hover { background: rgba(0,0,0,.06); }
#actionModal .btn:focus-visible { outline: 2px solid var(--focus-ring); outline-offset: 2px; }
#actionModal .btn.primary {
  /* rely on your existing .btn.primary colors; only small nudge */
  filter: saturate(1.02);
}


/* === Slice 4C: Details CTAs — cluster centered, one line (final) === */
/* Goal: three columns sized to content (left group | builder | right group),
   the entire cluster centered under the mini search, on a single baseline. */

.detailCtas{
  /* hard override the older flex/full-width row */
  display: grid !important;
  grid-auto-flow: column;
  grid-template-columns: auto auto auto;   /* content-sized columns */
  column-gap: 12px;
  align-items: center;                      /* same baseline */
  justify-content: center;                  /* center the 3 columns as a cluster */

  /* shrink to fit its contents and center under the mini search */
  width: fit-content;
  max-width: none;                          /* neutralize earlier max-width */
  margin: 8px auto 6px;                     /* center horizontally */
  padding: 0;                               /* no extra padding from old rules */
  white-space: nowrap;                      /* keep one line on desktop */
}

/* left/right groups are small inline rows */
.detailCtas .ctaGroup{
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

/* explicit column placement (DOM order already matches) */
.detailCtas .ctaGroup.left  { grid-column: 1; justify-content: flex-end; }
.detailCtas #openBuilder     { grid-column: 2; justify-self: center; }
.detailCtas .ctaGroup.right { grid-column: 3; justify-content: flex-start; }

/* unify button visuals in this row (only Builder stays primary) */
.detailCtas .btn{
  text-decoration: none;
  border-radius: 999px;
  transition: transform .06s ease, box-shadow .18s ease, background-color .12s ease, color .12s ease;
}
.detailCtas .btn.secondary{
  background:#fff; color:var(--fg); border:1px solid var(--border); box-shadow:none;
}
.detailCtas .btn.tertiary{ border-style: solid; color: var(--fg); }

/* Builder is the only primary */
.detailCtas #openBuilder.btn.primary{
  background: var(--fg); color:#fff; border-color: transparent;
  box-shadow: 0 6px 16px rgba(15,23,32,.15);
}

/* hover “bump” and focus clarity, scoped to this row */
.detailCtas .btn:hover{
  transform: translateY(-1px);
  box-shadow: 0 10px 24px rgba(15,23,32,.12);
}
.detailCtas .btn:active{ transform: translateY(0); }
.detailCtas .btn:focus-visible{ outline: 2px solid var(--focus-ring); outline-offset: 2px; }

/* Mobile: stack to 3 centered rows (left group, builder, right group) */
@media (max-width: 720px){
  .detailCtas{
    grid-template-columns: 1fr;       /* single column */
    grid-auto-flow: row;
    row-gap: 8px;
    width: 100%;                      /* allow full width on small screens */
    white-space: normal;              /* permit wrapping on narrow devices */
    justify-content: center;
    justify-items: center;
  }
  .detailCtas .ctaGroup.left,
  .detailCtas .ctaGroup.right{
    justify-content: center;
    flex-wrap: wrap;
  }
  .detailCtas #openBuilder{ justify-self: center; }
  .detailCtas .btn{ min-height:38px; padding:8px 10px; font-size:14px; }
}


/* Mobile polish */
@media (max-width: 720px){
  #actionModal {
    width: min(520px, 92vw);
    margin: 6vh auto;
    border-radius: 16px;
  }
  #actionPreview { min-height: 220px; }
  #actionModal .modal-footer { flex-wrap: wrap; gap: 8px; }
}

/* Motion safety */
@media (prefers-reduced-motion: reduce){
  #actionModal { transition: none; }
}








  
  
  /* =========================
   SLICE 1 — Mobile Layout Skeleton
   ========================= */
   
   /* === MOBILE HEADER MENU (Slice 4) — scoped & desktop-safe === */

/* Make the header bar a positioned anchor so the menu can be absolutely placed */
.resultHeader .bar { position: relative; }

/* Desktop: we already hide the hamburger. On mobile, show it. */
@media (max-width: 720px){
  html.is-mobile #resultMenuBtn.menuBtn{
    display: inline-flex;
    align-items: center; justify-content: center;
  }
  /* Hide the desktop CTAs row on mobile; the menu replaces it */
  html.is-mobile #resultHeader .ctas{ display: none; }
}

/* Menu panel */
#resultHeader .resultMenu[hidden]{ display:none !important; }
#resultHeader .resultMenu{
  position: absolute;
  right: 12px;
  top: calc(100% + 8px);             /* just below the header bar */
  min-width: 220px;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 12px;
  box-shadow: var(--shadow);
  padding: 6px;
  z-index: 3000;
}

/* Menu items */
#resultHeader .resultMenu .menuItem{
  display: block;
  width: 100%;
  text-align: left;
  border: 0;
  background: transparent;
  color: inherit;
  padding: 10px 10px;
  border-radius: 10px;
  cursor: pointer;
  -webkit-appearance: none; appearance: none;
  text-decoration: none;           /* anchors look like buttons */
}
#resultHeader .resultMenu .menuItem:hover{ background: rgba(0,0,0,.06); }
#resultHeader .resultMenu .menuItem:focus-visible{
  outline: 2px solid var(--focus-ring); outline-offset: 2px;
}
#resultHeader .resultMenu .menuItem[aria-disabled="true"]{
  opacity: .45; cursor: default; pointer-events: none;
}
   

/* a) Skip link: visible when tabbed, hidden visually otherwise */
.skip-link{
  position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden;
}
.skip-link:focus{
  position:fixed; left:16px; top:14px; width:auto; height:auto; padding:10px 14px;
  background:#fff; color:var(--fg); border:2px solid var(--focus-ring); border-radius:12px;
  box-shadow: 0 10px 24px rgba(0,0,0,.12);
  z-index: 10000;
}



/* b) Mobile scaffold: search + hint + 3 primary buttons under the hint */

/* Ensure input and button meet 44x44 min touch size */
.search input{ min-height:48px; }
.search button{ min-height:48px; }

/* Make each bar the positioning context */
.search, .detailSearch { position: relative; }

/* Dropdown spans the bar width and sits just below it */
.search > .ta{
  left: 0; right: 0;
  top: calc(100% + 8px);
  margin-top: 0;          /* override the old margin trick */
  z-index: 300;           /* already above nearby content */
}
.detailSearch > .ta{
  left: 0; right: 0;
  top: calc(100% + 6px);
  margin-top: 0;
  z-index: 400;           /* above the details card */
}



/* Keep overall mobile container padding sane */
@media (max-width:720px){
  .wrap{ padding-left:16px; padding-right:16px; }
}

/* c) Disable hover-only affordances on touch; prefer press/focus states */
@media (hover: none) and (pointer: coarse){
  /* Search CTA buttons: remove hover lift/animation; keep press/focus */
  .searchCtas .btn:hover,
  .searchCtas .btn:hover::before,
  .searchCtas .btn:hover::after{
    transform:none; box-shadow:none; opacity:1; animation:none;
  }
  /* Make press/focus clearly visible */
  .searchCtas .btn:active{
    transform: translateY(0) scale(.99);
    box-shadow: 0 8px 18px -12px rgba(0,0,0,.28);
  }
  .searchCtas .btn:focus-visible{
    outline: none;
    box-shadow: 0 0 0 2px var(--focus-ring) inset, 0 0 0 3px rgba(2,132,199,.15);
  }

  /* Quick-link tiles: kill heavy hover lifts on touch */
  .tile:hover{ transform:none; box-shadow: var(--shadow); }
  .tile:hover::before{ opacity:.18; }
}

/* d) Hint text remains readable and compact on XS screens */
@media (max-width:360px){
  .hint{ font-size:13px; }
}

/* e) Keep the search cluster centered and full-width within its max */
@media (max-width:720px){
  .searchWrap{ width:100%; max-width:780px; }
}

/* Slice 1: mobile spacing rhythm */
@media (max-width: 720px){
  .wrap{ padding-left:16px; padding-right:16px; }
  .search input{ margin-bottom:16px; }
  .hint{ margin-bottom:16px; }
  .searchCtas{ margin-bottom:24px; }
  
  
  /* Details mode: reduce top padding so content sits closer under the sticky header */
body.is-details .wrap{
  padding-top: 14px;   /* was 72px; tweak 10–18px to taste */
}


/* =========================
   SLICE 2 — Mobile Suggestions Overlay (desktop-safe)
   Everything is gated under html.is-mobile
   ========================= */

/* Lock page scroll when overlay is open */
html.is-mobile body.scroll-locked {
  overflow: hidden;
  touch-action: none;
}

/* Dim background */
html.is-mobile .suggestions-scrim {
  position: fixed;
  inset: 0;
  background: rgba(15,23,32,.20);  /* lighter, not opaque, and no blur */
  -webkit-backdrop-filter: none;
  backdrop-filter: none;
  z-index: 2100;
}

/* Keep the search field above the scrim when overlay is open */
html.is-mobile.overlay-open .searchWrap{
  position: relative;
  z-index: 2150; /* above scrim (2100), below overlay (2200) */
}


/* Overlay box that will hold #ta */
html.is-mobile .suggestions-overlay {
  position: fixed; /* JS sets top/left/width/max-height */
  background: var(--surface-1, #fff);
  border-radius: var(--radius, 16px);
  box-shadow: 0 24px 64px rgba(0,0,0,.18);
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 2200;
  max-height: 60vh; /* JS also sets this as a precise value */
}

/* When #ta is inside the overlay, neutralize its desktop absolute layout */
html.is-mobile .suggestions-overlay #ta {
  position: static;
  left: auto; right: auto; top: auto; margin-top: 0;
  max-height: inherit;
  border: none;
  box-shadow: none;
  background: transparent;
}


/* =========================
   MOBILE SHRINK KIT (desktop-safe)
   Tightens sizes, kills sideways scroll, keeps CTAs horizontal & compact
   ========================= */


/* Avoid Safari “bump up” and weird zoom behavior */
html.is-mobile html, 
html.is-mobile body { -webkit-text-size-adjust: 100%; }

/* 1) Global spacing + type on mobile */
@media (max-width: 720px){
  html.is-mobile .wrap{ padding: 40px 16px 24px; }     /* was 72/20/40 */
  html.is-mobile .hero{ padding: 28px 12px 8px; gap: 12px; }
  html.is-mobile .heroTitle{ font-size: clamp(22px, 6.2vw, 32px); } /* smaller hero */
  html.is-mobile .hint{ font-size: 13px; margin-top: 8px; }
}

/* 2) Search: make sure it never exceeds viewport and trim padding */
@media (max-width: 720px){
  html.is-mobile .searchWrap,
  html.is-mobile .search,
  html.is-mobile .searchRow{ width:100%; max-width:100%; box-sizing:border-box; }

  html.is-mobile #q{
    display:block; width:100%; max-width:100%; box-sizing:border-box;
    min-height:48px; padding:10px 12px; border-radius:16px;
    font-size:16px; /* keeps iOS from zooming on focus */
  }
  html.is-mobile .search{ padding:6px; }  /* tighter than desktop’s 8px */
}

/* 3) CTAs: compact, horizontal (single row that can scroll if needed) */
@media (max-width: 720px){
  html.is-mobile .searchCtas{
    display:flex; align-items:stretch; justify-content:center;
    gap:8px; margin-top:10px;
    overflow-x:auto; -webkit-overflow-scrolling:touch;
    padding-bottom: 2px; scroll-snap-type:x proximity;
  }
  html.is-mobile .searchCtas .btn{
    flex:0 0 auto; scroll-snap-align:start;
    min-height:40px; padding:8px 12px; border-radius:12px;
    font-size:14px; line-height:1.2;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  }
}

/* 4) QuickLinks: vertical stack (1 per row) + smaller tiles */
@media (max-width: 720px){
  html.is-mobile .quickLinks{
    display:grid; grid-template-columns:1fr; gap:10px; width:100%;
    margin:12px auto 0;
  }
  html.is-mobile .quickLinks > *{ width:100%; box-sizing:border-box; }
  html.is-mobile .tile{
    padding:14px 12px 44px; border-radius:16px;
    box-shadow: var(--shadow);
    transform:none !important;  /* no hover pop on touch */
  }
  html.is-mobile .tile h4{ font-size:15px; }
  html.is-mobile .tile p{ font-size:13px; }
  html.is-mobile .tile .cta{ padding:6px 10px; }
}

/* 5) Mantra: slightly smaller on tight screens to reduce scroll */
@media (max-width: 520px){
  html.is-mobile .mantra{ margin: clamp(24px, 5vh, 48px) auto 0; padding:0 12px; }
  html.is-mobile .mantraLine{ font-size: clamp(20px, 5.4vw, 30px); }
  html.is-mobile #mantraSlot{ --slot-pad:.12ch; }
}

/* 6) Details view: compress paddings and grid */
@media (max-width: 720px){
  html.is-mobile .resultHeader .bar{ padding:8px 12px; gap:8px; }
  html.is-mobile .card{
    grid-template-columns:1fr !important; gap:16px; padding:16px; border-radius:18px;
  }
  html.is-mobile .left h2{ font-size: clamp(20px, 4.8vw, 26px); }
}

/* 7) Common overflow guards */
@media (max-width: 720px){
  /* Anything trying to be wider than the viewport gets clamped */
  html.is-mobile [style*="width:100vw"],
  html.is-mobile .full-bleed,
  html.is-mobile .edge-to-edge{
    width:100% !important; max-width:100% !important;
  }
  /* Long content scrolls inside itself instead of the page */
  html.is-mobile pre,
  html.is-mobile code,
  html.is-mobile .code,
  html.is-mobile table{
    max-width:100%; overflow-x:auto; -webkit-overflow-scrolling:touch;
  }
  /* Media fits the container */
  html.is-mobile img, html.is-mobile video, html.is-mobile svg{ max-width:100%; height:auto; }
  /* Let long words/URLs wrap */
  html.is-mobile .title,
  html.is-mobile .hint,
  html.is-mobile .card-title,
  html.is-mobile .desc,
  html.is-mobile .copy{
    overflow-wrap:anywhere; word-break:break-word;
  }
}

html.is-mobile .tile{ padding:12px 10px 40px; }
html.is-mobile .tile h4{ font-size:14px; }
html.is-mobile .tile p{ font-size:12.5px; }

html.is-mobile .wrap{ padding-top:28px; }
html.is-mobile .hero{ padding-top:18px; }

/* Mobile: allow the search input to shrink inside the flex row */
@media (max-width: 720px){
  html.is-mobile .search{ min-width: 0; }   /* the container can shrink */
  html.is-mobile .search input{ min-width: 0; } /* the field can shrink */
  html.is-mobile .searchWrap{ padding-left:12px; padding-right:12px; } /* safe gutter */
  html.is-mobile #q{ width:100%; max-width:100%; box-sizing:border-box; }
}

/* Keep hero “slot” and mantra bounded on small screens */
@media (max-width: 720px){
  html.is-mobile .slot,
  html.is-mobile .mantraSlot{
    max-width: 100%;
    overflow: hidden;   /* if a word is mismeasured, it won't push the page */
  }

  /* Long words/URLs wrap instead of expanding layout */
  html.is-mobile .heroTitle,
  html.is-mobile .hint,
  html.is-mobile .tile h4,
  html.is-mobile .tile p{
    overflow-wrap:anywhere;
    word-break:break-word;
  }

  /* Tables/code blocks scroll inside themselves, not the whole page */
  html.is-mobile table,
  html.is-mobile pre,
  html.is-mobile code,
  html.is-mobile .code{
    max-width:100%;
    overflow-x:auto;
    -webkit-overflow-scrolling:touch;
  }
}



  
  </style>
  
  
</head>
<body>
<a class="skip-link" href="#main">skip to content</a>


  <!-- RESULTS HEADER (appears only on the results page) -->
  <header id="resultHeader" class="resultHeader" hidden>
    <div class="bar">
      <button id="back" class="btn link backBtn" type="button" aria-label="Back to search">
  <span class="icon" aria-hidden="true">←</span>
  <span class="label">back to home</span>
</button>
      <div class="spacer"></div>
      <button id="resultMenuBtn" class="btn link menuBtn" type="button"
        aria-label="More options" aria-haspopup="menu" aria-expanded="false">
  <!-- hamburger icon -->
  <svg class="icon" width="24" height="24" viewBox="0 0 24 24" aria-hidden="true">
    <path d="M3 6h18v2H3V6zm0 5h18v2H3v-2zm0 5h18v2H3v-2z"/>
  </svg>
</button>
<div id="resultMenu" class="resultMenu" role="menu" hidden></div>

<nav class="ctas" aria-hidden="true">
  <a class="btn tertiary"  href="#">all templates</a>
  <a class="btn secondary" href="#">worksheet</a>
  <a class="btn primary"   href="#">prompt builder</a>
</nav>
    </div>
    <div class="rainbowLine"></div>
  </header>

  <main id="main" class="wrap">

    <!-- HERO -->
    <section class="hero" id="hero">
      <h1 class="heroTitle">
        start building your 
        <span id="slot" class="slot" aria-live="polite" aria-atomic="true">
          <span id="reel" class="reel">
            <span id="reelList" class="reelList"></span>
          </span>
       </span>  
      </h1>

      <div class="searchWrap">
        <div class="search">
          <input id="q" type="text" placeholder="type what you’re trying to build…" autocomplete="off" />
          <button id="go" type="button" title="Search">search</button>
        </div>
        <div id="ta" class="ta" role="listbox" hidden></div>
        <p class="hint">type what you want to make in everyday words — we’ll shape it into a clear ai prompt.</p>
      </div>
      
      <div class="searchCtas" aria-label="quick search actions">
  <a id="btnAdv" class="btn tertiary" href="./glossary/templates-glossary.html">advanced search</a>
  <!-- You can rename to “where do I start?” later; wiring stays the same -->
  <button id="btnHelp" class="btn secondary" type="button" title="Pick a helper & use-case">help me</button>
  <button id="btnLucky" class="btn secondary" type="button" title="Random use-case from everything">i’m feeling lucky</button>
</div>

      
      <div class="quickLinks">
  <!-- If your full glossary lives on a different page than this index,
       change the href below to that page. -->
  <a class="tile" href="./glossary/index.html" aria-label="open full ai glossary">
    <h4>full ai glossary</h4>
    <p>everyday definitions for ai and prompting — search clear, plain-language terms.</p>
    <br>
    <span class="cta">open glossary</span>
  </a>

  <a class="tile" href="./glossary/templates-glossary.html" aria-label="open template glossary">
    <h4>template glossary</h4>
    <p>browse prompt-making templates with one-line summaries and examples.</p>
    <span class="cta">open templates</span>
  </a>

  <a class="tile" href="./glossary/prompt-builder.html" aria-label="open prompt builder config">
    <h4>prompt builder config</h4>
    <p>power-user controls for building and saving prompts with full options.</p>
    <span class="cta">open builder</span>
  </a>

  <a class="tile" href="./glossary/startup-wizard.html" aria-label="start the setup wizard">
    <h4>startup wizard (alpha)</h4>
    <p>a lighter, guided flow to set things up without the overwhelm.</p>
    <span class="cta">start wizard</span>
  </a>
</div>

<!-- MANTRA REEL -->
<section id="mantra" class="mantra" aria-label="prompting mantras">
  <div class="mantraLine">
    <span id="mantraSlot" class="mantraSlot" aria-live="polite" aria-atomic="true">
      <span id="mantraReel" class="mantraReel">
        <span id="mantraList" class="mantraList"></span>
      </span>
    </span>
  </div>
</section>


    </section>

    <!-- FAUX SCANNING -->
    <section class="scan" id="scan">
      <div class="roll">
        <ul id="rollList"></ul>
      </div>
    </section>

    <!-- DETAILS -->
    <section class="details" id="details" hidden>
    
    <!-- MINI SEARCH (redo) -->
<div class="detailSearchWrap" aria-label="redo search">
  <div class="detailSearch">
    <input id="q2" type="text" placeholder="tweak or redo your search…" autocomplete="off" />
    <button id="go2" class="go" type="button" title="run search">search</button>
    <button id="retry" class="retry" type="button" title="try a different close match">re-roll</button>
  </div>
  <div id="ta2" class="ta ta--mini" role="listbox" hidden></div>

  <!-- DETAILS CTAs (centered row under mini search) -->
<div class="detailCtas" role="group" aria-label="actions">
  <div class="ctaGroup left">
    <a id="openGlossary"   class="btn secondary" href="#">all templates</a>
    <a id="printWorksheet" class="btn secondary" href="#">worksheet</a>
  </div>

  <a id="openBuilder" class="btn primary" href="#">prompt builder</a>

  <div class="ctaGroup right">
    <button id="copyPrompt" class="btn secondary" type="button">copy</button>
    <button id="ask"        class="btn secondary" type="button">ask</button>
  </div>
</div>
    
    
      <div class="card">
        <div class="left">
          <h2 id="tplTitle">template</h2>

          <div class="block">
            <h3>definition</h3>
            <div id="def" class="uc"></div>
          </div>

          <div class="block">
            <h3>use-cases</h3>
            <div id="useCases"></div>
          </div>

          <div class="block" id="boostersBlock" hidden>
            <h3>boosters</h3>
            <div id="boosters"></div>
          </div>
          
          <div class="meta" id="meta"></div>

          <div class="divider"></div>
        

         
        </div>

        <div class="right">
          <div class="block">
            <h3>fields</h3>
            <div class="fields" id="fields"></div>
          </div>
        </div>
      </div>
    </section>
  </main>
  
  
  <!-- Action modal (shared by Copy + Ask) -->
<dialog id="actionModal" class="modal" aria-modal="true">
  <form method="dialog" class="modal-body" id="actionForm" aria-labelledby="actionTitle">
    <header class="modal-header">
      <h3 id="actionTitle">Action</h3>
      <button type="button" class="icon close" aria-label="Close" id="actionClose">×</button>
    </header>

    <section class="modal-section">
      <div class="field">
        <label for="actionPreview">Preview (you can edit before confirming)</label>
        <textarea id="actionPreview" rows="14" spellcheck="false"></textarea>
      </div>
      <p id="actionNote" class="note" hidden></p>
    </section>

    <footer class="modal-footer">
      <button type="submit" class="btn primary" id="actionConfirm">confirm</button>
      <button type="button" class="btn" id="actionCancel">cancel</button>
    </footer>
  </form>
</dialog>

  <!-- datasets -->
  
    <script src="./templates.data.js"></script>
    
     <script>
    // lazy-load tasks dataset
    (function ensureTasksLoaded(){
      if (Array.isArray(window.TEMPLATES)) return;
      const s = document.createElement('script');
      s.src = './glossary/templates.data.js';
      s.onerror = ()=> console.info('tasks dataset not found at ./glossary/templates.data.js');
      document.head.appendChild(s);
    })();
  </script>
  
  <script>
    // lazy-load tasks dataset
    (function ensureTasksLoaded(){
      if (Array.isArray(window.TASK_TEMPLATES)) return;
      const s = document.createElement('script');
      s.src = './glossary/templates.tasks.data.js';
      s.onerror = ()=> console.info('tasks dataset not found at ./glossary/templates.tasks.data.js');
      document.head.appendChild(s);
    })();
  </script>
  
<script>
  // Always bust cache in dev
  const DATA_VERSION = Date.now();

  function injectScript(src){
    const s = document.createElement('script');
    s.src = src + (src.includes('?') ? '&' : '?') + 'v=' + DATA_VERSION;
    s.crossOrigin = 'anonymous';
    document.head.appendChild(s);
    return s;
  }

  // Rebuild the search index any time a dataset arrives
  function rebuild(){ INDEX = buildIndex(); onQuery(); }

  injectScript('./glossary/templates.data.js').onload = rebuild;
  injectScript('./glossary/templates.tasks.data.js').onload = rebuild;
</script>

  <script>
/* ===== HERO: fixed-width slot + vertical reel (anti-clipping) ===== */
(function heroSlot(){
  const words = ['project.', 'life.', 'plan.', 'system.', 'idea.', 'prompt.'];

  const slot = document.getElementById('slot');
  const reel = document.getElementById('reel');
  const list = document.getElementById('reelList');

  list.innerHTML = words.map(w => `<span class="w">${w}</span>`).join('');

  const cs = getComputedStyle(document.documentElement);
  const holdMs  = parseFloat(cs.getPropertyValue('--slot-hold'))  || 680;
  const dpr = window.devicePixelRatio || 1;

  function widestWordPx(){
    const slotEl = document.getElementById('slot');
    const cs = getComputedStyle(slotEl);

    const meas = document.createElement('span');
    meas.style.position = 'absolute';
    meas.style.visibility = 'hidden';
    meas.style.whiteSpace = 'nowrap';
    meas.style.left = '-9999px';
    meas.style.top = '-9999px';

    // copy all width-affecting text styles
    meas.style.font = cs.font;
    meas.style.letterSpacing = cs.letterSpacing;
    meas.style.textTransform = cs.textTransform;
    meas.style.fontKerning = cs.fontKerning;
    meas.style.fontFeatureSettings = cs.fontFeatureSettings;
    meas.style.fontVariationSettings = cs.fontVariationSettings;
    meas.style.fontStretch = cs.fontStretch;

    document.body.appendChild(meas);

    let max = 0;
    for (const w of words){
      meas.textContent = w;
      const wpx = meas.getBoundingClientRect().width;
      if (wpx > max) max = wpx;
    }
    meas.remove();

    return Math.ceil(max + 20); // base guard; DPR fudge added separately
  }

  // Measure and lock the row height + slot width
  let rowH = 0;
  function lockMetrics(){
    // Row height in pixels (use rendered metrics, not ems)
    const first = list.firstElementChild;
    let h = first ? first.getBoundingClientRect().height : 0;
    if (!h){
      // fallback to slot font-size if fonts not ready
      h = parseFloat(getComputedStyle(slot).fontSize) || 32;
    }
    // Add a tiny cushion so mask never touches glyphs
    rowH = Math.ceil(h + 2);
    slot.style.setProperty('--slot-h', rowH + 'px');

    // Lock the slot width to the widest word (prevents horizontal clipping)
    const wpx = widestWordPx();
    // add one physical pixel to dodge subpixel rounding on high-DPI
    const fudge = Math.max(1, Math.round((window.devicePixelRatio || 1)));
    slot.style.setProperty('--slot-width', (wpx + fudge) + 'px');
  }

  function translateToRow(idx){
    // snap to device pixels so we never land on a half pixel under the mask
    const y = Math.round((idx * rowH) * dpr) / dpr;
    list.style.transform = `translate3d(0, ${-y}px, 0)`;
  }

  function run(){
    lockMetrics();
    let i = 0;

    const advance = ()=>{
      if (i < words.length - 1){
        i++;
        translateToRow(i);
        setTimeout(advance, holdMs);
      } else {
        // Landed on "prompt": remove mask and bounce
        slot.classList.add('final');
      }
    };

    // initial dwell so the first word is readable
    setTimeout(advance, holdMs);
  }

  // Wait for fonts so measurements are stable, then run
  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(run);
  } else {
    window.addEventListener('load', run, { once:true });
  }

  // Re-lock on resize or zoom
  window.addEventListener('resize', ()=>{ lockMetrics(); /* keep current row in view */ });
})();


  /* ===== Search + typeahead (same API, updated ranking) ===== */
  function allTemplates(){
    const base  = Array.isArray(window.TEMPLATES) ? window.TEMPLATES
                : Array.isArray(window.FRAMEWORKS) ? window.FRAMEWORKS : [];
    const tasks = Array.isArray(window.TASK_TEMPLATES) ? window.TASK_TEMPLATES
                : Array.isArray(window.tasks) ? window.tasks : [];

    // Preserve everything; just tag the origin so we can prioritize “task” kind
    const mark = (arr, isTask)=> arr.map(t => ({ ...t, __isTask:isTask }));

    return [...mark(base,false), ...mark(tasks,true)].map(t=>{
      const cats = Array.isArray(t.categories) ? t.categories : (t.category ? [t.category] : []);
      return { ...t, categories: cats, use_cases: Array.isArray(t.use_cases)? t.use_cases : [] };
    });
  }

// Replace your buildIndex() with this (adds kind/isTask but keeps existing fields)
  function buildIndex(){
    const src = allTemplates();
    return src.map(t=>{
      const useTags = (t.tags || [])
        .map(String).map(s => s.trim().toLowerCase())
        .filter(s => s.startsWith('use:'))
        .map(s => s.split(':',2)[1])
        .filter(Boolean);

      const uc    = (t.use_cases || []).map(String);
      const kind  = String(t.kind || t.type || '').toLowerCase();
      const isTask = (kind === 'task')
        || /^task[_-]/.test(String(t.id||''))
        || /^task[_-]/.test(String(t.slug||''));

      return {
        id: t.id || t.slug || t.label,
        slug: t.slug || t.id,
        label: t.label || t.name || t.slug || t.id || 'untitled',
        use_cases: uc,
        use_tags: useTags,
        tags: (t.tags || []).slice(),
        categories: t.categories || [],
        boosters: Array.isArray(t.boosters) ? t.boosters.slice() : [],
        definition: t.definition || t.help || '',
        fields: Array.isArray(t.fields) ? t.fields.slice() : [],
        // NEW: metadata for ranking only
        kind, isTask
      };
    });
  }

    function rankSuggestions(q, idx, limit = 8){
  const rawQ  = String(q || '').trim().toLowerCase();
  const terms = rawQ.split(/[^a-z0-9]+/).filter(Boolean);
  if (!terms.length) return [];

  const esc = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const hits = [];

  for (const t of idx){
    let bestUC = '';
    let ucScore = 0;

    // ========= 1) USE-CASES (now gated on real lexical match) =========
    for (const uc of t.use_cases){
      const l = uc.toLowerCase();
      let s = 0;
      let matched = false;          // <-- NEW: track if any lexical match happened
      let firstPos = Infinity;

      // phrase / exact line
      if (rawQ && l === rawQ){ s += 220; matched = true; }
      else if (rawQ && l.includes(rawQ)){ s += 120; matched = true; }

      // token scoring
      for (const tok of terms){
        if (l === tok){ s += 80; matched = true; }
        const re = new RegExp(`\\b${esc(tok)}\\b`);
        if (re.test(l)){ s += 40; matched = true; }
        const pos = l.indexOf(tok);
        if (pos >= 0){
          s += 24;                   // substring
          matched = true;
          firstPos = Math.min(firstPos, pos);
          if (pos === 0) s += 10;    // starts-with
        }
      }

      // ⛔️ If nothing matched, this UC should NOT enter the pool
      if (!matched) continue;

      // position + brevity nudges only apply when there was a match
      if (firstPos < Infinity){
        s += Math.max(0, 30 - Math.min(30, firstPos));
      }
      s += Math.max(0, 18 - Math.min(18, Math.floor(l.length / 12)));

      // gentle task nudge (ordering only) — only after a real match
      if (t.isTask) s += 30;

      // tiny kind-mention nudge
      if (t.kind && terms.some(tok => t.kind.includes(tok))) s += 12;

      if (s > ucScore){ ucScore = s; bestUC = uc; }
    }

    // ========= 2) use: TAGS (fallback only if no UC hit) =========
    let tagScore = 0;
    if (ucScore === 0 && t.use_tags.length){
      for (const tag of t.use_tags){
        const tl = String(tag).toLowerCase();
        for (const tok of terms){
          if (tl === tok) tagScore += 20;
          else if (tl.includes(tok)) tagScore += 12;
        }
      }
      if (tagScore > 0){
        if (t.isTask) tagScore += 12;
        if (t.kind && terms.some(tok => t.kind.includes(tok))) tagScore += 8;
      }
    }

    if (ucScore > 0){
      hits.push({ bucket:'uc', score: ucScore, use: bestUC || (t.use_cases[0] || ''), label:t.label, template:t, id:t.id, slug:t.slug });
    } else if (tagScore > 0){
      hits.push({ bucket:'tag', score: tagScore, use: bestUC || (t.use_cases[0] || ''), label:t.label, template:t, id:t.id, slug:t.slug });
    }
  }

  // primary sort (unchanged)
  hits.sort((a,b)=>
    (a.bucket === b.bucket ? 0 : (a.bucket === 'uc' ? -1 : 1)) ||
    (b.score - a.score) ||
    ((b.template.isTask?1:0) - (a.template.isTask?1:0)) ||
    (a.use.length - b.use.length) ||
    a.use.localeCompare(b.use)
  );

  // ========= Wild-query fallback (now triggers correctly) =========
  const TOP = hits[0]?.score || 0;
  const WILD_MIN_HITS  = 2;
  const WILD_TOP_SCORE = 60;
  const isWild = (hits.length === 0) || (hits.length <= WILD_MIN_HITS && TOP < WILD_TOP_SCORE);

  if (isWild){
    const HELPER_LABELS = new Set(['— Task Picker —','— Pattern Picker —']);
    const helperTemplates = idx.filter(t=>{
      const lbl = String(t.label||'').trim();
      const id  = String(t.id||'').trim().toLowerCase();
      const kind= String(t.kind||'').trim().toLowerCase();
      return HELPER_LABELS.has(lbl) && (id === 'none' || kind === 'helper');
    });

    const helperBase = Math.max(TOP + 5, 240);
    const seenUse = new Set(hits.map(h => h.use));
    let step = 0;

    for (const t of helperTemplates){
      for (const uc of (t.use_cases || [])){
        if (seenUse.has(uc)) continue;
        hits.push({
          bucket:'uc',
          score: helperBase - (step++ * 0.5),
          use: uc,
          label: t.label,
          template: t,
          id: t.id,
          slug: t.slug
        });
        seenUse.add(uc);
      }
    }

    hits.sort((a,b)=>
      (a.bucket === b.bucket ? 0 : (a.bucket === 'uc' ? -1 : 1)) ||
      (b.score - a.score) ||
      ((b.template.isTask?1:0) - (a.template.isTask?1:0)) ||
      (a.use.length - b.use.length) ||
      a.use.localeCompare(b.use)
    );
  }

  return hits.slice(0, limit);
}


// ===== Recent + idle helper suggestions =====
const RECENT_KEY  = 'pb_recent_queries';
const MAX_RECENT  = 12;

function loadRecent(){
  try { return JSON.parse(localStorage.getItem(RECENT_KEY) || '[]'); }
  catch { return []; }
}
function saveRecent(q){
  q = String(q||'').trim();
  if (!q) return;
  let list = loadRecent().filter(s => s && s.toLowerCase() !== q.toLowerCase());
  list.unshift(q);
  if (list.length > MAX_RECENT) list = list.slice(0, MAX_RECENT);
  localStorage.setItem(RECENT_KEY, JSON.stringify(list));
}

function helperTemplates(idx){
  const HELPER_LABELS = new Set(['— Task Picker —','— Pattern Picker —']);
  return idx.filter(t=>{
    const lbl = String(t.label||'').trim();
    const id  = String(t.id||'').trim().toLowerCase();
    const kind= String(t.kind||'').trim().toLowerCase();
    return HELPER_LABELS.has(lbl) && (id === 'none' || kind === 'helper');
  });
}

function helperUsecaseSuggestions(idx, limit, seen=new Set()){
  const out = [];
  for (const t of helperTemplates(idx)){
    for (const uc of (t.use_cases || [])){
      if (seen.has(uc)) continue;
      out.push({
        bucket:'uc', score: 999,
        use: uc, label: t.label,
        template: t, id: t.id, slug: t.slug,
        origin:'helper'
      });
      seen.add(uc);
      if (out.length >= limit) return out;
    }
  }
  return out;
}

function buildIdleSuggestions(idx, limit=8){
  const seen = new Set();
  const out  = [];

  // Recent searches first
  const rec = loadRecent();
  for (const r of rec){
    if (!r || seen.has(r)) continue;
    out.push({
      bucket:'uc', score: 1000,
      use: r, label:'recent',
      template:null, id:null, slug:null,
      origin:'recent'
    });
    seen.add(r);
    if (out.length >= limit) return out;
  }

  // Then helper picker use-cases
  return out.concat(helperUsecaseSuggestions(idx, Math.max(0, limit - out.length), seen));
}

    const qEl  = document.getElementById('q');
    const taEl = document.getElementById('ta');
    const goEl = document.getElementById('go');

    let INDEX = [];
    let active = -1;
    let picked = null;
    // remember last search + last shown template so "try another" can exclude it
let LAST_CTX = { q:'', slug:null };

    function renderTA(list){
      if (!list.length){ taEl.hidden = true; taEl.innerHTML = ''; active=-1; return; }
      taEl.innerHTML = list.map((s,i)=>`
        <div class="item${i===0?' active':''}" role="option" data-i="${i}">
          <div class="use">${s.use}</div>
          <div class="sub" aria-hidden="true">${s.label}</div>
        </div>
      `).join('');
      taEl.hidden = false; active = 0;
    }

    let SUGS = [];
function onQuery(){
  const q = qEl.value.trim();
  const focused = document.activeElement === qEl;

  if (!q){
    if (focused){
      SUGS = buildIdleSuggestions(INDEX, 8);
      renderTA(SUGS);
    } else {
      hideTA(); // collapsed when not focused
    }
    return;
  }

  SUGS = rankSuggestions(q, INDEX, 8);
  renderTA(SUGS);
}
    qEl.addEventListener('input', onQuery);
    qEl.addEventListener('keydown', (e)=>{
      const open = !taEl.hidden && taEl.children.length;
      if (open && (e.key === 'ArrowDown' || e.key === 'ArrowUp')){
        e.preventDefault();
        active = Math.max(0, Math.min(taEl.children.length-1, active + (e.key==='ArrowDown'?1:-1)));
        [...taEl.children].forEach((n,i)=> n.classList.toggle('active', i===active));
} else if (e.key === 'Enter'){
  e.preventDefault();
  if (!taEl.hidden && taEl.children.length){
    // choose() will call startScan() for us
    choose(active >= 0 ? active : 0);
  } else {
    if (!picked && SUGS[0]) picked = SUGS[0];
    if (qEl.value.trim()) startScan();
  }
} else if (e.key === 'Escape'){
        taEl.hidden = true; active=-1;
      }
    });
// Only stop propagation when the MOBILE overlay is open
taEl.addEventListener('pointerdown', function(e){
  if (document.documentElement.classList.contains('overlay-open')) {
    e.stopPropagation();
  }
}, true);

let __lastPickTs = 0;
function handlePick(e){
  const el = e.target.closest('.item');
  if (!el) return;

  // De-dupe across pointerdown/mousedown/click within 200ms
  const now = Date.now();
  if (now - __lastPickTs < 200) { e.preventDefault(); e.stopPropagation(); return; }
  __lastPickTs = now;

  e.preventDefault();   // avoid focus/blur races
  e.stopPropagation();  // don't bubble to any outside closers
  choose(parseInt(el.dataset.i,10) || 0);
}

// Fire on all common pathways
taEl.addEventListener('pointerdown', handlePick, { passive:false });
taEl.addEventListener('mousedown',  handlePick);
taEl.addEventListener('click',      handlePick);
goEl.addEventListener('click', ()=>{
  if (!picked && SUGS[0] && !taEl.hidden){ choose(0); }  // choose() triggers start
  else if (qEl.value.trim()) startScan();
});

// Show idle suggestions (recent → helper) the moment the field is focused & blank
qEl.addEventListener('focus', ()=>{
  if (!qEl.value.trim()){
    SUGS = buildIdleSuggestions(INDEX, 8);
    renderTA(SUGS);
  } else {
    onQuery(); // if user had text, refresh suggestions on focus
  }
});

qEl.addEventListener('blur', ()=>{
  // Let mousedown on a suggestion run first, then hide.
  setTimeout(hideTA, 80);
});

// Click anywhere outside the search area → hide dropdown
document.addEventListener('pointerdown', (e)=>{
  // If the mobile overlay is open, let the scrim/overlay manage closing.
  if (document.documentElement.classList.contains('overlay-open')) return;

  // Defensive: if the event is inside the mobile portal, ignore it here.
  var portal = document.getElementById('suggestions-portal');
  if (portal && portal.contains(e.target)) return;

  if (!searchWrap.contains(e.target)) hideTA();
});

function choose(i){
  const items = Array.from(taEl.children);
  const it = items[i]; if (!it) return;
  const s = SUGS[i];   if (!s) return;

  qEl.value = s.use;
  taEl.hidden = true; active = -1;

  // If it's a "recent" chip, convert it to a real search:
  if (s.origin === 'recent'){
    picked = null;           // not a specific template yet
    onQuery();               // recompute SUGS synchronously for this query
    if (SUGS[0] && SUGS[0].origin !== 'recent'){ picked = SUGS[0]; } // auto-pick top result if present
    if (qEl.value.trim()) startScan(); // run immediately
    return;
  }

  // Normal/helper suggestion → lock and run immediately
  picked = s;
  if (qEl.value.trim()) startScan();
}

// --- quick buttons under the search ---
const btnAdv   = document.getElementById('btnAdv');   // pure link, no JS needed
const btnHelp  = document.getElementById('btnHelp');
const btnLucky = document.getElementById('btnLucky');

// Pick a helper template (— Task Picker — or — Pattern Picker — preferred),
// otherwise anything with id:"none" or kind:"helper", then grab a random use-case.
function pickHelperUC(){
  const ALL = allTemplates();
  const HELPER_LABELS = new Set(['— Task Picker —','— Pattern Picker —']);
  const helpers = ALL.filter(t=>{
    const lbl  = String(t.label||'').trim();
    const id   = String(t.id||'').trim().toLowerCase();
    const kind = String(t.kind||t.type||'').trim().toLowerCase();
    return HELPER_LABELS.has(lbl) || id === 'none' || kind === 'helper';
  });
  const pool = helpers.length ? helpers : ALL.filter(t => (t.use_cases||[]).length);
  if (!pool.length) return null;
  const t = pool[Math.floor(Math.random()*pool.length)];
  const ucs = (t.use_cases || []);
  if (!ucs.length) return null;
  const uc = ucs[Math.floor(Math.random()*ucs.length)];
  return { uc, t };
}

btnHelp?.addEventListener('click', ()=>{
  const pick = pickHelperUC();
  if (!pick){
    // Fallback: use existing helper suggestion builder
    const h = helperUsecaseSuggestions(INDEX, 1);
    if (h[0]){
      picked = h[0];
      qEl.value = h[0].use;
      startScan();
    }
    return;
  }
  picked = {
    bucket:'uc', score:999,
    use: pick.uc,
    label: pick.t.label || pick.t.slug || pick.t.id,
    template: pick.t, id: pick.t.id, slug: pick.t.slug
  };
  qEl.value = pick.uc;
  startScan();
});

// Lucky: random use-case across ALL templates equally
btnLucky?.addEventListener('click', ()=>{
  const ALL = allTemplates();
  const bag = [];
  for (const t of ALL){
    for (const uc of (t.use_cases || [])){
      bag.push({ uc, t });
    }
  }
  if (!bag.length){
    // Fallback to helper if no use-cases exist yet
    const h = helperUsecaseSuggestions(INDEX, 1);
    if (h[0]){
      picked = h[0]; qEl.value = h[0].use; startScan();
    }
    return;
  }
  const { uc, t } = bag[Math.floor(Math.random()*bag.length)];
  picked = {
    bucket:'uc', score:999,
    use: uc,
    label: t.label || t.slug || t.id,
    template: t, id: t.id, slug: t.slug
  };
  qEl.value = uc;
  startScan();
});


/* ===== Mini redo search under details header ===== */
(function miniSearch(){
  const q2   = document.getElementById('q2');
  const ta2  = document.getElementById('ta2');
  const go2  = document.getElementById('go2');
  const retryBtn = document.getElementById('retry');
  const wrap = document.querySelector('.detailSearchWrap');

  if (!q2 || !ta2 || !go2 || !retryBtn || !wrap) return;

  let SUGS2 = [];
  let active2 = -1;
  let __lastPickTs2 = 0;

  function hideTA2(){
    ta2.hidden = true;
    ta2.innerHTML = '';
    active2 = -1;
  }
  function renderTA2(list){
    if (!list.length){ hideTA2(); return; }
    ta2.innerHTML = list.map((s,i)=>`
      <div class="item${i===0?' active':''}" role="option" data-i="${i}">
        <div class="use">${s.use}</div>
        <div class="sub" aria-hidden="true">${s.label}</div>
      </div>
    `).join('');
    ta2.hidden = false; active2 = 0;
  }

  q2.addEventListener('input', ()=>{
    SUGS2 = q2.value.trim()
      ? rankSuggestions(q2.value.trim(), INDEX, 8)
      : buildIdleSuggestions(INDEX, 6);
    renderTA2(SUGS2);
  });

  q2.addEventListener('keydown', (e)=>{
    const open = !ta2.hidden && ta2.children.length;
    if (open && (e.key === 'ArrowDown' || e.key === 'ArrowUp')){
      e.preventDefault();
      active2 = Math.max(0, Math.min(ta2.children.length-1, active2 + (e.key==='ArrowDown'?1:-1)));
      [...ta2.children].forEach((n,i)=> n.classList.toggle('active', i===active2));
    } else if (e.key === 'Enter'){
      e.preventDefault();
      if (open && SUGS2[0]) choose2(active2 >= 0 ? active2 : 0);
      else if (q2.value.trim()){
        picked = null;
        qEl.value = q2.value.trim();
        startScan();
      }
    } else if (e.key === 'Escape'){ hideTA2(); }
  });

  function choose2(i){
    const el = ta2.children[i]; if (!el) return;
    const s  = SUGS2[i];        if (!s)  return;

    qEl.value = s.use;
    picked = s;
    hideTA2();
    startScan();
  }

  function handlePick2(e){
    const el = e.target.closest('.item'); if (!el) return;
    const now = Date.now();
    if (now - __lastPickTs2 < 200){ e.preventDefault(); e.stopPropagation(); return; }
    __lastPickTs2 = now;

    e.preventDefault(); e.stopPropagation();
    choose2(parseInt(el.dataset.i,10) || 0);
  }

  ta2.addEventListener('pointerdown', handlePick2, { passive:false });
  ta2.addEventListener('mousedown',  handlePick2);
  ta2.addEventListener('click',      handlePick2);

  // click-away close for the mini list
  document.addEventListener('pointerdown', (e)=>{
    if (!wrap.contains(e.target)) hideTA2();
  }, true);

  // run search when pressing the mini "search" button
  go2.addEventListener('click', ()=>{
    if (!ta2.hidden && SUGS2[0]) choose2(0);
    else if (q2.value.trim()){
      picked = null;
      qEl.value = q2.value.trim();
      startScan();
    }
  });

  // "Try another" — same query, different closest template
  function tryAnother(){
    const q = (q2.value.trim() || LAST_CTX.q || '').trim();
    if (!q) return;

    const currentSlug = LAST_CTX.slug;
    const ranked = rankSuggestions(q, INDEX, 24);
    const alt = ranked.find(r=>{
      const slug = (r?.template?.slug || r?.template?.id || '').toString();
      return slug && slug !== currentSlug;
    });

    if (alt){
      picked = alt;
      qEl.value = alt.use;
      startScan();
      return;
    }

    // fallback: similar tags/cats, else any different template
    const current = INDEX.find(t => (t.slug || t.id) === currentSlug);
    let pool = INDEX.filter(t=>{
      const slug = (t.slug || t.id);
      if (!slug || slug === currentSlug) return false;
      const shareTag = (t.tags||[]).some(tag => (current?.tags||[]).includes(tag));
      const shareCat = (t.categories||[]).some(cat => (current?.categories||[]).includes(cat));
      return shareTag || shareCat;
    });
    if (!pool.length) pool = INDEX.filter(t => (t.slug||t.id) && (t.slug||t.id)!==currentSlug);

    if (pool.length){
      const t = pool[0];
      const uc = (t.use_cases && t.use_cases[0]) || (LAST_CTX.q || 'prompt');
      picked = { bucket:'uc', score:999, use: uc, label: t.label, template: t, id: t.id, slug: t.slug };
      qEl.value = uc;
      startScan();
    }
  }
  retryBtn.addEventListener('click', tryAnother);

  // Prefill when details open (also set in showDetails for freshness)
  try { q2.value = LAST_CTX.q; } catch(e){}
})();

    /* ===== Faux scan to details ===== */
    const hero = document.getElementById('hero');
    const scan = document.getElementById('scan');
    const details = document.getElementById('details');
    const rollList = document.getElementById('rollList');
    const resultHeader = document.getElementById('resultHeader');

    function startScan(){
    saveRecent(qEl.value.trim()); // ← NEW: remember it
    LAST_CTX.q = qEl.value.trim(); 
    
      hero.style.display = 'none';
      scan.style.display = 'flex';

      // ensure the center rainbow band exists (added once)
      const rollEl = document.querySelector('.scan .roll');
      if (rollEl && !rollEl.querySelector('.centerBand')){
        const band = document.createElement('div');
        band.className = 'centerBand';
        rollEl.appendChild(band);
      }

      const labels = allTemplates().map(t => t.label || t.slug || t.id).filter(Boolean);
      const unique = Array.from(new Set(labels));
      const chosenLabel = (picked && picked.label) || unique[0] || 'template';

      // Plenty above and below so the center has neighbors to fade
      const above = unique.sort(()=>Math.random()-.5).slice(0, 40);
      const below = unique.sort(()=>Math.random()-.5).slice(0, 12);
      const finalList = [...above, chosenLabel, ...below];

      rollList.innerHTML = finalList.map(l => `<li${l===chosenLabel?' class="hit"':''}>${l}</li>`).join('');

      // Skip fancy motion for reduced-motion users
      const prefersReduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      if (prefersReduce){
        // Hard-center without animation
        hardCenterHit();
        // Move on almost immediately
        setTimeout(()=> showDetails(picked?.template || INDEX.find(t => t.label === chosenLabel)), 250);
      } else {
        animateToCenterHit({ overshoot: 48, scrollMs: 2200, backMs: 420, fwdMs: 320, settleMs: 200, jiggleBack: 18, jiggleFwd: 9 })
          .then(()=>{ showDetails(picked?.template || INDEX.find(t => t.label === chosenLabel)); });
      }
    }

    function getHitGeometry(){
      const roll = document.querySelector('.scan .roll');
      const hit  = rollList.querySelector('.hit');
      if (!roll || !hit) return null;

      const ulRect  = rollList.getBoundingClientRect();
      const hitRect = hit.getBoundingClientRect();
      const viewportH = roll.clientHeight;

      // Distance from UL top to place hit in the vertical center of the roll viewport
      const target = (hitRect.top - ulRect.top) - (viewportH - hitRect.height)/2;

      return { roll, hit, target: Math.max(0, target) };
    }

    function hardCenterHit(){
      const g = getHitGeometry(); if (!g) return;
      rollList.style.transition = 'none';
      rollList.style.transform  = `translate3d(0, ${-g.target}px, 0)`;
    }

    function animateToCenterHit({ overshoot = 22, scrollMs = 1400, backMs = 300, fwdMs = 200, settleMs = 140, jiggleBack = 8, jiggleFwd = 4 } = {}){
      const g = getHitGeometry();
      if (!g) return Promise.resolve();

      const yPast   = g.target - overshoot;
      const yBack   = g.target + jiggleBack;
      const yFwd    = g.target - jiggleFwd;
      const yFinal  = g.target;

      const easingMain = 'cubic-bezier(.2,.9,.2,1)';
      const easingSnap = 'cubic-bezier(.15,.95,.2,1)';

      const transitionTo = (y, ms, easing) => new Promise((resolve)=>{
        const onEnd = (e)=> {
          if (e.propertyName !== 'transform') return;
          rollList.removeEventListener('transitionend', onEnd);
          resolve();
        };
        const failSafe = setTimeout(()=>{ rollList.removeEventListener('transitionend', onEnd); resolve(); }, ms + 60);

        rollList.addEventListener('transitionend', onEnd, { once:true });
        rollList.style.transition = `transform ${ms}ms ${easing}`;
        rollList.style.transform  = `translate3d(0, ${-y}px, 0)`;
      });

      rollList.style.transition = 'none';

      return Promise.resolve()
        .then(()=> transitionTo(yPast,  scrollMs, easingMain))
        .then(()=> transitionTo(yBack,   backMs,  easingSnap))
        .then(()=> transitionTo(yFwd,     fwdMs,  easingSnap))
        .then(()=> transitionTo(yFinal, settleMs, easingSnap));
    }
    
    
    /* ===== Slice 0: Flags + routing helper (SAFE, inert) ===== */
(function initFlagsAndRouting(){
  // Feature flags (all OFF by default; turn on per-slice during testing)
  window.PB_FLAGS = window.PB_FLAGS || {
    newActionModal:   false,  // Slice 1
    newWorksheetUrl:  false,  // later
    askUrlPrompt:     false,  // later
    mobileMenuParity: false   // later
  };

  // Compute stable routing bits for a template (not used yet in Slice 1)
  window.getRoutingFromTemplate = window.getRoutingFromTemplate || function(t){
    t = t || {};
    const id   = String(t.id   || t.slug || '').trim();
    const slug = String(t.slug || t.id   || '').trim();
    const kindRaw = String(t._displayKind || t.kind || t.type || 'framework').toLowerCase();

    // pluralization map (falls back to naive “+s”)
    const PLURALS = {
      pattern:'patterns',
      strategy:'strategies',
      framework:'frameworks',
      task:'tasks',
      heuristic:'heuristics',
      term:'terms',
      helper:'helpers'
    };
    const kindPlural =
      PLURALS[kindRaw] ||
      (kindRaw ? (kindRaw.endsWith('s') ? kindRaw : kindRaw + 's') : 'frameworks');

    const xfer = id ? `pb.v1.xfer.${kindPlural}.${id}` : '';
    return { id, slug, kindRaw, kindPlural, xfer };
  };
})();

// TEMP: enable Slice 1 during testing
window.PB_FLAGS.newActionModal = true;
window.PB_FLAGS.askUrlPrompt = true;
window.PB_FLAGS.newWorksheetUrl = true;
window.PB_FLAGS.mobileMenuParity = true;

/* ===== Slice 1: Modal manager (copy only) ===== */
/* ===== Slice 1: Modal manager (copy only) — FINAL UI/UX ===== */
/* ===== Slice 1+3: Modal manager (copy + ask) — FINAL UI/UX ===== */
function openAction({ mode='copy', prompt='', routing=null } = {}){
  const dlg        = document.getElementById('actionModal');
  const form       = document.getElementById('actionForm');
  const titleEl    = document.getElementById('actionTitle');
  const previewEl  = document.getElementById('actionPreview');
  const noteEl     = document.getElementById('actionNote');
  const confirmBtn = document.getElementById('actionConfirm');
  const cancelBtn  = document.getElementById('actionCancel');
  const closeBtn   = document.getElementById('actionClose');

  if (!dlg || !form || !titleEl || !previewEl || !confirmBtn) return;

  // Remember the opener to restore focus later
  const opener = document.activeElement instanceof HTMLElement ? document.activeElement : null;

  // --- Configure per mode ---
  if (mode === 'ask'){
    titleEl.textContent = 'ask chatgpt';
    confirmBtn.textContent = 'open in chatgpt';
  } else {
    titleEl.textContent = 'copy prompt';
    confirmBtn.textContent = 'copy';
  }

  // Seed editable preview
  previewEl.value = String(prompt || '');

  // Notes differ by mode: show "already copied" only for copy mode
  if (noteEl){
    if (mode === 'copy'){
      noteEl.textContent = 'copied to clipboard. you can edit and copy again.';
      noteEl.hidden = false;
      form.setAttribute('aria-describedby', noteEl.id);
    } else {
      noteEl.hidden = true;
      form.removeAttribute('aria-describedby');
    }
  }

  // Submit behaviors
  const onSubmit = async (e)=>{
    e.preventDefault();

    if (mode === 'ask'){
      // Always copy the preview text as a fallback
      try { await navigator.clipboard.writeText(previewEl.value); } catch {}

      // Build ChatGPT URL with ?prompt=
      let url = 'https://chat.openai.com/?prompt=' + encodeURIComponent(previewEl.value);

      // Try to open in a new tab; detect block
      let win = null;
      try { win = window.open(url, '_blank', 'noopener'); } catch {}

      // If blocked or failed, keep dialog open and instruct the user
      if (!win || win.closed){
        if (noteEl){
          noteEl.textContent = 'popup blocked — prompt is copied. open chat.openai.com and paste with ⌘/Ctrl+V.';
          noteEl.hidden = false;
          form.setAttribute('aria-describedby', noteEl.id);
        }
        return; // keep dialog open so they can read/copy again
      }

      // Success → close dialog
      closeDialog();
      return;
    }

    // mode === 'copy'
    try {
      await navigator.clipboard.writeText(previewEl.value);
      if (noteEl){ noteEl.textContent = 'copied!'; noteEl.hidden = false; }
    } catch {
      if (noteEl){
        noteEl.textContent = 'could not copy automatically — select all and press ⌘/Ctrl+C.';
        noteEl.hidden = false;
      }
    }
    // keep open so they can tweak/copy again
  };

  // Cmd/Ctrl+Enter submits (opens ChatGPT in ask mode; copies in copy mode)
  const onKeyPreview = (e)=>{
    if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)){
      e.preventDefault();
      onSubmit(e);
    }
  };

  // Click-outside close — ignore while actively resizing the textarea
  const onBackdropClick = (e)=>{
    const r = form.getBoundingClientRect();
    const inside =
      e.clientX >= r.left && e.clientX <= r.right &&
      e.clientY >= r.top  && e.clientY <= r.bottom;
    if (inside) return;
    if (e.target === previewEl && previewEl.matches(':active')) return;
    closeDialog();
  };

  const closeDialog = ()=>{
    try { dlg.close(); } catch {}
    form.removeEventListener('submit', onSubmit);
    previewEl.removeEventListener('keydown', onKeyPreview);
    cancelBtn && cancelBtn.removeEventListener('click', closeDialog);
    closeBtn  && closeBtn.removeEventListener('click', closeDialog);
    dlg.removeEventListener('cancel', closeDialog);
    dlg.removeEventListener('click', onBackdropClick);
    if (opener && typeof opener.focus === 'function'){
      setTimeout(()=>{ try{ opener.focus({ preventScroll:true }); }catch{} }, 0);
    }
  };

  // Fresh bindings
  form.addEventListener('submit', onSubmit);
  previewEl.addEventListener('keydown', onKeyPreview);
  cancelBtn && cancelBtn.addEventListener('click', closeDialog);
  closeBtn  && closeBtn.addEventListener('click', closeDialog);
  dlg.addEventListener('cancel', closeDialog);
  dlg.addEventListener('click', onBackdropClick);

  // Open and focus the preview so users can edit immediately
  try { dlg.showModal(); } catch {}
  setTimeout(()=>{
    try {
      previewEl.focus({ preventScroll: true });
      previewEl.setSelectionRange(0, previewEl.value.length);
    } catch {}
  }, 0);
}


    /* ===== Details page wiring ===== */
    const tplTitle = document.getElementById('tplTitle');
    const meta = document.getElementById('meta');
    const def = document.getElementById('def');
    const useCases = document.getElementById('useCases');
    const boosters = document.getElementById('boosters');
    const boostersBlock = document.getElementById('boostersBlock');
    const fields = document.getElementById('fields');

    const openBuilder = document.getElementById('openBuilder');
    const openGlossary = document.getElementById('openGlossary');
    const printWorksheet = document.getElementById('printWorksheet');
    const copyPrompt = document.getElementById('copyPrompt');
    const ask = document.getElementById('ask');
    const back = document.getElementById('back');

    function htmlEsc(s){ return String(s||'').replace(/[&<>"]/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[m])); }

    function showDetails(t){
      scan.style.display = 'none';
      details.hidden = false;
      resultHeader.hidden = false;
      document.body.classList.add('is-details');
      if (!t){ tplTitle.textContent = 'template'; return; }

      tplTitle.textContent = (t.label || t.slug || t.id || 'template').toLowerCase();
      meta.innerHTML = [
        ...(t.categories||[]).map(c => `<span class="chip">${htmlEsc(c)}</span>`),
        ...(t.tags||[]).map(tag => `<span class="chip">${htmlEsc(tag)}</span>`)
      ].join('');

      def.textContent = t.definition || 'No definition provided yet.';
      useCases.innerHTML = (t.use_cases||[]).map(u => `<div class="uc">${htmlEsc(u)}</div>`).join('') || '<div class="uc">No use-cases listed.</div>';

      if (t.boosters && t.boosters.length){
        boostersBlock.hidden = false;
        boosters.innerHTML = t.boosters.map(b => `<div class="booster">${htmlEsc(b)}</div>`).join('');
      } else {
        boostersBlock.hidden = true;
      }

      fields.innerHTML = (t.fields||[]).map(f => `
        <div class="row">
          <label>${htmlEsc(f.label || f.key || 'field')}</label>
          <div class="fake">${htmlEsc(f.ph || '')}</div>
        </div>
      `).join('') || '<div class="row"><div class="fake">No fields for this template.</div></div>';

      const slug = (t.slug || t.id || '').toString();
      openBuilder.href = './glossary/prompt-builder.html' + (slug ? ('?slug=' + encodeURIComponent(slug)) : '');
      openGlossary.href = './glossary/templates-glossary.html' + (slug ? ('?slug=' + encodeURIComponent(slug)) : '');
      // Slice 2: Worksheet URL — prefer ?kind=<plural>&id=<id>&xfer=pb.v1.xfer.<plural>.<id>
if (window.PB_FLAGS && window.PB_FLAGS.newWorksheetUrl){
  const r = getRoutingFromTemplate(t); // uses _displayKind || kind || type
  if (r && r.id && r.kindPlural){
    const params = new URLSearchParams();
    params.set('kind', r.kindPlural);
    params.set('id',   r.id);
    if (r.xfer) params.set('xfer', r.xfer);
    printWorksheet.href = './glossary/prompt-worksheet.html?' + params.toString();
  } else {
    // Safety fallback: keep legacy slug behavior if we somehow lack id/kind
    printWorksheet.href = './glossary/prompt-worksheet.html' + (slug ? ('?slug=' + encodeURIComponent(slug)) : '');
  }
} else {
  // Rollback path (flag off): legacy slug behavior
  printWorksheet.href = './glossary/prompt-worksheet.html' + (slug ? ('?slug=' + encodeURIComponent(slug)) : '');
}
      // remember what we just opened, so "try another" can exclude it
  LAST_CTX.slug = slug;
  LAST_CTX.q = qEl.value.trim() || LAST_CTX.q;

  // keep the mini search prefilled with the last query
  try { document.getElementById('q2').value = LAST_CTX.q; } catch(e){}  
    
      // Build the ChatGPT primer prompt from the template
      const fullPrompt = buildChatGPTPrompt(normalizeTemplateForSummary(t));
      // Expose for mobile menu parity
window.__lastRouting = getRoutingFromTemplate(t);
window.__lastFullPrompt = fullPrompt;

      // Slice 1: copy to clipboard, then (if enabled) open confirmation modal
copyPrompt.onclick = async ()=>{
  try { await navigator.clipboard.writeText(fullPrompt); } catch {}
  if (window.PB_FLAGS && window.PB_FLAGS.newActionModal){
    // routing not used in Slice 1, but passed for future slices
    openAction({ mode:'copy', prompt: fullPrompt, routing: getRoutingFromTemplate(t) });
  }
};
// Slice 3: Ask → open modal (edit), then open ChatGPT with ?prompt= on confirm
ask.onclick = async ()=>{
  if (window.PB_FLAGS && window.PB_FLAGS.askUrlPrompt){
    openAction({ mode:'ask', prompt: fullPrompt, routing: getRoutingFromTemplate(t) });
  } else {
    // Rollback path: legacy behavior if flag is off
    try { await navigator.clipboard.writeText(fullPrompt); } catch {}
    window.open('https://chat.openai.com/', '_blank', 'noopener');
  }
};
      back.onclick = ()=>{
        details.hidden = true;
        resultHeader.hidden = true;
        document.body.classList.remove('is-details');
        hero.style.display = 'block';
        qEl.focus();
      };
      
      window.__pushDetailsState(String(t.slug || t.id || ''));
    }

    function normalizeTemplateForSummary(t){
      return { ...t, _displayKind: (t._displayKind || t.kind || t.type || 'framework') };
    }
    function buildTemplateSummary(t){
      const lines = [];
      lines.push(`Template: ${t.label || t.slug || t.id || 'untitled'}`);
      lines.push(`Kind: ${t._displayKind || t.kind || 'framework'}`);
      if (t.definition) lines.push(`Definition: ${t.definition}`);
      if (t.categories?.length) lines.push(`Categories: ${t.categories.join(', ')}`);
      if (t.tags?.length) lines.push(`Tags: ${t.tags.join(', ')}`);
      if (t.use_cases?.length){ lines.push(`Use-cases:`); for (const u of t.use_cases) lines.push(`- ${u}`); }
      if (t.fields?.length){
        lines.push(`Fields:`); for (const f of t.fields){
          const label = f.label || f.key || 'field';
          const ph = f.ph ? ` — ${f.ph}` : '';
          lines.push(`- ${label}${ph}`);
        }
      }
      if (t.boosters?.length){ lines.push(`Boosters:`); for (const b of t.boosters) lines.push(`- ${b}`); }
      return lines.join('\n');
    }
    function buildChatGPTPrompt(t){
      const kind = (t._displayKind || 'framework').toLowerCase();
      const summary = buildTemplateSummary(t);
      return [
        `You are an expert AI tutor specializing in prompt engineering. I am reviewing a "${kind}"-type prompt template and will share its full structure with you below to prime your understanding:`,
        ``,
        summary,
        ``,
        `Please begin by asking me what I would like to accomplish using this template. Then:`,
        `1) Explain the ${kind} at a practitioner level with 1–2 concrete examples.`,
        `2) Contrast it with closely related terms (if any) and note common confusions.`,
        `3) Offer pitfalls, best practices, and a short checklist.`,
        `4) Suggest 3 reputable resources for deeper reading (link if possible).`,
        `5) Guide the user through the template provided for "${t.label || t.slug || t.id || ''}" (${kind}).`
      ].join('\n');
    }
    
    const searchWrap = document.querySelector('.searchWrap');

function hideTA(){
  taEl.hidden = true;
  taEl.innerHTML = '';
  active = -1;
}

    /* ===== Boot index for search ===== */
    function boot(){ INDEX = buildIndex(); onQuery(); }
function boot(){ INDEX = buildIndex(); onQuery(); }

(function watchDatasets(){
  let lastSeen = '';
  const timer = setInterval(()=>{
    const haveTpl  = Array.isArray(window.TEMPLATES) || Array.isArray(window.FRAMEWORKS);
    const haveTask = Array.isArray(window.TASK_TEMPLATES) || Array.isArray(window.tasks);
    const sig = (haveTpl ? 'T' : '_') + (haveTask ? 'K' : '_');
    if (sig !== lastSeen){
      lastSeen = sig;
      boot();            // rebuild when either dataset changes readiness
      if (haveTpl && haveTask) clearInterval(timer);  // stop once both are loaded
    }
  }, 80);
})();
  </script>
  
  <script>
/* ===== MANTRA REEL: slow, infinite, resize-safe vertical scroller ===== */
(function mantraReel(){
  // Tweakables
  var HOLD_MS  = 2200;   // dwell time per line
  var SLIDE_MS = 900;    // slide animation duration
  var MANTRA_SHIFT_RIGHT = 0; // px; positive pushes the whole line to the right

  var PHRASES = [
    "clarity is kindness to the model.",
    "context is half the answer.",
    "easy for you, easy for it.",
    "put smart, get smart.",
    "the divergent intern.",
    "the collaborative partner.",
    "the 10,000 experts.",
    "garbage in, garbage out.",
    "precision paints the picture.",
    "tone travels through tokens.",
    "the model mirrors your mind.",
    "examples are the skeleton key.",
    "what you frame is what you get.",
    "be the director, not the spectator.",
    "define the stage, script the play.",
    "a vague prompt breeds vague answers.",
    "specificity is the superpower.",
    "ask like a teacher, check like a scientist.",
    "layer tasks, don’t overload.",
    "persona shapes performance."
  ];

  var slot  = document.getElementById('mantraSlot');
  var reel  = document.getElementById('mantraReel');
  var list  = document.getElementById('mantraList');
  var line  = document.querySelector('#mantra .mantraLine');

  if (!slot || !reel || !list || !line) return;

  // Apply shift control (matches your earlier SHIFT_RIGHT pattern)
  line.style.setProperty('--mantra-shift-x', (MANTRA_SHIFT_RIGHT|0) + 'px');

  // Build DOM
  list.innerHTML = PHRASES.map(s => `<span class="w">${s}</span>`).join('');

  // Adopt timing to CSS custom prop so transitions stay in sync
  slot.style.setProperty('--mantra-slide', SLIDE_MS + 'ms');

  var dpr = window.devicePixelRatio || 1;
  var rowH = 0, i = 0, paused = false;

  function widestWidthPx(){
    // measure using the slot's computed font to avoid clipping
    var cs = getComputedStyle(slot);
    var meas = document.createElement('span');
    meas.style.position='absolute'; meas.style.visibility='hidden';
    meas.style.whiteSpace='nowrap'; meas.style.left='-9999px'; meas.style.top='-9999px';
    meas.style.font = cs.font;
    meas.style.letterSpacing = cs.letterSpacing;
    meas.style.textTransform = cs.textTransform;
    meas.style.fontKerning = cs.fontKerning;
    meas.style.fontFeatureSettings = cs.fontFeatureSettings;
    meas.style.fontVariationSettings = cs.fontVariationSettings;
    meas.style.fontStretch = cs.fontStretch;

    document.body.appendChild(meas);
    var max = 0;
    for (var s of PHRASES){ meas.textContent = s; var w = meas.getBoundingClientRect().width; if (w > max) max = w; }
    meas.remove();
    // +1 physical pixel fudge to avoid subpixel mask grazing
    var fudge = Math.max(1, Math.round(dpr));
    return Math.ceil(max + 20 + fudge);
  }

  function lockMetrics(){
    // lock row height from first child (rendered pixels, not ems)
    var first = list.firstElementChild;
    var h = first ? first.getBoundingClientRect().height : parseFloat(getComputedStyle(slot).fontSize) || 32;
    rowH = Math.ceil(h + 2); // cushion
    slot.style.setProperty('--mantra-slot-h', rowH + 'px');

    // lock slot width to widest phrase so we never clip mid-line
    var wpx = widestWidthPx();
    slot.style.setProperty('--mantra-slot-w', wpx + 'px');
  }

  function translateTo(idx){
    // snap to device pixels to prevent creeping drift under the mask
    var y = Math.round((idx * rowH) * dpr) / dpr;
    list.style.transform = 'translate3d(0,' + (-y) + 'px,0)';
  }

  function tick(){
    if (paused) { schedule(); return; }
    i = (i + 1) % PHRASES.length;
    translateTo(i);
    schedule();
  }
  function schedule(){ setTimeout(tick, HOLD_MS); }

  // Reduced motion: render first line only
  var prefersReduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  function start(){
    lockMetrics();
    translateTo(0);
    if (!prefersReduce){ schedule(); }
  }

  // Pause when off-screen (saves CPU; also halts motion while not visible)
  var mantraSection = document.getElementById('mantra');
  if ('IntersectionObserver' in window && mantraSection){
    var io = new IntersectionObserver(function(entries){
      entries.forEach(function(e){ paused = !e.isIntersecting; });
    }, { threshold: 0.1 });
    io.observe(mantraSection);
  }

  // Wait for fonts for stable measurements, then run
  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(start);
  } else {
    window.addEventListener('load', start, { once:true });
  }

  // On resize or zoom, re-lock metrics and keep current index visible
  window.addEventListener('resize', function(){
    var current = i;
    lockMetrics();
    translateTo(current);
  });
})();
</script>

<script>
/* ============ Slice 2 — Mobile-only suggestions overlay ============ */

/* A) Mobile detection: toggles .is-mobile on <html> */
(function mobileGate(){
  var mq = matchMedia('(hover: none) and (pointer: coarse)');
  var ua = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile/i;

  function compute(){
    var touchy = mq.matches;                 // real touch (no hover + coarse pointer)
    var uaMobile = ua.test(navigator.userAgent);
    var narrow = Math.min(window.innerWidth, window.innerHeight) <= 920; // phones/tablets
    return (touchy || uaMobile) && narrow;
  }
  function apply(){
    document.documentElement.classList.toggle('is-mobile', compute());
  }
  try{ mq.addEventListener ? mq.addEventListener('change', apply) : mq.addListener(apply);}catch(e){}
  window.addEventListener('resize', apply, {passive:true});
  window.addEventListener('orientationchange', apply, {passive:true});
  apply();
})();

/* B) Overlay portal controller (uses #q and #ta that you already have) */
(function portal(){
  var input = document.getElementById('q');   // your search field
  var ta    = document.getElementById('ta');  // your suggestions listbox
  if (!input || !ta) return;

  var portalRoot, scrim, overlay, origParent, origNext, observer;
  var opened = false;

  function isMobile(){ return document.documentElement.classList.contains('is-mobile'); }

  function ensurePortal(){
    if (portalRoot) return;
    portalRoot = document.createElement('div');
    portalRoot.id = 'suggestions-portal';
    document.body.appendChild(portalRoot);

    scrim = document.createElement('div');
    scrim.className = 'suggestions-scrim';
    scrim.hidden = true;
    portalRoot.appendChild(scrim);

    overlay = document.createElement('div');
    overlay.className = 'suggestions-overlay';
    overlay.hidden = true;
    portalRoot.appendChild(overlay);

    /* stop document pointerdown from hiding #ta when tapping suggestions */
    overlay.addEventListener('pointerdown', function(e){
  // Allow taps on the actual suggestion items (#ta descendants) to reach their handlers
  var taInOverlay = overlay.querySelector('#ta');
  if (taInOverlay && taInOverlay.contains(e.target)) return;
  // Otherwise, prevent document’s global pointerdown from hiding the list prematurely
  e.stopPropagation();
}, true);
    scrim.addEventListener('click', function(){
      // close and also hide #ta so your app state stays consistent
      closeOverlay();
      if (window.hideTA) window.hideTA(); else { ta.hidden = true; ta.innerHTML = ''; }
    }, { passive: true });
  }

  function position(){
  if (!opened) return;

  var r  = input.getBoundingClientRect();
  var vv = window.visualViewport || { offsetTop: 0, offsetLeft: 0, width: window.innerWidth, height: window.innerHeight };

  var gutter = 8;                                  // keep a small left/right padding
  var vLeft  = vv.offsetLeft || 0;
  var vTop   = vv.offsetTop  || 0;
  var vWidth = vv.width || window.innerWidth;
  var vHeight= vv.height|| window.innerHeight;

  // Start by aligning to the input
  var left = r.left - vLeft;
  var top  = r.bottom - vTop;
  var width= r.width;

  // Clamp to viewport so the overlay never goes off-screen
  if (left < gutter) left = gutter;
  var maxWidth = Math.max(140, vWidth - left - gutter);
  if (width > maxWidth) width = maxWidth;

  overlay.style.top  = Math.round(top)  + 'px';
  overlay.style.left = Math.round(left) + 'px';
  overlay.style.width= Math.round(width)+ 'px';
  overlay.style.maxHeight = Math.round(vHeight * 0.60) + 'px';
}
  function openOverlay(){
    if (!isMobile() || opened) { position(); return; }
    ensurePortal();

    // remember original slot to restore later
    if (!origParent){ origParent = ta.parentNode; origNext = ta.nextSibling; }

    overlay.appendChild(ta);
    scrim.hidden = false;
    overlay.hidden = false;
    document.body.classList.add('scroll-locked');
    document.documentElement.classList.add('overlay-open');
    input.setAttribute('aria-expanded','true');
    position();

    // keep it anchored on viewport/keyboard changes
    window.addEventListener('resize', position, { passive: true });
    window.addEventListener('scroll', position, { passive: true });
    if (window.visualViewport){
      visualViewport.addEventListener('resize', position, { passive: true });
      visualViewport.addEventListener('scroll', position, { passive: true });
    }
    document.addEventListener('keydown', onKey, true);
    opened = true;
  }

  function closeOverlay(){
    if (!opened) return;
    scrim.hidden = true;
    overlay.hidden = true;

    // restore #ta to original DOM so desktop is unchanged
    try {
      if (origParent) origParent.insertBefore(ta, origNext);
    } catch(e){}

    document.body.classList.remove('scroll-locked');
    document.documentElement.classList.remove('overlay-open');
    input.setAttribute('aria-expanded','false');

    window.removeEventListener('resize', position, { passive: true });
    window.removeEventListener('scroll', position, { passive: true });
    if (window.visualViewport){
      visualViewport.removeEventListener('resize', position, { passive: true });
      visualViewport.removeEventListener('scroll', position, { passive: true });
    }
    document.removeEventListener('keydown', onKey, true);
    opened = false;
  }

  function onKey(e){ if (e.key === 'Escape'){ e.preventDefault(); closeOverlay(); } }

  /* C) Sync overlay with your existing show/hide logic via MutationObserver */
  observer = new MutationObserver(function(){
    if (!isMobile()) return;
    // If app has shown #ta, open overlay; if it hid it, close overlay.
    (!ta.hidden && ta.children.length) ? openOverlay() : closeOverlay();
  });
  observer.observe(ta, { attributes:true, attributeFilter:['hidden'], childList:true, subtree:false });

  /* D) Also react to input focus (your code already renders idle suggestions on focus) */
  input.addEventListener('focus', function(){ if (isMobile() && !ta.hidden) openOverlay(); });

  /* E) If device flips to desktop midsession, close & restore */
  var mq = window.matchMedia('(hover: none) and (pointer: coarse)');
  function maybeClose(){ if (!isMobile()) closeOverlay(); }
  try { mq.addEventListener ? mq.addEventListener('change', maybeClose) : mq.addListener(maybeClose); } catch(e){}
})();
</script>

<script>
(function findWidest(){
  if (!document.documentElement.classList.contains('is-mobile')) return;
  var widest = { el:null, w:0 };
  document.querySelectorAll('body *').forEach(function(el){
    var r = el.getBoundingClientRect();
    if (r.width > widest.w) widest = { el: el, w: r.width };
  });
  console.log('Widest element:', widest.el, 'width:', widest.w, 'viewport:', window.innerWidth);
})();
</script>

<script>
(function detailsHeaderMobile(){
  var root = document.getElementById('resultHeader');
  if (!root) return;

  var btn  = document.getElementById('resultMenuBtn');
  var menu = document.getElementById('resultMenu');

  // Desktop safety: do nothing if pieces are missing
  if (!btn || !menu) return;

  function isMobile(){
    return document.documentElement.classList.contains('is-mobile');
  }
  function haveDetails(){
    return document.body.classList.contains('is-details') &&
           !!window.__lastRouting && !!window.__lastFullPrompt;
  }

  function clearMenu(){
    while (menu.firstChild) menu.removeChild(menu.firstChild);
  }

  // Build an item that can be a button or link depending on href
  function addItem(label, opts){
    opts = opts || {};
    var href = opts.href || '';
    var onClick = opts.onClick || null;
    var disabled = !!opts.disabled;

    var el = document.createElement(href ? 'a' : 'button');
    el.className = 'menuItem';
    el.setAttribute('role','menuitem');
    el.textContent = label;

    if (href) el.href = href;

    if (disabled){
      el.setAttribute('aria-disabled','true');
    } else if (onClick){
      el.addEventListener('click', function(e){
        e.preventDefault();
        e.stopPropagation();
        close();
        onClick();
      });
    } else if (href){
      // Navigate via href on click (close first for tidiness)
      el.addEventListener('click', function(e){
        // Allow normal link behavior, just close menu visually
        close();
      });
    }

    menu.appendChild(el);
    return el;
  }

  function buildParityMenu(){
    clearMenu();

    // Defensive lookups so we mirror the same links desktop uses
    var openGlossary = document.getElementById('openGlossary');
    var printWorksheet = document.getElementById('printWorksheet');
    var openBuilder = document.getElementById('openBuilder');

    var routing = window.__lastRouting || {};
    var fullPrompt = String(window.__lastFullPrompt || '');

    // 1) all templates — unchanged link
    var glossHref = (openGlossary && openGlossary.href) || './glossary/templates-glossary.html';
    addItem('all templates', { href: glossHref });

    // 2) worksheet — kind/id/xfer when available; else disabled
    var canWorksheet = !!(routing.id && routing.kindPlural);
    var wsHref = (printWorksheet && printWorksheet.href) || '';
    addItem('worksheet', {
      href: canWorksheet ? wsHref : '',
      disabled: !canWorksheet,
      onClick: canWorksheet ? function(){ window.location.href = wsHref; } : null
    });

    // 3) prompt builder — existing ?slug
    var pbHref = (openBuilder && openBuilder.href) || './glossary/prompt-builder.html';
    addItem('prompt builder', { href: pbHref });

    // 4) ask — open the same action modal as desktop
    addItem('ask', {
      disabled: !haveDetails(),
      onClick: function(){
        if (!haveDetails()) return;
        if (window.PB_FLAGS && window.PB_FLAGS.askUrlPrompt){
          openAction({ mode:'ask', prompt: fullPrompt, routing: routing });
        } else {
          // rollback path if flag off
          try { navigator.clipboard.writeText(fullPrompt); } catch(e){}
          window.open('https://chat.openai.com/', '_blank', 'noopener');
        }
      }
    });

    // 5) copy — open the same action modal as desktop
    addItem('copy', {
      disabled: !haveDetails(),
      onClick: function(){
        if (!haveDetails()) return;
        // keep initial quick copy for parity with desktop flow
        (async function(){
          try { await navigator.clipboard.writeText(fullPrompt); } catch(e){}
          if (window.PB_FLAGS && window.PB_FLAGS.newActionModal){
            openAction({ mode:'copy', prompt: fullPrompt, routing: routing });
          }
        })();
      }
    });
  }

  // Legacy fallback: clone the header CTAs if parity flag is OFF
  function buildLegacyMenu(){
    clearMenu();
    var ctas = root.querySelector('.ctas');
    if (!ctas) return;
    Array.from(ctas.children).forEach(function(node){
      if (!(node instanceof HTMLElement)) return;
      var isLink = node.tagName.toLowerCase() === 'a';
      var item = document.createElement(isLink ? 'a' : 'button');
      item.setAttribute('role','menuitem');
      item.className = 'menuItem';
      item.textContent = (node.getAttribute('aria-label') || node.textContent || 'Action').trim();
      if (isLink && node.getAttribute('href')) {
        item.href = node.getAttribute('href');
      }
      item.addEventListener('click', function(e){
        e.preventDefault(); e.stopPropagation();
        close();
        if (isLink && node.href) { window.location.href = node.href; return; }
        node.click();
      });
      menu.appendChild(item);
    });
  }

  function ensureMenu(){
    if (!isMobile()) return;
    if (window.PB_FLAGS && window.PB_FLAGS.mobileMenuParity) buildParityMenu();
    else buildLegacyMenu();
  }

  function open(){
    if (!isMobile()) return;
    ensureMenu();
    menu.hidden = false;
    btn.setAttribute('aria-expanded','true');
    trapOutsideOnce();
  }
  function close(){
    if (menu.hidden) return;
    menu.hidden = true;
    btn.setAttribute('aria-expanded','false');
  }

  function trapOutsideOnce(){
    var onDoc = function(e){
      if (!menu.contains(e.target) && e.target !== btn) {
        close();
        document.removeEventListener('click', onDoc, true);
      }
    };
    document.addEventListener('click', onDoc, true);

    var onKey = function(e){
      if (e.key === 'Escape') { e.preventDefault(); close(); document.removeEventListener('keydown', onKey, true); }
    };
    document.addEventListener('keydown', onKey, true);
  }

  btn.addEventListener('click', function(e){
    if (!isMobile()) return;
    e.preventDefault(); e.stopPropagation();
    menu.hidden ? open() : close();
  });

  // If device context flips to desktop, ensure the menu is closed
  var mq = matchMedia('(hover: none) and (pointer: coarse)');
  function maybeClose(){ if (!isMobile()) close(); }
  try { mq.addEventListener ? mq.addEventListener('change', maybeClose) : mq.addListener(maybeClose); } catch(e){}
})();
</script>

<script>
// === 1) History wiring: add near your other top-level refs (after hero/scan/details/resultHeader are defined) ===
(function wireHistory(){
  // Make sure we have an initial "home" state
  try {
    if (!(history.state && history.state.view)) {
      history.replaceState({ view: 'home' }, '', location.pathname + location.search);
    }
  } catch(e){}

  // Respond to browser back/forward
  window.addEventListener('popstate', function(e){
    var st = e.state || { view: 'home' };

    if (st.view === 'home'){
      // Show hero; hide details/scan/header
      try { scan.style.display = 'none'; } catch(e){}
      try { details.hidden = true; } catch(e){}
      try { resultHeader.hidden = true; } catch(e){}
      try { hero.style.display = 'block'; } catch(e){}
      try { qEl && qEl.focus(); } catch(e){}
    } else if (st.view === 'details'){
      // Optional: restore details by slug if present; otherwise fall back to hero
      var slug = st.slug;
      var t = slug && Array.isArray(INDEX) ? INDEX.find(function(x){
        return String(x.slug || x.id) === String(slug);
      }) : null;
      if (t) { showDetails(t); }
      else {
        try { scan.style.display = 'none'; } catch(e){}
        try { details.hidden = true; } catch(e){}
        try { resultHeader.hidden = true; } catch(e){}
        try { hero.style.display = 'block'; } catch(e){}
      }
    }
  });

  // Helper we’ll call when entering details
  window.__pushDetailsState = function(slug){
    try { history.pushState({ view:'details', slug: slug || null }, '', '#details'); } catch(e){}
  };
})();
</script>

<script>
// Anchor both dropdowns under their respective bars
(function anchorTypeaheads(){
  var ta  = document.getElementById('ta');
  var bar = document.querySelector('.searchWrap .search');
  if (ta && bar && ta.parentNode !== bar) bar.appendChild(ta);

  var ta2  = document.getElementById('ta2');
  var bar2 = document.querySelector('.detailSearchWrap .detailSearch');
  if (ta2 && bar2 && ta2.parentNode !== bar2) bar2.appendChild(ta2);
})();
</script>


<script>
  // --- redirect helper ---
  function gotoWizard(t) {
    if (!t) return;
    const slug = t.slug || (t.label || '').toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9\-]/g, '')
      .replace(/\-+/g, '-')
      .replace(/^\-|\-$/g, '');
    // If your wizard lives under /glossary/, swap to './glossary/startup-wizard.html'
    const base = './glossary/startup-wizard.html';
    window.location.assign(`${base}?slug=${encodeURIComponent(slug)}`);
  }

  // --- hijack details to route to the wizard ---
  (function hijackShowDetails(){
    const prev = window.showDetails;  // keep a reference just in case
    window.showDetails = function(t){
      gotoWizard(t);
      // If you ever need to fall back to the old behavior for debugging,
      // comment the line above and uncomment the line below:
      // return prev ? prev(t) : undefined;
    };
  })();
</script>

  
</body>
</html>
